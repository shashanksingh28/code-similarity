{"paramTypes":[],"returnType":"void","methodCalls":{"getSource":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"GrayFilter":1,"ImageFilter":1,"ImageProducer":1,"FilteredImageSource":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":13,"StringLiteralExpr":1,"ThisExpr":3,"AssignExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n   * Load the image.  Create a new image that is a grayer version of it, using\n   * a FilteredImageSource, ImageProducer and a the GrayFilter class, below.\n   */\npublic void init() {\n    orig = this.getImage(this.getDocumentBase(), \"cover.gif\");\n    ImageFilter filter = new GrayFilter();\n    ImageProducer producer = new FilteredImageSource(orig.getSource(), filter);\n    gray = this.createImage(producer);\n}\n","name":"init","className":"GrayImage","variables":{"filter":2,"gray":1,"orig":2,"producer":1},"constants":{"\"cover.gif\"":1},"javaDoc":"Load the image Create a new image that is a grayer version of it using a FilteredImageSource ImageProducer and a the GrayFilter class below","comments":"\n   * Load the image.  Create a new image that is a grayer version of it, using\n   * a FilteredImageSource, ImageProducer and a the GrayFilter class, below.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"NameExpr":8,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Display the original image and gray version side-by-side */\npublic void paint(Graphics g) {\n    g.drawImage(orig, 25, 25, this);\n    g.drawImage(gray, 200, 25, this);\n}\n","name":"paint","className":"GrayImage","variables":{"g":2},"constants":{"200":1,"25":3},"javaDoc":"Display the original image and gray version side-by-side","comments":" Display the original image and gray version side-by-side ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GrayFilter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public GrayFilter() {\n    canFilterIndexColorModel = true;\n}\n","name":"GrayFilter","className":"GrayFilter","variables":{"canFilterIndexColorModel":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":4},"expressions":{"IntegerLiteralExpr":13,"VariableDeclarationExpr":4,"BinaryExpr":16,"NameExpr":8,"EnclosedExpr":9},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"public int filterRGB(int x, int y, int rgb) {\n    int a = rgb & 0xff000000;\n    int r = (((rgb & 0xff0000) + 0x1800000) / 3) & 0xff0000;\n    int g = (((rgb & 0x00ff00) + 0x018000) / 3) & 0x00ff00;\n    int b = (((rgb & 0x0000ff) + 0x000180) / 3) & 0x0000ff;\n    return a | r | g | b;\n}\n","name":"filterRGB","className":"GrayFilter","variables":{"a":2,"r":2,"b":2,"g":2,"rgb":4},"constants":{"3":3,"0x000180":1,"0xff000000":1,"0x018000":1,"0x00ff00":2,"0x1800000":1,"0xff0000":2,"0x0000ff":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"ThisExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void init() {\n    // Tell this applet what MouseListener and MouseMotionListener\n    // objects to notify when mouse and mouse motion events occur.\n    // Since we implement the interfaces ourself, our own methods are called.\n    this.addMouseListener(this);\n    this.addMouseMotionListener(this);\n}\n","name":"init","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","comments":"Tell this applet what MouseListener and MouseMotionListener objects to notify when mouse and mouse motion events occur Since we implement the interfaces ourself our own methods are called ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"// A method from the MouseListener interface.  Invoked when the\n// user presses a mouse button.\npublic void mousePressed(MouseEvent e) {\n    last_x = e.getX();\n    last_y = e.getY();\n}\n","name":"mousePressed","className":"Scribble2","variables":{"e":2,"last_x":1,"last_y":1},"constants":{},"javaDoc":"","comments":" user presses a mouse button.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":19,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":5},"text":"// A method from the MouseMotionListener interface.  Invoked when the\n// user drags the mouse with a button pressed.\npublic void mouseDragged(MouseEvent e) {\n    Graphics g = this.getGraphics();\n    int x = e.getX(), y = e.getY();\n    g.drawLine(last_x, last_y, x, y);\n    last_x = x;\n    last_y = y;\n}\n","name":"mouseDragged","className":"Scribble2","variables":{"e":2,"g":2,"last_x":1,"x":2,"last_y":1,"y":2},"constants":{},"javaDoc":"","comments":" user drags the mouse with a button pressed.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"EmptyStmt":1},"text":"// The other, unused methods of the MouseListener interface.\npublic void mouseReleased(MouseEvent e) {\n    ;\n}\n","name":"mouseReleased","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","comments":" The other, unused methods of the MouseListener interface.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"EmptyStmt":1},"text":"public void mouseClicked(MouseEvent e) {\n    ;\n}\n","name":"mouseClicked","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"EmptyStmt":1},"text":"public void mouseEntered(MouseEvent e) {\n    ;\n}\n","name":"mouseEntered","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"EmptyStmt":1},"text":"public void mouseExited(MouseEvent e) {\n    ;\n}\n","name":"mouseExited","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"EmptyStmt":1},"text":"// The other method of the MouseMotionListener interface.\npublic void mouseMoved(MouseEvent e) {\n    ;\n}\n","name":"mouseMoved","className":"Scribble2","variables":{},"constants":{},"javaDoc":"","comments":" The other method of the MouseMotionListener interface.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method displays the applet.\n// The Graphics class is how you do all drawing in Java.\npublic void paint(Graphics g) {\n    g.drawString(\"Hello World\", 25, 50);\n}\n","name":"paint","className":"FirstApplet","variables":{"g":1},"constants":{"\"Hello World\"":1,"25":1,"50":1},"javaDoc":"","comments":" The Graphics class is how you do all drawing in Java.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Throwable"],"returnType":"void","methodCalls":{"getClass":2,"getName":2,"printStackTrace":3,"format":1,"getMessage":2,"getString":1,"getBundle":1,"substring":2,"parseInt":1,"lastIndexOf":1,"toString":1,"indexOf":3,"getSuperclass":1,"System.out.println":1},"annotations":[],"exceptions":["MissingResourceException","Exception"],"concepts":["ExceptionHandling"],"types":{"StringWriter":1,"ResourceBundle":1,"Class":1,"String":4,"int":3,"Object[]":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":12,"BinaryExpr":9,"NameExpr":98,"StringLiteralExpr":3,"CharLiteralExpr":4,"ConditionalExpr":1,"AssignExpr":7,"NullLiteralExpr":5,"ArrayInitializerExpr":1,"FieldAccessExpr":3,"ClassExpr":1,"EnclosedExpr":4,"MethodCallExpr":22},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":3,"BlockStmt":8,"EmptyStmt":1,"ReturnStmt":2,"ExpressionStmt":23},"text":"public static void display(Throwable error) {\n    ResourceBundle bundle;\n    // If none, print the error in a non-localized way.\n    try {\n        bundle = ResourceBundle.getBundle(\"Errors\");\n    } catch (MissingResourceException e) {\n        error.printStackTrace(System.err);\n        return;\n    }\n    // Look up a localized message resource in that bundle, using the\n    // classname of the error (or its superclasses) as the resource name.\n    // If no resource was found, display the error without localization.\n    String message = null;\n    Class c = error.getClass();\n    while ((message == null) && (c != Object.class)) {\n        try {\n            message = bundle.getString(c.getName());\n        } catch (MissingResourceException e) {\n            c = c.getSuperclass();\n        }\n    }\n    if (message == null) {\n        error.printStackTrace(System.err);\n        return;\n    }\n    // Try to figure out the filename and line number of the\n    // exception.  Output the error's stack trace into a string, and\n    // use the heuristic that the first line number that appears in\n    // the stack trace is after the first or  second colon.  We assume that\n     // Try to get the resource bundle.\n\n    // this stack frame is the first one the programmer has any control\n    // over, and so report it as the location of the exception.\n    String filename = \"\";\n    int linenum = 0;\n    try {\n        // Output stream into a string.\n        StringWriter sw = new StringWriter();\n        // PrintWriter wrapper.\n        PrintWriter out = new PrintWriter(sw);\n        // Print stacktrace.\n        error.printStackTrace(out);\n        // Get it as a string.\n        String trace = sw.toString();\n        // Look for first colon.\n        int pos = trace.indexOf(':');\n        if (// If the error has a message\n        error.getMessage() != null)\n            // look for second colon.\n            pos = trace.indexOf(':', pos + 1);\n        // Look for end of line number.\n        int pos2 = trace.indexOf(')', pos);\n        // Get linenum.\n        linenum = Integer.parseInt(trace.substring(pos + 1, pos2));\n        // Back to start of filename.\n        pos2 = trace.lastIndexOf('(', pos);\n        // Get filename.\n        filename = trace.substring(pos2 + 1, pos);\n    }// Ignore exceptions.\n     catch (Exception e) {\n        ;\n    }\n    // Set up an array of arguments to use with the message\n    String errmsg = error.getMessage();\n    Object[] args = { ((errmsg != null) ? errmsg : \"\"), error.getClass().getName(), filename, new Integer(linenum), new Date() };\n    // Finally, display the localized error message, using\n    // MessageFormat.format() to substitute the arguments into the message.\n    System.out.println(MessageFormat.format(message, args));\n}\n","name":"display","className":"LocalizedError","variables":{"c":5,"sw":3,"MessageFormat":1,"e":3,"errmsg":3,"pos2":3,"error":7,"message":4,"out":1,"Integer":1,"args":1,"trace":7,"filename":3,"pos":4,"linenum":3,"ResourceBundle":1,"bundle":3},"constants":{"\"\"":2,"0":1,"1":3,"null":5,"':'":2,"')'":1,"'('":1,"\"Errors\"":1},"javaDoc":"","comments":"Try to get the resource bundle Look up a localized message resource in that bundle using the classname of the error (or its superclasses) as the resource name Try to figure out the filename and line number of the exception Output the error's stack trace into a string and use the heuristic that the first line number that appears in the stack trace is after the first or second colon We assume that this stack frame is the first one the programmer has any control Finally display the localized error message using If none print the error in a non-localized way If no resource was found display the error without localization over and so report it as the location of the exception Output stream into a string PrintWriter wrapper Print stacktrace Get it as a string Look for first colon If the error has a message look for second colon Look for end of line number Get linenum Back to start of filename Get filename Ignore exceptions Set up an array of arguments to use with the message MessageFormat format() to substitute the arguments into the message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"rot13":1,"equals":1,"length":1,"setCharAt":1,"readLine":1,"System.out.print":1,"charAt":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringBuffer":1,"BufferedReader":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    // Get set up to read lines of text from the user\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    for (; ; ) {\n        // Loop forever\n        // Print a prompt\n        System.out.print(\"> \");\n        // Read a line\n        String line = in.readLine();\n        if (// If EOF or \"quit\" then...\n        (line == null) || line.equals(\"quit\"))\n            // ... break out of the loop\n            break;\n        // Convert to a StringBuffer\n        StringBuffer buf = new StringBuffer(line);\n        for (// For each character...\n        int i = 0; // For each character...\n        i < buf.length(); // For each character...\n        i++) //   read, encode, put it back\n        buf.setCharAt(i, rot13(buf.charAt(i)));\n        // Print encoded line\n        System.out.println(buf);\n    }\n}\n","name":"main","className":"Rot13Input","variables":{"buf":4,"in":2,"line":4,"i":3},"constants":{"0":1,"\"quit\"":1,"null":1,"\"> \"":1},"javaDoc":"","comments":"Get set up to read lines of text from the user Loop forever Print a prompt Read a line If EOF or \"quit\" then break out of the loop Convert to a StringBuffer For each character For each character For each character read encode put it back Print encoded line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"char","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":8,"NameExpr":11,"CharLiteralExpr":6,"EnclosedExpr":4,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n   * This method performs the Rot13 substitution cipher.  It \"rotates\"\n   * each letter 13 places through the alphabet.  Since the Latin alphabet\n   * has 26 letters, this method both encodes and decodes.\n   **/\npublic static char rot13(char c) {\n    if ((c >= 'A') && (c <= 'Z')) {\n        // For uppercase letters\n        // Rotate forward 13\n        c += 13;\n        // And subtract 26 if necessary\n        if (c > 'Z')\n            c -= 26;\n    }\n    if ((c >= 'a') && (c <= 'z')) {\n        // Do the same for lowercase letters\n        c += 13;\n        if (c > 'z')\n            c -= 26;\n    }\n    // Return the modified letter\n    return c;\n}\n","name":"rot13","className":"Rot13Input","variables":{"c":11},"constants":{"13":2,"'Z'":2,"26":2,"'z'":2,"'A'":1,"'a'":1},"javaDoc":"This method performs the Rot13 substitution cipher It \"rotates\" each letter 13 places through the alphabet Since the Latin alphabet has 26 letters this method both encodes and decodes","comments":"For uppercase letters Rotate forward 13 And subtract 26 if necessary Do the same for lowercase letters Return the modified letter \n   * This method performs the Rot13 substitution cipher.  It \"rotates\"\n   * each letter 13 places through the alphabet.  Since the Latin alphabet\n   * has 26 letters, this method both encodes and decodes.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getPredefinedCursor":1,"setCursor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Button":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/** Create a grid of buttons each using a different cursor */\npublic void init() {\n    this.setLayout(new GridLayout(0, 2, 5, 5));\n    for (int i = 0; i < cursor_types.length; i++) {\n        Button b = new Button(cursor_names[i]);\n        // This is how we obtain a Cursor object and set it on a Component\n        b.setCursor(Cursor.getPredefinedCursor(cursor_types[i]));\n        this.add(b);\n    }\n}\n","name":"init","className":"Cursors","variables":{"b":2,"cursor_names":1,"i":5,"cursor_types":1,"Cursor":1},"constants":{"0":2,"2":1,"5":2},"javaDoc":"Create a grid of buttons each using a different cursor","comments":"This is how we obtain a Cursor object and set it on a Component  Create a grid of buttons each using a different cursor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","PrintWriter"],"returnType":"MudPerson","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public MudPerson(String n, String d, PrintWriter out) throws RemoteException {\n    name = n;\n    description = d;\n    tellStream = out;\n}\n","name":"MudPerson","className":"MudPerson","variables":{"tellStream":1,"d":1,"name":1,"description":1,"n":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the person's name.  Not a remote method */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"MudPerson","variables":{"name":1},"constants":{},"javaDoc":"Return the person's name Not a remote method","comments":" Return the person's name.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the person's name.  Not a remote method */\npublic void setName(String n) {\n    name = n;\n}\n","name":"setName","className":"MudPerson","variables":{"name":1,"n":1},"constants":{},"javaDoc":"Set the person's name Not a remote method","comments":" Set the person's name.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the person's description.  Not a remote method */\npublic void setDescription(String d) {\n    description = d;\n}\n","name":"setDescription","className":"MudPerson","variables":{"d":1,"description":1},"constants":{},"javaDoc":"Set the person's description Not a remote method","comments":" Set the person's description.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the stream that messages to us should be written to.  Not remote. */\npublic void setTellStream(PrintWriter out) {\n    tellStream = out;\n}\n","name":"setTellStream","className":"MudPerson","variables":{"tellStream":1,"out":1},"constants":{},"javaDoc":"Set the stream that messages to us should be written to Not remote","comments":" Set the stream that messages to us should be written to.  Not remote. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** A remote method that returns this person's description */\npublic String getDescription() throws RemoteException {\n    return description;\n}\n","name":"getDescription","className":"MudPerson","variables":{"description":1},"constants":{},"javaDoc":"A remote method that returns this person's description","comments":" A remote method that returns this person's description ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"flush":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n   * A remote method that delivers a message to the person.\n   * I.e. it delivers a message to the user controlling the \"person\"\n   **/\npublic void tell(String message) throws RemoteException {\n    tellStream.println(message);\n    tellStream.flush();\n}\n","name":"tell","className":"MudPerson","variables":{"tellStream":2},"constants":{},"javaDoc":"A remote method that delivers a message to the person I e it delivers a message to the user controlling the \"person\"","comments":" \n   * A remote method that delivers a message to the person.\n   * I.e. it delivers a message to the user controlling the \"person\"\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // Loop backwards through the array of arguments\n    for (int i = args.length - 1; i >= 0; i--) {\n        // Loop backwards through the characters in each argument\n        for (int j = args[i].length() - 1; j >= 0; j--) {\n            // Print out character j of argument i.\n            System.out.print(args[i].charAt(j));\n        }\n        // add a space at the end of each argument\n        System.out.print(\" \");\n    }\n    // and terminate the line when we're done.\n    System.out.println();\n}\n","name":"main","className":"Reverse","variables":{"args":2,"i":5,"j":3},"constants":{"0":2,"1":2,"\" \"":1},"javaDoc":"","comments":"Loop backwards through the array of arguments Loop backwards through the characters in each argument Print out character j of argument i add a space at the end of each argument and terminate the line when we're done ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Specify the event types we care about, and ask for keyboard focus */\npublic void init() {\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\n    // Ask for keyboard focus so we get key events\n    this.requestFocus();\n}\n","name":"init","className":"Scribble7","variables":{},"constants":{},"javaDoc":"Specify the event types we care about and ask for keyboard focus","comments":"Ask for keyboard focus so we get key events  Specify the event types we care about, and ask for keyboard focus ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AWTEvent"],"returnType":"void","methodCalls":{"getX":2,"getY":2,"setColor":1,"getID":1,"drawLine":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"MouseEvent":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"SuperExpr":2,"BinaryExpr":1,"NameExpr":72,"CastExpr":3,"FieldAccessExpr":5,"CharLiteralExpr":1,"EnclosedExpr":1,"ThisExpr":5,"MethodCallExpr":16,"AssignExpr":8},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":4,"BlockStmt":1,"SwitchEntryStmt":4,"ExpressionStmt":16},"text":"/**\n   * Called when an event arrives.  Do the right thing based on the event\n   * type.  Pass unhandled events to the superclass for possible processing\n   */\npublic void processEvent(AWTEvent e) {\n    MouseEvent me;\n    Graphics g;\n    switch(e.getID()) {\n        case MouseEvent.MOUSE_PRESSED:\n            me = (MouseEvent) e;\n            lastx = me.getX();\n            lasty = me.getY();\n            break;\n        case MouseEvent.MOUSE_DRAGGED:\n            me = (MouseEvent) e;\n            int x = me.getX(), y = me.getY();\n            g = this.getGraphics();\n            g.drawLine(lastx, lasty, x, y);\n            lastx = x;\n            lasty = y;\n            break;\n        case KeyEvent.KEY_TYPED:\n            if (((KeyEvent) e).getKeyChar() == 'c') {\n                g = this.getGraphics();\n                g.setColor(this.getBackground());\n                g.fillRect(0, 0, this.getSize().width, this.getSize().height);\n            } else\n                super.processEvent(e);\n            break;\n        default:\n            super.processEvent(e);\n            break;\n    }\n}\n","name":"processEvent","className":"Scribble7","variables":{"e":4,"g":6,"me":7,"x":2,"y":2,"lasty":2,"lastx":2},"constants":{"0":2,"'c'":1},"javaDoc":"Called when an event arrives Do the right thing based on the event type Pass unhandled events to the superclass for possible processing","comments":"\n   * Called when an event arrives.  Do the right thing based on the event\n   * type.  Pass unhandled events to the superclass for possible processing\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"println":2,"read":1,"flush":2,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":26,"StringLiteralExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":7},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public void run() {\n    char[] buffer = new char[1024];\n    int chars_read;\n    try {\n        while ((chars_read = from_server.read(buffer)) != -1) {\n            to_user.write(buffer, 0, chars_read);\n            to_user.flush();\n        }\n    } catch (IOException e) {\n        to_user.println(e);\n    }\n    // When the server closes the connection, the loop above will end.\n    // Tell the user what happened, and call System.exit(), causing\n    // the main thread to exit along with this one.\n    to_user.println(\"Connection closed by server.\");\n    to_user.flush();\n    System.exit(0);\n}\n","name":"run","className":"","variables":{"chars_read":2,"to_user":5,"e":1,"from_server":1,"buffer":1,"System":1},"constants":{"0":2,"1":1,"1024":1,"\"Connection closed by server.\"":1},"javaDoc":"","comments":"When the server closes the connection the loop above will end Tell the user what happened and call System exit() causing the main thread to exit along with this one ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getInetAddress":1,"currentThread":1,"read":1,"start":1,"readLine":1,"getInputStream":1,"parseInt":1,"exit":1,"println":5,"getPort":1,"flush":5,"stop":1,"getPriority":1,"getOutputStream":1,"System.err.println":2,"write":1,"setPriority":1,"close":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException","Exception"],"concepts":["InnerMethod","FinalVariables","PolyMorphism","ExceptionHandling"],"types":{"InputStreamReader":1,"BufferedReader":1,"Reader":1,"String":2,"int":2,"Socket":1,"PrintWriter":2,"Thread":1,"char[]":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":10,"VariableDeclarationExpr":11,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":107,"StringLiteralExpr":6,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":27},"statements":{"IfStmt":1,"WhileStmt":2,"TryStmt":2,"BlockStmt":7,"ThrowStmt":1,"ExpressionStmt":29},"text":"public static void main(String[] args) throws IOException {\n    try {\n        // Check the number of arguments\n        if (args.length != 2)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Parse the host and port specifications\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        // Connect to the specified host and port\n        Socket s = new Socket(host, port);\n        // Set up streams for reading from and writing to the server.\n        // The from_server stream is final for use in the anonymous class below\n        final Reader from_server = new InputStreamReader(s.getInputStream());\n        PrintWriter to_server = new PrintWriter(new OutputStreamWriter(s.getOutputStream()));\n        // Set up streams for reading from and writing to the console\n        // The to_user stream is final for use in the anonymous class below.\n        BufferedReader from_user = new BufferedReader(new InputStreamReader(System.in));\n        final PrintWriter to_user = new PrintWriter(new OutputStreamWriter(System.out));\n        // Tell the user that we've connected\n        to_user.println(\"Connected to \" + s.getInetAddress() + \":\" + s.getPort());\n        to_user.flush();\n        // Create a thread that gets output from the server and displays \n        // it to the user.  We use a separate thread for this so that we can\n        // receive asynchronous output\n        Thread t = new Thread() {\n\n            public void run() {\n                char[] buffer = new char[1024];\n                int chars_read;\n                try {\n                    while ((chars_read = from_server.read(buffer)) != -1) {\n                        to_user.write(buffer, 0, chars_read);\n                        to_user.flush();\n                    }\n                } catch (IOException e) {\n                    to_user.println(e);\n                }\n                // When the server closes the connection, the loop above will end.\n                // Tell the user what happened, and call System.exit(), causing\n                // the main thread to exit along with this one.\n                to_user.println(\"Connection closed by server.\");\n                to_user.flush();\n                System.exit(0);\n            }\n        };\n        // We set the priority of the server-to-user thread above to be one\n        // level higher than the main thread.  We shouldn't have to do this, but\n        // on some operating systems, output sent to the console doesn't appear\n        // when a thread at the same priority level is blocked waiting for\n        // input from the console.\n        t.setPriority(Thread.currentThread().getPriority() + 1);\n        // Now start the server-to-user thread\n        t.start();\n        // And in parallel, read the user's input and pass it on to the server.\n        String line;\n        while ((line = from_user.readLine()) != null) {\n            to_server.println(line);\n            to_server.flush();\n        }\n        // If the user types a Ctrl-D (Unix) or Ctrl-Z (Windows) to end their\n        // input, we'll get and EOF, and the loop above will exit.  When this\n        // happens, we stop the server-to-user thread and close the socket.\n        t.stop();\n        s.close();\n        to_user.println(\"Connection closed by client.\");\n        to_user.flush();\n    }// If anything goes wrong, print an error message\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GenericClient <hostname> <port>\");\n    }\n}\n","name":"main","className":"GenericClient","variables":{"to_user":10,"chars_read":2,"e":2,"line":2,"from_server":2,"run":1,"System":1,"from_user":2,"Thread":1,"args":2,"Integer":1,"to_server":3,"s":6,"t":4,"port":2,"host":2,"buffer":1},"constants":{"0":3,"1":3,"2":1,"\"Connected to \"":1,"null":1,"1024":1,"\"Connection closed by client.\"":1,"\"Wrong number of arguments\"":1,"\":\"":1,"\"Connection closed by server.\"":1,"\"Usage: java GenericClient <hostname> <port>\"":1},"javaDoc":"","comments":"Set up streams for reading from and writing to the server Set up streams for reading from and writing to the console Create a thread that gets output from the server and displays it to the user We use a separate thread for this so that we can We set the priority of the server-to-user thread above to be one level higher than the main thread We shouldn't have to do this but on some operating systems output sent to the console doesn't appear when a thread at the same priority level is blocked waiting for If the user types a Ctrl-D (Unix) or Ctrl-Z (Windows) to end their input we'll get and EOF and the loop above will exit When this Check the number of arguments Parse the host and port specifications Connect to the specified host and port The from_server stream is final for use in the anonymous class below The to_user stream is final for use in the anonymous class below Tell the user that we've connected receive asynchronous output When the server closes the connection the loop above will end Tell the user what happened and call System exit() causing the main thread to exit along with this one input from the console Now start the server-to-user thread And in parallel read the user's input and pass it on to the server happens we stop the server-to-user thread and close the socket If anything goes wrong print an error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["ArrayIndexOutOfBoundsException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":5},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/** Return an element of the array */\npublic int elementAt(int index) throws ArrayIndexOutOfBoundsException {\n    if (index >= size)\n        throw new ArrayIndexOutOfBoundsException(index);\n    else\n        return nums[index];\n}\n","name":"elementAt","className":"IntList","variables":{"size":1,"index":3,"nums":1},"constants":{},"javaDoc":"Return an element of the array","comments":" Return an element of the array ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Add an int to the array, growing the array if necessary */\npublic void add(int x) {\n    // Grow array, if needed.\n    if (nums.length == size)\n        resize(nums.length * 2);\n    // Store the int in it.\n    nums[size++] = x;\n}\n","name":"add","className":"IntList","variables":{"size":2,"x":1,"nums":1},"constants":{"2":1},"javaDoc":"Add an int to the array growing the array if necessary","comments":"Grow array if needed Store the int in it  Add an int to the array, growing the array if necessary ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":9,"ArrayCreationExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** An internal method to change the allocated size of the array */\nprotected void resize(int newsize) {\n    int[] oldnums = nums;\n    // Create a new array.\n    nums = new int[newsize];\n    // Copy array elements.\n    System.arraycopy(oldnums, 0, nums, 0, size);\n}\n","name":"resize","className":"IntList","variables":{"oldnums":1,"newsize":1,"nums":2,"System":1},"constants":{"0":2},"javaDoc":"An internal method to change the allocated size of the array","comments":"Create a new array Copy array elements  An internal method to change the allocated size of the array ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ObjectOutputStream"],"returnType":"void","methodCalls":{"resize":1,"defaultWriteObject":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Get rid of unused array elements before serializing the array */\nprivate void writeObject(ObjectOutputStream out) throws IOException {\n    // Compact the array.\n    if (nums.length > size)\n        resize(size);\n    // Then write it out normally.\n    out.defaultWriteObject();\n}\n","name":"writeObject","className":"IntList","variables":{"size":1,"out":1},"constants":{},"javaDoc":"Get rid of unused array elements before serializing the array","comments":"Compact the array Then write it out normally  Get rid of unused array elements before serializing the array ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ObjectInputStream"],"returnType":"void","methodCalls":{"defaultReadObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Compute the transient size field after deserializing the array */\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Read the array normally.\n    in.defaultReadObject();\n    // Restore the transient field.\n    size = nums.length;\n}\n","name":"readObject","className":"IntList","variables":{"size":1,"in":1},"constants":{},"javaDoc":"Compute the transient size field after deserializing the array","comments":"Read the array normally Restore the transient field  Compute the transient size field after deserializing the array ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Handle mouse events\npublic boolean mouseDown(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Down: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseDown","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"Mouse Down: [\"":1,"\"]\"":1,"\",\"":1,"true":1},"javaDoc":"","comments":" Handle mouse events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseUp(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Up: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseUp","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Up: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseDrag(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Drag: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseDrag","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Drag: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseMove(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Move: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseMove","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Move: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":4,"StringLiteralExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseEnter(Event e, int x, int y) {\n    showLine(\"Mouse Enter: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseEnter","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Enter: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":4,"StringLiteralExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseExit(Event e, int x, int y) {\n    showLine(\"Mouse Exit: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseExit","className":"EventTester1","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Exit: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Handle focus events\npublic boolean gotFocus(Event e, Object what) {\n    showLine(\"Got Focus\");\n    return true;\n}\n","name":"gotFocus","className":"EventTester1","variables":{},"constants":{"\"Got Focus\"":1,"true":1},"javaDoc":"","comments":" Handle focus events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean lostFocus(Event e, Object what) {\n    showLine(\"Lost Focus\");\n    return true;\n}\n","name":"lostFocus","className":"EventTester1","variables":{},"constants":{"\"Lost Focus\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"key_name":1,"mods":2,"function_key_name":1,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"IfStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"// Handle key down and key up events\n// This gets more confusing because there are two types of key events\npublic boolean keyDown(Event e, int key) {\n    int flags = e.modifiers;\n    if (// a regular key\n    e.id == Event.KEY_PRESS)\n        showLine(\"Key Down: \" + mods(flags) + key_name(e));\n    else if (// a function key\n    e.id == Event.KEY_ACTION)\n        showLine(\"Function Key Down: \" + mods(flags) + function_key_name(key));\n    return true;\n}\n","name":"keyDown","className":"EventTester1","variables":{"flags":1},"constants":{"\"Key Down: \"":1,"true":1,"\"Function Key Down: \"":1},"javaDoc":"","comments":"a regular key a function key  This gets more confusing because there are two types of key events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"key_name":1,"mods":2,"function_key_name":1,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"IfStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"public boolean keyUp(Event e, int key) {\n    int flags = e.modifiers;\n    if (// a regular key\n    e.id == Event.KEY_RELEASE)\n        showLine(\"Key Up: \" + mods(flags) + key_name(e));\n    else if (// a function key\n    e.id == Event.KEY_ACTION_RELEASE)\n        showLine(\"Function Key Up: \" + mods(flags) + function_key_name(key));\n    return true;\n}\n","name":"keyUp","className":"EventTester1","variables":{"flags":1},"constants":{"true":1,"\"Key Up: \"":1,"\"Function Key Up: \"":1},"javaDoc":"","comments":"a regular key a function key ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":1,"BinaryExpr":9,"StringLiteralExpr":7,"NameExpr":23,"FieldAccessExpr":4,"EnclosedExpr":4,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":2,"ExpressionStmt":6},"text":"// The remaining methods help us sort out the various modifiers and keys\n// Return the current list of modifier keys\nprivate String mods(int flags) {\n    String s = \"[ \";\n    if (flags == 0)\n        return \"\";\n    if ((flags & Event.SHIFT_MASK) != 0)\n        s += \"Shift \";\n    if ((flags & Event.CTRL_MASK) != 0)\n        s += \"Control \";\n    if ((flags & Event.META_MASK) != 0)\n        s += \"Meta \";\n    if ((flags & Event.ALT_MASK) != 0)\n        s += \"Alt \";\n    s += \"] \";\n    return s;\n}\n","name":"mods","className":"EventTester1","variables":{"s":7,"flags":5},"constants":{"0":5,"\"\"":1,"\"Alt \"":1,"\"Meta \"":1,"\"[ \"":1,"\"Control \"":1,"\"] \"":1,"\"Shift \"":1},"javaDoc":"","comments":" Return the current list of modifier keys","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Event"],"returnType":"String","methodCalls":{"controlDown":1,"valueOf":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"char":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"CastExpr":1,"NameExpr":16,"StringLiteralExpr":7,"FieldAccessExpr":1,"CharLiteralExpr":8,"MethodCallExpr":2,"AssignExpr":1},"statements":{"SwitchStmt":1,"IfStmt":4,"BlockStmt":3,"SwitchEntryStmt":4,"ReturnStmt":8,"ExpressionStmt":2},"text":"// Return the name of a regular (non-function) key.\nprivate String key_name(Event e) {\n    char c = (char) e.key;\n    if (e.controlDown()) {\n        // If CTRL flag is set, handle control chars.\n        if (c < ' ') {\n            c += '@';\n            return \"^\" + c;\n        }\n    } else {\n        // If CTRL flag is not set, then certain ASCII\n        switch(// control characters have special meaning.\n        c) {\n            case '\\n':\n                return \"Return\";\n            case '\\t':\n                return \"Tab\";\n            case '\\033':\n                return \"Escape\";\n            case '\\010':\n                return \"Backspace\";\n        }\n    }\n    // Handle the remaining possibilities.\n    if (c == '\\177')\n        return \"Delete\";\n    else if (c == ' ')\n        return \"Space\";\n    else\n        return String.valueOf(c);\n}\n","name":"key_name","className":"EventTester1","variables":{"c":7,"e":1,"String":1},"constants":{"\"Backspace\"":1,"\"^\"":1,"\"Return\"":1,"\"Tab\"":1,"\"Escape\"":1,"' '":2,"'@'":1,"\"Space\"":1,"'\\033'":1,"'\\010'":1,"'\\t'":1,"'\\n'":1,"'\\177'":1,"\"Delete\"":1},"javaDoc":"","comments":"If CTRL flag is set handle control chars If CTRL flag is not set then certain ASCII control characters have special meaning Handle the remaining possibilities  Return the name of a regular (non-function) key.","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":61,"StringLiteralExpr":21,"FieldAccessExpr":20},"statements":{"SwitchStmt":1,"SwitchEntryStmt":20,"ReturnStmt":21},"text":"// Return the name of a function key.  Just compare the key to the\n// constants defined in the Event class.\nprivate String function_key_name(int key) {\n    switch(key) {\n        case Event.HOME:\n            return \"Home\";\n        case Event.END:\n            return \"End\";\n        case Event.PGUP:\n            return \"Page Up\";\n        case Event.PGDN:\n            return \"Page Down\";\n        case Event.UP:\n            return \"Up\";\n        case Event.DOWN:\n            return \"Down\";\n        case Event.LEFT:\n            return \"Left\";\n        case Event.RIGHT:\n            return \"Right\";\n        case Event.F1:\n            return \"F1\";\n        case Event.F2:\n            return \"F2\";\n        case Event.F3:\n            return \"F3\";\n        case Event.F4:\n            return \"F4\";\n        case Event.F5:\n            return \"F5\";\n        case Event.F6:\n            return \"F6\";\n        case Event.F7:\n            return \"F7\";\n        case Event.F8:\n            return \"F8\";\n        case Event.F9:\n            return \"F9\";\n        case Event.F10:\n            return \"F10\";\n        case Event.F11:\n            return \"F11\";\n        case Event.F12:\n            return \"F12\";\n    }\n    return \"Unknown Function Key\";\n}\n","name":"function_key_name","className":"EventTester1","variables":{"key":1},"constants":{"\"F6\"":1,"\"F10\"":1,"\"F5\"":1,"\"F11\"":1,"\"F4\"":1,"\"F12\"":1,"\"F3\"":1,"\"F2\"":1,"\"F1\"":1,"\"End\"":1,"\"Down\"":1,"\"Page Up\"":1,"\"Page Down\"":1,"\"Home\"":1,"\"Right\"":1,"\"Up\"":1,"\"Left\"":1,"\"Unknown Function Key\"":1,"\"F9\"":1,"\"F8\"":1,"\"F7\"":1},"javaDoc":"","comments":" constants defined in the Event class.","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"removeElementAt":1,"addElement":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Add a new line to the list of lines, and redisplay */\nprotected void showLine(String s) {\n    if (lines.size() == 20)\n        lines.removeElementAt(0);\n    lines.addElement(s);\n    repaint();\n}\n","name":"showLine","className":"EventTester1","variables":{"lines":3},"constants":{"0":1,"20":1},"javaDoc":"Add a new line to the list of lines and redisplay","comments":" Add a new line to the list of lines, and redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":13,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/** This method repaints the text in the window */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) g.drawString((String) lines.elementAt(i), 20, i * 16 + 50);\n}\n","name":"paint","className":"EventTester1","variables":{"g":1,"i":4,"lines":2},"constants":{"0":1,"16":1,"50":1,"20":1},"javaDoc":"This method repaints the text in the window","comments":" This method repaints the text in the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getMessage":1,"System.err.println":2,"delete":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/** \n   * This is the main() method of the standalone program.  After checking\n   * it arguments, it invokes the Delete.delete() method to do the deletion\n   **/\npublic static void main(String[] args) {\n    if (args.length != 1) {\n        // Check command-line arguments\n        System.err.println(\"Usage: java Delete <file or directory>\");\n        System.exit(0);\n    }\n    // Call delete() and display any error messages it throws.\n    try {\n        delete(args[0]);\n    } catch (IllegalArgumentException e) {\n        System.err.println(e.getMessage());\n    }\n}\n","name":"main","className":"Delete","variables":{"args":1,"e":2,"System":1},"constants":{"0":2,"1":1,"\"Usage: java Delete <file or directory>\"":1},"javaDoc":"This is the main() method of the standalone program After checking it arguments it invokes the Delete delete() method to do the deletion","comments":"Check command-line arguments Call delete() and display any error messages it throws  \n   * This is the main() method of the standalone program.  After checking\n   * it arguments, it invokes the Delete.delete() method to do the deletion\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"fail":4,"exists":1,"canWrite":1,"list":1,"delete":1,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String[]":1,"File":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":9},"statements":{"IfStmt":5,"BlockStmt":1,"ExpressionStmt":7},"text":"/**\n   * The static method that does the deletion.  Invoked by main(), and designed\n   * for use by other programs as well.  It first makes sure that the \n   * specified file or directory is deleteable before attempting to delete it.\n   * If there is a problem, it throws an IllegalArgumentException.\n   */\npublic static void delete(String filename) {\n    // Create a File object to represent the filename\n    File f = new File(filename);\n    // Make sure the file or directory exists and isn't write protected\n    if (!f.exists())\n        fail(\"Delete: no such file or directory: \" + filename);\n    if (!f.canWrite())\n        fail(\"Delete: write protected: \" + filename);\n    // If it is a directory, make sure it is empty\n    if (f.isDirectory()) {\n        String[] files = f.list();\n        if (files.length > 0)\n            fail(\"Delete: directory not empty: \" + filename);\n    }\n    // If we passed all the tests, then attempt to delete it\n    boolean success = f.delete();\n    // directory deletion always fails \n    if (!success)\n        fail(\"Delete: deletion failed\");\n}\n     // And throw an exception if it didn't work for some (unknown) reason.\n\n     // For example, because of a bug with Java 1.1.1 on Linux, \n\n","name":"delete","className":"Delete","variables":{"filename":4,"f":6,"success":2,"files":1},"constants":{"0":1,"\"Delete: no such file or directory: \"":1,"\"Delete: directory not empty: \"":1,"\"Delete: write protected: \"":1,"\"Delete: deletion failed\"":1},"javaDoc":"The static method that does the deletion Invoked by main() and designed for use by other programs as well It first makes sure that the specified file or directory is deleteable before attempting to delete it If there is a problem it throws an IllegalArgumentException","comments":"And throw an exception if it didn't work for some (unknown) reason For example because of a bug with Java 1 1 1 on Linux Create a File object to represent the filename Make sure the file or directory exists and isn't write protected If it is a directory make sure it is empty If we passed all the tests then attempt to delete it directory deletion always fails \n   * The static method that does the deletion.  Invoked by main(), and designed\n   * for use by other programs as well.  It first makes sure that the \n   * specified file or directory is deleteable before attempting to delete it.\n   * If there is a problem, it throws an IllegalArgumentException.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ThrowStmt":1},"text":"/** A convenience method to throw an exception */\nprotected static void fail(String msg) throws IllegalArgumentException {\n    throw new IllegalArgumentException(msg);\n}\n","name":"fail","className":"Delete","variables":{"msg":1},"constants":{},"javaDoc":"A convenience method to throw an exception","comments":" A convenience method to throw an exception ","isEmpty":false,"hasInnerClass":false,"modifier":12}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"read":1,"length":1,"getByName":1,"System.err.println":2,"send":1,"close":1,"getBytes":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":1,"DatagramSocket":1,"DatagramPacket":1,"String":2,"File":1,"InetAddress":1,"int":4,"FileInputStream":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":5,"VariableDeclarationExpr":12,"ArrayAccessExpr":6,"BinaryExpr":8,"NameExpr":72,"StringLiteralExpr":5,"UnaryExpr":2,"AssignExpr":5,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":5,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":20,"DoStmt":1},"text":"public static void main(String args[]) {\n    try {\n        // Check the number of arguments\n        if (args.length < 3)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Parse the arguments\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        // Figure out the message to send.  \n        // If the third argument is -f, then send the contents of the file\n        // specified as the fourth argument.  Otherwise, concatenate the \n        // third and all remaining arguments and send that.\n        byte[] message;\n        if (args[2].equals(\"-f\")) {\n            File f = new File(args[3]);\n            // figure out how big the file is\n            int len = (int) f.length();\n            // create a buffer big enough\n            message = new byte[len];\n            FileInputStream in = new FileInputStream(f);\n            int bytes_read = 0, n;\n            do {\n                // loop until we've read it all\n                n = in.read(message, bytes_read, len - bytes_read);\n                bytes_read += n;\n            } while ((bytes_read < len) && (n != -1));\n        } else {\n            // Otherwise, just combine all the remaining arguments.\n            String msg = args[2];\n            for (int i = 3; i < args.length; i++) msg += \" \" + args[i];\n            message = msg.getBytes();\n        }\n        // Get the internet address of the specified host\n        InetAddress address = InetAddress.getByName(host);\n        // Initialize a datagram packet with data and address\n        DatagramPacket packet = new DatagramPacket(message, message.length, address, port);\n        // Create a datagram socket, send the packet through it, close it.\n        DatagramSocket dsocket = new DatagramSocket();\n        dsocket.send(packet);\n        dsocket.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java UDPSend <hostname> <port> <msg>...\\n\" + \"   or: java UDPSend <hostname> <port> -f <file>\");\n    }\n}\n","name":"main","className":"UDPSend","variables":{"msg":3,"dsocket":3,"address":2,"in":2,"e":1,"f":3,"i":4,"bytes_read":4,"message":4,"packet":1,"n":4,"args":6,"Integer":1,"len":4,"port":2,"host":1,"InetAddress":1},"constants":{"0":2,"\"   or: java UDPSend <hostname> <port> -f <file>\"":1,"1":2,"2":2,"3":3,"\" \"":1,"\"Wrong number of arguments\"":1,"\"-f\"":1,"\"Usage: java UDPSend <hostname> <port> <msg>...\\n\"":1},"javaDoc":"","comments":"Figure out the message to send If the third argument is -f then send the contents of the file specified as the fourth argument Otherwise concatenate the Check the number of arguments Parse the arguments third and all remaining arguments and send that figure out how big the file is create a buffer big enough loop until we've read it all Otherwise just combine all the remaining arguments Get the internet address of the specified host Initialize a datagram packet with data and address Create a datagram socket send the packet through it close it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setFont":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2,"Font":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":8,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":4},"text":"public void paint(Graphics g) {\n    for (int family = 0; family < families.length; family++) {\n        // for each family\n        for (int style = 0; style < styles.length; style++) {\n            // for each style\n            // create font\n            Font f = new Font(families[family], styles[style], 16);\n            // create name\n            String s = families[family] + \" \" + stylenames[style];\n            // set font\n            g.setFont(f);\n            // display name\n            g.drawString(s, 10, (family * 4 + style + 1) * 20);\n        }\n    }\n}\n","name":"paint","className":"FontList","variables":{"s":1,"stylenames":1,"f":1,"g":2,"style":6,"styles":1,"family":6,"families":2},"constants":{"0":2,"1":1,"\" \"":1,"4":1,"16":1,"20":1,"10":1},"javaDoc":"","comments":"for each family for each style create font create name set font display name ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","String","Object"],"returnType":"UniversalActionListener","methodCalls":{"getClass":2,"getMethod":1},"annotations":[],"exceptions":["SecurityException","NoSuchMethodException"],"concepts":[],"types":{"Class":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BinaryExpr":1,"NameExpr":22,"FieldAccessExpr":2,"ArrayCreationExpr":2,"ThisExpr":2,"AssignExpr":6,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":7},"text":"public UniversalActionListener(Object target, String methodname, Object arg) throws NoSuchMethodException, SecurityException {\n    // Save the target object.\n    this.target = target;\n    // And method argument.\n    this.arg = arg;\n    // Now look up and save the Method to invoke on that target object\n    Class c, parameters[];\n    // The Class object.\n    c = target.getClass();\n    if (// Method parameter.\n    arg == null)\n        // Method parameter.\n        parameters = new Class[0];\n    else\n        parameters = new Class[] { arg.getClass() };\n    // Find matching method.\n    m = c.getMethod(methodname, parameters);\n}\n","name":"UniversalActionListener","className":"UniversalActionListener","variables":{"c":3,"arg":3,"parameters":3,"m":1,"target":2},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Save the target object And method argument Now look up and save the Method to invoke on that target object The Class object Method parameter Method parameter Find matching method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"invoke":1,"System.err.println":2},"annotations":[],"exceptions":["// Should never happen.\nInvocationTargetException","// Should never happen.\nIllegalAccessException"],"concepts":["ExceptionHandling"],"types":{"Object[]":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":2,"FieldAccessExpr":2,"ArrayCreationExpr":2,"AssignExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":6},"text":"public void actionPerformed(ActionEvent event) {\n    Object[] arguments;\n    if (// Set up arguments.\n    arg == null)\n        // Set up arguments.\n        arguments = new Object[0];\n    else\n        arguments = new Object[] { arg };\n    try // And invoke the method.\n    {\n        m.invoke(target, arguments);\n    } catch (// Should never happen.\n    IllegalAccessException // Should never happen.\n    e) {\n        System.err.println(\"UniversalActionListener: \" + e);\n    } catch (// Should never happen.\n    InvocationTargetException // Should never happen.\n    e) {\n        System.err.println(\"UniversalActionListener: \" + e);\n    }\n}\n","name":"actionPerformed","className":"UniversalActionListener","variables":{"e":4,"arg":2,"arguments":3,"m":1},"constants":{"0":1,"null":1,"\"UniversalActionListener: \"":2},"javaDoc":"","comments":"Set up arguments Set up arguments And invoke the method Should never happen Should never happen Should never happen Should never happen ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"addActionListener":7,"show":1,"setLayout":1,"pack":1},"annotations":[],"exceptions":["NoSuchMethodException"],"concepts":[],"types":{"Frame":1,"Button":3},"expressions":{"ObjectCreationExpr":12,"NullLiteralExpr":3,"VariableDeclarationExpr":4,"StringLiteralExpr":15,"NameExpr":49,"MethodCallExpr":13},"statements":{"ExpressionStmt":17},"text":"// A simple test program for the UniversalActionListener\npublic static void main(String[] args) throws NoSuchMethodException {\n    // Create window.\n    Frame f = new Frame(\"UniversalActionListener Test\");\n    // Set layout manager.\n    f.setLayout(new FlowLayout());\n    // Create buttons.\n    Button b1 = new Button(\"tick\");\n    Button b2 = new Button(\"tock\");\n    Button b3 = new Button(\"Close Window\");\n    // Add them to window.\n    f.add(b1);\n    // Add them to window.\n    f.add(b2);\n    // Add them to window.\n    f.add(b3);\n    // Specify what the buttons do.  Invoke a named method with\n    // the UniversalActionListener object.\n    b1.addActionListener(new UniversalActionListener(b1, \"setLabel\", \"tock\"));\n    b1.addActionListener(new UniversalActionListener(b2, \"setLabel\", \"tick\"));\n    b1.addActionListener(new UniversalActionListener(b3, \"hide\", null));\n    b2.addActionListener(new UniversalActionListener(b1, \"setLabel\", \"tick\"));\n    b2.addActionListener(new UniversalActionListener(b2, \"setLabel\", \"tock\"));\n    b2.addActionListener(new UniversalActionListener(b3, \"show\", null));\n    b3.addActionListener(new UniversalActionListener(f, \"dispose\", null));\n    // Set window size.\n    f.pack();\n    // And pop it up.\n    f.show();\n}\n","name":"main","className":"UniversalActionListener","variables":{"b2":6,"b3":4,"f":8,"b1":6},"constants":{"\"UniversalActionListener Test\"":1,"\"hide\"":1,"\"setLabel\"":4,"\"dispose\"":1,"null":3,"\"tock\"":3,"\"show\"":1,"\"tick\"":3,"\"Close Window\"":1},"javaDoc":"","comments":"Specify what the buttons do Invoke a named method with Create window Set layout manager Create buttons Add them to window Add them to window Add them to window the UniversalActionListener object Set window size And pop it up  A simple test program for the UniversalActionListener","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":14,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":4,"BlockStmt":1,"SwitchEntryStmt":12,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    for (int i = 1; i <= 100; i++) {\n        // count from 1 to 100\n        switch(// What's the remainder when divided by 35?\n        i % 35) {\n            case // For multiples of 35...\n            0:\n                // print \"fizzbuzz\"\n                System.out.print(\"fizzbuzz \");\n                // Don't forget this statement!\n                break;\n            // If the remainder is any of these\n            case 5:\n            // If the remainder is any of these\n            case 10:\n            // If the remainder is any of these\n            case 15:\n            case 20:\n            case 25:\n            case // then the number is a multiple of 5\n            30:\n                // so print \"fizz\"\n                System.out.print(\"fizz \");\n                break;\n            case 7:\n            case 14:\n            case 21:\n            case // For any multiple of 7...\n            28:\n                // print \"buzz\"\n                System.out.print(\"buzz \");\n                break;\n            default:\n                // For any other number...\n                // print the number\n                System.out.print(i + \" \");\n                break;\n        }\n    }\n    System.out.println();\n}\n","name":"main","className":"FizzBuzz2","variables":{"i":5},"constants":{"35":1,"25":1,"14":1,"15":1,"\"fizz \"":1,"\" \"":1,"\"buzz \"":1,"1":1,"100":1,"5":1,"7":1,"\"fizzbuzz \"":1,"20":1,"10":1,"21":1},"javaDoc":"","comments":"count from 1 to 100 What's the remainder when divided by 35? For multiples of 35 print \"fizzbuzz\" Don't forget this statement! If the remainder is any of these If the remainder is any of these If the remainder is any of these then the number is a multiple of 5 so print \"fizz\" For any multiple of 7 print \"buzz\" For any other number print the number ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","FilenameFilter"],"returnType":"FileLister","methodCalls":{"add":2,"setEditable":1,"listDirectory":1,"addActionListener":3,"addItemListener":1,"setFont":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":8,"BooleanLiteralExpr":2,"StringLiteralExpr":9,"NameExpr":69,"FieldAccessExpr":5,"ThisExpr":9,"AssignExpr":6,"MethodCallExpr":16},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":22},"text":"/** \n   * Constructor: create the GUI, and list the initial directory. \n   **/\npublic FileLister(String directory, FilenameFilter filter) {\n    // Create the window\n    super(\"File Lister\");\n    // Save the filter, if any\n    this.filter = filter;\n    // Set up the list\n    list = new List(12, false);\n    list.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 14));\n    list.addActionListener(this);\n    list.addItemListener(this);\n    // Set up the details area\n    details = new TextField();\n    details.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 12));\n    details.setEditable(false);\n    // Set up the button box\n    buttons = new Panel();\n    buttons.setLayout(new FlowLayout(FlowLayout.RIGHT, 15, 5));\n    buttons.setFont(new Font(\"SansSerif\", Font.BOLD, 14));\n    // Set up the two buttons\n    up = new Button(\"Up a Directory\");\n    close = new Button(\"Close\");\n    up.addActionListener(this);\n    close.addActionListener(this);\n    // Add buttons to button box\n    buttons.add(up);\n    buttons.add(close);\n    // Add stuff to the window\n    this.add(list, \"Center\");\n    this.add(details, \"North\");\n    this.add(buttons, \"South\");\n    this.setSize(500, 350);\n    // And now list the initial directory.\n    listDirectory(directory);\n}\n","name":"FileLister","className":"FileLister","variables":{"filter":1,"buttons":5,"details":3,"up":2,"list":4,"close":2},"constants":{"\"North\"":1,"12":2,"\"Close\"":1,"14":2,"15":1,"false":2,"\"SansSerif\"":1,"\"Up a Directory\"":1,"\"File Lister\"":1,"\"Center\"":1,"350":1,"\"MonoSpaced\"":2,"5":1,"500":1,"\"South\"":1},"javaDoc":"Constructor: create the GUI and list the initial directory","comments":"Create the window Save the filter if any Set up the list Set up the details area Set up the button box Set up the two buttons Add buttons to button box Add stuff to the window And now list the initial directory  \n   * Constructor: create the GUI, and list the initial directory. \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"addItem":2,"removeAll":1,"sort":1,"list":1,"isDirectory":1,"setText":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":38,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"/**\n   * This method uses the list() method to get all entries in a directory\n   * and then displays them in the List component. \n   **/\npublic void listDirectory(String directory) {\n    // Convert the string to a File object, and check that the dir exists\n    File dir = new File(directory);\n    if (!dir.isDirectory())\n        throw new IllegalArgumentException(\"FileLister: no such directory\");\n    // Get the (filtered) directory entries\n    files = dir.list(filter);\n    // And sort them.\n    Sorter.sort(files);\n    // Remove any old entries in the list, and add the new ones\n    list.removeAll();\n    // A special case entry\n    list.addItem(\"[Up to Parent Directory]\");\n    for (int i = 0; i < files.length; i++) list.addItem(files[i]);\n    // Display directory name in window titlebar and in the details box\n    this.setTitle(directory);\n    details.setText(directory);\n    // Remember this directory for later.\n    currentDir = dir;\n}\n","name":"listDirectory","className":"FileLister","variables":{"currentDir":1,"Sorter":1,"files":2,"i":4,"details":1,"dir":4,"list":3,"directory":1},"constants":{"0":1,"\"[Up to Parent Directory]\"":1,"\"FileLister: no such directory\"":1},"javaDoc":"This method uses the list() method to get all entries in a directory and then displays them in the List component","comments":"Convert the string to a File object and check that the dir exists Get the (filtered) directory entries And sort them Remove any old entries in the list and add the new ones A special case entry Display directory name in window titlebar and in the details box Remember this directory for later \n   * This method uses the list() method to get all entries in a directory\n   * and then displays them in the List component. \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"canRead":1,"length":1,"format":1,"getSelectedIndex":1,"exists":1,"canWrite":1,"lastModified":1,"isDirectory":1,"setText":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"String":2,"File":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":42,"StringLiteralExpr":6,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":9,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":10},"text":"/**\n   * This ItemListener method uses various File methods to obtain information\n   * about a file or directory. Then it displays that info in the details box.\n   **/\npublic void itemStateChanged(ItemEvent e) {\n    // minus 1 for Up To Parent entry\n    int i = list.getSelectedIndex() - 1;\n    if (i < 0)\n        return;\n    // Get the selected entry \n    String filename = files[i];\n    // Convert to a File\n    File f = new File(currentDir, filename);\n    if (// Confirm that it exists\n    !f.exists())\n        throw new IllegalArgumentException(\"FileLister: \" + \"no such file or directory\");\n    // Get the details about the file or directory, concatenate to a string\n    String info = filename;\n    if (f.isDirectory())\n        info += File.separator;\n    info += \" \" + f.length() + \" bytes \";\n    info += dateFormatter.format(new java.util.Date(f.lastModified()));\n    if (f.canRead())\n        info += \" Read\";\n    if (f.canWrite())\n        info += \" Write\";\n    // And display the details string\n    details.setText(info);\n}\n","name":"itemStateChanged","className":"FileLister","variables":{"filename":3,"currentDir":1,"f":7,"i":3,"files":1,"dateFormatter":1,"details":1,"list":1,"info":6},"constants":{"0":1,"1":1,"\" \"":1,"\" bytes \"":1,"\"FileLister: \"":1,"\"no such file or directory\"":1,"\" Write\"":1,"\" Read\"":1},"javaDoc":"This ItemListener method uses various File methods to obtain information about a file or directory Then it displays that info in the details box","comments":"minus 1 for Up To Parent entry Get the selected entry Convert to a File Confirm that it exists Get the details about the file or directory concatenate to a string And display the details string \n   * This ItemListener method uses various File methods to obtain information\n   * about a file or directory. Then it displays that info in the details box.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getAbsolutePath":1,"getSource":3,"listDirectory":1,"getSelectedIndex":1,"up":2,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"File":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":38,"ThisExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":5,"BlockStmt":3,"ExpressionStmt":9},"text":"/**\n   * This ActionListener method is invoked when the user double-clicks on an \n   * entry or clicks on one of the buttons.  If they double-click on a file,\n   * create a FileViewer to display that file.  If they double-click on a\n   * directory, call the listDirectory() method to display that directory\n   **/\npublic void actionPerformed(ActionEvent e) {\n    if (e.getSource() == close)\n        this.dispose();\n    else if (e.getSource() == up) {\n        up();\n    } else if (e.getSource() == list) {\n        // Double click on an item\n        // Check which item\n        int i = list.getSelectedIndex();\n        if (// Handle first Up To Parent item\n        i == 0)\n            // Handle first Up To Parent item\n            up();\n        else {\n            // Otherwise, get filename\n            String name = files[i - 1];\n            // Convert to a File\n            File f = new File(currentDir, name);\n            String fullname = f.getAbsolutePath();\n            if (// List a directory\n            f.isDirectory())\n                // List a directory\n                listDirectory(fullname);\n            else\n                // or display a file\n                new FileViewer(fullname).show();\n        }\n    }\n}\n","name":"actionPerformed","className":"FileLister","variables":{"currentDir":1,"e":3,"f":3,"name":2,"i":3,"files":1,"up":1,"fullname":2,"list":2,"close":1},"constants":{"0":1,"1":1},"javaDoc":"This ActionListener method is invoked when the user double-clicks on an entry or clicks on one of the buttons If they double-click on a file create a FileViewer to display that file If they double-click on a directory call the listDirectory() method to display that directory","comments":"Double click on an item Check which item Handle first Up To Parent item Handle first Up To Parent item Otherwise get filename Convert to a File List a directory List a directory or display a file \n   * This ActionListener method is invoked when the user double-clicks on an \n   * entry or clicks on one of the buttons.  If they double-click on a file,\n   * create a FileViewer to display that file.  If they double-click on a\n   * directory, call the listDirectory() method to display that directory\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getParent":1,"listDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** A convenience method to display the contents of the parent directory */\nprotected void up() {\n    String parent = currentDir.getParent();\n    if (parent == null)\n        return;\n    listDirectory(parent);\n}\n","name":"up","className":"FileLister","variables":{"parent":2,"currentDir":1},"constants":{"null":1},"javaDoc":"A convenience method to display the contents of the parent directory","comments":" A convenience method to display the contents of the parent directory ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** A convenience method used by main() */\npublic static void usage() {\n    System.out.println(\"Usage: java FileLister [directory_name] \" + \"[-e file_extension]\");\n    System.exit(0);\n}\n","name":"usage","className":"FileLister","variables":{"System":1},"constants":{"0":1,"\"Usage: java FileLister [directory_name] \"":1,"\"[-e file_extension]\"":1},"javaDoc":"A convenience method used by main()","comments":" A convenience method used by main() ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","String"],"returnType":"boolean","methodCalls":{"endsWith":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"public boolean accept(File dir, String name) {\n    if (name.endsWith(suffix))\n        return true;\n    else\n        return (new File(dir, name)).isDirectory();\n}\n","name":"accept","className":"","variables":{"name":2,"dir":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosed(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addWindowListener":1,"exit":1,"getProperty":1,"usage":2,"endsWith":1,"show":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","FinalVariables"],"types":{"FilenameFilter":1,"String":2,"int":1,"FileLister":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":5,"BlockStmt":5,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":13},"text":"/**\n   * A main() method so FileLister can be run standalone.\n   * Parse command line arguments and create the FileLister object.\n   * If an extension is specified, create a FilenameFilter for it.\n   * If no directory is specified, use the current directory.\n   */\npublic static void main(String args[]) throws IOException {\n    FileLister f;\n    // The filter, if any\n    FilenameFilter filter = null;\n    // The specified dir, or the current dir\n    String directory = null;\n    // Loop through args array, parsing arguments\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-e\")) {\n            if (++i >= args.length)\n                usage();\n            // final for use in anon. class below\n            final String suffix = args[i];\n            // This class is a simple FilenameFilter.  It defines the\n            // accept() method required to determine whether a specified\n            // file should be listed.  A file will be listed if its name\n            // ends with the specified extension, or if it is a directory.\n            filter = new FilenameFilter() {\n\n                public boolean accept(File dir, String name) {\n                    if (name.endsWith(suffix))\n                        return true;\n                    else\n                        return (new File(dir, name)).isDirectory();\n                }\n            };\n        } else {\n            if (// If dir already specified, fail.\n            directory != null)\n                // If dir already specified, fail.\n                usage();\n            else\n                directory = args[i];\n        }\n    }\n    // if no directory specified, use the current directoy\n    if (directory == null)\n        directory = System.getProperty(\"user.dir\");\n    // Create the FileLister object, with directory and filter specified.\n    f = new FileLister(directory, filter);\n    // Arrange for the application to exit when the FileLister window closes\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosed(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // And pop up the FileLister.\n    f.show();\n}\n","name":"main","className":"FileLister","variables":{"filter":3,"args":3,"windowClosed":1,"e":1,"f":4,"name":3,"i":7,"suffix":1,"dir":2,"directory":6,"System":2,"accept":1},"constants":{"0":2,"\"user.dir\"":1,"null":4,"\"-e\"":1,"true":1},"javaDoc":"A main() method so FileLister can be run standalone Parse command line arguments and create the FileLister object If an extension is specified create a FilenameFilter for it If no directory is specified use the current directory","comments":"The filter if any The specified dir or the current dir Loop through args array parsing arguments This class is a simple FilenameFilter It defines the accept() method required to determine whether a specified file should be listed A file will be listed if its name final for use in anon class below ends with the specified extension or if it is a directory If dir already specified fail If dir already specified fail if no directory specified use the current directoy Create the FileLister object with directory and filter specified Arrange for the application to exit when the FileLister window closes And pop up the FileLister \n   * A main() method so FileLister can be run standalone.\n   * Parse command line arguments and create the FileLister object.\n   * If an extension is specified, create a FilenameFilter for it.\n   * If no directory is specified, use the current directory.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"next":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    // When button is clicked\n    // display the next one.\n    cardlayout.next(CardLayoutExample.this);\n}\n","name":"actionPerformed","className":"","variables":{"CardLayoutExample":1,"cardlayout":1},"constants":{},"javaDoc":"","comments":"When button is clicked display the next one ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":1,"addActionListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"CardLayout":1,"ActionListener":1,"Button":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":2,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":4},"statements":{"BlockStmt":2,"ForStmt":1,"ExpressionStmt":7},"text":"public void init() {\n    // Create a layout manager, and save a reference to it for future use.\n    // This CardLayout leaves 10 pixels margins around the component.\n    final CardLayout cardlayout = new CardLayout(10, 10);\n    // Specify the layout manager for the applet\n    this.setLayout(cardlayout);\n    for (int i = 1; i <= 9; i++) {\n        Button b = new Button(\"Button #\" + i);\n        ActionListener listener = new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                // When button is clicked\n                // display the next one.\n                cardlayout.next(CardLayoutExample.this);\n            }\n        };\n        b.addActionListener(listener);\n        // Specify a name for each component\n        this.add(\"Button\" + i, b);\n    }\n}\n","name":"init","className":"CardLayoutExample","variables":{"actionPerformed":1,"b":2,"e":1,"CardLayoutExample":1,"listener":1,"i":5,"cardlayout":2},"constants":{"1":1,"9":1,"\"Button #\"":1,"\"Button\"":1,"10":2},"javaDoc":"","comments":"Create a layout manager and save a reference to it for future use This CardLayout leaves 10 pixels margins around the component Specify the layout manager for the applet When button is clicked display the next one Specify a name for each component ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"exit":1,"addService":1,"System.err.println":2},"annotations":[],"exceptions":["// Print an error message if anything goes wrong.\nException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"Server":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":42,"StringLiteralExpr":3,"FieldAccessExpr":5,"EnclosedExpr":2,"UnaryExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":9},"text":"/** \n   * Create a Server object, and add Proxy service objects to it to provide\n   * proxy service as specified by the command-line arguments.\n   **/\npublic static void main(String[] args) {\n    try {\n        // Check number of args.  Must be a multiple of 3 and > 0.\n        if ((args.length == 0) || (args.length % 3 != 0))\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Create the Server object\n        // log stream, max connections\n        Server s = new Server(null, 12);\n        // Loop through the arguments parsing (host, remoteport, localport)\n        // tuples.  Create an appropriate Proxy object, and add it to the server\n        int i = 0;\n        while (i < args.length) {\n            String host = args[i++];\n            int remoteport = Integer.parseInt(args[i++]);\n            int localport = Integer.parseInt(args[i++]);\n            s.addService(new Proxy(host, remoteport), localport);\n        }\n    } catch (// Print an error message if anything goes wrong.\n    Exception // Print an error message if anything goes wrong.\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java ProxyServer \" + \"<host> <remoteport> <localport> ...\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"ProxyServer","variables":{"args":3,"Integer":2,"s":2,"e":1,"host":2,"i":5,"remoteport":2,"localport":1,"System":1},"constants":{"0":3,"\"Usage: java ProxyServer \"":1,"12":1,"1":1,"3":1,"null":1,"\"Wrong number of arguments\"":1,"\"<host> <remoteport> <localport> ...\"":1},"javaDoc":"Create a Server object and add Proxy service objects to it to provide proxy service as specified by the command-line arguments","comments":"Create the Server object Loop through the arguments parsing (host remoteport localport) Check number of args Must be a multiple of 3 and > 0 log stream max connections tuples Create an appropriate Proxy object and add it to the server Print an error message if anything goes wrong Print an error message if anything goes wrong  \n   * Create a Server object, and add Proxy service objects to it to provide\n   * proxy service as specified by the command-line arguments.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"Proxy","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Remember the host and port we are a proxy for */\npublic Proxy(String host, int port) {\n    this.host = host;\n    this.port = port;\n}\n","name":"Proxy","className":"Proxy","variables":{"port":1,"host":1},"constants":{},"javaDoc":"Remember the host and port we are a proxy for","comments":" Remember the host and port we are a proxy for ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":6},"text":"public void run() {\n    byte[] buffer = new byte[2048];\n    int bytes_read;\n    try {\n        while ((bytes_read = from_client.read(buffer)) != -1) {\n            to_server.write(buffer, 0, bytes_read);\n            to_server.flush();\n        }\n    } catch (IOException e) {\n    }\n    // if the client closed its stream to us, we close our stream\n    // to the server.  First, stop the other thread\n    threads[1].stop();\n    try {\n        to_server.close();\n    } catch (IOException e) {\n    }\n}\n","name":"run","className":"","variables":{"to_server":3,"from_client":1,"e":2,"threads":1,"bytes_read":2,"buffer":1},"constants":{"0":1,"1":2,"2048":1},"javaDoc":"","comments":"if the client closed its stream to us we close our stream to the server First stop the other thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":19,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":6},"text":"public void run() {\n    byte[] buffer = new byte[2048];\n    int bytes_read;\n    try {\n        while ((bytes_read = from_server.read(buffer)) != -1) {\n            to_client.write(buffer, 0, bytes_read);\n            to_client.flush();\n        }\n    } catch (IOException e) {\n    }\n    // if the server closed its stream to us, we close our stream\n    // to the client.  First, stop the other thread, though.\n    threads[0].stop();\n    try {\n        to_client.close();\n    } catch (IOException e) {\n    }\n}\n","name":"run","className":"","variables":{"e":2,"to_client":3,"threads":1,"bytes_read":2,"from_server":1,"buffer":1},"constants":{"0":2,"1":1,"2048":1},"javaDoc":"","comments":"if the server closed its stream to us we close our stream to the client First stop the other thread though ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"println":1,"read":2,"flush":3,"start":2,"getOutputStream":1,"join":2,"getInputStream":1,"close":4,"write":2},"annotations":[],"exceptions":["IOException","InterruptedException","Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"byte[]":2,"InputStream":2,"OutputStream":2,"Thread[]":1,"Socket":1,"int":2,"PrintWriter":1,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":11,"VariableDeclarationExpr":13,"ArrayAccessExpr":4,"BinaryExpr":5,"NameExpr":86,"StringLiteralExpr":2,"EnclosedExpr":2,"ArrayCreationExpr":3,"UnaryExpr":2,"AssignExpr":7,"MethodCallExpr":20},"statements":{"WhileStmt":2,"TryStmt":7,"BlockStmt":18,"ReturnStmt":1,"ExpressionStmt":34},"text":"/** The server invokes this method when a client connects. */\npublic void serve(InputStream in, OutputStream out) {\n    // These are some sockets we'll use.  They are final so they can be used\n    // by the anonymous classes defined below.\n    final InputStream from_client = in;\n    final OutputStream to_client = out;\n    final InputStream from_server;\n    final OutputStream to_server;\n    // Try to establish a connection to the specified server and port\n    // and get sockets to talk to it.  Tell our client if we fail.\n    Socket server;\n    try {\n        server = new Socket(host, port);\n        from_server = server.getInputStream();\n        to_server = server.getOutputStream();\n    } catch (Exception e) {\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));\n        pw.println(\"Proxy server could not connect to \" + host + \":\" + port);\n        pw.flush();\n        pw.close();\n        try {\n            in.close();\n        } catch (IOException ex) {\n        }\n        return;\n    }\n    // Create an array to hold two Threads.  It is declared final so that\n    // it can be used by the anonymous classes below.  We use an array\n    // instead of two variables because given the structure of this program\n    // two variables would not work if declared final.\n    final Thread[] threads = new Thread[2];\n    // Define and create a thread to transmit bytes from client to server\n    Thread c2s = new Thread() {\n\n        public void run() {\n            byte[] buffer = new byte[2048];\n            int bytes_read;\n            try {\n                while ((bytes_read = from_client.read(buffer)) != -1) {\n                    to_server.write(buffer, 0, bytes_read);\n                    to_server.flush();\n                }\n            } catch (IOException e) {\n            }\n            // if the client closed its stream to us, we close our stream\n            // to the server.  First, stop the other thread\n            threads[1].stop();\n            try {\n                to_server.close();\n            } catch (IOException e) {\n            }\n        }\n    };\n    // Define and create a thread to copy bytes from server to client.\n    Thread s2c = new Thread() {\n\n        public void run() {\n            byte[] buffer = new byte[2048];\n            int bytes_read;\n            try {\n                while ((bytes_read = from_server.read(buffer)) != -1) {\n                    to_client.write(buffer, 0, bytes_read);\n                    to_client.flush();\n                }\n            } catch (IOException e) {\n            }\n            // if the server closed its stream to us, we close our stream\n            // to the client.  First, stop the other thread, though.\n            threads[0].stop();\n            try {\n                to_client.close();\n            } catch (IOException e) {\n            }\n        }\n    };\n    // Store the threads into the final threads[] array, so that the \n    // anonymous classes can refer to each other.\n    threads[0] = c2s;\n    threads[1] = s2c;\n    // start the threads\n    c2s.start();\n    s2c.start();\n    // Wait for them to exit\n    try {\n        c2s.join();\n        s2c.join();\n    } catch (InterruptedException e) {\n    }\n}\n","name":"serve","className":"Proxy","variables":{"server":4,"from_client":2,"in":2,"e":6,"c2s":4,"s2c":4,"pw":4,"to_client":4,"threads":5,"from_server":3,"run":2,"bytes_read":4,"out":2,"to_server":5,"ex":1,"port":2,"host":2,"buffer":2},"constants":{"\"Proxy server could not connect to \"":1,"0":4,"1":4,"2":1,"2048":2,"\":\"":1},"javaDoc":"The server invokes this method when a client connects","comments":"These are some sockets we'll use They are final so they can be used Try to establish a connection to the specified server and port Create an array to hold two Threads It is declared final so that it can be used by the anonymous classes below We use an array instead of two variables because given the structure of this program Store the threads into the final threads[] array so that the by the anonymous classes defined below and get sockets to talk to it Tell our client if we fail two variables would not work if declared final Define and create a thread to transmit bytes from client to server if the client closed its stream to us we close our stream to the server First stop the other thread Define and create a thread to copy bytes from server to client if the server closed its stream to us we close our stream to the client First stop the other thread though anonymous classes can refer to each other start the threads Wait for them to exit  The server invokes this method when a client connects. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMessage":1,"copy":1,"System.err.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"/** The main() method of the standalone program.  Calls copy(). */\npublic static void main(String[] args) {\n    if (// Check arguments \n    args.length != 2)\n        System.err.println(\"Usage: java FileCopy <source file> <destination>\");\n    else {\n        // Call copy() to do the copy, and display any error messages it throws.\n        try {\n            copy(args[0], args[1]);\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}\n","name":"main","className":"FileCopy","variables":{"args":2,"e":2},"constants":{"0":1,"1":1,"2":1,"\"Usage: java FileCopy <source file> <destination>\"":1},"javaDoc":"The main() method of the standalone program Calls copy()","comments":"Check arguments Call copy() to do the copy and display any error messages it throws  The main() method of the standalone program.  Calls copy(). ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"getParent":1,"getName":1,"getProperty":1,"read":1,"isFile":2,"canRead":1,"System.out.flush":1,"canWrite":2,"readLine":1,"abort":8,"equals":2,"exists":3,"write":1,"close":2,"isDirectory":1,"System.out.print":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"FileOutputStream":1,"BufferedReader":1,"String":2,"File":3,"FileInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":3,"VariableDeclarationExpr":10,"BinaryExpr":14,"NameExpr":111,"StringLiteralExpr":13,"UnaryExpr":9,"AssignExpr":5,"NullLiteralExpr":5,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":29},"statements":{"IfStmt":13,"WhileStmt":1,"BlockStmt":8,"TryStmt":3,"EmptyStmt":2,"ExpressionStmt":27},"text":"/**\n   * The static method that actually performs the file copy.\n   * Before copying the file, however, it performs a lot of tests to make\n   * sure everything is as it should be.\n   */\npublic static void copy(String from_name, String to_name) throws IOException {\n    // Get File objects from Strings\n    File from_file = new File(from_name);\n    File to_file = new File(to_name);\n    // First make sure the source file exists, is a file, and is readable.\n    if (!from_file.exists())\n        abort(\"FileCopy: no such source file: \" + from_name);\n    if (!from_file.isFile())\n        abort(\"FileCopy: can't copy directory: \" + from_name);\n    if (!from_file.canRead())\n        abort(\"FileCopy: source file is unreadable: \" + from_name);\n    // as the destination file name\n    if (to_file.isDirectory())\n        to_file = new File(to_file, from_file.getName());\n    // exist, make sure the directory exists and is writeable.\n    if (to_file.exists()) {\n        if (!to_file.canWrite())\n            abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        // Ask whether to overwrite it\n        System.out.print(\"Overwrite existing file \" + to_name + \"? (Y/N): \");\n        System.out.flush();\n        // Get the user's response.\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String response = in.readLine();\n        // Check the response.  If not a Yes, abort the copy.\n        if (!response.equals(\"Y\") && !response.equals(\"y\"))\n            abort(\"FileCopy: existing file was not overwritten.\");\n    } else {\n        // if file doesn't exist, check if directory exists and is writeable.\n        // If getParent() returns null, then the directory is the current dir.\n        // so look up the user.dir system property to find out what that is.\n        // Get the destination directory\n        String parent = to_file.getParent();\n        // or CWD\n        if (parent == null)\n            parent = System.getProperty(\"user.dir\");\n        // Convert it to a file.\n     // If the destination is a directory, use the source file name\n\n        File dir = new File(parent);\n        if (!dir.exists())\n            abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n        if (dir.isFile())\n     // If the destination exists, make sure it is a writeable file\n\n     // and ask before overwriting it.  If the destination doesn't\n\n            abort(\"FileCopy: destination is not a directory: \" + parent);\n        if (!dir.canWrite())\n            abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n    }\n    // If we've gotten this far, then everything is okay.\n    // So we copy the file, a buffer of bytes at a time.\n    // Stream to read from source\n    FileInputStream from = null;\n    // Stream to write to destination\n    FileOutputStream to = null;\n    try {\n        // Create input stream\n        from = new FileInputStream(from_file);\n        // Create output stream\n        to = new FileOutputStream(to_file);\n        // A buffer to hold file contents\n        byte[] buffer = new byte[4096];\n        // How many bytes in buffer\n        int bytes_read;\n        // loop.  This is a common I/O programming idiom.\n        while (// Read bytes until EOF\n        (bytes_read = from.read(buffer)) != -1) //   write bytes \n        to.write(buffer, 0, bytes_read);\n    } finally // Always close the streams, even if exceptions were thrown\n    {\n        if (from != null)\n            try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n        if (to != null)\n            try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n    }\n       // Read a chunk of bytes into the buffer, then write them out, \n\n       // looping until we reach the end of the file (when read() returns -1).\n\n       // Note the combination of assignment and comparison in this while\n\n}\n","name":"copy","className":"FileCopy","variables":{"parent":7,"to_name":3,"in":2,"e":2,"to_file":8,"bytes_read":2,"from_name":4,"dir":4,"System":1,"response":3,"from_file":6,"from":5,"to":5,"buffer":1},"constants":{"\"FileCopy: destination file is unwriteable: \"":1,"4096":1,"\"FileCopy: destination is not a directory: \"":1,"\"FileCopy: no such source file: \"":1,"\"FileCopy: can't copy directory: \"":1,"\"? (Y/N): \"":1,"\"Y\"":1,"\"y\"":1,"\"FileCopy: source file is unreadable: \"":1,"\"FileCopy: existing file was not overwritten.\"":1,"\"FileCopy: destination directory is unwriteable: \"":1,"0":1,"1":1,"\"user.dir\"":1,"null":5,"\"FileCopy: destination directory doesn't exist: \"":1,"\"Overwrite existing file \"":1},"javaDoc":"The static method that actually performs the file copy Before copying the file however it performs a lot of tests to make sure everything is as it should be","comments":"If the destination is a directory use the source file name If the destination exists make sure it is a writeable file and ask before overwriting it If the destination doesn't If we've gotten this far then everything is okay So we copy the file a buffer of bytes at a time Get File objects from Strings First make sure the source file exists is a file and is readable as the destination file name exist make sure the directory exists and is writeable Ask whether to overwrite it Get the user's response Check the response If not a Yes abort the copy if file doesn't exist check if directory exists and is writeable If getParent() returns null then the directory is the current dir so look up the user dir system property to find out what that is Get the destination directory or CWD Convert it to a file Stream to read from source Stream to write to destination Read a chunk of bytes into the buffer then write them out looping until we reach the end of the file (when read() returns -1) Note the combination of assignment and comparison in this while Create input stream Create output stream A buffer to hold file contents How many bytes in buffer loop This is a common I/O programming idiom Read bytes until EOF write bytes Always close the streams even if exceptions were thrown \n   * The static method that actually performs the file copy.\n   * Before copying the file, however, it performs a lot of tests to make\n   * sure everything is as it should be.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ThrowStmt":1},"text":"/** A convenience method to throw an exception */\nprivate static void abort(String msg) throws IOException {\n    throw new IOException(msg);\n}\n","name":"abort","className":"FileCopy","variables":{"msg":1},"constants":{},"javaDoc":"A convenience method to throw an exception","comments":" A convenience method to throw an exception ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["int","int","int","int"],"returnType":"DrawableRect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** The DrawableRect constructor just invokes the Rect() constructor */\npublic DrawableRect(int x1, int y1, int x2, int y2) {\n    super(x1, y1, x2, y2);\n}\n","name":"DrawableRect","className":"DrawableRect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"The DrawableRect constructor just invokes the Rect() constructor","comments":" The DrawableRect constructor just invokes the Rect() constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["java.awt.Graphics"],"returnType":"void","methodCalls":{"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":9,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This is the new method defined by DrawableRect */\npublic void draw(java.awt.Graphics g) {\n    g.drawRect(x1, y1, (x2 - x1), (y2 - y1));\n}\n","name":"draw","className":"DrawableRect","variables":{"g":1,"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"This is the new method defined by DrawableRect","comments":" This is the new method defined by DrawableRect ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getGraphics":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":16,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":3,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"/** Set up an off-screen Image for double-buffering */\npublic void init() {\n    size = this.size();\n    buffer = this.createImage(size.width, size.height);\n    bufferGraphics = buffer.getGraphics();\n}\n","name":"init","className":"SmoothCircle","variables":{"size":1,"bufferGraphics":1,"buffer":2},"constants":{},"javaDoc":"Set up an off-screen Image for double-buffering","comments":" Set up an off-screen Image for double-buffering ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1,"setColor":2,"fillOval":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"BinaryExpr":4,"NameExpr":33,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":5},"text":"/** Draw the circle at its current position, using double-buffering */\npublic void paint(Graphics g) {\n    // Draw into the off-screen buffer.\n    // Note, we could do even better clipping by setting the clip rectangle\n    // of bufferGraphics to be the same as that of g.\n    // In Java 1.1:  bufferGraphics.setClip(g.getClip());\n    bufferGraphics.setColor(this.getBackground());\n    // clear the buffer\n    bufferGraphics.fillRect(0, 0, size.width, size.height);\n    bufferGraphics.setColor(Color.red);\n    // draw the circle\n    bufferGraphics.fillOval(x - r, y - r, r * 2, r * 2);\n    // Then copy the off-screen buffer onto the screen\n    g.drawImage(buffer, 0, 0, this);\n}\n","name":"paint","className":"SmoothCircle","variables":{"r":4,"bufferGraphics":4,"g":1,"x":1,"y":1},"constants":{"0":4,"2":2},"javaDoc":"Draw the circle at its current position using double-buffering","comments":"Draw into the off-screen buffer Note we could do even better clipping by setting the clip rectangle of bufferGraphics to be the same as that of g In Java 1 1: bufferGraphics setClip(g getClip()); clear the buffer draw the circle Then copy the off-screen buffer onto the screen  Draw the circle at its current position, using double-buffering ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"paint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Don't clear the screen; just call paint() immediately\n  *   It is important to override this method like this for double-buffering */\npublic void update(Graphics g) {\n    paint(g);\n}\n","name":"update","className":"SmoothCircle","variables":{},"constants":{},"javaDoc":"Don't clear the screen; just call paint() immediately It is important to override this method like this for double-buffering","comments":" Don't clear the screen; just call paint() immediately\n  *   It is important to override this method like this for double-buffering ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"repaint":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":7,"NullLiteralExpr":1,"BinaryExpr":24,"NameExpr":49,"FieldAccessExpr":2,"EnclosedExpr":4,"UnaryExpr":3,"AssignExpr":5,"MethodCallExpr":3},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"EmptyStmt":1,"ExpressionStmt":8},"text":"/** The body of the animation thread */\npublic void run() {\n    while (!please_stop) {\n        // Bounce the circle if we've hit an edge.\n        if ((x - r + dx < 0) || (x + r + dx > size.width))\n            dx = -dx;\n        if ((y - r + dy < 0) || (y + r + dy > size.height))\n            dy = -dy;\n        // Move the circle.\n        x += dx;\n        y += dy;\n        // Ask the browser to call our paint() method to redraw the circle\n        // at its new position.  Tell repaint what portion of the applet needs\n        // be redrawn: the rectangle containing the old circle and the\n        // the rectangle containing the new circle.  These two redraw requests\n        // will be merged into a single call to paint()\n        // repaint old position of circle\n        repaint(x - r - dx, y - r - dy, 2 * r, 2 * r);\n        // repaint new position of circle\n        repaint(x - r, y - r, 2 * r, 2 * r);\n        // Now pause 1/10th of a second before drawing the circle again.\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            ;\n        }\n    }\n    animator = null;\n}\n","name":"run","className":"SmoothCircle","variables":{"r":12,"dx":6,"please_stop":1,"dy":6,"e":1,"x":5,"y":5,"animator":1,"Thread":1},"constants":{"0":2,"100":1,"2":4,"null":1},"javaDoc":"The body of the animation thread","comments":"Ask the browser to call our paint() method to redraw the circle at its new position Tell repaint what portion of the applet needs be redrawn: the rectangle containing the old circle and the the rectangle containing the new circle These two redraw requests will be merged into a single call to paint() Bounce the circle if we've hit an edge Move the circle repaint old position of circle repaint new position of circle Now pause 1/10th of a second before drawing the circle again  The body of the animation thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Start the animation thread */\npublic void start() {\n    if (animator == null) {\n        please_stop = false;\n        animator = new Thread(this);\n        animator.start();\n    }\n}\n","name":"start","className":"SmoothCircle","variables":{"please_stop":1,"animator":3},"constants":{"null":1,"false":1},"javaDoc":"Start the animation thread","comments":" Start the animation thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Stop the animation thread */\npublic void stop() {\n    please_stop = true;\n}\n","name":"stop","className":"SmoothCircle","variables":{"please_stop":1},"constants":{"true":1},"javaDoc":"Stop the animation thread","comments":" Stop the animation thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Allow the user to start and stop the animation by clicking */\npublic boolean mouseDown(Event e, int x, int y) {\n    if (// if running request a stop\n    animator != null)\n        // if running request a stop\n        please_stop = true;\n    else\n        // otherwise start it.\n        start();\n    return true;\n}\n","name":"mouseDown","className":"SmoothCircle","variables":{"please_stop":1,"animator":1},"constants":{"null":1,"true":2},"javaDoc":"Allow the user to start and stop the animation by clicking","comments":"if running request a stop if running request a stop otherwise start it  Allow the user to start and stop the animation by clicking ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static long factorial(int x) throws IllegalArgumentException {\n    // Check if x is too big or too small.  Throw an exception if so.\n    if (// \".length\" returns length of any array\n    x >= table.length)\n        throw new IllegalArgumentException(\"Overflow; x is too large.\");\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be non-negative.\");\n    // Compute and cache any values that are not yet cached.\n    while (last < x) {\n        table[last + 1] = table[last] * (last + 1);\n        last++;\n    }\n    // Now return the cached factorial of x.\n    return table[x];\n}\n","name":"factorial","className":"Factorial3","variables":{"last":5,"x":4,"table":3},"constants":{"0":1,"1":2,"\"x must be non-negative.\"":1,"\"Overflow; x is too large.\"":1},"javaDoc":"","comments":"Check if x is too big or too small Throw an exception if so \" length\" returns length of any array Compute and cache any values that are not yet cached Now return the cached factorial of x ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"startPipe":1,"joinPipe":1,"System.out.println":3},"annotations":[],"exceptions":["IOException","InterruptedException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"Rot13Filter":2,"UnicodeToASCIIFilter":1,"BufferedReader":1,"GrepFilter":1,"Reader":1,"PipeFilter":4,"Writer":1,"WriterPipeSink":1,"ReaderPipeSource":1,"BufferedWriter":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":10,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":39,"StringLiteralExpr":3,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":14},"text":"/** This is the test program for our pipes infrastructure */\npublic static void main(String[] args) throws IOException {\n    // Check the command-line arguments\n    if (args.length != 2) {\n        System.out.println(\"Usage: java Pipe$Test <pattern> <filename>\");\n        System.exit(0);\n    }\n    // Create a Reader to read data from, and a Writer to send data to.\n    Reader in = new BufferedReader(new FileReader(args[1]));\n    Writer out = new BufferedWriter(new OutputStreamWriter(System.out));\n    // Now build up the pipe, starting with the sink, and working \n    // backwards, through various filters, until we reach the source\n    WriterPipeSink sink = new WriterPipeSink(out);\n    PipeFilter filter4 = new UnicodeToASCIIFilter(sink);\n    PipeFilter filter3 = new Rot13Filter(filter4);\n    PipeFilter filter2 = new Rot13Filter(filter3);\n    PipeFilter filter1 = new GrepFilter(filter2, args[0]);\n    ReaderPipeSource source = new ReaderPipeSource(filter1, in);\n    // Start the pipe -- start each of the threads in the pipe running.\n    // This call returns quickly, since the each component of the pipe\n    // is its own thread\n    System.out.println(\"Starting pipe...\");\n    source.startPipe();\n    // Wait for the pipe to complete\n    try {\n        source.joinPipe();\n    } catch (InterruptedException e) {\n    }\n    System.out.println(\"Done.\");\n}\n","name":"main","className":"Test","variables":{"args":2,"in":2,"e":1,"sink":2,"filter1":2,"filter2":2,"filter3":2,"source":3,"filter4":2,"System":1,"out":2},"constants":{"0":2,"1":1,"2":1,"\"Starting pipe...\"":1,"\"Done.\"":1,"\"Usage: java Pipe$Test <pattern> <filename>\"":1},"javaDoc":"This is the test program for our pipes infrastructure","comments":"Now build up the pipe starting with the sink and working Start the pipe -- start each of the threads in the pipe running This call returns quickly since the each component of the pipe Check the command-line arguments Create a Reader to read data from and a Writer to send data to backwards through various filters until we reach the source is its own thread Wait for the pipe to complete  This is the test program for our pipes infrastructure ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Pipe"],"returnType":"Pipe","methodCalls":{"getReader":1,"connect":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":10,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * Create a Pipe and connect it to the specified Pipe \n     **/\npublic Pipe(Pipe sink) throws IOException {\n    this.sink = sink;\n    out = new PipedWriter();\n    out.connect(sink.getReader());\n}\n","name":"Pipe","className":"Pipe","variables":{"sink":2,"out":2},"constants":{},"javaDoc":"Create a Pipe and connect it to the specified Pipe","comments":"\n     * Create a Pipe and connect it to the specified Pipe \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Pipe","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * This constructor is for creating terminal Pipe threads--i.e. those\n     * sinks that are at the end of the pipe, and are not connected to any\n     * other threads.\n     **/\npublic Pipe() {\n    super();\n}\n","name":"Pipe","className":"Pipe","variables":{},"constants":{},"javaDoc":"This constructor is for creating terminal Pipe threads--i e those sinks that are at the end of the pipe and are not connected to any other threads","comments":"\n     * This constructor is for creating terminal Pipe threads--i.e. those\n     * sinks that are at the end of the pipe, and are not connected to any\n     * other threads.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"PipedReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This protected method requests a Pipe threads to create and return\n     * a PipedReader thread so that another Pipe thread can connect to it.\n     **/\nprotected PipedReader getReader() {\n    if (in == null)\n        in = new PipedReader();\n    return in;\n}\n","name":"getReader","className":"Pipe","variables":{"in":3},"constants":{"null":1},"javaDoc":"This protected method requests a Pipe threads to create and return a PipedReader thread so that another Pipe thread can connect to it","comments":"\n     * This protected method requests a Pipe threads to create and return\n     * a PipedReader thread so that another Pipe thread can connect to it.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"startPipe":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/**\n     * This and the following methods provide versions of basic Thread methods\n     * that operate on the entire pipe of threads.  \n     * This one calls start() on all threads in sink-to-source order.\n     **/\npublic void startPipe() {\n    if (sink != null)\n        sink.startPipe();\n    this.start();\n}\n","name":"startPipe","className":"Pipe","variables":{"sink":2},"constants":{"null":1},"javaDoc":"This and the following methods provide versions of basic Thread methods that operate on the entire pipe of threads This one calls start() on all threads in sink-to-source order","comments":"\n     * This and the following methods provide versions of basic Thread methods\n     * that operate on the entire pipe of threads.  \n     * This one calls start() on all threads in sink-to-source order.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"resumePipe":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Call resume() on all threads in the pipe, in sink-to-source order */\npublic void resumePipe() {\n    if (sink != null)\n        sink.resumePipe();\n    this.resume();\n}\n","name":"resumePipe","className":"Pipe","variables":{"sink":2},"constants":{"null":1},"javaDoc":"Call resume() on all threads in the pipe in sink-to-source order","comments":" Call resume() on all threads in the pipe, in sink-to-source order ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"stopPipe":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Call stop() on all threads in the pipe, in source-to-sink order */\npublic void stopPipe() {\n    this.stop();\n    if (sink != null)\n        sink.stopPipe();\n}\n","name":"stopPipe","className":"Pipe","variables":{"sink":2},"constants":{"null":1},"javaDoc":"Call stop() on all threads in the pipe in source-to-sink order","comments":" Call stop() on all threads in the pipe, in source-to-sink order ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"suspendPipe":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Call suspend() on all threads in the pipe, in source-to-sink order */\npublic void suspendPipe() {\n    this.suspend();\n    if (sink != null)\n        sink.suspendPipe();\n}\n","name":"suspendPipe","className":"Pipe","variables":{"sink":2},"constants":{"null":1},"javaDoc":"Call suspend() on all threads in the pipe in source-to-sink order","comments":" Call suspend() on all threads in the pipe, in source-to-sink order ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"joinPipe":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Wait for all threads in the pipe to terminate */\npublic void joinPipe() throws InterruptedException {\n    if (sink != null)\n        sink.joinPipe();\n    this.join();\n}\n","name":"joinPipe","className":"Pipe","variables":{"sink":2},"constants":{"null":1},"javaDoc":"Wait for all threads in the pipe to terminate","comments":" Wait for all threads in the pipe to terminate ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Pipe","Reader"],"returnType":"ReaderPipeSource","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** \n     * To create a ReaderPipeSource, specify the Reader that data comes from\n     * and the Pipe sink that it should be sent to.\n     **/\npublic ReaderPipeSource(Pipe sink, Reader in) throws IOException {\n    super(sink);\n    this.in = in;\n}\n","name":"ReaderPipeSource","className":"ReaderPipeSource","variables":{"in":1,"sink":1},"constants":{},"javaDoc":"To create a ReaderPipeSource specify the Reader that data comes from and the Pipe sink that it should be sent to","comments":" \n     * To create a ReaderPipeSource, specify the Reader that data comes from\n     * and the Pipe sink that it should be sent to.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":16,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":5},"text":"/** \n     * This is the thread body.  When the pipe is started, this method copies \n     * characters from the Reader into the pipe\n     **/\npublic void run() {\n    try {\n        char[] buffer = new char[1024];\n        int chars_read;\n        while ((chars_read = in.read(buffer)) != -1) out.write(buffer, 0, chars_read);\n    } catch (IOException e) {\n    } finally // When done with the data, close the Reader and the pipe\n    {\n        try {\n            in.close();\n            out.close();\n        } catch (IOException e) {\n        }\n    }\n}\n","name":"run","className":"ReaderPipeSource","variables":{"chars_read":2,"in":2,"e":2,"buffer":1,"out":2},"constants":{"0":1,"1":1,"1024":1},"javaDoc":"This is the thread body When the pipe is started this method copies characters from the Reader into the pipe","comments":"When done with the data close the Reader and the pipe  \n     * This is the thread body.  When the pipe is started, this method copies \n     * characters from the Reader into the pipe\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"PipedReader","methodCalls":{},"annotations":[],"exceptions":["Error"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"StringLiteralExpr":1},"statements":{"ThrowStmt":1},"text":"/**\n     * This method overrides the getReader() method of Pipe.  Because this\n     * is a source thread, this method should never be called.  To make sure\n     * that it is never called, we throw an Error if it is.\n     **/\nprotected PipedReader getReader() {\n    throw new Error(\"Can't connect to a ReaderPipeSource!\");\n}\n","name":"getReader","className":"ReaderPipeSource","variables":{},"constants":{"\"Can't connect to a ReaderPipeSource!\"":1},"javaDoc":"This method overrides the getReader() method of Pipe Because this is a source thread this method should never be called To make sure that it is never called we throw an Error if it is","comments":"\n     * This method overrides the getReader() method of Pipe.  Because this\n     * is a source thread, this method should never be called.  To make sure\n     * that it is never called, we throw an Error if it is.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Writer"],"returnType":"WriterPipeSink","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n     * To create a WriterPipeSink, just specify what Writer characters \n     * from the pipe should be written to\n     **/\npublic WriterPipeSink(Writer out) throws IOException {\n    // Create a terminal Pipe with no sink attached.\n    super();\n    this.out = out;\n}\n","name":"WriterPipeSink","className":"WriterPipeSink","variables":{"out":1},"constants":{},"javaDoc":"To create a WriterPipeSink just specify what Writer characters from the pipe should be written to","comments":"Create a terminal Pipe with no sink attached \n     * To create a WriterPipeSink, just specify what Writer characters \n     * from the pipe should be written to\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":16,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":5},"text":"/** \n     * This is the thread body for this sink.  When the pipe is started, it\n     * copies characters from the pipe into the specified Writer.\n     **/\npublic void run() {\n    try {\n        char[] buffer = new char[1024];\n        int chars_read;\n        while ((chars_read = in.read(buffer)) != -1) out.write(buffer, 0, chars_read);\n    } catch (IOException e) {\n    } finally // When done with the data, close the pipe and flush the Writer\n    {\n        try {\n            in.close();\n            out.flush();\n        } catch (IOException e) {\n        }\n    }\n}\n","name":"run","className":"WriterPipeSink","variables":{"chars_read":2,"in":2,"e":2,"buffer":1,"out":2},"constants":{"0":1,"1":1,"1024":1},"javaDoc":"This is the thread body for this sink When the pipe is started it copies characters from the pipe into the specified Writer","comments":"When done with the data close the pipe and flush the Writer  \n     * This is the thread body for this sink.  When the pipe is started, it\n     * copies characters from the pipe into the specified Writer.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Pipe"],"returnType":"PipeFilter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public PipeFilter(Pipe sink) throws IOException {\n    super(sink);\n}\n","name":"PipeFilter","className":"PipeFilter","variables":{"sink":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"filter":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":3},"statements":{"TryStmt":2,"BlockStmt":5,"ExpressionStmt":3},"text":"public void run() {\n    try {\n        filter(in, out);\n    } catch (IOException e) {\n    } finally {\n        try {\n            in.close();\n            out.close();\n        } catch (IOException e) {\n        }\n    }\n}\n","name":"run","className":"PipeFilter","variables":{"e":2,"in":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","Writer"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/** The method that subclasses must implement to do the filtering */\npublic abstract void filter(Reader in, Writer out) throws IOException;\n","name":"filter","className":"PipeFilter","variables":{},"constants":{},"javaDoc":"The method that subclasses must implement to do the filtering","comments":" The method that subclasses must implement to do the filtering ","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["Pipe","String"],"returnType":"GrepFilter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** \n     * Create a GrepFilter, will search its input for the specified pattern\n     * and send the results to the specified Pipe.\n     **/\npublic GrepFilter(Pipe sink, String pattern) throws IOException {\n    super(sink);\n    this.pattern = pattern;\n}\n","name":"GrepFilter","className":"GrepFilter","variables":{"sink":1,"pattern":1},"constants":{},"javaDoc":"Create a GrepFilter will search its input for the specified pattern and send the results to the specified Pipe","comments":" \n     * Create a GrepFilter, will search its input for the specified pattern\n     * and send the results to the specified Pipe.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","Writer"],"returnType":"void","methodCalls":{"println":1,"readLine":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"GrepReader":1,"String":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":11,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"ExpressionStmt":4},"text":"/** \n     * Do the filtering, using a GrepReader to filter lines read from\n     * the Reader, and using a PrintWriter to send those lines back out\n     * to the Writer.\n     **/\npublic void filter(Reader in, Writer out) throws IOException {\n    GrepReader gr = new GrepReader(new BufferedReader(in), pattern);\n    PrintWriter pw = new PrintWriter(out);\n    String line;\n    while ((line = gr.readLine()) != null) pw.println(line);\n}\n","name":"filter","className":"GrepFilter","variables":{"in":1,"line":2,"pw":2,"pattern":1,"gr":2,"out":1},"constants":{"null":1},"javaDoc":"Do the filtering using a GrepReader to filter lines read from the Reader and using a PrintWriter to send those lines back out to the Writer","comments":" \n     * Do the filtering, using a GrepReader to filter lines read from\n     * the Reader, and using a PrintWriter to send those lines back out\n     * to the Writer.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Pipe"],"returnType":"Rot13Filter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Constructor just calls superclass */\npublic Rot13Filter(Pipe sink) throws IOException {\n    super(sink);\n}\n","name":"Rot13Filter","className":"Rot13Filter","variables":{"sink":1},"constants":{},"javaDoc":"Constructor just calls superclass","comments":" Constructor just calls superclass ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","Writer"],"returnType":"void","methodCalls":{"read":1,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":2,"char[]":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":3,"ArrayAccessExpr":8,"BinaryExpr":16,"NameExpr":29,"CastExpr":2,"CharLiteralExpr":8,"EnclosedExpr":11,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":3,"MethodCallExpr":2},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":5},"text":"/** Filter characters from in to out */\npublic void filter(Reader in, Writer out) throws IOException {\n    char[] buffer = new char[1024];\n    int chars_read;\n    while ((chars_read = in.read(buffer)) != -1) {\n        // Apply rot-13 to each character, one at a time\n        for (int i = 0; i < chars_read; i++) {\n            if ((buffer[i] >= 'a') && (buffer[i] <= 'z')) {\n                buffer[i] = (char) ('a' + ((buffer[i] - 'a') + 13) % 26);\n            }\n            if ((buffer[i] >= 'A') && (buffer[i] <= 'Z')) {\n                buffer[i] = (char) ('A' + ((buffer[i] - 'A') + 13) % 26);\n            }\n        }\n        // write the batch of chars\n        out.write(buffer, 0, chars_read);\n    }\n}\n                                                     // read a batch of chars\n\n","name":"filter","className":"Rot13Filter","variables":{"chars_read":3,"in":1,"i":11,"buffer":9,"out":1},"constants":{"0":2,"1":1,"13":2,"'z'":1,"26":2,"'Z'":1,"1024":1,"'a'":3,"'A'":3},"javaDoc":"Filter characters from in to out","comments":"read a batch of chars Apply rot-13 to each character one at a time write the batch of chars  Filter characters from in to out ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Pipe"],"returnType":"UnicodeToASCIIFilter","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public UnicodeToASCIIFilter(Pipe sink) throws IOException {\n    super(sink);\n}\n","name":"UnicodeToASCIIFilter","className":"UnicodeToASCIIFilter","variables":{"sink":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","Writer"],"returnType":"void","methodCalls":{"print":4,"read":1,"toHexString":1,"flush":1,"length":1,"write":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1,"int":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":14,"NameExpr":41,"StringLiteralExpr":4,"CharLiteralExpr":5,"EnclosedExpr":7,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":9},"statements":{"SwitchStmt":1,"IfStmt":1,"WhileStmt":1,"BreakStmt":4,"BlockStmt":2,"SwitchEntryStmt":4,"ExpressionStmt":10},"text":"/**\n     * Read characters from the reader, one at a time (using a BufferedReader\n     * for efficiency).  Output printable ASCII characters unfiltered.  For\n     * other characters, output the \\U Unicode encoding.\n     **/\npublic void filter(Reader r, Writer w) throws IOException {\n    BufferedReader in = new BufferedReader(r);\n    PrintWriter out = new PrintWriter(new BufferedWriter(w));\n    int c;\n    while ((c = in.read()) != -1) {\n        // Just output ASCII characters\n        if (((c >= ' ') && (c <= '~')) || (c == '\\t') || (c == '\\n') || (c == '\\r'))\n            out.write(c);\n        else // And encode the others\n        {\n            String hex = Integer.toHexString(c);\n            switch(hex.length()) {\n                case 1:\n                    out.print(\"\\\\u000\" + hex);\n                    break;\n                case 2:\n                    out.print(\"\\\\u00\" + hex);\n                    break;\n                case 3:\n                    out.print(\"\\\\u0\" + hex);\n                    break;\n                default:\n                    out.print(\"\\\\u\" + hex);\n                    break;\n            }\n        }\n    }\n    // flush the output buffer we create\n    out.flush();\n}\n","name":"filter","className":"UnicodeToASCIIFilter","variables":{"Integer":1,"r":1,"c":7,"in":2,"w":1,"hex":6,"out":7},"constants":{"'~'":1,"1":2,"2":1,"3":1,"\"\\\\u0\"":1,"\"\\\\u\"":1,"\"\\\\u00\"":1,"'\\r'":1,"'\\t'":1,"'\\n'":1,"' '":1,"\"\\\\u000\"":1},"javaDoc":"Read characters from the reader one at a time (using a BufferedReader for efficiency) Output printable ASCII characters unfiltered For other characters output the \\U Unicode encoding","comments":"Just output ASCII characters And encode the others flush the output buffer we create \n     * Read characters from the reader, one at a time (using a BufferedReader\n     * for efficiency).  Output printable ASCII characters unfiltered.  For\n     * other characters, output the \\U Unicode encoding.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"/** A very simple main() method for our program. */\npublic static void main(String[] args) {\n    new SerializedScribble();\n}\n","name":"main","className":"SerializedScribble","variables":{},"constants":{},"javaDoc":"A very simple main() method for our program","comments":" A very simple main() method for our program. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"load":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    scribble.load();\n}\n","name":"actionPerformed","className":"","variables":{"scribble":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"save":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    scribble.save();\n}\n","name":"actionPerformed","className":"","variables":{"scribble":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SerializedScribble","methodCalls":{"add":4,"exit":2,"addSeparator":1,"load":1,"addActionListener":3,"save":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"Scribble":1,"MenuBar":1,"MenuItem":1,"Menu":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"StringLiteralExpr":6,"NameExpr":61,"ThisExpr":6,"AssignExpr":4,"MethodCallExpr":17},"statements":{"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":22},"text":"/** Create a Frame, Menu, and Scribble component */\npublic SerializedScribble() {\n    // Create the window.\n    super(\"SerialziedScribble\");\n    final Scribble scribble;\n    // Create a bigger scribble area.\n    scribble = new Scribble(this, 300, 300);\n    // Add it to the ScrollPane.\n    this.add(scribble, \"Center\");\n    // Create a menubar.\n    MenuBar menubar = new MenuBar();\n    // Add it to the frame.\n    this.setMenuBar(menubar);\n    // Create a File menu.\n    Menu file = new Menu(\"File\");\n    // Add to menubar.\n    menubar.add(file);\n    // Create three menu items, with menu shortcuts, and add to the menu.\n    MenuItem load, save, quit;\n    file.add(load = new MenuItem(\"Load\"));\n    file.add(save = new MenuItem(\"Save\"));\n    // Put a separator in the menu\n    file.addSeparator();\n    file.add(quit = new MenuItem(\"Quit\"));\n    // Create and register action listener objects for the three menu items.\n    load.addActionListener(new // Open a new window\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            scribble.load();\n        }\n    });\n    save.addActionListener(new // Close this window.\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            scribble.save();\n        }\n    });\n    quit.addActionListener(new // Quit the program.\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    // Another event listener, this one to handle window close requests.\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Set the window size and pop it up.\n    this.pack();\n    this.show();\n}\n","name":"SerializedScribble","className":"SerializedScribble","variables":{"menubar":2,"actionPerformed":3,"file":5,"load":3,"e":4,"windowClosing":1,"save":3,"quit":3,"scribble":4,"System":2},"constants":{"0":2,"\"Quit\"":1,"300":2,"\"SerialziedScribble\"":1,"\"File\"":1,"\"Save\"":1,"\"Center\"":1,"\"Load\"":1},"javaDoc":"Create a Frame Menu and Scribble component","comments":"Create the window Create a bigger scribble area Add it to the ScrollPane Create a menubar Add it to the frame Create a File menu Add to menubar Create three menu items with menu shortcuts and add to the menu Put a separator in the menu Create and register action listener objects for the three menu items Open a new window Close this window Quit the program Another event listener this one to handle window close requests Set the window size and pop it up  Create a Frame, Menu, and Scribble component ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame","int","int"],"returnType":"Scribble","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":19,"FieldAccessExpr":5,"ThisExpr":5,"AssignExpr":3,"MethodCallExpr":2},"statements":{"ExpressionStmt":5},"text":"/** This constructor requires a Frame and a desired size */\npublic Scribble(Frame frame, int width, int height) {\n    this.frame = frame;\n    this.width = width;\n    this.height = height;\n    // We handle scribbling with low-level events, so we must specify\n    // which events we are interested in.\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n    this.enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);\n}\n","name":"Scribble","className":"Scribble","variables":{"width":1,"frame":1,"height":1},"constants":{},"javaDoc":"This constructor requires a Frame and a desired size","comments":"We handle scribbling with low-level events so we must specify which events we are interested in  This constructor requires a Frame and a desired size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n     * Specifies big the component would like to be.  It always returns the\n     * preferred size passed to the Scribble() constructor \n     **/\npublic Dimension getPreferredSize() {\n    return new Dimension(width, height);\n}\n","name":"getPreferredSize","className":"Scribble","variables":{"width":1,"height":1},"constants":{},"javaDoc":"Specifies big the component would like to be It always returns the preferred size passed to the Scribble() constructor","comments":" \n     * Specifies big the component would like to be.  It always returns the\n     * preferred size passed to the Scribble() constructor \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"CastExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** Draw all the saved lines of the scribble */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) {\n        Line l = (Line) lines.elementAt(i);\n        g.drawLine(l.x1, l.y1, l.x2, l.y2);\n    }\n}\n","name":"paint","className":"Scribble","variables":{"g":1,"i":3,"lines":2,"l":1},"constants":{"0":1},"javaDoc":"Draw all the saved lines of the scribble","comments":" Draw all the saved lines of the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":17,"CastExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n     * This is the low-level event-handling method called on mouse events\n     * that do not involve mouse motion.\n     **/\npublic void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // Save position.\n        last_x = (short) e.getX();\n        // Save position.\n        last_y = (short) e.getY();\n    } else\n        // Pass other event types on.\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"Scribble","variables":{"e":3,"last_x":1,"last_y":1},"constants":{},"javaDoc":"This is the low-level event-handling method called on mouse events that do not involve mouse motion","comments":"Save position Save position Pass other event types on \n     * This is the low-level event-handling method called on mouse events\n     * that do not involve mouse motion.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":3,"getY":3,"getID":1,"getGraphics":1,"drawLine":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":41,"CastExpr":4,"FieldAccessExpr":1,"MethodCallExpr":11,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/**\n     * This method is called for mouse motion events.  It adds a line to the\n     * scribble, on screen, and in the saved representation\n     **/\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        // Object to draw with.\n        Graphics g = getGraphics();\n        // Draw this line\n        g.drawLine(last_x, last_y, e.getX(), e.getY());\n        lines.addElement(new // and save it, too.\n        Line(// and save it, too.\n        last_x, // and save it, too.\n        last_y, (short) e.getX(), (short) e.getY()));\n        // Remember current mouse coordinates.\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        // Important!\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"Scribble","variables":{"e":7,"g":2,"last_x":2,"last_y":2,"lines":1},"constants":{},"javaDoc":"This method is called for mouse motion events It adds a line to the scribble on screen and in the saved representation","comments":"Object to draw with Draw this line and save it too and save it too and save it too Remember current mouse coordinates Important! \n     * This method is called for mouse motion events.  It adds a line to the\n     * scribble, on screen, and in the saved representation\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1,"writeObject":1,"show":1,"getFile":1,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"GZIPOutputStream":1,"FileOutputStream":1,"String":1,"ObjectOutputStream":1,"FileDialog":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":1,"NameExpr":30,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":10},"text":"/**\n     * Prompt the user for a filename, and save the scribble in that file.\n     * Serialize the vector of lines with an ObjectOutputStream.\n     * Compress the serialized objects with a GZIPOutputStream.\n     * Write the compressed, serialized data to a file with a FileOutputStream.\n     * Don't forget to flush and close the stream.\n     **/\npublic void save() {\n    // Create a file dialog to query the user for a filename.\n    FileDialog f = new FileDialog(frame, \"Save Scribble\", FileDialog.SAVE);\n    // Display the dialog and block.\n    f.show();\n    // Get the user's response\n    String filename = f.getFile();\n    if (filename != null) {\n        // If user didn't click \"Cancel\".\n        try {\n            // Create the necessary output streams to save the scribble.\n            // Save to file\n            FileOutputStream fos = new FileOutputStream(filename);\n            // Compressed\n            GZIPOutputStream gzos = new GZIPOutputStream(fos);\n            // Save objects\n            ObjectOutputStream out = new ObjectOutputStream(gzos);\n            // Write the entire Vector of scribbles\n            out.writeObject(lines);\n            // Always flush the output.\n            out.flush();\n            // And close the stream.\n            out.close();\n        }// Print out exceptions.  We should really display them in a dialog...\n         catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n","name":"save","className":"Scribble","variables":{"filename":3,"e":1,"f":3,"gzos":2,"fos":2,"frame":1,"out":4},"constants":{"null":1,"\"Save Scribble\"":1},"javaDoc":"Prompt the user for a filename and save the scribble in that file Serialize the vector of lines with an ObjectOutputStream Compress the serialized objects with a GZIPOutputStream Write the compressed serialized data to a file with a FileOutputStream Don't forget to flush and close the stream","comments":"Create a file dialog to query the user for a filename Display the dialog and block Get the user's response If user didn't click \"Cancel\" Create the necessary output streams to save the scribble Save to file Compressed Save objects Write the entire Vector of scribbles Always flush the output And close the stream Print out exceptions We should really display them in a dialog \n     * Prompt the user for a filename, and save the scribble in that file.\n     * Serialize the vector of lines with an ObjectOutputStream.\n     * Compress the serialized objects with a GZIPOutputStream.\n     * Write the compressed, serialized data to a file with a FileOutputStream.\n     * Don't forget to flush and close the stream.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"show":1,"repaint":1,"getFile":1,"close":1,"readObject":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"GZIPInputStream":1,"String":1,"FileDialog":1,"Vector":1,"FileInputStream":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":1,"NameExpr":30,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":2,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":11},"text":"/**\n     * Prompt for a filename, and load a scribble from that file.\n     * Read compressed, serialized data with a FileInputStream.\n     * Uncompress that data with a GZIPInputStream.\n     * Deserialize the vector of lines with a ObjectInputStream.\n     * Replace current data with new data, and redraw everything.\n     **/\npublic void load() {\n    // Create a file dialog to query the user for a filename.\n    FileDialog f = new FileDialog(frame, \"Load Scribble\", FileDialog.LOAD);\n    // Display the dialog and block.\n    f.show();\n    // Get the user's response\n    String filename = f.getFile();\n    if (filename != null) {\n        // If user didn't click \"Cancel\".\n        try {\n            // Create necessary input streams\n            // Read from file\n            FileInputStream fis = new FileInputStream(filename);\n            // Uncompress\n            GZIPInputStream gzis = new GZIPInputStream(fis);\n            // Read objects\n            ObjectInputStream in = new ObjectInputStream(gzis);\n            // Read in an object.  It should be a vector of scribbles\n            Vector newlines = (Vector) in.readObject();\n            // Close the stream.\n            in.close();\n            // Set the Vector of lines.\n            lines = newlines;\n            // And redisplay the scribble.\n            repaint();\n        }// Print out exceptions.  We should really display them in a dialog...\n         catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n}\n","name":"load","className":"Scribble","variables":{"fis":2,"filename":3,"in":3,"newlines":2,"e":1,"f":3,"lines":1,"gzis":2,"frame":1},"constants":{"\"Load Scribble\"":1,"null":1},"javaDoc":"Prompt for a filename and load a scribble from that file Read compressed serialized data with a FileInputStream Uncompress that data with a GZIPInputStream Deserialize the vector of lines with a ObjectInputStream Replace current data with new data and redraw everything","comments":"Create a file dialog to query the user for a filename Display the dialog and block Get the user's response If user didn't click \"Cancel\" Create necessary input streams Read from file Uncompress Read objects Read in an object It should be a vector of scribbles Close the stream Set the Vector of lines And redisplay the scribble Print out exceptions We should really display them in a dialog \n     * Prompt for a filename, and load a scribble from that file.\n     * Read compressed, serialized data with a FileInputStream.\n     * Uncompress that data with a GZIPInputStream.\n     * Deserialize the vector of lines with a ObjectInputStream.\n     * Replace current data with new data, and redraw everything.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["short","short","short","short"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Line(short x1, short y1, short x2, short y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Line","className":"Line","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addWindowListener":1,"exit":1,"show":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"Frame":1,"StringCutAndPaste":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":14,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ExpressionStmt":5},"text":"/**\n   * The main method creates a frame, arranges to handle its closing,\n   * packs it and pops it up.\n   **/\npublic static void main(String[] args) {\n    Frame f = new StringCutAndPaste();\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    f.pack();\n    f.show();\n}\n","name":"main","className":"StringCutAndPaste","variables":{"e":1,"windowClosing":1,"f":4,"System":1},"constants":{"0":1},"javaDoc":"The main method creates a frame arranges to handle its closing packs it and pops it up","comments":"\n   * The main method creates a frame, arranges to handle its closing,\n   * packs it and pops it up.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"StringCutAndPaste","methodCalls":{"addActionListener":2,"setActionCommand":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Button":2},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"NameExpr":27,"StringLiteralExpr":8,"FieldAccessExpr":1,"ThisExpr":6,"MethodCallExpr":8,"AssignExpr":1},"statements":{"ExpressionStmt":11},"text":"/**\n   * The constructor builds a very simple test GUI, and registers this object\n   * as the ActionListener for the buttons \n   **/\npublic StringCutAndPaste() {\n    // Use a nice font\n    this.setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n    // Set up the Cut button\n    Button cut = new Button(\"Cut\");\n    cut.addActionListener(this);\n    cut.setActionCommand(\"cut\");\n    this.add(cut, \"West\");\n    // Set up the Paste button\n    Button paste = new Button(\"Paste\");\n    paste.addActionListener(this);\n    paste.setActionCommand(\"paste\");\n    this.add(paste, \"East\");\n    // Set up the text field that they both operate on\n    field = new TextField();\n    this.add(field, \"North\");\n}\n","name":"StringCutAndPaste","className":"StringCutAndPaste","variables":{"cut":3,"field":1,"paste":3},"constants":{"\"North\"":1,"14":1,"\"Paste\"":1,"\"SansSerif\"":1,"\"Cut\"":1,"\"East\"":1,"\"paste\"":1,"\"cut\"":1,"\"West\"":1},"javaDoc":"The constructor builds a very simple test GUI and registers this object as the ActionListener for the buttons","comments":"Use a nice font Set up the Cut button Set up the Paste button Set up the text field that they both operate on \n   * The constructor builds a very simple test GUI, and registers this object\n   * as the ActionListener for the buttons \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"cut":1,"equals":2,"getActionCommand":1,"paste":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":13,"StringLiteralExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"/**\n   * Clicking on one of the buttons invokes this method, which in turn\n   * invokes either the cut() or the paste() method\n   **/\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (cmd.equals(\"cut\"))\n        cut();\n    else if (cmd.equals(\"paste\"))\n        paste();\n}\n","name":"actionPerformed","className":"StringCutAndPaste","variables":{"e":1,"cmd":3},"constants":{"\"paste\"":1,"\"cut\"":1},"javaDoc":"Clicking on one of the buttons invokes this method which in turn invokes either the cut() or the paste() method","comments":"\n   * Clicking on one of the buttons invokes this method, which in turn\n   * invokes either the cut() or the paste() method\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getText":1,"setContents":1,"getSystemClipboard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"StringSelection":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":12,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"/**\n   * This method takes the current contents of the text field, creates a\n   * StringSelection object to represent that string, and puts the \n   * StringSelection onto the clipboard\n   **/\npublic void cut() {\n    // Get the currently displayed value\n    String s = field.getText();\n    // Create a StringSelection object to represent it.\n    // This is a big convenience, because StringSelection implements both\n    // the Transferable interface and the ClipboardOwner.  We don't have\n    // to deal with either of them.\n    StringSelection ss = new StringSelection(s);\n    // Now set the StringSelection object as the contents of the clipboard\n    // Also set it as the owner of the clipboard.\n    this.getToolkit().getSystemClipboard().setContents(ss, ss);\n}\n","name":"cut","className":"StringCutAndPaste","variables":{"ss":1,"s":2,"field":1},"constants":{},"javaDoc":"This method takes the current contents of the text field creates a StringSelection object to represent that string and puts the StringSelection onto the clipboard","comments":"Create a StringSelection object to represent it This is a big convenience because StringSelection implements both the Transferable interface and the ClipboardOwner We don't have Now set the StringSelection object as the contents of the clipboard Get the currently displayed value to deal with either of them Also set it as the owner of the clipboard \n   * This method takes the current contents of the text field, creates a\n   * StringSelection object to represent that string, and puts the \n   * StringSelection onto the clipboard\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"beep":1,"getContents":1,"getTransferData":1,"getSystemClipboard":1,"setText":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Transferable":1,"Clipboard":1,"String":1},"expressions":{"VariableDeclarationExpr":3,"NameExpr":21,"CastExpr":1,"FieldAccessExpr":1,"ThisExpr":3,"MethodCallExpr":7},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n   * This method does the reverse.  It gets the contents of the clipboard,\n   * then asks for them to be converted to a string, then displays the\n   * string.\n   **/\npublic void paste() {\n    // Get the clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Get the contents of the clipboard, as a Transferable object\n    Transferable t = c.getContents(this);\n    // string DataFlavor.  Then display that string in the field.\n    try {\n        String s = (String) t.getTransferData(DataFlavor.stringFlavor);\n        field.setText(s);\n    }// If anything goes wrong with the transfer, just beep and do nothing.\n     catch (Exception e) {\n        this.getToolkit().beep();\n        return;\n    }\n}\n     // Ask for the transferable data in string form, using the predefined\n\n","name":"paste","className":"StringCutAndPaste","variables":{"c":2,"s":1,"t":2,"field":1,"e":1},"constants":{},"javaDoc":"This method does the reverse It gets the contents of the clipboard then asks for them to be converted to a string then displays the string","comments":"Ask for the transferable data in string form using the predefined Get the clipboard Get the contents of the clipboard as a Transferable object string DataFlavor Then display that string in the field If anything goes wrong with the transfer just beep and do nothing \n   * This method does the reverse.  It gets the contents of the clipboard,\n   * then asks for them to be converted to a string, then displays the\n   * string.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":4,"StringLiteralExpr":1,"FieldAccessExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// One-time initialization for the applet\n// Note: no constructor defined.\npublic void init() {\n    font = new Font(\"Helvetica\", Font.BOLD, 48);\n}\n","name":"init","className":"SecondApplet","variables":{"font":1},"constants":{"\"Helvetica\"":1,"48":1},"javaDoc":"","comments":" Note: no constructor defined.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawOval":4,"setColor":3,"setFont":1,"fillOval":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":22,"NameExpr":41,"FieldAccessExpr":3,"MethodCallExpr":10},"statements":{"ExpressionStmt":10},"text":"// Draw the applet whenever necessary.  Do some fancy graphics.\npublic void paint(Graphics g) {\n    // The pink oval\n    g.setColor(Color.pink);\n    g.fillOval(10, 10, 330, 100);\n    // The red outline. Java doesn't support wide lines, so we\n    // try to simulate a 4-pixel wide line by drawing four ovals.\n    g.setColor(Color.red);\n    g.drawOval(10, 10, 330, 100);\n    g.drawOval(9, 9, 332, 102);\n    g.drawOval(8, 8, 334, 104);\n    g.drawOval(7, 7, 336, 106);\n    // The text\n    g.setColor(Color.black);\n    g.setFont(font);\n    g.drawString(message, 40, 75);\n}\n","name":"paint","className":"SecondApplet","variables":{"g":10},"constants":{"330":2,"100":2,"332":1,"102":1,"334":1,"104":1,"336":1,"7":2,"106":1,"8":2,"9":2,"40":1,"75":1,"10":4},"javaDoc":"","comments":"The red outline Java doesn't support wide lines so we The pink oval try to simulate a 4-pixel wide line by drawing four ovals The text  Draw the applet whenever necessary.  Do some fancy graphics.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"BigInteger","methodCalls":{"size":1,"valueOf":1,"elementAt":2,"addElement":1,"multiply":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["Casting","Synchronization"],"types":{"BigInteger":2,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":26,"StringLiteralExpr":1,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** The factorial() method, using BigIntegers cached in a Vector */\npublic static synchronized BigInteger factorial(int x) {\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be non-negative.\");\n    for (int size = table.size(); size <= x; size++) {\n        BigInteger lastfact = (BigInteger) table.elementAt(size - 1);\n        BigInteger nextfact = lastfact.multiply(BigInteger.valueOf(size));\n        table.addElement(nextfact);\n    }\n    return (BigInteger) table.elementAt(x);\n}\n","name":"factorial","className":"Factorial4","variables":{"nextfact":1,"size":4,"x":2,"lastfact":2,"BigInteger":1,"table":4},"constants":{"0":1,"1":1,"\"x must be non-negative.\"":1},"javaDoc":"The factorial() method using BigIntegers cached in a Vector","comments":" The factorial() method, using BigIntegers cached in a Vector ","isEmpty":false,"hasInnerClass":false,"modifier":41}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"factorial":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/**\n   * A simple main() method that we can use as a standalone test program\n   * for our factorial() method.  \n   **/\npublic static void main(String[] args) {\n    for (int i = 1; i <= 50; i++) System.out.println(i + \"! = \" + factorial(i));\n}\n","name":"main","className":"Factorial4","variables":{"i":4},"constants":{"1":1,"50":1,"\"! = \"":1},"javaDoc":"A simple main() method that we can use as a standalone test program for our factorial() method","comments":"\n   * A simple main() method that we can use as a standalone test program\n   * for our factorial() method.  \n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getRectangleParameter":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1,"ImagemapRectangle":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":26,"StringLiteralExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":7,"AssignExpr":4,"MethodCallExpr":9},"statements":{"ForStmt":1,"ExpressionStmt":6},"text":"/** Initialize the applet */\npublic void init() {\n    // Look up the name of the image, relative to a base URL, and load it.\n    // Note the use of three Applet methods in this one line.\n    image = this.getImage(this.getDocumentBase(), this.getParameter(\"image\"));\n    // Lookup and parse a list of rectangular areas and the URLs they map to.\n    // The convenience routine getRectangleParameter() is defined below.\n    rects = new Vector();\n    ImagemapRectangle r;\n    for (int i = 0; (r = getRectangleParameter(\"rect\" + i)) != null; i++) rects.addElement(r);\n    // Look up a sound to play when the user clicks one of those areas.\n    sound = this.getAudioClip(this.getDocumentBase(), this.getParameter(\"sound\"));\n    // Specify an \"event listener\" object to respond to mouse button\n    // presses and releases.  Note that this is the Java 1.1 event model.\n    // Note that it also uses a Java 1.1 inner class, defined below.\n    this.addMouseListener(new Listener());\n}\n","name":"init","className":"Soundmap","variables":{"image":1,"r":2,"sound":1,"i":3,"rects":2},"constants":{"0":1,"\"sound\"":1,"null":1,"\"rect\"":1,"\"image\"":1},"javaDoc":"Initialize the applet","comments":"Look up the name of the image relative to a base URL and load it Lookup and parse a list of rectangular areas and the URLs they map to Specify an \"event listener\" object to respond to mouse button presses and releases Note that this is the Java 1 1 event model Note the use of three Applet methods in this one line The convenience routine getRectangleParameter() is defined below Look up a sound to play when the user clicks one of those areas Note that it also uses a Java 1 1 inner class defined below  Initialize the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Called when the applet is being unloaded from the system.\n   * We use it here to \"flush\" the image we no longer need. This may\n   * result in memory and other resources being freed more quickly. */\npublic void destroy() {\n    image.flush();\n}\n","name":"destroy","className":"Soundmap","variables":{"image":1},"constants":{},"javaDoc":"Called when the applet is being unloaded from the system We use it here to \"flush\" the image we no longer need This may result in memory and other resources being freed more quickly","comments":" Called when the applet is being unloaded from the system.\n   * We use it here to \"flush\" the image we no longer need. This may\n   * result in memory and other resources being freed more quickly. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** To display the applet, we simply draw the image. */\npublic void paint(Graphics g) {\n    g.drawImage(image, 0, 0, this);\n}\n","name":"paint","className":"Soundmap","variables":{"g":1},"constants":{"0":2},"javaDoc":"To display the applet we simply draw the image","comments":" To display the applet, we simply draw the image. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"paint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** We override this method so that it doesn't clear the background\n   * before calling paint().  No clear is necessary, since paint() overwrites\n   * everything with an image.  Causes less flickering this way. */\npublic void update(Graphics g) {\n    paint(g);\n}\n","name":"update","className":"Soundmap","variables":{},"constants":{},"javaDoc":"We override this method so that it doesn't clear the background before calling paint() No clear is necessary since paint() overwrites everything with an image Causes less flickering this way","comments":" We override this method so that it doesn't clear the background\n   * before calling paint().  No clear is necessary, since paint() overwrites\n   * everything with an image.  Causes less flickering this way. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ImagemapRectangle","methodCalls":{"parseInt":4,"nextToken":5},"annotations":[],"exceptions":["MalformedURLException","NumberFormatException","NoSuchElementException"],"concepts":["ExceptionHandling"],"types":{"StringTokenizer":1,"String":1,"int":1,"URL":1},"expressions":{"NullLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":44,"StringLiteralExpr":1,"ThisExpr":2,"MethodCallExpr":11,"AssignExpr":5},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ReturnStmt":5,"ExpressionStmt":9},"text":"/** Parse a comma-separated list of rectangle coordinates and a URL.\n   * Used to read the imagemap rectangle definitions from applet parameters */\nprotected ImagemapRectangle getRectangleParameter(String name) {\n    int x, y, w, h;\n    URL url;\n    String value = this.getParameter(name);\n    if (value == null)\n        return null;\n    try {\n        StringTokenizer st = new StringTokenizer(value, \",\");\n        x = Integer.parseInt(st.nextToken());\n        y = Integer.parseInt(st.nextToken());\n        w = Integer.parseInt(st.nextToken());\n        h = Integer.parseInt(st.nextToken());\n        url = new URL(this.getDocumentBase(), st.nextToken());\n    } catch (NoSuchElementException e) {\n        return null;\n    } catch (NumberFormatException e) {\n        return null;\n    } catch (MalformedURLException e) {\n        return null;\n    }\n    return new ImagemapRectangle(x, y, w, h, url);\n}\n","name":"getRectangleParameter","className":"Soundmap","variables":{"Integer":4,"st":6,"e":3,"w":3,"x":3,"h":3,"y":3,"value":3,"url":3},"constants":{"null":5,"\",\"":1},"javaDoc":"Parse a comma-separated list of rectangle coordinates and a URL Used to read the imagemap rectangle definitions from applet parameters","comments":" Parse a comma-separated list of rectangle coordinates and a URL.\n   * Used to read the imagemap rectangle definitions from applet parameters ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"play":1,"findrect":1,"setXORMode":1,"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"ImagemapRectangle":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":39,"StringLiteralExpr":1,"FieldAccessExpr":6,"ThisExpr":2,"MethodCallExpr":6,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** Called when a mouse button is pressed. */\npublic void mousePressed(MouseEvent e) {\n    // On button down, check if we're inside one of the specified rectangles.\n    // If so, highlight the rectangle, display a message, and play a sound.\n    // The utility routine findrect() is defined below.\n    ImagemapRectangle r = findrect(e);\n    if (r == null)\n        return;\n    Graphics g = Applet.this.getGraphics();\n    g.setXORMode(Color.red);\n    // highlight rectangle\n    g.drawRect(r.x, r.y, r.width, r.height);\n    // display URL\n    Applet.this.showStatus(\"To: \" + r.url);\n    // play the sound\n    sound.play();\n    // Remember the rectangle so it can be un-highlighted.\n    lastrect = r;\n}\n","name":"mousePressed","className":"Listener","variables":{"r":3,"Applet":2,"g":3,"sound":1,"lastrect":1},"constants":{"null":1,"\"To: \"":1},"javaDoc":"Called when a mouse button is pressed","comments":"On button down check if we're inside one of the specified rectangles If so highlight the rectangle display a message and play a sound The utility routine findrect() is defined below highlight rectangle display URL play the sound Remember the rectangle so it can be un-highlighted  Called when a mouse button is pressed. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"findrect":1,"showDocument":1,"setXORMode":1,"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"ImagemapRectangle":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":43,"StringLiteralExpr":1,"FieldAccessExpr":6,"EnclosedExpr":2,"ThisExpr":3,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":7},"text":"/** Called when a mouse button is released. */\npublic void mouseReleased(MouseEvent e) {\n    // mouse is still inside it, ask the browser to go to the URL.\n    if (lastrect != null) {\n        Graphics g = Applet.this.getGraphics();\n        g.setXORMode(Color.red);\n        g.drawRect(lastrect.x, lastrect.y, lastrect.width, lastrect.height);\n        // Clear the message.\n        Applet.this.showStatus(\"\");\n        ImagemapRectangle r = findrect(e);\n        if (// If still in the same rectangle\n        (r != null) && (r == lastrect))\n            // Go to the URL\n            Applet.this.getAppletContext().showDocument(r.url);\n        lastrect = null;\n    }\n}\n       // When the button is released, unhighlight the rectangle.  If the\n\n","name":"mouseReleased","className":"Listener","variables":{"r":3,"Applet":3,"g":3,"lastrect":3},"constants":{"\"\"":1,"null":3},"javaDoc":"Called when a mouse button is released","comments":"When the button is released unhighlight the rectangle If the mouse is still inside it ask the browser to go to the URL Clear the message If still in the same rectangle Go to the URL  Called when a mouse button is released. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"ImagemapRectangle","methodCalls":{"getX":1,"contains":1,"getY":1,"size":1,"elementAt":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":1,"ImagemapRectangle":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** Find the rectangle we're inside. */\nprotected ImagemapRectangle findrect(MouseEvent e) {\n    int i, x = e.getX(), y = e.getY();\n    for (i = 0; i < rects.size(); i++) {\n        ImagemapRectangle r = (ImagemapRectangle) rects.elementAt(i);\n        if (r.contains(x, y))\n            return r;\n    }\n    return null;\n}\n","name":"findrect","className":"Listener","variables":{"r":3,"e":2,"x":1,"i":4,"y":1,"rects":2},"constants":{"0":1,"null":1},"javaDoc":"Find the rectangle we're inside","comments":" Find the rectangle we're inside. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int","int","int","int","URL"],"returnType":"ImagemapRectangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public ImagemapRectangle(int x, int y, int w, int h, URL url) {\n    super(x, y, w, h);\n    this.url = url;\n}\n","name":"ImagemapRectangle","className":"ImagemapRectangle","variables":{"w":1,"x":1,"h":1,"y":1,"url":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int"],"returnType":"ColumnLayout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/** The constructor.  See comment above for meanings of these arguments */\npublic ColumnLayout(int margin_height, int margin_width, int spacing, int alignment) {\n    this.margin_height = margin_height;\n    this.margin_width = margin_width;\n    this.spacing = spacing;\n    this.alignment = alignment;\n}\n","name":"ColumnLayout","className":"ColumnLayout","variables":{"margin_height":1,"spacing":1,"alignment":1,"margin_width":1},"constants":{},"javaDoc":"The constructor See comment above for meanings of these arguments","comments":" The constructor.  See comment above for meanings of these arguments ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ColumnLayout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** A default constructor that creates a ColumnLayout using 5-pixel\n   *  margin width and height, 5-pixel spacing, and left alignment */\npublic ColumnLayout() {\n    this(5, 5, 5, LEFT);\n}\n","name":"ColumnLayout","className":"ColumnLayout","variables":{"LEFT":1},"constants":{"5":3},"javaDoc":"A default constructor that creates a ColumnLayout using 5-pixel margin width and height 5-pixel spacing and left alignment","comments":" A default constructor that creates a ColumnLayout using 5-pixel\n   *  margin width and height, 5-pixel spacing, and left alignment ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"void","methodCalls":{"getComponentCount":1,"getSize":1,"getPreferredSize":1,"getInsets":1,"getComponent":1,"isVisible":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Insets":1,"Dimension":2,"Component":1,"int":5},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":9,"BinaryExpr":10,"NameExpr":72,"FieldAccessExpr":10,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":7,"AssignExpr":5},"statements":{"ContinueStmt":1,"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":4,"ForStmt":1,"ExpressionStmt":14},"text":"/** The method that actually performs the layout.  Called by the Container */\npublic void layoutContainer(Container parent) {\n    Insets insets = parent.getInsets();\n    Dimension parent_size = parent.getSize();\n    Component kid;\n    int nkids = parent.getComponentCount();\n    int x0 = insets.left + margin_width;\n    int x;\n    int y = insets.top + margin_height;\n    for (int i = 0; i < nkids; i++) {\n        kid = parent.getComponent(i);\n        if (!kid.isVisible())\n            continue;\n        Dimension pref = kid.getPreferredSize();\n        switch(alignment) {\n            default:\n            case LEFT:\n                x = x0;\n                break;\n            case CENTER:\n                x = x0 + (parent_size.width - pref.width) / 2;\n                break;\n            case RIGHT:\n                x = parent_size.width - insets.right - margin_width - pref.width;\n                break;\n        }\n        kid.setBounds(x, y, pref.width, pref.height);\n        y += pref.height + spacing;\n    }\n}\n","name":"layoutContainer","className":"ColumnLayout","variables":{"margin_height":1,"parent":4,"LEFT":1,"insets":1,"kid":5,"i":3,"CENTER":1,"spacing":1,"parent_size":1,"pref":1,"x0":3,"x":4,"y":2,"RIGHT":1,"nkids":2,"alignment":1,"margin_width":2},"constants":{"0":1,"2":1},"javaDoc":"The method that actually performs the layout Called by the Container","comments":" The method that actually performs the layout.  Called by the Container ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout should to be */\npublic Dimension preferredLayoutSize(Container parent) {\n    return layoutSize(parent, 1);\n}\n","name":"preferredLayoutSize","className":"ColumnLayout","variables":{},"constants":{"1":1},"javaDoc":"The Container calls this to find out how big the layout should to be","comments":" The Container calls this to find out how big the layout should to be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout must be */\npublic Dimension minimumLayoutSize(Container parent) {\n    return layoutSize(parent, 2);\n}\n","name":"minimumLayoutSize","className":"ColumnLayout","variables":{},"constants":{"2":1},"javaDoc":"The Container calls this to find out how big the layout must be","comments":" The Container calls this to find out how big the layout must be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout can be */\npublic Dimension maximumLayoutSize(Container parent) {\n    return layoutSize(parent, 3);\n}\n","name":"maximumLayoutSize","className":"ColumnLayout","variables":{},"constants":{"3":1},"javaDoc":"The Container calls this to find out how big the layout can be","comments":" The Container calls this to find out how big the layout can be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container","int"],"returnType":"Dimension","methodCalls":{"getComponentCount":1,"getMaximumSize":1,"getPreferredSize":1,"getMinimumSize":1,"getInsets":1,"getComponent":1,"isVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Insets":1,"Dimension":2,"Component":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":10,"VariableDeclarationExpr":7,"BinaryExpr":13,"NameExpr":76,"FieldAccessExpr":13,"EnclosedExpr":1,"UnaryExpr":3,"MethodCallExpr":7,"AssignExpr":8},"statements":{"ContinueStmt":1,"IfStmt":5,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"protected Dimension layoutSize(Container parent, int sizetype) {\n    int nkids = parent.getComponentCount();\n    Dimension size = new Dimension(0, 0);\n    Insets insets = parent.getInsets();\n    int num_visible_kids = 0;\n    // Compute maximum width and total height of all visible kids\n    for (int i = 0; i < nkids; i++) {\n        Component kid = parent.getComponent(i);\n        Dimension d;\n        if (!kid.isVisible())\n            continue;\n        num_visible_kids++;\n        if (sizetype == 1)\n            d = kid.getPreferredSize();\n        else if (sizetype == 2)\n            d = kid.getMinimumSize();\n        else\n            d = kid.getMaximumSize();\n        if (d.width > size.width)\n            size.width = d.width;\n        size.height += d.height;\n    }\n    // Now add in margins and stuff\n    size.width += insets.left + insets.right + 2 * margin_width;\n    size.height += insets.top + insets.bottom + 2 * margin_height;\n    if (num_visible_kids > 1)\n        size.height += (num_visible_kids - 1) * spacing;\n    return size;\n}\n","name":"layoutSize","className":"ColumnLayout","variables":{"margin_height":1,"parent":3,"sizetype":2,"spacing":1,"size":2,"d":4,"insets":1,"kid":5,"i":3,"nkids":2,"margin_width":1,"num_visible_kids":4},"constants":{"0":4,"1":3,"2":3},"javaDoc":"","comments":"Compute maximum width and total height of all visible kids Now add in margins and stuff ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Other LayoutManager(2) methods that are unused by this class\npublic void addLayoutComponent(String constraint, Component comp) {\n}\n","name":"addLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","comments":" Other LayoutManager(2) methods that are unused by this class","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void addLayoutComponent(Component comp, Object constraint) {\n}\n","name":"addLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void removeLayoutComponent(Component comp) {\n}\n","name":"removeLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void invalidateLayout(Container parent) {\n}\n","name":"invalidateLayout","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getLayoutAlignmentX(Container parent) {\n    return 0.5f;\n}\n","name":"getLayoutAlignmentX","className":"ColumnLayout","variables":{},"constants":{"0.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getLayoutAlignmentY(Container parent) {\n    return 0.5f;\n}\n","name":"getLayoutAlignmentY","className":"ColumnLayout","variables":{},"constants":{"0.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getRed":1,"getGreen":1,"setForeground":1,"getBlue":1,"setBackground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":1,"Label":1,"int":3},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":7,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":46,"FieldAccessExpr":4,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":7,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public void init() {\n    // Use a bunch of Label objects arranged in a grid to display the colors.\n    this.setLayout(new GridLayout(0, 3, 5, 5));\n    for (int i = 0; i < colors.length; i++) {\n        // Create a label object to display a system color and its name\n        Label l = new Label(color_names[i], Label.CENTER);\n        this.add(l);\n        // compute a foreground color to contrast with the background\n        Color bg = colors[i], fg;\n        int r = bg.getRed(), g = bg.getGreen(), b = bg.getBlue();\n        int avg = (r + g + b) / 3;\n        if (avg > 128)\n            fg = Color.black;\n        else\n            fg = Color.white;\n        // And assign the colors.\n        l.setBackground(bg);\n        l.setForeground(fg);\n    }\n}\n","name":"init","className":"SystemColorList","variables":{"fg":3,"r":2,"b":2,"avg":2,"color_names":1,"bg":4,"g":2,"i":5,"l":3,"colors":1},"constants":{"0":2,"3":2,"5":2,"128":1},"javaDoc":"","comments":"Use a bunch of Label objects arranged in a grid to display the colors Create a label object to display a system color and its name compute a foreground color to contrast with the background And assign the colors ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"println":4,"flush":1,"length":1,"getOutputStream":1,"readLine":1,"System.err.println":2,"getInputStream":1,"close":3,"accept":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"ServerSocket":1,"String":1,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":5,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":57,"StringLiteralExpr":3,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":16,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":16},"text":"public static void main(String args[]) {\n    try {\n        // Get the port to listen on\n        int port = Integer.parseInt(args[0]);\n        // Create a ServerSocket to listen on that port.\n        ServerSocket ss = new ServerSocket(port);\n        // Now enter an infinite loop, waiting for connections and handling them.\n        for (; ; ) {\n            // Wait for a client to connect.  The method will block, and when it\n            // returns the socket will be already connected to the client\n            Socket client = ss.accept();\n            // Get input and output streams to talk to the client from the socket\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(new OutputStreamWriter(client.getOutputStream()));\n            // Start sending our reply, using the HTTP 1.0 protocol\n            // Version & status code\n            out.println(\"HTTP/1.0 200 \");\n            // The type of data we send\n            out.println(\"Content-Type: text/plain\");\n            // End of response headers\n            out.println();\n            out.flush();\n            // Now, read the HTTP request from the client, and send it right\n            // back to the client as part of the body of our response.\n            // The client doesn't disconnect, so we never get an EOF.\n            // It does sends an empty line at the end of the headers, though.  \n            // So when we see the empty line, we stop reading.  This means we \n            // don't mirror the contents of POST requests, for example.\n            String line;\n            while ((line = in.readLine()) != null) {\n                if (line.length() == 0)\n                    break;\n                out.println(line);\n            }\n            // Close the streams and socket, breaking the connection to the client\n            out.close();\n            in.close();\n            client.close();\n        }\n    // Loop again, waiting for the next connection\n    }// If anything goes wrong, print an error message\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java HttpMirror <port>\");\n    }\n}\n","name":"main","className":"HttpMirror","variables":{"Integer":1,"args":1,"ss":2,"port":2,"in":3,"e":1,"line":3,"client":4,"out":7},"constants":{"0":2,"null":1,"\"Usage: java HttpMirror <port>\"":1,"\"Content-Type: text/plain\"":1,"\"HTTP/1.0 200 \"":1},"javaDoc":"","comments":"Loop again waiting for the next connection Get the port to listen on Create a ServerSocket to listen on that port Now enter an infinite loop waiting for connections and handling them Wait for a client to connect The method will block and when it Start sending our reply using the HTTP 1 0 protocol Now read the HTTP request from the client and send it right back to the client as part of the body of our response The client doesn't disconnect so we never get an EOF It does sends an empty line at the end of the headers though So when we see the empty line we stop reading This means we returns the socket will be already connected to the client Get input and output streams to talk to the client from the socket Version & status code The type of data we send End of response headers don't mirror the contents of POST requests for example Close the streams and socket breaking the connection to the client If anything goes wrong print an error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // All programs must have main()\n    // Say hello!\n    System.out.println(\"Hello World!\");\n}\n","name":"main","className":"Hello","variables":{},"constants":{"\"Hello World!\"":1},"javaDoc":"","comments":"All programs must have main() Say hello! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDriverName":1,"next":2,"getProperty":4,"forName":1,"length":2,"getDatabaseProductVersion":1,"getString":3,"getColumns":1,"getConnection":1,"getURL":1,"getDatabaseProductName":1,"load":1,"getTables":1,"getUserName":1,"getMetaData":1,"System.err.println":3,"close":1,"getDriverVersion":1,"System.out.println":8},"annotations":[],"exceptions":["Exception","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"ResultSet":2,"String":6,"Properties":1,"DatabaseMetaData":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":6,"VariableDeclarationExpr":12,"ArrayAccessExpr":11,"BinaryExpr":25,"NameExpr":187,"StringLiteralExpr":34,"UnaryExpr":5,"InstanceOfExpr":1,"AssignExpr":7,"NullLiteralExpr":8,"CastExpr":1,"ClassExpr":1,"FieldAccessExpr":12,"EnclosedExpr":3,"MethodCallExpr":41},"statements":{"IfStmt":10,"WhileStmt":2,"TryStmt":3,"BlockStmt":10,"ForStmt":1,"ThrowStmt":2,"ExpressionStmt":32},"text":"public static void main(String[] args) {\n    // The JDBC connection to the database server\n    Connection c = null;\n    try {\n        // Look for the properties file DB.props in the same directory as\n        // this program.  It will contain default values for the various\n        // parameters needed to connect to a database\n        Properties p = new Properties();\n        try {\n            p.load(GetDBInfo.class.getResourceAsStream(\"DB.props\"));\n        } catch (Exception e) {\n        }\n        // Get default values from the properties file\n        // Name of driver class\n        String driver = p.getProperty(\"driver\");\n        // JDBC URL for server\n        String server = p.getProperty(\"server\", \"\");\n        // db user name\n        String user = p.getProperty(\"user\", \"\");\n        // db account password\n        String password = p.getProperty(\"password\", \"\");\n        // These variables don't have defaults\n        // The db name (to be appended to server URL)\n        String database = null;\n        // The optional name of a table in the db\n        String table = null;\n        // Parse the command-line arguments to override the default values above\n        for (int i = 0; i < args.length; i++) {\n            if (// -d <driver>\n            args[i].equals(\"-d\"))\n                // -d <driver>\n                driver = args[++i];\n            else if (// -s <server>\n            args[i].equals(\"-s\"))\n                // -s <server>\n                server = args[++i];\n            else if (// -u <user>\n            args[i].equals(\"-u\"))\n                // -u <user>\n                user = args[++i];\n            else if (// -p <password>\n            args[i].equals(\"-p\"))\n                // -p <password>\n                password = args[++i];\n            else if (// <dbname>\n            database == null)\n                // <dbname>\n       // Make sure that at least a server or a database were specified. \n\n                database = args[i];\n            else if (// <tablename>\n            table == null)\n                // <tablename>\n                table = args[i];\n            else\n                throw new IllegalArgumentException(\"Unknown argument: \" + args[i]);\n        }\n        // If not, we have no idea what to connect to, and cannot continue.\n        if ((server.length() == 0) && (database.length() == 0))\n            throw new IllegalArgumentException(\"No database or server specified.\");\n        // Load the db driver, if any was specified.\n        if (driver != null)\n            Class.forName(driver);\n        // Now attempt to open a connection to the specified database on\n        // the specified server, using the specified name and password\n        c = DriverManager.getConnection(server + database, user, password);\n        // Get the DatabaseMetaData object for the connection.  This is the\n        // object that will return us all the data we're interested in here.\n        DatabaseMetaData md = c.getMetaData();\n        // Display information about the server, the driver, etc.\n        System.out.println(\"DBMS: \" + md.getDatabaseProductName() + \" \" + md.getDatabaseProductVersion());\n        System.out.println(\"JDBC Driver: \" + md.getDriverName() + \" \" + md.getDriverVersion());\n       // Now, if the user did not specify a table, then display a list of\n\n       // all tables defined in the named database.  Note that tables are\n\n        System.out.println(\"Database: \" + md.getURL());\n        System.out.println(\"User: \" + md.getUserName());\n        // returned in a ResultSet, just like query results are.\n        if (table == null) {\n            System.out.println(\"Tables:\");\n            ResultSet r = md.getTables(\"\", \"\", \"%\", null);\n            while (r.next()) System.out.println(\"\\t\" + r.getString(3));\n        } else // Otherwise, list all columns of the specified table.\n        // Again, information about the columns is returned in a ResultSet\n        {\n            System.out.println(\"Columns of \" + table + \": \");\n            ResultSet r = md.getColumns(\"\", \"\", table, \"%\");\n            while (r.next()) System.out.println(\"\\t\" + r.getString(4) + \" : \" + r.getString(6));\n        }\n    }// Print an error message if anything goes wrong.\n     catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java GetDBInfo [-d <driver] [-s <dbserver>]\\n\" + \"\\t[-u <username>] [-p <password>] <dbname>\");\n    } finally // Always remember to close the Connection object when we're done!\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"GetDBInfo","variables":{"server":4,"c":4,"e":5,"i":14,"p":6,"args":11,"password":2,"database":5,"r":7,"driver":3,"md":9,"Class":1,"user":2,"DriverManager":1,"table":5},"constants":{"\"\"":7,"\"driver\"":1,"\"-u\"":1,"\"-s\"":1,"\": \"":1,"\"\\t[-u <username>] [-p <password>] <dbname>\"":1,"\" : \"":1,"\"JDBC Driver: \"":1,"\"User: \"":1,"\"-d\"":1,"\"Unknown argument: \"":1,"\"Tables:\"":1,"\"No database or server specified.\"":1,"\" \"":2,"\"DBMS: \"":1,"\"password\"":1,"\"Columns of \"":1,"\"-p\"":1,"0":3,"3":1,"null":8,"\"DB.props\"":1,"\"Database: \"":1,"4":1,"\"server\"":1,"6":1,"\"\\t\"":2,"\"Usage: java GetDBInfo [-d <driver] [-s <dbserver>]\\n\"":1,"\"user\"":1,"\"%\"":2},"javaDoc":"","comments":"The JDBC connection to the database server Look for the properties file DB props in the same directory as this program It will contain default values for the various Get default values from the properties file These variables don't have defaults Make sure that at least a server or a database were specified Now attempt to open a connection to the specified database on Get the DatabaseMetaData object for the connection This is the Now if the user did not specify a table then display a list of all tables defined in the named database Note that tables are parameters needed to connect to a database Name of driver class JDBC URL for server db user name db account password The db name (to be appended to server URL) The optional name of a table in the db Parse the command-line arguments to override the default values above -d <driver> -d <driver> -s <server> -s <server> -u <user> -u <user> -p <password> -p <password> <dbname> <dbname> <tablename> <tablename> If not we have no idea what to connect to and cannot continue Load the db driver if any was specified the specified server using the specified name and password object that will return us all the data we're interested in here Display information about the server the driver etc returned in a ResultSet just like query results are Otherwise list all columns of the specified table Again information about the columns is returned in a ResultSet Print an error message if anything goes wrong Always remember to close the Connection object when we're done! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"intersection":1,"union":1,"isInside":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rect":4},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"BinaryExpr":12,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":7,"MethodCallExpr":6},"statements":{"IfStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // Create Rect objects\n    Rect r1 = new Rect(1, 1, 4, 4);\n    Rect r2 = new Rect(2, 3, 5, 6);\n    // Invoke Rect methods\n    Rect u = r1.union(r2);\n    Rect i = r2.intersection(r1);\n    if (// Use Rect fields and invoke a method\n    u.isInside(r2.x1, r2.y1))\n        System.out.println(\"(\" + r2.x1 + \",\" + r2.y1 + \") is inside the union\");\n    // These string concatenations implicitly call the Rect.toString() method\n    System.out.println(r1 + \" union \" + r2 + \" = \" + u);\n    System.out.println(r1 + \" intersect \" + r2 + \" = \" + i);\n}\n","name":"main","className":"RectTest","variables":{"r2":4,"u":3,"i":2,"r1":4},"constants":{"1":2,"\" intersect \"":1,"2":1,"3":1,"4":2,"5":1,"\") is inside the union\"":1,"\" union \"":1,"6":1,"\",\"":1,"\"(\"":1,"\" = \"":2},"javaDoc":"","comments":"Create Rect objects Invoke Rect methods Use Rect fields and invoke a method These string concatenations implicitly call the Rect toString() method ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"print_class":1},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":[],"types":{"Class":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** The main method.  Print info about the named class */\npublic static void main(String[] args) throws ClassNotFoundException {\n    Class c = Class.forName(args[0]);\n    print_class(c);\n}\n","name":"main","className":"ShowClass","variables":{"args":1,"c":1,"Class":1},"constants":{"0":1},"javaDoc":"The main method Print info about the named class","comments":" The main method.  Print info about the named class ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"void","methodCalls":{"getName":4,"getDeclaredConstructors":1,"getInterfaces":1,"getDeclaredFields":1,"getDeclaredMethods":1,"toString":3,"getModifiers":3,"print_field":1,"print_method_or_constructor":2,"isInterface":2,"System.out.print":6,"getSuperclass":2,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"Class[]":1,"Constructor[]":1,"Method[]":1,"int":4,"Field[]":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":17,"NameExpr":154,"StringLiteralExpr":12,"FieldAccessExpr":17,"EnclosedExpr":2,"UnaryExpr":4,"MethodCallExpr":34},"statements":{"IfStmt":5,"BlockStmt":3,"ForStmt":4,"ExpressionStmt":19},"text":"/** Display the modifiers, name, superclass and interfaces of a class\n   *  or interface. Then go and list all constructors, fields, and methods. */\npublic static void print_class(Class c) {\n    // Print modifiers, type (class or interface), name and superclass.\n    if (c.isInterface()) {\n        // The modifiers will include the \"interface\" keyword here...\n        System.out.print(Modifier.toString(c.getModifiers()) + \" \" + c.getName());\n    } else if (c.getSuperclass() != null)\n        System.out.print(Modifier.toString(c.getModifiers()) + \" class \" + c.getName() + \" extends \" + c.getSuperclass().getName());\n    else\n        System.out.print(Modifier.toString(c.getModifiers()) + \" class \" + c.getName());\n    // Print interfaces or super-interfaces of the class or interface.\n    Class[] interfaces = c.getInterfaces();\n    if ((interfaces != null) && (interfaces.length > 0)) {\n        if (c.isInterface())\n            System.out.println(\" extends \");\n        else\n            System.out.print(\" implements \");\n        for (int i = 0; i < interfaces.length; i++) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(interfaces[i].getName());\n        }\n    }\n    // Begin class member listing.\n    System.out.println(\" {\");\n    // Now look up and display the members of the class.\n    System.out.println(\" // Constructors\");\n    Constructor[] constructors = c.getDeclaredConstructors();\n    for (// Display constructors.\n    int i = 0; // Display constructors.\n    i < constructors.length; // Display constructors.\n    i++) print_method_or_constructor(constructors[i]);\n    System.out.println(\" // Fields\");\n    // Look up fields.\n    Field[] fields = c.getDeclaredFields();\n    for (// Display them.\n    int i = 0; // Display them.\n    i < fields.length; // Display them.\n    i++) print_field(fields[i]);\n    System.out.println(\" // Methods\");\n    // Look up methods.\n    Method[] methods = c.getDeclaredMethods();\n    for (// Display them.\n    int i = 0; // Display them.\n    i < methods.length; // Display them.\n    i++) print_method_or_constructor(methods[i]);\n    // End class member listing.\n    System.out.println(\"}\");\n}\n","name":"print_class","className":"ShowClass","variables":{"constructors":2,"interfaces":3,"c":14,"methods":2,"i":17,"fields":2,"Modifier":3},"constants":{"0":6,"\" class \"":2,"\" // Methods\"":1,"\" \"":1,"null":2,"\" // Fields\"":1,"\" // Constructors\"":1,"\"}\"":1,"\" extends \"":2,"\" {\"":1,"\", \"":1,"\" implements \"":1},"javaDoc":"Display the modifiers name superclass and interfaces of a class or interface Then go and list all constructors fields and methods","comments":"Print modifiers type (class or interface) name and superclass The modifiers will include the \"interface\" keyword here Print interfaces or super-interfaces of the class or interface Begin class member listing Now look up and display the members of the class Display constructors Display constructors Display constructors Look up fields Display them Display them Display them Look up methods Display them Display them Display them End class member listing  Display the modifiers, name, superclass and interfaces of a class\n   *  or interface. Then go and list all constructors, fields, and methods. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"String","methodCalls":{"getName":1,"getComponentType":1,"isArray":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":12,"MethodCallExpr":3,"AssignExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Return the name of an interface or primitive type, handling arrays. */\npublic static String typename(Class t) {\n    String brackets = \"\";\n    while (t.isArray()) {\n        brackets += \"[]\";\n        t = t.getComponentType();\n    }\n    return t.getName() + brackets;\n}\n","name":"typename","className":"ShowClass","variables":{"t":4,"brackets":3},"constants":{"\"\"":1,"\"[]\"":1},"javaDoc":"Return the name of an interface or primitive type handling arrays","comments":" Return the name of an interface or primitive type, handling arrays. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"/** Return a string version of modifiers, handling spaces nicely. */\npublic static String modifiers(int m) {\n    if (m == 0)\n        return \"\";\n    else\n        return Modifier.toString(m) + \" \";\n}\n","name":"modifiers","className":"ShowClass","variables":{"m":1,"Modifier":1},"constants":{"0":1,"\"\"":1,"\" \"":1},"javaDoc":"Return a string version of modifiers handling spaces nicely","comments":" Return a string version of modifiers, handling spaces nicely. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Field"],"returnType":"void","methodCalls":{"getName":1,"getType":1,"getModifiers":1,"modifiers":1,"typename":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":18,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":1},"text":"/** Print the modifiers, type, and name of a field */\npublic static void print_field(Field f) {\n    System.out.println(\"  \" + modifiers(f.getModifiers()) + typename(f.getType()) + \" \" + f.getName() + \";\");\n}\n","name":"print_field","className":"ShowClass","variables":{"f":3},"constants":{"\" \"":1,"\";\"":1,"\"  \"":1},"javaDoc":"Print the modifiers type and name of a field","comments":" Print the modifiers, type, and name of a field ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Member"],"returnType":"void","methodCalls":{"getExceptionTypes":2,"getName":1,"getReturnType":1,"getParameterTypes":2,"getModifiers":1,"modifiers":1,"System.out.print":7,"typename":3,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Constructor":1,"Class":1,"Method":1,"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":11,"NameExpr":98,"StringLiteralExpr":9,"ConditionalExpr":1,"InstanceOfExpr":1,"UnaryExpr":2,"AssignExpr":5,"NullLiteralExpr":2,"CastExpr":2,"FieldAccessExpr":11,"EnclosedExpr":2,"MethodCallExpr":19},"statements":{"IfStmt":4,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":16},"text":"/** Print the modifiers, return type, name, parameter types and exception\n   *  type of a method or constructor.  Note the use of the Member interface\n   *  to allow this method to work with both Method and Constructor objects */\npublic static void print_method_or_constructor(Member member) {\n    Class returntype = null, parameters[], exceptions[];\n    if (member instanceof Method) {\n        Method m = (Method) member;\n        returntype = m.getReturnType();\n        parameters = m.getParameterTypes();\n        exceptions = m.getExceptionTypes();\n    } else {\n        Constructor c = (Constructor) member;\n        parameters = c.getParameterTypes();\n        exceptions = c.getExceptionTypes();\n    }\n    System.out.print(\"  \" + modifiers(member.getModifiers()) + ((returntype != null) ? typename(returntype) + \" \" : \"\") + member.getName() + \"(\");\n    for (int i = 0; i < parameters.length; i++) {\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(typename(parameters[i]));\n    }\n    System.out.print(\")\");\n    if (exceptions.length > 0)\n        System.out.print(\" throws \");\n    for (int i = 0; i < exceptions.length; i++) {\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(typename(exceptions[i]));\n    }\n    System.out.println(\";\");\n}\n","name":"print_method_or_constructor","className":"ShowClass","variables":{"c":3,"returntype":3,"member":5,"i":10,"parameters":4,"m":4,"exceptions":4},"constants":{"\"\"":1,"0":5,"null":2,"\" \"":1,"\" throws \"":1,"\";\"":1,"\")\"":1,"\"(\"":1,"\", \"":2,"\"  \"":1},"javaDoc":"Print the modifiers return type name parameter types and exception type of a method or constructor Note the use of the Member interface to allow this method to work with both Method and Constructor objects","comments":" Print the modifiers, return type, name, parameter types and exception\n   *  type of a method or constructor.  Note the use of the Member interface\n   *  to allow this method to work with both Method and Constructor objects ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getProperty":1,"getHostName":1,"System.out.flush":2,"openConnection":1,"getProperties":1,"readLine":4,"setDoInput":1,"put":1,"getLocalHost":1,"println":5,"equals":1,"getOutputStream":1,"System.err.println":2,"close":1,"System.out.print":3,"connect":1,"setDoOutput":1,"System.out.println":3},"annotations":[],"exceptions":["// Handle any exceptions, print error message.\nException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":4,"URL":1,"URLConnection":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":5,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":13,"NameExpr":126,"StringLiteralExpr":18,"AssignExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":12,"EnclosedExpr":1,"MethodCallExpr":31},"statements":{"IfStmt":2,"BreakStmt":1,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":29},"text":"public static void main(String[] args) {\n    try {\n        // If the user specified a mailhost, tell the system about it.\n        if (args.length >= 1)\n            System.getProperties().put(\"mail.host\", args[0]);\n        // A Reader stream to read from the console\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        // Ask the user for the from, to, and subject lines\n        System.out.print(\"From: \");\n        String from = in.readLine();\n        System.out.print(\"To: \");\n        String to = in.readLine();\n        System.out.print(\"Subject: \");\n        String subject = in.readLine();\n        // Establish a network connection for sending mail\n        // Create a mailto: URL \n        URL u = new URL(\"mailto:\" + to);\n        // Create a URLConnection for it\n        URLConnection c = u.openConnection();\n        // Specify no input from this URL\n        c.setDoInput(false);\n        // Specify we'll do output\n        c.setDoOutput(true);\n        // Tell the user what's happening\n        System.out.println(\"Connecting...\");\n        // Tell them right now\n        System.out.flush();\n        // Connect to mail host\n        c.connect();\n        PrintWriter // Get output stream to mail host\n        out = new PrintWriter(new OutputStreamWriter(c.getOutputStream()));\n        // Write out mail headers.  Don't let users fake the From address\n        out.println(\"From: \\\"\" + from + \"\\\" <\" + System.getProperty(\"user.name\") + \"@\" + InetAddress.getLocalHost().getHostName() + \">\");\n        out.println(\"To: \" + to);\n        out.println(\"Subject: \" + subject);\n        // blank line to end the list of headers\n        out.println();\n        // Now ask the user to enter the body of the message\n        System.out.println(\"Enter the message. \" + \"End with a '.' on a line by itself.\");\n        // Read message line by line and send it out.\n        String line;\n        for (; ; ) {\n            line = in.readLine();\n            if ((line == null) || line.equals(\".\"))\n                break;\n            out.println(line);\n        }\n        // Close the stream to terminate the message \n        out.close();\n        // Tell the user it was successfully sent.\n        System.out.println(\"Message sent.\");\n        System.out.flush();\n    } catch (// Handle any exceptions, print error message.\n    Exception // Handle any exceptions, print error message.\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java SendMail [<mailhost>]\");\n    }\n}\n","name":"main","className":"SendMail","variables":{"args":1,"c":5,"in":5,"u":2,"e":1,"subject":2,"line":4,"from":2,"to":3,"InetAddress":1,"System":2,"out":7},"constants":{"\"From: \"":1,"\"@\"":1,"\">\"":1,"\"Enter the message. \"":1,"\"To: \"":2,"false":1,"\"Message sent.\"":1,"0":1,"\"user.name\"":1,"1":1,"\"Subject: \"":2,"\"mailto:\"":1,"null":1,"\".\"":1,"\"End with a '.' on a line by itself.\"":1,"true":1,"\"Connecting...\"":1,"\"From: \\\"\"":1,"\"mail.host\"":1,"\"\\\" <\"":1,"\"Usage: java SendMail [<mailhost>]\"":1},"javaDoc":"","comments":"Establish a network connection for sending mail If the user specified a mailhost tell the system about it A Reader stream to read from the console Ask the user for the from to and subject lines Create a mailto: URL Create a URLConnection for it Specify no input from this URL Specify we'll do output Tell the user what's happening Tell them right now Connect to mail host Get output stream to mail host Write out mail headers Don't let users fake the From address blank line to end the list of headers Now ask the user to enter the body of the message Read message line by line and send it out Close the stream to terminate the message Tell the user it was successfully sent Handle any exceptions print error message Handle any exceptions print error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"CloseableFrame","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ThisExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// as its own WindowListener object\npublic CloseableFrame() {\n    this.addWindowListener(this);\n}\n","name":"CloseableFrame","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","comments":" as its own WindowListener object","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"CloseableFrame","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"ThisExpr":2,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public CloseableFrame(String title) {\n    super(title);\n    this.addWindowListener(this);\n}\n","name":"CloseableFrame","className":"CloseableFrame","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// These are the methods of the WindowListener object.  Only \n// windowClosing() is implemented\npublic void windowClosing(WindowEvent e) {\n    this.dispose();\n}\n","name":"windowClosing","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","comments":" windowClosing() is implemented","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowOpened(WindowEvent e) {\n}\n","name":"windowOpened","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowClosed(WindowEvent e) {\n}\n","name":"windowClosed","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowIconified(WindowEvent e) {\n}\n","name":"windowIconified","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowDeiconified(WindowEvent e) {\n}\n","name":"windowDeiconified","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowActivated(WindowEvent e) {\n}\n","name":"windowActivated","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void windowDeactivated(WindowEvent e) {\n}\n","name":"windowDeactivated","className":"CloseableFrame","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Open a new account, with the specified name and password */\npublic void openAccount(String name, String password) throws RemoteException, BankingException;\n","name":"openAccount","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Open a new account with the specified name and password","comments":" Open a new account, with the specified name and password ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Close the named account */\npublic FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException;\n","name":"closeAccount","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Close the named account","comments":" Close the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Deposit money into the named account */\npublic void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException;\n","name":"deposit","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Deposit money into the named account","comments":" Deposit money into the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Withdraw the specified amount of money from the named account */\npublic FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException;\n","name":"withdraw","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Withdraw the specified amount of money from the named account","comments":" Withdraw the specified amount of money from the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the amount of money in the named account */\npublic int getBalance(String name, String password) throws RemoteException, BankingException;\n","name":"getBalance","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Return the amount of money in the named account","comments":" Return the amount of money in the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Return a Vector of Strings that list the transaction history \n     * of the named account \n     **/\npublic Vector getTransactionHistory(String name, String password) throws RemoteException, BankingException;\n","name":"getTransactionHistory","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Return a Vector of Strings that list the transaction history of the named account","comments":" \n     * Return a Vector of Strings that list the transaction history \n     * of the named account \n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public FunnyMoney(int amount) {\n    this.amount = amount;\n}\n","name":"FunnyMoney","className":"FunnyMoney","variables":{"amount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"BankingException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public BankingException(String msg) {\n    super(msg);\n}\n","name":"BankingException","className":"BankingException","variables":{"msg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookup":1,"getProperty":1,"getTransactionHistory":1,"setSecurityManager":1,"getMessage":1,"parseInt":2,"closeAccount":1,"getBalance":1,"size":1,"equals":6,"elementAt":1,"deposit":1,"openAccount":1,"System.err.println":5,"System.out.println":8,"withdraw":1},"annotations":[],"exceptions":["BankingException","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"FunnyMoney":3,"RemoteBank":1,"String":2,"Vector":1,"int":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":16,"VariableDeclarationExpr":9,"ArrayAccessExpr":15,"BinaryExpr":10,"NameExpr":159,"StringLiteralExpr":22,"CastExpr":1,"FieldAccessExpr":16,"UnaryExpr":1,"MethodCallExpr":34},"statements":{"IfStmt":6,"TryStmt":1,"BlockStmt":10,"ForStmt":1,"ExpressionStmt":24},"text":"public static void main(String[] args) {\n    try {\n        // Set the standard RMI security manager so that we can safely load\n        // untrusted RemoteBank stub code over the network.\n        System.setSecurityManager(new RMISecurityManager());\n        // Figure out what RemoteBank to connect to by reading a system\n        // property (specified on the command line with a -D option to java)\n        // or, if it is not defined, use a default URL.  Note that by default\n        // this client tries to connect to a server on the local machine\n        String url = System.getProperty(\"bank\", \"rmi:///FirstRemote\");\n        // Now look up that RemoteBank server using the Naming object, which\n        // contacts the rmiregistry server.  Given the url, this call returns\n        // a RemoteBank object whose methods may be invoked remotely\n        RemoteBank bank = (RemoteBank) Naming.lookup(url);\n        // Convert the user's command to lower case\n        String cmd = args[0].toLowerCase();\n        // Now, go test the command against a bunch of possible options\n        if (cmd.equals(\"open\")) {\n            // Open an account\n            bank.openAccount(args[1], args[2]);\n            System.out.println(\"Account opened.\");\n        } else if (cmd.equals(\"close\")) {\n            // Close an account\n            FunnyMoney money = bank.closeAccount(args[1], args[2]);\n            // Note that FunnyMoney currency is denominated in wooden nickels\n            System.out.println(money.amount + \" wooden nickels returned to you.\");\n            System.out.println(\"Thanks for banking with us.\");\n        } else if (cmd.equals(\"deposit\")) {\n            // Deposit money\n            FunnyMoney money = new FunnyMoney(Integer.parseInt(args[3]));\n            bank.deposit(args[1], args[2], money);\n            System.out.println(\"Deposited \" + money.amount + \" wooden nickels.\");\n        } else if (cmd.equals(\"withdraw\")) {\n            // Withdraw money\n            FunnyMoney money = bank.withdraw(args[1], args[2], Integer.parseInt(args[3]));\n            System.out.println(\"Withdrew \" + money.amount + \" wooden nickels.\");\n        } else if (cmd.equals(\"balance\")) {\n            // Check account balance\n            int amt = bank.getBalance(args[1], args[2]);\n            System.out.println(\"You have \" + amt + \" wooden nickels in the bank.\");\n        } else if (cmd.equals(\"history\")) {\n            // Get transaction history\n            Vector transactions = bank.getTransactionHistory(args[1], args[2]);\n            for (int i = 0; i < transactions.size(); i++) System.out.println(transactions.elementAt(i));\n        } else\n            System.out.println(\"Unknown command\");\n    }// Catch and display RMI exceptions\n     catch (RemoteException e) {\n        System.err.println(e);\n    }// Catch and display Banking related exceptions\n     catch (BankingException e) {\n        System.err.println(e.getMessage());\n    }// Other exceptions are probably user syntax errors, so show usage.\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java [-Dbank=<url>] Bank$Client \" + \"<cmd> <name> <password> [<amount>]\");\n        System.err.println(\"where cmd is: open, close, deposit, \" + \"withdraw, balance, history\");\n    }\n}\n","name":"main","className":"Client","variables":{"args":15,"Integer":2,"bank":7,"money":3,"e":4,"amt":2,"i":3,"cmd":7,"Naming":1,"transactions":3,"System":2,"url":1},"constants":{"\"Unknown command\"":1,"\" wooden nickels.\"":2,"\"You have \"":1,"\"rmi:///FirstRemote\"":1,"\"Thanks for banking with us.\"":1,"\"bank\"":1,"\"withdraw\"":1,"\"Withdrew \"":1,"\"Usage: java [-Dbank=<url>] Bank$Client \"":1,"\"open\"":1,"\"history\"":1,"\"close\"":1,"0":2,"1":6,"2":6,"\"Deposited \"":1,"3":2,"\"deposit\"":1,"\"balance\"":1,"\"where cmd is: open, close, deposit, \"":1,"\" wooden nickels returned to you.\"":1,"\"Account opened.\"":1,"\"withdraw, balance, history\"":1,"\" wooden nickels in the bank.\"":1,"\"<cmd> <name> <password> [<amount>]\"":1},"javaDoc":"","comments":"Set the standard RMI security manager so that we can safely load Figure out what RemoteBank to connect to by reading a system property (specified on the command line with a -D option to java) or if it is not defined use a default URL Note that by default Now look up that RemoteBank server using the Naming object which contacts the rmiregistry server Given the url this call returns untrusted RemoteBank stub code over the network this client tries to connect to a server on the local machine a RemoteBank object whose methods may be invoked remotely Convert the user's command to lower case Now go test the command against a bunch of possible options Open an account Close an account Note that FunnyMoney currency is denominated in wooden nickels Deposit money Withdraw money Check account balance Get transaction history Catch and display RMI exceptions Catch and display Banking related exceptions Other exceptions are probably user syntax errors so show usage ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"factorial":1,"getMessage":1,"System.out.println":5},"annotations":[],"exceptions":["NumberFormatException","ArrayIndexOutOfBoundsException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":4,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Try to compute a factorial.  If something goes wrong, handle it below.\n    try {\n        int x = Integer.parseInt(args[0]);\n        System.out.println(x + \"! = \" + Factorial4.factorial(x));\n    }// The user forgot to specify an argument.  Thrown if args[0] is undefined.\n     catch (ArrayIndexOutOfBoundsException e) {\n        System.out.println(\"You must specify an argument\");\n        System.out.println(\"Usage: java FactComputer <number>\");\n    }// The argument is not a number.  Thrown by Integer.parseInt().\n     catch (NumberFormatException e) {\n        System.out.println(\"The argument you specify must be an integer\");\n    }// The argument is < 0.  Thrown by Factorial4.factorial()\n     catch (IllegalArgumentException e) {\n        System.out.println(\"Bad argument: \" + e.getMessage());\n    }\n}\n       // Display the message sent by the factorial() method:\n\n","name":"main","className":"FactComputer","variables":{"Integer":1,"args":1,"Factorial4":1,"e":4,"x":2},"constants":{"0":1,"\"Bad argument: \"":1,"\"You must specify an argument\"":1,"\"The argument you specify must be an integer\"":1,"\"! = \"":1,"\"Usage: java FactComputer <number>\"":1},"javaDoc":"","comments":"Try to compute a factorial If something goes wrong handle it below The user forgot to specify an argument Thrown if args[0] is undefined The argument is not a number Thrown by Integer parseInt() The argument is < 0 Thrown by Factorial4 factorial() Display the message sent by the factorial() method: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Load the image */\npublic void init() {\n    i = getImage(this.getDocumentBase(), \"tiger.gif\");\n}\n","name":"init","className":"ImageSampler","variables":{"i":1},"constants":{"\"tiger.gif\"":1},"javaDoc":"Load the image","comments":" Load the image ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":12,"drawString":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":100,"NameExpr":63,"StringLiteralExpr":5,"ThisExpr":12,"MethodCallExpr":17},"statements":{"ExpressionStmt":17},"text":"/** Display the image in a variety of ways */\npublic void paint(Graphics g) {\n    // Display original image\n    g.drawString(\"Original image:\", 20, 20);\n    // Old version of drawImage()\n    g.drawImage(i, 110, 10, this);\n    // Display scaled images\n    g.drawString(\"Scaled Images:\", 20, 120);\n    // New version\n    g.drawImage(i, 20, 130, 40, 150, 0, 0, 100, 100, this);\n    g.drawImage(i, 60, 130, 100, 170, 0, 0, 100, 100, this);\n    g.drawImage(i, 120, 130, 200, 210, 0, 0, 100, 100, this);\n    g.drawImage(i, 220, 80, 370, 230, 0, 0, 100, 100, this);\n    // Display cropped images\n    g.drawString(\"Cropped Images:\", 20, 250);\n    g.drawImage(i, 20, 260, 70, 310, 0, 0, 50, 50, this);\n    g.drawImage(i, 80, 260, 130, 310, 25, 25, 75, 75, this);\n    g.drawImage(i, 140, 260, 190, 310, 50, 50, 100, 100, this);\n    // Display flipped images\n    g.drawString(\"Flipped Images:\", 20, 330);\n    g.drawImage(i, 20, 340, 120, 440, 100, 0, 0, 100, this);\n    g.drawImage(i, 130, 340, 230, 440, 0, 100, 100, 0, this);\n    g.drawImage(i, 240, 340, 340, 440, 100, 100, 0, 0, this);\n    // Do all three\n    g.drawString(\"Scaled, Cropped, and Flipped:\", 20, 460);\n    g.drawImage(i, 20, 470, 170, 550, 90, 70, 10, 20, this);\n}\n","name":"paint","className":"ImageSampler","variables":{"g":17},"constants":{"25":2,"190":1,"170":2,"150":1,"370":1,"250":1,"470":1,"130":5,"230":2,"110":1,"330":1,"550":1,"\"Original image:\"":1,"210":1,"310":3,"90":1,"70":2,"50":4,"75":2,"10":2,"\"Scaled, Cropped, and Flipped:\"":1,"260":3,"140":1,"240":1,"460":1,"120":3,"340":4,"0":16,"220":1,"440":3,"\"Scaled Images:\"":1,"100":17,"200":1,"80":2,"60":1,"40":1,"\"Flipped Images:\"":1,"\"Cropped Images:\"":1,"20":11},"javaDoc":"Display the image in a variety of ways","comments":"Display original image Old version of drawImage() Display scaled images New version Display cropped images Display flipped images Do all three  Display the image in a variety of ways ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"runServer":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":36,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":7},"text":"/** The main method parses arguments and passes them to runServer */\npublic static void main(String[] args) throws IOException {\n    try {\n        // Check the number of arguments\n        if (args.length != 3)\n            throw new IllegalArgumentException(\"Wrong number of arguments.\");\n        // Get the command-line arguments: the host and port we are proxy for\n        // and the local port that we listen for connections on\n        String host = args[0];\n        int remoteport = Integer.parseInt(args[1]);\n        int localport = Integer.parseInt(args[2]);\n        // Print a start-up message\n        System.out.println(\"Starting proxy for \" + host + \":\" + remoteport + \" on port \" + localport);\n        // And start running the server\n        // never returns\n        runServer(host, remoteport, localport);\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java SimpleProxyServer \" + \"<host> <remoteport> <localport>\");\n    }\n}\n","name":"main","className":"SimpleProxyServer","variables":{"args":3,"Integer":2,"e":1,"host":2,"remoteport":2,"localport":2},"constants":{"0":1,"1":1,"\"Wrong number of arguments.\"":1,"2":1,"3":1,"\"<host> <remoteport> <localport>\"":1,"\" on port \"":1,"\"Usage: java SimpleProxyServer \"":1,"\"Starting proxy for \"":1,"\":\"":1},"javaDoc":"The main method parses arguments and passes them to runServer","comments":"Get the command-line arguments: the host and port we are proxy for And start running the server Check the number of arguments and the local port that we listen for connections on Print a start-up message never returns  The main method parses arguments and passes them to runServer ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":4},"text":"public void run() {\n    int bytes_read;\n    try {\n        while ((bytes_read = from_client.read(request)) != -1) {\n            to_server.write(request, 0, bytes_read);\n            to_server.flush();\n        }\n    } catch (IOException e) {\n    }\n    // server-to-client loop in the main thread exit.\n    try {\n        to_server.close();\n    } catch (IOException e) {\n    }\n}\n             // the client closed the connection to us, so  close our \n\n             // connection to the server.  This will also cause the \n\n","name":"run","className":"","variables":{"to_server":3,"from_client":1,"e":2,"bytes_read":2},"constants":{"0":1,"1":1},"javaDoc":"","comments":"the client closed the connection to us so close our connection to the server This will also cause the server-to-client loop in the main thread exit ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","int"],"returnType":"void","methodCalls":{"println":1,"read":2,"flush":3,"start":1,"getOutputStream":2,"System.err.println":1,"getInputStream":2,"close":5,"write":2,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"byte[]":2,"InputStream":2,"OutputStream":2,"ServerSocket":1,"Socket":1,"int":2,"PrintWriter":1,"Thread":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":6,"VariableDeclarationExpr":12,"BinaryExpr":9,"NameExpr":84,"StringLiteralExpr":3,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":20},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":3,"BlockStmt":17,"TryStmt":6,"ExpressionStmt":27},"text":"/**\n   * This method runs a single-threaded proxy server for \n   * host:remoteport on the specified local port.  It never returns.\n   **/\npublic static void runServer(String host, int remoteport, int localport) throws IOException {\n    // Create a ServerSocket to listen for connections with\n    ServerSocket ss = new ServerSocket(localport);\n    // Create buffers for client-to-server and server-to-client communication.\n    // We make one final so it can be used in an anonymous class below.\n    // Note the assumptions about the volume of traffic in each direction...\n    final byte[] request = new byte[1024];\n    byte[] reply = new byte[4096];\n    // This is a server that never returns, so enter an infinite loop.\n    while (true) {\n        // Variables to hold the sockets to the client and to the server.\n        Socket client = null, server = null;\n        try {\n            // Wait for a connection on the local port\n            client = ss.accept();\n            // Get client streams.  Make them final so they can\n            // be used in the anonymous thread below.\n            final InputStream from_client = client.getInputStream();\n            final OutputStream to_client = client.getOutputStream();\n            // client, disconnect, then continue waiting for another connection.\n            try {\n                server = new Socket(host, remoteport);\n            } catch (IOException e) {\n                PrintWriter out = new PrintWriter(new OutputStreamWriter(to_client));\n                out.println(\"Proxy server cannot connect to \" + host + \":\" + remoteport + \":\\n\" + e);\n                out.flush();\n                client.close();\n                continue;\n            }\n            // Get server streams.\n            final InputStream from_server = server.getInputStream();\n            final OutputStream to_server = server.getOutputStream();\n            // Make a thread to read the client's requests and pass them to the \n            // server.  We have to use a separate thread because requests and\n            // responses may be asynchronous.\n            Thread t = new Thread() {\n\n                public void run() {\n                    int bytes_read;\n                    try {\n                        while ((bytes_read = from_client.read(request)) != -1) {\n                            to_server.write(request, 0, bytes_read);\n                            to_server.flush();\n                        }\n                    } catch (IOException e) {\n                    }\n                    // server-to-client loop in the main thread exit.\n                    try {\n                        to_server.close();\n                    } catch (IOException e) {\n                    }\n                }\n            };\n            // Start the client-to-server request thread running\n            t.start();\n            // Meanwhile, in the main thread, read the server's responses\n            // and pass them back to the client.  This will be done in\n            // parallel with the client-to-server request thread above.\n            int bytes_read;\n            try {\n                while ((bytes_read = from_server.read(reply)) != -1) {\n                    to_client.write(reply, 0, bytes_read);\n                    to_client.flush();\n         // Make a connection to the real server\n\n         // If we cannot connect to the server, send an error to the \n\n                }\n            } catch (IOException e) {\n            }\n            // The server closed its connection to us, so close our \n            // connection to our client.  This will make the other thread exit.\n            to_client.close();\n        } catch (IOException e) {\n            System.err.println(e);\n        } finally // Close the sockets no matter what happens each time through the loop.\n        {\n            try {\n                if (server != null)\n                    server.close();\n                if (client != null)\n                    client.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}\n             // the client closed the connection to us, so  close our \n\n             // connection to the server.  This will also cause the \n\n","name":"runServer","className":"SimpleProxyServer","variables":{"ss":2,"request":1,"server":6,"from_client":2,"e":7,"to_client":5,"from_server":2,"run":1,"bytes_read":4,"out":3,"to_server":4,"t":2,"host":2,"client":7,"localport":1,"remoteport":2,"reply":1},"constants":{"0":2,"4096":1,"1":2,"\":\\n\"":1,"null":4,"\"Proxy server cannot connect to \"":1,"1024":1,"true":1,"\":\"":1},"javaDoc":"This method runs a single-threaded proxy server for host:remoteport on the specified local port It never returns","comments":"Create buffers for client-to-server and server-to-client communication We make one final so it can be used in an anonymous class below Create a ServerSocket to listen for connections with Note the assumptions about the volume of traffic in each direction This is a server that never returns so enter an infinite loop Variables to hold the sockets to the client and to the server Get client streams Make them final so they can Make a connection to the real server If we cannot connect to the server send an error to the Make a thread to read the client's requests and pass them to the server We have to use a separate thread because requests and Meanwhile in the main thread read the server's responses and pass them back to the client This will be done in The server closed its connection to us so close our Wait for a connection on the local port be used in the anonymous thread below client disconnect then continue waiting for another connection Get server streams responses may be asynchronous the client closed the connection to us so close our connection to the server This will also cause the server-to-client loop in the main thread exit Start the client-to-server request thread running parallel with the client-to-server request thread above connection to our client This will make the other thread exit Close the sockets no matter what happens each time through the loop \n   * This method runs a single-threaded proxy server for \n   * host:remoteport on the specified local port.  It never returns.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"/** main entry point.  Just create an instance of this application class */\npublic static void main(String[] args) {\n    new Scribble5();\n}\n","name":"main","className":"Scribble5","variables":{},"constants":{},"javaDoc":"main entry point Just create an instance of this application class","comments":" main entry point.  Just create an instance of this application class ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Scribble5","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Application constructor:  create an instance of our GUI class */\npublic Scribble5() {\n    window = new ScribbleGUI(this);\n}\n","name":"Scribble5","className":"Scribble5","variables":{"window":1},"constants":{},"javaDoc":"Application constructor: create an instance of our GUI class","comments":" Application constructor:  create an instance of our GUI class ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"exit":1,"getSize":2,"setColor":1,"equals":3,"dispose":1,"getGraphics":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":37,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":5},"text":"/** This is the application method that processes commands sent by the GUI */\npublic void doCommand(String command) {\n    if (command.equals(\"clear\")) {\n        // clear the GUI window\n        // It would be more modular to include this functionality in the GUI\n        // class itself.  But for demonstration purposes, we do it here.\n        Graphics g = window.getGraphics();\n        g.setColor(window.getBackground());\n        g.fillRect(0, 0, window.getSize().width, window.getSize().height);\n    } else if (// not yet implemented\n    command.equals(\"print\")) // not yet implemented\n    {\n    } else if (command.equals(\"quit\")) {\n        // quit the application\n        // close the GUI\n        window.dispose();\n        // and exit.\n        System.exit(0);\n    }\n}\n","name":"doCommand","className":"Scribble5","variables":{"g":3,"window":5,"command":3,"System":1},"constants":{"0":3,"\"quit\"":1,"\"clear\"":1,"\"print\"":1},"javaDoc":"This is the application method that processes commands sent by the GUI","comments":"clear the GUI window It would be more modular to include this functionality in the GUI class itself But for demonstration purposes we do it here not yet implemented not yet implemented quit the application close the GUI and exit  This is the application method that processes commands sent by the GUI ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ScribbleActionListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public ScribbleActionListener(String cmd) {\n    command = cmd;\n}\n","name":"ScribbleActionListener","className":"ScribbleActionListener","variables":{"cmd":1,"command":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"doCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    app.doCommand(command);\n}\n","name":"actionPerformed","className":"ScribbleActionListener","variables":{"app":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"doCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    app.doCommand(\"quit\");\n}\n","name":"windowClosing","className":"","variables":{"app":1},"constants":{"\"quit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    lastx = e.getX();\n    lasty = e.getY();\n}\n","name":"mousePressed","className":"","variables":{"e":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"setColor":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":25,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public void mouseDragged(MouseEvent e) {\n    Graphics g = getGraphics();\n    int x = e.getX(), y = e.getY();\n    g.setColor(Color.black);\n    g.drawLine(lastx, lasty, x, y);\n    lastx = x;\n    lasty = y;\n}\n","name":"mouseDragged","className":"","variables":{"e":2,"g":3,"x":2,"y":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scribble5"],"returnType":"ScribbleGUI","methodCalls":{"getX":2,"getY":2,"setColor":1,"addActionListener":3,"getGraphics":1,"drawLine":1,"doCommand":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod","InnerClass"],"types":{"Graphics":1,"Button":3,"int":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"StringLiteralExpr":8,"NameExpr":89,"FieldAccessExpr":2,"ThisExpr":9,"AssignExpr":6,"MethodCallExpr":21},"statements":{"TypeDeclarationStmt":1,"BlockStmt":5,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":27},"text":"/**\n   * The GUI constructor does all the work of creating the GUI and setting\n   * up event listeners.  Note the use of local and anonymous classes.\n   */\npublic ScribbleGUI(Scribble5 application) {\n    // Create the window\n    super(\"Scribble\");\n    // Remember the application reference\n    app = application;\n    // Create three buttons\n    Button clear = new Button(\"Clear\");\n    Button print = new Button(\"Print\");\n    Button quit = new Button(\"Quit\");\n    // Set a LayoutManager, and add the buttons to the window.\n    this.setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 5));\n    this.add(clear);\n    this.add(print);\n    this.add(quit);\n    // Here's a local class used for action listeners for the buttons\n    class ScribbleActionListener implements ActionListener {\n\n        private String command;\n\n        public ScribbleActionListener(String cmd) {\n            command = cmd;\n        }\n\n        public void actionPerformed(ActionEvent e) {\n            app.doCommand(command);\n        }\n    }\n    // Define action listener adapters that connect the  buttons to the app\n    clear.addActionListener(new ScribbleActionListener(\"clear\"));\n    print.addActionListener(new ScribbleActionListener(\"print\"));\n    quit.addActionListener(new ScribbleActionListener(\"quit\"));\n    // Handle the window close request similarly\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            app.doCommand(\"quit\");\n        }\n    });\n    // High-level action events are passed to the application, but we\n    // still handle scribbling right here.  Register a MouseListener object.\n    this.addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            lastx = e.getX();\n            lasty = e.getY();\n        }\n    });\n    // Define, instantiate and register a MouseMotionListener object\n    this.addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            Graphics g = getGraphics();\n            int x = e.getX(), y = e.getY();\n            g.setColor(Color.black);\n            g.drawLine(lastx, lasty, x, y);\n            lastx = x;\n            lasty = y;\n        }\n    });\n    // Finally, set the size of the window, and pop it up\n    this.setSize(400, 400);\n    this.show();\n}\n","name":"ScribbleGUI","className":"ScribbleGUI","variables":{"app":3,"ScribbleActionListener":2,"mouseDragged":1,"e":8,"g":3,"clear":2,"command":2,"mousePressed":1,"actionPerformed":1,"print":2,"application":1,"windowClosing":1,"x":2,"y":2,"quit":2,"cmd":2,"lasty":2,"lastx":2},"constants":{"\"Quit\"":1,"\"quit\"":2,"\"clear\"":1,"400":2,"5":1,"\"Print\"":1,"\"Scribble\"":1,"\"print\"":1,"\"Clear\"":1,"10":1},"javaDoc":"The GUI constructor does all the work of creating the GUI and setting up event listeners Note the use of local and anonymous classes","comments":"High-level action events are passed to the application but we Create the window Remember the application reference Create three buttons Set a LayoutManager and add the buttons to the window Here's a local class used for action listeners for the buttons Define action listener adapters that connect the buttons to the app Handle the window close request similarly still handle scribbling right here Register a MouseListener object Define instantiate and register a MouseMotionListener object Finally set the size of the window and pop it up \n   * The GUI constructor does all the work of creating the GUI and setting\n   * up event listeners.  Note the use of local and anonymous classes.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"MyMouseListener":1,"MyMouseMotionListener":1,"MouseListener":1,"MouseMotionListener":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":6,"ThisExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"public void init() {\n    MouseListener ml = new MyMouseListener(this);\n    MouseMotionListener mml = new MyMouseMotionListener(this);\n    // Tell this component what MouseListener and MouseMotionListener\n    // objects to notify when mouse and mouse motion events occur.\n    this.addMouseListener(ml);\n    this.addMouseMotionListener(mml);\n}\n","name":"init","className":"Scribble3","variables":{"mml":1,"ml":1},"constants":{},"javaDoc":"","comments":"Tell this component what MouseListener and MouseMotionListener objects to notify when mouse and mouse motion events occur ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scribble3"],"returnType":"MyMouseListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public MyMouseListener(Scribble3 s) {\n    scribble = s;\n}\n","name":"MyMouseListener","className":"MyMouseListener","variables":{"s":1,"scribble":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    scribble.last_x = e.getX();\n    scribble.last_y = e.getY();\n}\n","name":"mousePressed","className":"MyMouseListener","variables":{"e":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scribble3"],"returnType":"MyMouseMotionListener","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public MyMouseMotionListener(Scribble3 s) {\n    scribble = s;\n}\n","name":"MyMouseMotionListener","className":"MyMouseMotionListener","variables":{"s":1,"scribble":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":28,"FieldAccessExpr":4,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":5},"text":"public void mouseDragged(MouseEvent e) {\n    Graphics g = scribble.getGraphics();\n    int x = e.getX(), y = e.getY();\n    g.drawLine(scribble.last_x, scribble.last_y, x, y);\n    scribble.last_x = x;\n    scribble.last_y = y;\n}\n","name":"mouseDragged","className":"MyMouseMotionListener","variables":{"e":2,"g":2,"x":2,"y":2,"scribble":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** This is the constructor.  It initializes the x and y variables */\npublic ComplexNumber(double real, double imaginary) {\n    this.x = real;\n    this.y = imaginary;\n}\n","name":"ComplexNumber","className":"ComplexNumber","variables":{"imaginary":1,"real":1},"constants":{},"javaDoc":"This is the constructor It initializes the x and y variables","comments":" This is the constructor.  It initializes the x and y variables ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n   * An accessor method.  Returns the real part of the complex number.\n   * Note that there is no setReal() method to set the real part.  This means\n   * that the ComplexNumber class is \"immutable\".\n   **/\npublic double real() {\n    return x;\n}\n","name":"real","className":"ComplexNumber","variables":{"x":1},"constants":{},"javaDoc":"An accessor method Returns the real part of the complex number Note that there is no setReal() method to set the real part This means that the ComplexNumber class is \"immutable\"","comments":" \n   * An accessor method.  Returns the real part of the complex number.\n   * Note that there is no setReal() method to set the real part.  This means\n   * that the ComplexNumber class is \"immutable\".\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** An accessor method.  Returns the imaginary part of the complex number */\npublic double imaginary() {\n    return y;\n}\n","name":"imaginary","className":"ComplexNumber","variables":{"y":1},"constants":{},"javaDoc":"An accessor method Returns the imaginary part of the complex number","comments":" An accessor method.  Returns the imaginary part of the complex number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Compute the magnitude of a complex number */\npublic double magnitude() {\n    return Math.sqrt(x * x + y * y);\n}\n","name":"magnitude","className":"ComplexNumber","variables":{"x":2,"y":2,"Math":1},"constants":{},"javaDoc":"Compute the magnitude of a complex number","comments":" Compute the magnitude of a complex number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n   * This method converts a ComplexNumber to a string.  This is a method of\n   * Object that we override so that complex numbers can be meaningfully\n   * converted to strings, and so they can conveniently be printed out with\n   * System.out.println() and related methods\n   **/\npublic String toString() {\n    return \"{\" + x + \",\" + y + \"}\";\n}\n","name":"toString","className":"ComplexNumber","variables":{"x":1,"y":1},"constants":{"\"}\"":1,"\",\"":1,"\"{\"":1},"javaDoc":"This method converts a ComplexNumber to a string This is a method of Object that we override so that complex numbers can be meaningfully converted to strings and so they can conveniently be printed out with System out println() and related methods","comments":" \n   * This method converts a ComplexNumber to a string.  This is a method of\n   * Object that we override so that complex numbers can be meaningfully\n   * converted to strings, and so they can conveniently be printed out with\n   * System.out.println() and related methods\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComplexNumber","ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** \n   * This is a static class method.  It takes two complex numbers, adds them, \n   * and returns the result as a third number.  Because it is static, there is\n   * no \"current instance\" or \"this\" object.  Use it like this:\n   * ComplexNumber c = ComplexNumber.add(a, b);\n   **/\npublic static ComplexNumber add(ComplexNumber a, ComplexNumber b) {\n    return new ComplexNumber(a.x + b.x, a.y + b.y);\n}\n","name":"add","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"This is a static class method It takes two complex numbers adds them and returns the result as a third number Because it is static there is no \"current instance\" or \"this\" object Use it like this: ComplexNumber c = ComplexNumber add(a b);","comments":" \n   * This is a static class method.  It takes two complex numbers, adds them, \n   * and returns the result as a third number.  Because it is static, there is\n   * no \"current instance\" or \"this\" object.  Use it like this:\n   * ComplexNumber c = ComplexNumber.add(a, b);\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":10,"FieldAccessExpr":4,"ThisExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n   * This is a non-static instance method by the same name.  It adds the\n   * specified complex number to the current complex number.  Use it like this:\n   * ComplexNumber c = a.add(b);\n   **/\npublic ComplexNumber add(ComplexNumber a) {\n    return new ComplexNumber(this.x + a.x, this.y + a.y);\n}\n","name":"add","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"This is a non-static instance method by the same name It adds the specified complex number to the current complex number Use it like this: ComplexNumber c = a add(b);","comments":"\n   * This is a non-static instance method by the same name.  It adds the\n   * specified complex number to the current complex number.  Use it like this:\n   * ComplexNumber c = a.add(b);\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComplexNumber","ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":24,"FieldAccessExpr":8},"statements":{"ReturnStmt":1},"text":"/** A static class method to multiply complex numbers */\npublic static ComplexNumber multiply(ComplexNumber a, ComplexNumber b) {\n    return new ComplexNumber(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n","name":"multiply","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"A static class method to multiply complex numbers","comments":" A static class method to multiply complex numbers ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":16,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** An instance method to multiply complex numbers */\npublic ComplexNumber multiply(ComplexNumber a) {\n    return new ComplexNumber(x * a.x - y * a.y, x * a.y + y * a.x);\n}\n","name":"multiply","className":"ComplexNumber","variables":{"x":2,"y":2},"constants":{},"javaDoc":"An instance method to multiply complex numbers","comments":" An instance method to multiply complex numbers ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"/** A very simple main() method for our program. */\npublic static void main(String[] args) {\n    new ScribbleCutAndPaste();\n}\n","name":"main","className":"ScribbleCutAndPaste","variables":{},"constants":{},"javaDoc":"A very simple main() method for our program","comments":" A very simple main() method for our program. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    new ScribbleCutAndPaste();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    close();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    close();\n}\n","name":"windowClosing","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribbleCutAndPaste","methodCalls":{"add":4,"exit":1,"addSeparator":1,"addActionListener":3,"close":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"MenuBar":1,"MenuItem":1,"Menu":1,"ScribblePanel":1},"expressions":{"ObjectCreationExpr":14,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"StringLiteralExpr":6,"NameExpr":65,"FieldAccessExpr":3,"UnaryExpr":1,"ThisExpr":6,"MethodCallExpr":16,"AssignExpr":3},"statements":{"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":22},"text":"/** Create a Frame, Menu, and ScrollPane for the scribble component */\npublic ScribbleCutAndPaste() {\n    // Create the window\n    super(\"ScribbleCutAndPaste\");\n    // Count it\n    num_windows++;\n    // Create scribble area and add to the frame\n    ScribblePanel scribble = new ScribblePanel(this, 400, 300);\n    this.add(scribble, \"Center\");\n    // Set up a menubar\n    // Create menubar\n    MenuBar menubar = new MenuBar();\n    // Add it to the frame\n    this.setMenuBar(menubar);\n    // Create a File menu\n    Menu file = new Menu(\"File\");\n    // Add to menubar\n    menubar.add(file);\n    // Create three menu items, with menu shortcuts, and add to the menu\n    MenuItem n, c, q;\n    file.add(n = new MenuItem(\"New Window\", new MenuShortcut(KeyEvent.VK_N)));\n    file.add(c = new MenuItem(\"Close Window\", new MenuShortcut(KeyEvent.VK_W)));\n    file.addSeparator();\n    file.add(q = new MenuItem(\"Quit\", new MenuShortcut(KeyEvent.VK_Q)));\n    // Create and register action listener objects for the three menu items\n    n.addActionListener(new // Open a new window\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            new ScribbleCutAndPaste();\n        }\n    });\n    c.addActionListener(new // Close this window\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            close();\n        }\n    });\n    q.addActionListener(new // Quit the program\n    ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    // Another event listener, this one to handle window close requests\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            close();\n        }\n    });\n    // Set the window size and pop it up\n    this.pack();\n    this.show();\n}\n","name":"ScribbleCutAndPaste","className":"ScribbleCutAndPaste","variables":{"menubar":2,"q":3,"actionPerformed":3,"num_windows":1,"file":5,"c":3,"e":4,"windowClosing":1,"scribble":1,"n":3,"System":1},"constants":{"0":1,"\"Quit\"":1,"\"ScribbleCutAndPaste\"":1,"300":1,"400":1,"\"File\"":1,"\"Center\"":1,"\"New Window\"":1,"\"Close Window\"":1},"javaDoc":"Create a Frame Menu and ScrollPane for the scribble component","comments":"Set up a menubar Create the window Count it Create scribble area and add to the frame Create menubar Add it to the frame Create a File menu Add to menubar Create three menu items with menu shortcuts and add to the menu Create and register action listener objects for the three menu items Open a new window Close this window Quit the program Another event listener this one to handle window close requests Set the window size and pop it up  Create a Frame, Menu, and ScrollPane for the scribble component ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Close a window.  If this is the last open window, just quit. */\nvoid close() {\n    if (--num_windows == 0)\n        System.exit(0);\n    else\n        this.dispose();\n}\n","name":"close","className":"ScribbleCutAndPaste","variables":{"num_windows":1,"System":1},"constants":{"0":2},"javaDoc":"Close a window If this is the last open window just quit","comments":" Close a window.  If this is the last open window, just quit. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Frame","int","int"],"returnType":"ScribblePanel","methodCalls":{"add":1,"addActionListener":1,"setActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MenuItem":1,"String[]":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":42,"StringLiteralExpr":8,"UnaryExpr":1,"AssignExpr":4,"ArrayInitializerExpr":2,"FieldAccessExpr":6,"ArrayCreationExpr":2,"ThisExpr":7,"MethodCallExpr":6},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"/** This constructor requires a Frame and a desired size */\npublic ScribblePanel(Frame frame, int width, int height) {\n    this.frame = frame;\n    this.width = width;\n    this.height = height;\n    // We handle scribbling with low-level events, so we must specify\n    // which events we are interested in.\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK);\n    this.enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);\n    // Create the popup menu.\n    String[] labels = new String[] { \"Clear\", \"Cut\", \"Copy\", \"Paste\" };\n    String[] commands = new String[] { \"clear\", \"cut\", \"copy\", \"paste\" };\n    // Create the menu\n    popup = new PopupMenu();\n    for (int i = 0; i < labels.length; i++) {\n        // Create a menu item \n        MenuItem mi = new MenuItem(labels[i]);\n        // Set its action command\n        mi.setActionCommand(commands[i]);\n        // And its action listener\n        mi.addActionListener(this);\n        // Add item to the popup menu\n        popup.add(mi);\n    }\n    // Finally, register the popup menu with the component it appears over\n    this.add(popup);\n}\n","name":"ScribblePanel","className":"ScribblePanel","variables":{"popup":2,"width":1,"i":5,"mi":3,"commands":2,"frame":1,"height":1,"labels":2},"constants":{"0":1,"\"Copy\"":1,"\"clear\"":1,"\"Paste\"":1,"\"copy\"":1,"\"Cut\"":1,"\"Clear\"":1,"\"paste\"":1,"\"cut\"":1},"javaDoc":"This constructor requires a Frame and a desired size","comments":"We handle scribbling with low-level events so we must specify which events we are interested in Create the popup menu Create the menu Create a menu item Set its action command And its action listener Add item to the popup menu Finally register the popup menu with the component it appears over  This constructor requires a Frame and a desired size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n     * Specifies how big the component would like to be.  It always returns the\n     * preferred size passed to the ScribblePanel() constructor \n     **/\npublic Dimension getPreferredSize() {\n    return new Dimension(width, height);\n}\n","name":"getPreferredSize","className":"ScribblePanel","variables":{"width":1,"height":1},"constants":{},"javaDoc":"Specifies how big the component would like to be It always returns the preferred size passed to the ScribblePanel() constructor","comments":" \n     * Specifies how big the component would like to be.  It always returns the\n     * preferred size passed to the ScribblePanel() constructor \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"cut":1,"equals":4,"clear":1,"getActionCommand":1,"copy":1,"paste":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":23,"StringLiteralExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":4,"ExpressionStmt":5},"text":"/** This is the ActionListener method invoked by the popup menu items */\npublic void actionPerformed(ActionEvent event) {\n    String command = event.getActionCommand();\n    if (command.equals(\"clear\"))\n        clear();\n    else if (command.equals(\"cut\"))\n        cut();\n    else if (command.equals(\"copy\"))\n        copy();\n    else if (command.equals(\"paste\"))\n        paste();\n}\n","name":"actionPerformed","className":"ScribblePanel","variables":{"event":1,"command":5},"constants":{"\"clear\"":1,"\"copy\"":1,"\"paste\"":1,"\"cut\"":1},"javaDoc":"This is the ActionListener method invoked by the popup menu items","comments":" This is the ActionListener method invoked by the popup menu items ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"CastExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** Draw all the saved lines of the scribble */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) {\n        Line l = (Line) lines.elementAt(i);\n        g.drawLine(l.x1, l.y1, l.x2, l.y2);\n    }\n}\n","name":"paint","className":"ScribblePanel","variables":{"g":1,"i":3,"lines":2,"l":1},"constants":{"0":1},"javaDoc":"Draw all the saved lines of the scribble","comments":" Draw all the saved lines of the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":2,"getY":2,"show":1,"getID":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":29,"CastExpr":2,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":4},"text":"/** \n     * This is the low-level event-handling method called on mouse events \n     * that do not involve mouse motion.  It handles posting the popup menu\n     * and also initiates scribbles\n     **/\npublic void processMouseEvent(MouseEvent e) {\n    if (// If popup trigger,\n    e.isPopupTrigger())\n        // Pop up the menu\n        popup.show(this, e.getX(), e.getY());\n    else if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // Otherwise\n        // Save position\n        last_x = (short) e.getX();\n        // Save position\n        last_y = (short) e.getY();\n    } else\n        // Pass other event types on\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"ScribblePanel","variables":{"popup":1,"e":6,"last_x":1,"last_y":1},"constants":{},"javaDoc":"This is the low-level event-handling method called on mouse events that do not involve mouse motion It handles posting the popup menu and also initiates scribbles","comments":"If popup trigger Pop up the menu Otherwise Save position Save position Pass other event types on  \n     * This is the low-level event-handling method called on mouse events \n     * that do not involve mouse motion.  It handles posting the popup menu\n     * and also initiates scribbles\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":3,"getY":3,"getID":1,"getGraphics":1,"drawLine":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":41,"CastExpr":4,"FieldAccessExpr":1,"MethodCallExpr":11,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/**\n     * This method is called for mouse motion events.  It adds a line to the\n     * scribble, both on the screen and in the saved representation\n     **/\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        // Object to draw with\n        Graphics g = getGraphics();\n        // Draw this line\n        g.drawLine(last_x, last_y, e.getX(), e.getY());\n        lines.addElement(new // And save it, too.\n        Line(// And save it, too.\n        last_x, // And save it, too.\n        last_y, (short) e.getX(), (short) e.getY()));\n        // Remember current mouse coordinates\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        // Important!\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"ScribblePanel","variables":{"e":7,"g":2,"last_x":2,"last_y":2,"lines":1},"constants":{},"javaDoc":"This method is called for mouse motion events It adds a line to the scribble both on the screen and in the saved representation","comments":"Object to draw with Draw this line And save it too And save it too And save it too Remember current mouse coordinates Important! \n     * This method is called for mouse motion events.  It adds a line to the\n     * scribble, both on the screen and in the saved representation\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"repaint":1,"removeAllElements":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Clear the scribble.  Invoked by popup menu */\nvoid clear() {\n    // Throw out the saved scribble\n    lines.removeAllElements();\n    // And redraw everything.\n    repaint();\n}\n","name":"clear","className":"ScribblePanel","variables":{"lines":1},"constants":{},"javaDoc":"Clear the scribble Invoked by popup menu","comments":"Throw out the saved scribble And redraw everything  Clear the scribble.  Invoked by popup menu ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"clone":1,"setContents":1,"getSystemClipboard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"SimpleSelection":1,"Clipboard":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":13,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"/** \n     * Copy the current scribble and store it in a SimpleSelection object\n     * (defined below).  Then put that object on the clipboard for pasting.\n     **/\npublic void copy() {\n    // Get system clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Copy and save the scribble in a Transferable object\n    SimpleSelection s = new SimpleSelection(lines.clone(), dataFlavor);\n    // Put that object on the clipboard\n    c.setContents(s, s);\n}\n","name":"copy","className":"ScribblePanel","variables":{"c":2,"s":1,"lines":1,"dataFlavor":1},"constants":{},"javaDoc":"Copy the current scribble and store it in a SimpleSelection object (defined below) Then put that object on the clipboard for pasting","comments":"Get system clipboard Copy and save the scribble in a Transferable object Put that object on the clipboard  \n     * Copy the current scribble and store it in a SimpleSelection object\n     * (defined below).  Then put that object on the clipboard for pasting.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"clear":1,"copy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Cut is just like a copy, except we erase the scribble afterwards */\npublic void cut() {\n    copy();\n    clear();\n}\n","name":"cut","className":"ScribblePanel","variables":{},"constants":{},"javaDoc":"Cut is just like a copy except we erase the scribble afterwards","comments":" Cut is just like a copy, except we erase the scribble afterwards ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"beep":3,"size":1,"elementAt":1,"getContents":1,"addElement":1,"getTransferData":1,"repaint":1,"getSystemClipboard":1},"annotations":[],"exceptions":["UnsupportedFlavorException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Transferable":1,"Clipboard":1,"Vector":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":2,"NameExpr":38,"CastExpr":1,"UnaryExpr":1,"ThisExpr":5,"MethodCallExpr":14},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"/** \n     * Ask for the Transferable contents of the system clipboard.\n     * Then ask that Transferable object for the scribble data it represents.  \n     * If either step fails, beep!\n     **/\npublic void paste() {\n    // Get clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Get its contents\n    Transferable t = c.getContents(this);\n    if (t == null) {\n        // If there is nothing to paste, beep\n        this.getToolkit().beep();\n        return;\n    }\n    try {\n        // Ask for clipboard contents to be converted to our data flavor.\n        // This will throw an exception if our flavor is not supported.\n        Vector newlines = (Vector) t.getTransferData(dataFlavor);\n        // Add all those pasted lines to our scribble.\n        for (int i = 0; i < newlines.size(); i++) lines.addElement(newlines.elementAt(i));\n        // And redraw the whole thing\n        repaint();\n    } catch (UnsupportedFlavorException e) {\n        this.getToolkit().beep();\n    } catch (Exception e) {\n        this.getToolkit().beep();\n    }\n}\n                                     // If clipboard has some other type of data\n\n                                     // Or if anything else goes wrong...\n\n","name":"paste","className":"ScribblePanel","variables":{"c":2,"t":3,"newlines":3,"e":2,"i":3,"lines":1},"constants":{"0":1,"null":1},"javaDoc":"Ask for the Transferable contents of the system clipboard Then ask that Transferable object for the scribble data it represents If either step fails beep!","comments":"Get clipboard Get its contents If there is nothing to paste beep Ask for clipboard contents to be converted to our data flavor This will throw an exception if our flavor is not supported Add all those pasted lines to our scribble And redraw the whole thing If clipboard has some other type of data Or if anything else goes wrong  \n     * Ask for the Transferable contents of the system clipboard.\n     * Then ask that Transferable object for the scribble data it represents.  \n     * If either step fails, beep!\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","DataFlavor"],"returnType":"SimpleSelection","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** The constructor.  Just initialize some fields */\npublic SimpleSelection(Object selection, DataFlavor flavor) {\n    // Specify data\n    this.selection = selection;\n    // Specify flavor\n    this.flavor = flavor;\n}\n","name":"SimpleSelection","className":"SimpleSelection","variables":{"flavor":1,"selection":1},"constants":{},"javaDoc":"The constructor Just initialize some fields","comments":"Specify data Specify flavor  The constructor.  Just initialize some fields ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"DataFlavor[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayInitializerExpr":1,"NameExpr":1,"ArrayCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the list of supported flavors.  Just one in this case */\npublic DataFlavor[] getTransferDataFlavors() {\n    return new DataFlavor[] { flavor };\n}\n","name":"getTransferDataFlavors","className":"SimpleSelection","variables":{"flavor":1},"constants":{},"javaDoc":"Return the list of supported flavors Just one in this case","comments":" Return the list of supported flavors.  Just one in this case ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DataFlavor"],"returnType":"boolean","methodCalls":{"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Check whether we support a specified flavor */\npublic boolean isDataFlavorSupported(DataFlavor f) {\n    return f.equals(flavor);\n}\n","name":"isDataFlavorSupported","className":"SimpleSelection","variables":{"f":1},"constants":{},"javaDoc":"Check whether we support a specified flavor","comments":" Check whether we support a specified flavor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DataFlavor"],"returnType":"Object","methodCalls":{"equals":1},"annotations":[],"exceptions":["UnsupportedFlavorException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ThrowStmt":1},"text":"/** If the flavor is right, transfer the data (i.e. return it) */\npublic Object getTransferData(DataFlavor f) throws UnsupportedFlavorException {\n    if (f.equals(flavor))\n        return selection;\n    else\n        throw new UnsupportedFlavorException(f);\n}\n","name":"getTransferData","className":"SimpleSelection","variables":{"selection":1,"f":2},"constants":{},"javaDoc":"If the flavor is right transfer the data (i e return it)","comments":" If the flavor is right, transfer the data (i.e. return it) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Clipboard","Transferable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n       * This is the ClipboardOwner method.  Called when the data is no\n       * longer on the clipboard.  In this case, we don't need to do much. \n       **/\npublic void lostOwnership(Clipboard c, Transferable t) {\n    selection = null;\n}\n","name":"lostOwnership","className":"SimpleSelection","variables":{"selection":1},"constants":{"null":1},"javaDoc":"This is the ClipboardOwner method Called when the data is no longer on the clipboard In this case we don't need to do much","comments":" \n       * This is the ClipboardOwner method.  Called when the data is no\n       * longer on the clipboard.  In this case, we don't need to do much. \n       *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["short","short","short","short"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Line(short x1, short y1, short x2, short y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Line","className":"Line","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getDateTimeInstance":1,"format":6,"getInstance":1,"getCurrencyInstance":1,"getPercentInstance":1,"System.out.print":5,"getDateInstance":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"DateFormat":2,"int":1,"NumberFormat":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":8,"BinaryExpr":11,"NameExpr":121,"StringLiteralExpr":9,"FieldAccessExpr":20,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":19},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":14},"text":"public void print() {\n    // Obtain NumberFormat and DateFormat objects to format our data.\n    NumberFormat number = NumberFormat.getInstance();\n    NumberFormat price = NumberFormat.getCurrencyInstance();\n    NumberFormat percent = NumberFormat.getPercentInstance();\n    DateFormat shortdate = DateFormat.getDateInstance(DateFormat.SHORT);\n    DateFormat fulldate = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);\n    // Print some introductory data.\n    System.out.println(\"Portfolio value at \" + fulldate.format(lastQuoteTime) + \":\");\n    System.out.println(\"Symbol\\tShares\\tBought On\\tAt\\t\" + \"Quote\\tChange\");\n    // Then display the table using the format() methods of the Format objects.\n    for (int i = 0; i < positions.length; i++) {\n        System.out.print(positions[i].name + \"\\t\");\n        System.out.print(number.format(positions[i].shares) + \"\\t\");\n        System.out.print(shortdate.format(positions[i].purchased) + \"\\t\");\n        System.out.print(price.format(positions[i].bought) + \"\\t\");\n        System.out.print(price.format(positions[i].current) + \"\\t\");\n        double change = (positions[i].current - positions[i].bought) / positions[i].bought;\n        System.out.println(percent.format(change));\n    }\n}\n","name":"print","className":"Portfolio","variables":{"fulldate":2,"number":2,"price":3,"DateFormat":2,"change":1,"i":11,"positions":8,"percent":2,"NumberFormat":3,"shortdate":2},"constants":{"0":1,"\"Portfolio value at \"":1,"\"Symbol\\tShares\\tBought On\\tAt\\t\"":1,"\"Quote\\tChange\"":1,"\"\\t\"":5,"\":\"":1},"javaDoc":"","comments":"Obtain NumberFormat and DateFormat objects to format our data Print some introductory data Then display the table using the format() methods of the Format objects ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","Date","double","double"],"returnType":"EquityPosition","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"EquityPosition(String n, int s, Date when, double then, double now) {\n    name = n;\n    shares = s;\n    purchased = when;\n    bought = then;\n    current = now;\n}\n","name":"EquityPosition","className":"EquityPosition","variables":{"shares":1,"current":1,"s":1,"purchased":1,"bought":1,"now":1,"name":1,"then":1,"when":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setSize":1,"show":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"EventTester2":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** The main method: create an EventTester frame, and pop it up */\npublic static void main(String[] args) {\n    EventTester2 et = new EventTester2();\n    et.setSize(500, 400);\n    et.show();\n}\n","name":"main","className":"EventTester2","variables":{"et":3},"constants":{"400":1,"500":1},"javaDoc":"The main method: create an EventTester frame and pop it up","comments":" The main method: create an EventTester frame, and pop it up ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"EventTester2","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"StringLiteralExpr":1,"NameExpr":20,"FieldAccessExpr":6,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** The constructor: register the event types we are interested in */\npublic EventTester2() {\n    super(\"Event Tester\");\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK | AWTEvent.COMPONENT_EVENT_MASK | AWTEvent.WINDOW_EVENT_MASK);\n}\n","name":"EventTester2","className":"EventTester2","variables":{},"constants":{"\"Event Tester\"":1},"javaDoc":"The constructor: register the event types we are interested in","comments":" The constructor: register the event types we are interested in ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"mousemods":1,"getClickCount":1,"getID":1,"showLine":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":9,"NameExpr":41,"StringLiteralExpr":11,"FieldAccessExpr":5,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":7,"AssignExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":5,"SwitchEntryStmt":5,"ExpressionStmt":7},"text":"/**\n   * Display mouse events that don't involve mouse motion.\n   * The mousemods() method prints modifiers, and is defined below.\n   * The other methods return additional information about the mouse event.\n   * showLine() displays a line of text in the window.  It is defined\n   * at the end of this class, along with the paint() method.\n   */\npublic void processMouseEvent(MouseEvent e) {\n    String type = null;\n    switch(e.getID()) {\n        case MouseEvent.MOUSE_PRESSED:\n            type = \"MOUSE_PRESSED\";\n            break;\n        case MouseEvent.MOUSE_RELEASED:\n            type = \"MOUSE_RELEASED\";\n            break;\n        case MouseEvent.MOUSE_CLICKED:\n            type = \"MOUSE_CLICKED\";\n            break;\n        case MouseEvent.MOUSE_ENTERED:\n            type = \"MOUSE_ENTERED\";\n            break;\n        case MouseEvent.MOUSE_EXITED:\n            type = \"MOUSE_EXITED\";\n            break;\n    }\n    showLine(mousemods(e) + type + \": [\" + e.getX() + \",\" + e.getY() + \"] \" + \"num clicks = \" + e.getClickCount() + (e.isPopupTrigger() ? \"; is popup trigger\" : \"\"));\n}\n","name":"processMouseEvent","className":"EventTester2","variables":{"e":5,"type":7},"constants":{"\"\"":1,"\"; is popup trigger\"":1,"\"MOUSE_PRESSED\"":1,"null":1,"\"MOUSE_RELEASED\"":1,"\": [\"":1,"\"num clicks = \"":1,"\",\"":1,"\"MOUSE_ENTERED\"":1,"\"MOUSE_EXITED\"":1,"\"] \"":1,"\"MOUSE_CLICKED\"":1},"javaDoc":"Display mouse events that don't involve mouse motion The mousemods() method prints modifiers and is defined below The other methods return additional information about the mouse event showLine() displays a line of text in the window It is defined at the end of this class along with the paint() method","comments":"\n   * Display mouse events that don't involve mouse motion.\n   * The mousemods() method prints modifiers, and is defined below.\n   * The other methods return additional information about the mouse event.\n   * showLine() displays a line of text in the window.  It is defined\n   * at the end of this class, along with the paint() method.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"mousemods":1,"getClickCount":1,"getID":1,"showLine":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":9,"NameExpr":29,"StringLiteralExpr":8,"FieldAccessExpr":2,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":7,"AssignExpr":2},"statements":{"SwitchStmt":1,"BreakStmt":2,"SwitchEntryStmt":2,"ExpressionStmt":4},"text":"/**\n   * Display mouse moved and dragged mouse event.  Note that MouseEvent\n   * is the only event type that has two methods, two EventListener interfaces\n   * and two adapter classes to handle two distinct categories of events.\n   * Also, as seen in init(), mouse motion events must be requested\n   * separately from other mouse event types.\n   */\npublic void processMouseMotionEvent(MouseEvent e) {\n    String type = null;\n    switch(e.getID()) {\n        case MouseEvent.MOUSE_MOVED:\n            type = \"MOUSE_MOVED\";\n            break;\n        case MouseEvent.MOUSE_DRAGGED:\n            type = \"MOUSE_DRAGGED\";\n            break;\n    }\n    showLine(mousemods(e) + type + \": [\" + e.getX() + \",\" + e.getY() + \"] \" + \"num clicks = \" + e.getClickCount() + (e.isPopupTrigger() ? \"; is popup trigger\" : \"\"));\n}\n","name":"processMouseMotionEvent","className":"EventTester2","variables":{"e":5,"type":4},"constants":{"\"\"":1,"\"; is popup trigger\"":1,"\"MOUSE_DRAGGED\"":1,"null":1,"\": [\"":1,"\"num clicks = \"":1,"\",\"":1,"\"MOUSE_MOVED\"":1,"\"] \"":1},"javaDoc":"Display mouse moved and dragged mouse event Note that MouseEvent is the only event type that has two methods two EventListener interfaces and two adapter classes to handle two distinct categories of events Also as seen in init() mouse motion events must be requested separately from other mouse event types","comments":"\n   * Display mouse moved and dragged mouse event.  Note that MouseEvent\n   * is the only event type that has two methods, two EventListener interfaces\n   * and two adapter classes to handle two distinct categories of events.\n   * Also, as seen in init(), mouse motion events must be requested\n   * separately from other mouse event types.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"String","methodCalls":{"isControlDown":1,"getModifiers":1,"isShiftDown":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":27,"StringLiteralExpr":6,"FieldAccessExpr":3,"EnclosedExpr":3,"MethodCallExpr":3,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** Return a string representation of the modifiers for a MouseEvent.\n   *  Note that the methods called here are inherited from InputEvent.\n   */\nprotected String mousemods(MouseEvent e) {\n    int mods = e.getModifiers();\n    String s = \"\";\n    if (e.isShiftDown())\n        s += \"Shift \";\n    if (e.isControlDown())\n        s += \"Ctrl \";\n    if ((mods & InputEvent.BUTTON1_MASK) != 0)\n        s += \"Button 1 \";\n    if ((mods & InputEvent.BUTTON2_MASK) != 0)\n        s += \"Button 2 \";\n    if ((mods & InputEvent.BUTTON3_MASK) != 0)\n        s += \"Button 3 \";\n    return s;\n}\n","name":"mousemods","className":"EventTester2","variables":{"mods":4,"s":7,"e":3},"constants":{"\"\"":1,"0":3,"\"Button 2 \"":1,"\"Button 3 \"":1,"\"Shift \"":1,"\"Ctrl \"":1,"\"Button 1 \"":1},"javaDoc":"Return a string representation of the modifiers for a MouseEvent Note that the methods called here are inherited from InputEvent","comments":" Return a string representation of the modifiers for a MouseEvent.\n   *  Note that the methods called here are inherited from InputEvent.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"isActionKey":1,"getKeyModifiersText":1,"getKeyText":1,"getKeyChar":2,"getID":2,"getModifiers":1,"showLine":1,"getKeyCode":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":15,"NameExpr":57,"StringLiteralExpr":15,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":11,"AssignExpr":9},"statements":{"SwitchStmt":1,"IfStmt":2,"BreakStmt":3,"SwitchEntryStmt":4,"ExpressionStmt":11},"text":"/**\n   * Display keyboard events.\n   * Note that there are three distinct types of key events, and that\n   * key events are reported by key code and/or Unicode character.\n   * KEY_PRESSED and KEY_RELEASED events are generated for all key strokes.\n   * KEY_TYPED events are only generated when a key stroke produces a\n   * Unicode character; these events do not report a key code.\n   * If isActionKey() returns true, then the key event reports only\n   * a key code, because the key that was pressed or released (such as a\n   * function key) has no corresponding Unicode character.\n   * Key codes can be interpreted by using the many VK_ constants defined\n   * by the KeyEvent class, or they can be converted to strings using\n   * the static getKeyText() method as we do here.\n   */\npublic void processKeyEvent(KeyEvent e) {\n    String eventtype, modifiers, code, character;\n    switch(e.getID()) {\n        case KeyEvent.KEY_PRESSED:\n            eventtype = \"KEY_PRESSED\";\n            break;\n        case KeyEvent.KEY_RELEASED:\n            eventtype = \"KEY_RELEASED\";\n            break;\n        case KeyEvent.KEY_TYPED:\n            eventtype = \"KEY_TYPED\";\n            break;\n        default:\n            eventtype = \"UNKNOWN\";\n    }\n    // Convert the list of modifier keys to a string\n    modifiers = KeyEvent.getKeyModifiersText(e.getModifiers());\n    // Get string and numeric versions of the key code, if any.\n    if (e.getID() == KeyEvent.KEY_TYPED)\n        code = \"\";\n    else\n        code = \"Code=\" + KeyEvent.getKeyText(e.getKeyCode()) + \" (\" + e.getKeyCode() + \")\";\n    // Get string and numeric versions of the Unicode character, if any.\n    if (e.isActionKey())\n        character = \"\";\n    else\n        character = \"Character=\" + e.getKeyChar() + \" (Unicode=\" + ((int) e.getKeyChar()) + \")\";\n    // Display it all.\n    showLine(eventtype + \": \" + modifiers + \" \" + code + \" \" + character);\n}\n","name":"processKeyEvent","className":"EventTester2","variables":{"KeyEvent":2,"character":4,"code":4,"e":8,"eventtype":6,"modifiers":3},"constants":{"\"\"":2,"\" (Unicode=\"":1,"\" \"":2,"\"KEY_PRESSED\"":1,"\"UNKNOWN\"":1,"\"Code=\"":1,"\" (\"":1,"\"Character=\"":1,"\"KEY_RELEASED\"":1,"\": \"":1,"\"KEY_TYPED\"":1,"\")\"":2},"javaDoc":"Display keyboard events Note that there are three distinct types of key events and that key events are reported by key code and/or Unicode character KEY_PRESSED and KEY_RELEASED events are generated for all key strokes KEY_TYPED events are only generated when a key stroke produces a Unicode character; these events do not report a key code If isActionKey() returns true then the key event reports only a key code because the key that was pressed or released (such as a function key) has no corresponding Unicode character Key codes can be interpreted by using the many VK_ constants defined by the KeyEvent class or they can be converted to strings using the static getKeyText() method as we do here","comments":"Convert the list of modifier keys to a string Get string and numeric versions of the key code if any Get string and numeric versions of the Unicode character if any Display it all \n   * Display keyboard events.\n   * Note that there are three distinct types of key events, and that\n   * key events are reported by key code and/or Unicode character.\n   * KEY_PRESSED and KEY_RELEASED events are generated for all key strokes.\n   * KEY_TYPED events are only generated when a key stroke produces a\n   * Unicode character; these events do not report a key code.\n   * If isActionKey() returns true, then the key event reports only\n   * a key code, because the key that was pressed or released (such as a\n   * function key) has no corresponding Unicode character.\n   * Key codes can be interpreted by using the many VK_ constants defined\n   * by the KeyEvent class, or they can be converted to strings using\n   * the static getKeyText() method as we do here.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["FocusEvent"],"returnType":"void","methodCalls":{"getID":1,"isTemporary":2,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":6,"FieldAccessExpr":1,"EnclosedExpr":2,"ConditionalExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Display keyboard focus events.  Focus can be permanently\n   *  gained or lost, or temporarily transferred to or from a component. */\npublic void processFocusEvent(FocusEvent e) {\n    if (e.getID() == FocusEvent.FOCUS_GAINED)\n        showLine(\"FOCUS_GAINED\" + (e.isTemporary() ? \" (temporary)\" : \"\"));\n    else\n        showLine(\"FOCUS_LOST\" + (e.isTemporary() ? \" (temporary)\" : \"\"));\n}\n","name":"processFocusEvent","className":"EventTester2","variables":{"e":3},"constants":{"\"\"":2,"\" (temporary)\"":2,"\"FOCUS_LOST\"":1,"\"FOCUS_GAINED\"":1},"javaDoc":"Display keyboard focus events Focus can be permanently gained or lost or temporarily transferred to or from a component","comments":" Display keyboard focus events.  Focus can be permanently\n   *  gained or lost, or temporarily transferred to or from a component. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComponentEvent"],"returnType":"void","methodCalls":{"getID":1,"showLine":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":23,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":4,"SwitchEntryStmt":4,"ExpressionStmt":4},"text":"/** Display Component events.  */\npublic void processComponentEvent(ComponentEvent e) {\n    switch(e.getID()) {\n        case ComponentEvent.COMPONENT_MOVED:\n            showLine(\"COMPONENT_MOVED\");\n            break;\n        case ComponentEvent.COMPONENT_RESIZED:\n            showLine(\"COMPONENT_RESIZED\");\n            break;\n        case ComponentEvent.COMPONENT_HIDDEN:\n            showLine(\"COMPONENT_HIDDEN\");\n            break;\n        case ComponentEvent.COMPONENT_SHOWN:\n            showLine(\"COMPONENT_SHOWN\");\n            break;\n    }\n}\n","name":"processComponentEvent","className":"EventTester2","variables":{"e":1},"constants":{"\"COMPONENT_RESIZED\"":1,"\"COMPONENT_SHOWN\"":1,"\"COMPONENT_MOVED\"":1,"\"COMPONENT_HIDDEN\"":1},"javaDoc":"Display Component events","comments":" Display Component events.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"sleep":1,"exit":1,"update":1,"getID":2,"showLine":9},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":58,"StringLiteralExpr":9,"FieldAccessExpr":8,"ThisExpr":1,"MethodCallExpr":15},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":7,"BlockStmt":3,"TryStmt":1,"SwitchEntryStmt":7,"EmptyStmt":1,"ExpressionStmt":12},"text":"/** Display Window events.  Note the special handling of WINDOW_CLOSING */\npublic void processWindowEvent(WindowEvent e) {\n    switch(e.getID()) {\n        case WindowEvent.WINDOW_OPENED:\n            showLine(\"WINDOW_OPENED\");\n            break;\n        case WindowEvent.WINDOW_CLOSED:\n            showLine(\"WINDOW_CLOSED\");\n            break;\n        case WindowEvent.WINDOW_CLOSING:\n            showLine(\"WINDOW_CLOSING\");\n            break;\n        case WindowEvent.WINDOW_ICONIFIED:\n            showLine(\"WINDOW_ICONIFIED\");\n            break;\n        case WindowEvent.WINDOW_DEICONIFIED:\n            showLine(\"WINDOW_DEICONIFIED\");\n            break;\n        case WindowEvent.WINDOW_ACTIVATED:\n            showLine(\"WINDOW_ACTIVATED\");\n            break;\n        case WindowEvent.WINDOW_DEACTIVATED:\n            showLine(\"WINDOW_DEACTIVATED\");\n            break;\n    }\n    // sure the user has time to read it.\n    if (e.getID() == WindowEvent.WINDOW_CLOSING) {\n        showLine(\"WINDOW_CLOSING event received.\");\n        showLine(\"Application will exit in 5 seconds\");\n        update(this.getGraphics());\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException ie) {\n            ;\n        }\n        System.exit(0);\n    }\n}\n     // If the user requested a window close, quit the program.\n\n     // But first display a message, force it to be visible, and make\n\n","name":"processWindowEvent","className":"EventTester2","variables":{"e":2,"ie":1,"System":1,"Thread":1},"constants":{"\"WINDOW_OPENED\"":1,"0":1,"\"WINDOW_ICONIFIED\"":1,"\"WINDOW_DEACTIVATED\"":1,"5000":1,"\"WINDOW_CLOSED\"":1,"\"WINDOW_CLOSING event received.\"":1,"\"WINDOW_CLOSING\"":1,"\"WINDOW_ACTIVATED\"":1,"\"WINDOW_DEICONIFIED\"":1,"\"Application will exit in 5 seconds\"":1},"javaDoc":"Display Window events Note the special handling of WINDOW_CLOSING","comments":"If the user requested a window close quit the program But first display a message force it to be visible and make sure the user has time to read it  Display Window events.  Note the special handling of WINDOW_CLOSING ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"removeElementAt":1,"addElement":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Add a new line to the list of lines, and redisplay */\nprotected void showLine(String s) {\n    if (lines.size() == 20)\n        lines.removeElementAt(0);\n    lines.addElement(s);\n    repaint();\n}\n","name":"showLine","className":"EventTester2","variables":{"lines":3},"constants":{"0":1,"20":1},"javaDoc":"Add a new line to the list of lines and redisplay","comments":" Add a new line to the list of lines, and redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":13,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/** This method repaints the text in the window */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) g.drawString((String) lines.elementAt(i), 20, i * 16 + 50);\n}\n","name":"paint","className":"EventTester2","variables":{"g":1,"i":4,"lines":2},"constants":{"0":1,"16":1,"50":1,"20":1},"javaDoc":"This method repaints the text in the window","comments":" This method repaints the text in the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":1},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Compute and return x!, the factorial of x */\npublic static int factorial(int x) {\n    int fact = 1;\n    for (// loop\n    int i = 2; // loop\n    i <= x; // loop\n    i++) // shorthand for: fact = fact * i;\n    fact *= i;\n    return fact;\n}\n","name":"factorial","className":"Factorial","variables":{"fact":3,"x":1,"i":4},"constants":{"1":1,"2":1},"javaDoc":"Compute and return x! the factorial of x","comments":"loop loop loop shorthand for: fact = fact i;  Compute and return x!, the factorial of x ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    last_x = e.getX();\n    last_y = e.getY();\n}\n","name":"mousePressed","className":"","variables":{"e":2,"last_x":1,"last_y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"setColor":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":25,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public void mouseDragged(MouseEvent e) {\n    Graphics g = getGraphics();\n    int x = e.getX(), y = e.getY();\n    g.setColor(Color.black);\n    g.drawLine(last_x, last_y, x, y);\n    last_x = x;\n    last_y = y;\n}\n","name":"mouseDragged","className":"","variables":{"e":2,"g":3,"last_x":1,"x":2,"last_y":1,"y":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSize":2,"setColor":1,"getGraphics":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    // clear the scribble\n    Graphics g = getGraphics();\n    g.setColor(getBackground());\n    g.fillRect(0, 0, getSize().width, getSize().height);\n}\n","name":"actionPerformed","className":"","variables":{"g":3},"constants":{"0":2},"javaDoc":"","comments":"clear the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getX":2,"getSize":2,"getY":2,"setColor":2,"addActionListener":1,"getGraphics":2,"drawLine":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Graphics":2,"Button":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"NameExpr":67,"StringLiteralExpr":1,"FieldAccessExpr":3,"ThisExpr":3,"MethodCallExpr":17,"AssignExpr":4},"statements":{"BlockStmt":3,"ExpressionStmt":16},"text":"public void init() {\n    // Define, instantiate and register a MouseListener object\n    this.addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            last_x = e.getX();\n            last_y = e.getY();\n        }\n    });\n    // Define, instantiate and register a MouseMotionListener object\n    this.addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            Graphics g = getGraphics();\n            int x = e.getX(), y = e.getY();\n            g.setColor(Color.black);\n            g.drawLine(last_x, last_y, x, y);\n            last_x = x;\n            last_y = y;\n        }\n    });\n    // Create a clear button\n    Button b = new Button(\"Clear\");\n    // Define, instantiate, and register a listener to handle button presses\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // clear the scribble\n            Graphics g = getGraphics();\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getSize().width, getSize().height);\n        }\n    });\n    // And add the button to the applet\n    this.add(b);\n}\n","name":"init","className":"Scribble4","variables":{"actionPerformed":1,"b":2,"mouseDragged":1,"e":7,"last_x":2,"g":6,"last_y":2,"x":2,"y":2,"mousePressed":1},"constants":{"0":2,"\"Clear\"":1},"javaDoc":"","comments":"Define instantiate and register a MouseListener object Define instantiate and register a MouseMotionListener object Create a clear button Define instantiate and register a listener to handle button presses clear the scribble And add the button to the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame","String","String"],"returnType":"InfoDialog","methodCalls":{"add":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":25,"StringLiteralExpr":3,"FieldAccessExpr":1,"ThisExpr":4,"MethodCallExpr":6,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":9},"text":"public InfoDialog(Frame parent, String title, String message) {\n    // Create a non-modal dialog with the specified title and parent\n    super(parent, title, false);\n    // Create and use a BorderLayout manager with 15 pixel spacing\n    this.setLayout(new BorderLayout(15, 15));\n    // Create the message component and add it to the window\n    // MultiLineLabel is a custom component defined later in this chapter\n    label = new MultiLineLabel(message, 20, 20);\n    this.add(\"Center\", label);\n    // Create an Okay button in a Panel; add the Panel to the window\n    // Use a FlowLayout to center the button in the panel and give it margins.\n    // Note the nested use of containers and layout managers.\n    button = new Button(\"Okay\");\n    Panel p = new Panel();\n    p.setLayout(new FlowLayout(FlowLayout.CENTER, 15, 15));\n    p.add(button);\n    this.add(\"South\", p);\n    // Set the dialog size to the preferred size of its components\n    this.pack();\n}\n","name":"InfoDialog","className":"InfoDialog","variables":{"button":1,"p":3,"parent":1,"label":1,"title":1,"message":1},"constants":{"15":4,"false":1,"\"Center\"":1,"\"Okay\"":1,"20":2,"\"South\"":1},"javaDoc":"","comments":"Create the message component and add it to the window Create an Okay button in a Panel; add the Panel to the window Use a FlowLayout to center the button in the panel and give it margins Create a non-modal dialog with the specified title and parent Create and use a BorderLayout manager with 15 pixel spacing MultiLineLabel is a custom component defined later in this chapter Note the nested use of containers and layout managers Set the dialog size to the preferred size of its components ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"// Pop down the window when the button is clicked.  Note 1.0 event model\npublic boolean action(Event e, Object arg) {\n    if (e.target == button) {\n        // Pop the dialog down\n        this.hide();\n        // Destroy it.  Cannot be shown again after disposed\n        this.dispose();\n        return true;\n    } else\n        return false;\n}\n","name":"action","className":"InfoDialog","variables":{"button":1},"constants":{"true":1,"false":1},"javaDoc":"","comments":"Pop the dialog down Destroy it Cannot be shown again after disposed  Pop down the window when the button is clicked.  Note 1.0 event model","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":2,"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Frame":1,"InfoDialog":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"/**\n   * A main method that demonstrates how to use this class, and allows testing\n   */\npublic static void main(String[] args) {\n    // Create, size, and show a frame because dialogs require a frame parent.\n    Frame f = new Frame(\"InfoDialog Test\");\n    // Use setSize() in Java 1.1\n    f.resize(100, 100);\n    f.show();\n    // Create an instance of InfoDialog, with title and message specified\n    InfoDialog d = new InfoDialog(f, \"InfoDialog Test\", \"This demo was written by David Flanagan\\n\" + \"Copyright (c) 1997 O'Reilly & Associates\");\n    // And pop it up.  It will pop itself down automatically.\n    d.show();\n}\n","name":"main","className":"InfoDialog","variables":{"d":2,"f":4},"constants":{"100":2,"\"InfoDialog Test\"":2,"\"This demo was written by David Flanagan\\n\"":1,"\"Copyright (c) 1997 O'Reilly & Associates\"":1},"javaDoc":"A main method that demonstrates how to use this class and allows testing","comments":"Create size and show a frame because dialogs require a frame parent Use setSize() in Java 1 1 Create an instance of InfoDialog with title and message specified And pop it up It will pop itself down automatically \n   * A main method that demonstrates how to use this class, and allows testing\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the name of this MUD */\npublic String getMudName() throws RemoteException;\n","name":"getMudName","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Return the name of this MUD","comments":" Return the name of this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the main entrance place for this MUD */\npublic RemoteMudPlace getEntrance() throws RemoteException;\n","name":"getEntrance","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Return the main entrance place for this MUD","comments":" Return the main entrance place for this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["NoSuchPlace","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Look up and return some other named place in this MUD */\npublic RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace;\n","name":"getNamedPlace","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Look up and return some other named place in this MUD","comments":" Look up and return some other named place in this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BadPassword","IOException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Dump the state of the server to a file so that it can be restored later\n     * All places, and their exits and things are dumped, but the \"people\"\n     * in them are not.\n     **/\npublic void dump(String password, String filename) throws RemoteException, BadPassword, IOException;\n","name":"dump","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Dump the state of the server to a file so that it can be restored later All places and their exits and things are dumped but the \"people\" in them are not","comments":" \n     * Dump the state of the server to a file so that it can be restored later\n     * All places, and their exits and things are dumped, but the \"people\"\n     * in them are not.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return a full description of the person */\npublic String getDescription() throws RemoteException;\n","name":"getDescription","className":"RemoteMudPerson","variables":{},"constants":{},"javaDoc":"Return a full description of the person","comments":" Return a full description of the person ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Deliver a message to the person */\npublic void tell(String message) throws RemoteException;\n","name":"tell","className":"RemoteMudPerson","variables":{},"constants":{},"javaDoc":"Deliver a message to the person","comments":" Deliver a message to the person ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Look up the name of this place */\npublic String getPlaceName() throws RemoteException;\n","name":"getPlaceName","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Look up the name of this place","comments":" Look up the name of this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get a description of this place */\npublic String getDescription() throws RemoteException;\n","name":"getDescription","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get a description of this place","comments":" Get a description of this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Find out the names of all people here */\npublic Vector getNames() throws RemoteException;\n","name":"getNames","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Find out the names of all people here","comments":" Find out the names of all people here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the names of all things here */\npublic Vector getThings() throws RemoteException;\n","name":"getThings","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the names of all things here","comments":" Get the names of all things here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the names of all ways out of here */\npublic Vector getExits() throws RemoteException;\n","name":"getExits","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the names of all ways out of here","comments":" Get the names of all ways out of here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPerson","methodCalls":{},"annotations":[],"exceptions":["NoSuchPerson","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the RemoteMudPerson object for the named person. */\npublic RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson;\n","name":"getPerson","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the RemoteMudPerson object for the named person","comments":" Get the RemoteMudPerson object for the named person. ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["NoSuchThing","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get more details about a named thing */\npublic String examineThing(String name) throws RemoteException, NoSuchThing;\n","name":"examineThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get more details about a named thing","comments":" Get more details about a named thing ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["LinkFailed","NotThere","NoSuchExit","AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Use the named exit */\npublic RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed;\n","name":"go","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Use the named exit","comments":" Use the named exit ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Send a message of the form \"David: hi everyone\" */\npublic void speak(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere;\n","name":"speak","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Send a message of the form \"David: hi everyone\"","comments":" Send a message of the form \"David: hi everyone\" ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Send a message of the form \"David laughs loudly\" */\npublic void act(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere;\n","name":"act","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Send a message of the form \"David laughs loudly\"","comments":" Send a message of the form \"David laughs loudly\" ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Add a new thing in this place */\npublic void createThing(RemoteMudPerson who, String name, String description) throws RemoteException, NotThere, AlreadyThere;\n","name":"createThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Add a new thing in this place","comments":" Add a new thing in this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchThing","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Remove a thing from this place */\npublic void destroyThing(RemoteMudPerson who, String thing) throws RemoteException, NotThere, NoSuchThing;\n","name":"destroyThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove a thing from this place","comments":" Remove a thing from this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","PlaceAlreadyExists","ExitAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Create a new place, bi-directionally linked to this one by an exit */\npublic void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists;\n","name":"createPlace","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Create a new place bi-directionally linked to this one by an exit","comments":" Create a new place, bi-directionally linked to this one by an exit ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchPlace","ExitAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Link this place (unidirectionally) to some existing place.  The\n     * destination place may even be on another server.\n     **/\npublic void linkTo(RemoteMudPerson who, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace;\n","name":"linkTo","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Link this place (unidirectionally) to some existing place The destination place may even be on another server","comments":" \n     * Link this place (unidirectionally) to some existing place.  The\n     * destination place may even be on another server.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchExit","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Remove an existing exit */\npublic void close(RemoteMudPerson who, String exit) throws RemoteException, NotThere, NoSuchExit;\n","name":"close","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove an existing exit","comments":" Remove an existing exit ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Remove this person from this place, leaving them nowhere.\n     * Send the specified message to everyone left in the place.\n     **/\npublic void exit(RemoteMudPerson who, String message) throws RemoteException, NotThere;\n","name":"exit","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove this person from this place leaving them nowhere Send the specified message to everyone left in the place","comments":" \n     * Remove this person from this place, leaving them nowhere.\n     * Send the specified message to everyone left in the place.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Put a person in a place, assigning their name, and sending the \n     * specified message to everyone else in the place.  The client should\n     * not make this method available to the user.  They should use go()\n     * instead.\n     **/\npublic void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere;\n","name":"enter","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Put a person in a place assigning their name and sending the specified message to everyone else in the place The client should not make this method available to the user They should use go() instead","comments":"\n     * Put a person in a place, assigning their name, and sending the \n     * specified message to everyone else in the place.  The client should\n     * not make this method available to the user.  They should use go()\n     * instead.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Return the server object of the MUD that \"contains\" this place \n     * This method should not be directly visible to the player\n     **/\npublic RemoteMudServer getServer() throws RemoteException;\n","name":"getServer","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Return the server object of the MUD that \"contains\" this place This method should not be directly visible to the player","comments":" \n     * Return the server object of the MUD that \"contains\" this place \n     * This method should not be directly visible to the player\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Connection"],"returnType":"RemoteDBBankServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The constructor.  Just save the database connection object away */\npublic RemoteDBBankServer(Connection db) throws RemoteException {\n    this.db = db;\n}\n","name":"RemoteDBBankServer","className":"RemoteDBBankServer","variables":{"db":1},"constants":{},"javaDoc":"The constructor Just save the database connection object away","comments":" The constructor.  Just save the database connection object away ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"createStatement":2,"next":1,"rollback":1,"getResultSet":1,"commit":1,"getMessage":1,"getSQLState":1,"close":1,"executeQuery":1,"executeUpdate":3},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"ResultSet":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":16,"NameExpr":46,"StringLiteralExpr":14,"AssignExpr":2,"MethodCallExpr":13},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":2,"ExpressionStmt":11},"text":"/** Open an account */\npublic synchronized void openAccount(String name, String password) throws RemoteException, BankingException {\n    // First, check if there is already an account with that name\n    Statement s = null;\n    try {\n        s = db.createStatement();\n        s.executeQuery(\"SELECT * FROM accounts WHERE name='\" + name + \"'\");\n        ResultSet r = s.getResultSet();\n        if (r.next())\n            throw new BankingException(\"Account already exists.\");\n        // If it doesn't exist, go ahead and create it\n        // Also, create a table for the transaction history of this account and\n        // insert an initial transaction into it.\n        s = db.createStatement();\n        s.executeUpdate(\"INSERT INTO accounts VALUES ('\" + name + \"', '\" + password + \"', 0)\");\n        s.executeUpdate(\"CREATE TABLE \" + name + \"_history (msg VARCHAR(80))\");\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Account opened at \" + new Date() + \"')\");\n        // And if we've been successful so far, commit these updates,\n        // ending the atomic transaction.  All the methods below also use this\n        // atomic transaction commit/rollback scheme\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally // No matter what happens, don't forget to close the DB Statement\n    {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n       // If an exception was thrown, \"rollback\" the prior updates,\n\n       // removing them from the database.  This also ends the atomic\n\n       // transaction.\n\n       // Pass the SQLException on in the body of a BankingException\n\n","name":"openAccount","className":"RemoteDBBankServer","variables":{"r":2,"password":1,"s":9,"e":4,"name":4,"e2":1,"db":4},"constants":{"\"_history \"":1,"\"VALUES ('Account opened at \"":1,"\"CREATE TABLE \"":1,"\"', '\"":1,"\": \"":1,"\"', 0)\"":1,"\"INSERT INTO accounts VALUES ('\"":1,"\"')\"":1,"null":1,"\"Account already exists.\"":1,"\"SELECT * FROM accounts WHERE name='\"":1,"\"_history (msg VARCHAR(80))\"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Open an account","comments":"First check if there is already an account with that name If it doesn't exist go ahead and create it Also create a table for the transaction history of this account and And if we've been successful so far commit these updates ending the atomic transaction All the methods below also use this insert an initial transaction into it atomic transaction commit/rollback scheme If an exception was thrown \"rollback\" the prior updates removing them from the database This also ends the atomic transaction Pass the SQLException on in the body of a BankingException No matter what happens don't forget to close the DB Statement  Open an account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"createStatement":1,"next":1,"getInt":1,"getResultSet":1,"close":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException","BankingException","Exception"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"ResultSet":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":21,"StringLiteralExpr":6,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n   * This convenience method checks whether the name and password match\n   * an existing account.  If so, it returns the balance in that account.\n   * If not, it throws an exception.  Note that this method does not call\n   * commit() or rollback(), so its query is part of a larger transaction.\n   **/\npublic int verify(String name, String password) throws BankingException, SQLException {\n    Statement s = null;\n    try {\n        s = db.createStatement();\n        s.executeQuery(\"SELECT balance FROM accounts \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        ResultSet r = s.getResultSet();\n        if (!r.next())\n            throw new BankingException(\"No such account or invalid password\");\n        return r.getInt(1);\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"verify","className":"RemoteDBBankServer","variables":{"password":1,"r":3,"s":5,"e":1,"name":1,"db":1},"constants":{"1":1,"null":1,"\"WHERE name='\"":1,"\"' \"":1,"\"SELECT balance FROM accounts \"":1,"\"No such account or invalid password\"":1,"\"  AND password = '\"":1,"\"'\"":1},"javaDoc":"This convenience method checks whether the name and password match an existing account If so it returns the balance in that account If not it throws an exception Note that this method does not call commit() or rollback() so its query is part of a larger transaction","comments":" \n   * This convenience method checks whether the name and password match\n   * an existing account.  If so, it returns the balance in that account.\n   * If not, it throws an exception.  Note that this method does not call\n   * commit() or rollback(), so its query is part of a larger transaction.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":11,"NameExpr":34,"StringLiteralExpr":9,"AssignExpr":2,"MethodCallExpr":9},"statements":{"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Close a named account */\npublic synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        s = db.createStatement();\n        // Delete the account from the accounts table\n        s.executeUpdate(\"DELETE FROM accounts \" + \"WHERE name = '\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // And drop the transaction history table for this account\n        s.executeUpdate(\"DROP TABLE \" + name + \"_history\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // Finally, return whatever balance remained in the account\n    return new FunnyMoney(balance);\n}\n","name":"closeAccount","className":"RemoteDBBankServer","variables":{"password":1,"s":5,"balance":3,"e":4,"name":2,"e2":1,"db":3},"constants":{"0":1,"null":1,"\"DELETE FROM accounts \"":1,"\"' \"":1,"\"DROP TABLE \"":1,"\"_history\"":1,"\"SQLException: \"":1,"\": \"":1,"\"WHERE name = '\"":1,"\"  AND password = '\"":1,"\"'\"":1},"javaDoc":"Close a named account","comments":"Delete the account from the accounts table And drop the transaction history table for this account Finally return whatever balance remained in the account  Close a named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":20,"NameExpr":40,"StringLiteralExpr":14,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":9},"statements":{"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ExpressionStmt":9},"text":"/** Deposit the specified money into the named account */\npublic synchronized void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        s = db.createStatement();\n        // Update the balance\n        s.executeUpdate(\"UPDATE accounts \" + \"SET balance = \" + balance + money.amount + \" \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // Add a row to the transaction history\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Deposited \" + money.amount + \" at \" + new Date() + \"')\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"deposit","className":"RemoteDBBankServer","variables":{"password":1,"s":5,"balance":3,"e":4,"name":2,"e2":1,"db":3},"constants":{"\"_history \"":1,"\" \"":1,"\"WHERE name='\"":1,"\" at \"":1,"\": \"":1,"\"  AND password = '\"":1,"\"')\"":1,"0":1,"\"SET balance = \"":1,"\"VALUES ('Deposited \"":1,"null":1,"\"UPDATE accounts \"":1,"\"' \"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Deposit the specified money into the named account","comments":"Update the balance Add a row to the transaction history  Deposit the specified money into the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":21,"NameExpr":39,"StringLiteralExpr":15,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Withdraw the specified amount from the named account */\npublic synchronized FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        if (balance < amount)\n            throw new BankingException(\"Insufficient Funds\");\n        s = db.createStatement();\n        // Update the account balance\n        s.executeUpdate(\"UPDATE accounts \" + \"SET balance = \" + (balance - amount) + \" \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // Add a row to the transaction history\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Withdrew \" + amount + \" at \" + new Date() + \"')\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    return new FunnyMoney(amount);\n}\n","name":"withdraw","className":"RemoteDBBankServer","variables":{"amount":4,"password":1,"s":5,"balance":4,"e":4,"name":2,"e2":1,"db":3},"constants":{"\"_history \"":1,"\"Insufficient Funds\"":1,"\" \"":1,"\"WHERE name='\"":1,"\" at \"":1,"\": \"":1,"\"  AND password = '\"":1,"\"')\"":1,"0":1,"\"SET balance = \"":1,"null":1,"\"UPDATE accounts \"":1,"\"' \"":1,"\"VALUES ('Withdrew \"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Withdraw the specified amount from the named account","comments":"Update the account balance Add a row to the transaction history  Withdraw the specified amount from the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":2,"AssignExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Return the balance of the specified account */\npublic synchronized int getBalance(String name, String password) throws RemoteException, BankingException {\n    int balance;\n    try {\n        // Get the balance\n        balance = verify(name, password);\n        // Commit the transaction\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    }\n    // Return the balance\n    return balance;\n}\n","name":"getBalance","className":"RemoteDBBankServer","variables":{"balance":3,"e":3,"e2":1,"db":2},"constants":{"\"SQLException: \"":1,"\": \"":1},"javaDoc":"Return the balance of the specified account","comments":"Get the balance Commit the transaction Return the balance  Return the balance of the specified account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"Vector","methodCalls":{"createStatement":1,"next":1,"rollback":1,"getResultSet":1,"commit":1,"verify":1,"getMessage":1,"addElement":1,"getString":1,"getSQLState":1,"close":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"ResultSet":1,"Vector":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":40,"StringLiteralExpr":4,"MethodCallExpr":12,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Get the transaction history of the named account */\npublic synchronized Vector getTransactionHistory(String name, String password) throws RemoteException, BankingException {\n    Statement s = null;\n    Vector v = new Vector();\n    try {\n        // Call verify to check the password, even though we don't \n        // care what the current balance is.\n        verify(name, password);\n        s = db.createStatement();\n        // Request everything out of the history table\n        s.executeQuery(\"SELECT * from \" + name + \"_history\");\n        // Get the results of the query and put them in a Vector\n        ResultSet r = s.getResultSet();\n        while (r.next()) v.addElement(r.getString(1));\n        // Commit the transaction\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // Return the Vector of transaction history.\n    return v;\n}\n","name":"getTransactionHistory","className":"RemoteDBBankServer","variables":{"r":3,"s":5,"e":4,"v":3,"name":1,"e2":1,"db":3},"constants":{"\"SELECT * from \"":1,"1":1,"null":1,"\"_history\"":1,"\"SQLException: \"":1,"\": \"":1},"javaDoc":"Get the transaction history of the named account","comments":"Call verify to check the password even though we don't care what the current balance is Request everything out of the history table Get the results of the query and put them in a Vector Commit the transaction Return the Vector of transaction history  Get the transaction history of the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getConnection":1,"exit":1,"getProperty":5,"setTransactionIsolation":1,"load":2,"forName":1,"rebind":1,"setAutoCommit":1,"System.err.println":3,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"RemoteDBBankServer":1,"Connection":1,"String":5,"Properties":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":76,"StringLiteralExpr":13,"InstanceOfExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":18},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":6,"ExpressionStmt":19},"text":"/**\n   * This main() method is the standalone program that figures out what\n   * database to connect to with what driver, connects to the database,\n   * creates a RemoteDBBankServer object, and registers it with the registry,\n   * making it available for client use\n   **/\npublic static void main(String[] args) {\n    try {\n        // Create a new Properties object.  Attempt to initialize it from\n        // the BankDB.props file or the file optionally specified on the \n        // command line, ignoring errors.\n        Properties p = new Properties();\n        try {\n            p.load(new FileInputStream(args[0]));\n        } catch (Exception e) {\n            try {\n                p.load(new FileInputStream(\"BankDB.props\"));\n            } catch (Exception e2) {\n            }\n        }\n        // The BankDB.props file (or file specified on the command line)\n        // must contain properties \"driver\" and \"database\", and may optionally\n        // contain properties \"user\" and  \"password\".\n        String driver = p.getProperty(\"driver\");\n        String database = p.getProperty(\"database\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // Load the database driver class\n        Class.forName(driver);\n        // Connect to the database that stores our accounts\n        Connection db = DriverManager.getConnection(database, user, password);\n        // Configure the database to allow multiple queries and updates\n        // to be grouped into atomic transactions\n        db.setAutoCommit(false);\n        db.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        // Create a server object that uses our database connection\n        RemoteDBBankServer bank = new RemoteDBBankServer(db);\n        // Read a system property to figure out how to name this server.\n        // Use \"SecondRemote\" as the default.\n        String name = System.getProperty(\"bankname\", \"SecondRemote\");\n        // Register the server with the name\n        Naming.rebind(name, bank);\n        // And tell everyone that we're up and running.\n        System.out.println(name + \" is open and ready for customers.\");\n    } catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQL State: \" + ((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java [-Dbankname=<name>] RemoteDBBankServer \" + \"[<dbpropsfile>]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"RemoteDBBankServer","variables":{"e":4,"Naming":1,"e2":1,"System":2,"p":7,"args":1,"database":1,"password":1,"bank":1,"driver":1,"name":2,"Class":1,"user":1,"DriverManager":1,"db":4},"constants":{"\"\"":2,"\"Usage: java [-Dbankname=<name>] RemoteDBBankServer \"":1,"\" is open and ready for customers.\"":1,"\"driver\"":1,"false":1,"\"password\"":1,"0":1,"1":1,"\"BankDB.props\"":1,"\"[<dbpropsfile>]\"":1,"\"bankname\"":1,"\"SQL State: \"":1,"\"user\"":1,"\"database\"":1,"\"SecondRemote\"":1},"javaDoc":"This main() method is the standalone program that figures out what database to connect to with what driver connects to the database creates a RemoteDBBankServer object and registers it with the registry making it available for client use","comments":"Create a new Properties object Attempt to initialize it from the BankDB props file or the file optionally specified on the The BankDB props file (or file specified on the command line) must contain properties \"driver\" and \"database\" and may optionally Configure the database to allow multiple queries and updates Read a system property to figure out how to name this server command line ignoring errors contain properties \"user\" and \"password\" Load the database driver class Connect to the database that stores our accounts to be grouped into atomic transactions Create a server object that uses our database connection Use \"SecondRemote\" as the default Register the server with the name And tell everyone that we're up and running \n   * This main() method is the standalone program that figures out what\n   * database to connect to with what driver, connects to the database,\n   * creates a RemoteDBBankServer object, and registers it with the registry,\n   * making it available for client use\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookup":1,"exit":1,"currentThread":2,"setSecurityManager":1,"getNamedPlace":1,"getEntrance":1,"getLine":1,"getPriority":1,"setPriority":1,"runMud":1,"getMultiLine":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"MudPerson":1,"String":5,"int":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":6,"NullLiteralExpr":3,"ObjectCreationExpr":4,"VariableDeclarationExpr":10,"ArrayAccessExpr":3,"BinaryExpr":9,"NameExpr":73,"CastExpr":2,"StringLiteralExpr":7,"FieldAccessExpr":6,"AssignExpr":3,"MethodCallExpr":15},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":20},"text":"/**\n   * The main program.  It expects two or three arguments:\n   *   0) the name of the host on which the mud server is running\n   *   1) the name of the MUD on that host\n   *   2) the name of a place within that MUD to start at (optional).\n   *\n   * It uses the Naming.lookup() method to obtain a RemoteMudServer object\n   * for the named MUD on the specified host.  Then it uses the getEntrance()\n   * or getNamedPlace() method of RemoteMudServer to obtain the starting\n   * RemoteMudPlace object.  It prompts the user for a their name and \n   * description, and creates a MudPerson object.  Finally, it passes\n   * the person and the place to runMud() to begin interaction with the MUD.\n   **/\npublic static void main(String[] args) {\n    try {\n        // Each MUD is uniquely identified by a \n        String hostname = args[0];\n        //   host and a MUD name.\n        String mudname = args[1];\n        // Each place within a MUD has a unique name\n        String placename = null;\n        if (args.length > 2)\n            placename = args[2];\n        // Set the RMI security manager so that untrusted stub objects loaded \n        // over the network can't cause havoc.\n        System.setSecurityManager(new RMISecurityManager());\n        // Look up the RemoteMudServer object for the named MUD using\n        // the default registry on the specified host.  Note the use of\n        // the Mud.mudPrefix constant to help prevent naming conflicts\n        // in the registry.\n        RemoteMudServer server = (RemoteMudServer) Naming.lookup(\"rmi://\" + hostname + \"/\" + Mud.mudPrefix + mudname);\n        // If the user did not specify a place in the mud, use getEntrance()\n        // to get the initial place.  Otherwise, call getNamedPlace() to find\n        // the initial place.\n        RemoteMudPlace location = null;\n        if (placename == null)\n            location = server.getEntrance();\n        else\n            location = (RemoteMudPlace) server.getNamedPlace(placename);\n        // Greet the user and ask for their name and description.\n        // This relies on getLine() and getMultiLine() defined below.\n        System.out.println(\"Welcome to \" + mudname);\n        String name = getLine(\"Enter your name: \");\n        String description = getMultiLine(\"Please describe what \" + \"people see when they look at you:\");\n        // Define an output stream that the MudPerson object will use to\n        // display messages sent to it to the user.  We'll use the console.\n        PrintWriter myout = new PrintWriter(new OutputStreamWriter(System.out));\n        // Create a MudPerson object to represent the user in the MUD.\n        // Use the specified name and description, and the output stream.\n        MudPerson me = new MudPerson(name, description, myout);\n        // Lower this thread's priority one notch so that broadcast messages\n        // can appear even when we're blocking for I/O.  This is necessary\n        // on the Linux platform, but may not be necessary on all platforms.\n        int pri = Thread.currentThread().getPriority();\n        Thread.currentThread().setPriority(pri - 1);\n        // Finally, put the MudPerson into the RemoteMudPlace, and start\n        // prompting the user for commands.\n        runMud(location, me);\n    }// If anything goes wrong, print a message and exit.\n     catch (Exception e) {\n        System.out.println(e);\n        System.out.println(\"Usage: java MudClient <host> <mud> [<place>]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"MudClient","variables":{"server":3,"mudname":3,"e":1,"pri":2,"description":2,"placename":3,"Naming":1,"System":2,"Thread":2,"args":3,"hostname":2,"name":2,"me":1,"location":3,"myout":2},"constants":{"0":1,"1":3,"2":2,"\"Welcome to \"":1,"\"Usage: java MudClient <host> <mud> [<place>]\"":1,"null":3,"\"rmi://\"":1,"\"/\"":1,"\"Please describe what \"":1,"\"people see when they look at you:\"":1,"\"Enter your name: \"":1},"javaDoc":"The main program It expects two or three arguments: 0) the name of the host on which the mud server is running 1) the name of the MUD on that host 2) the name of a place within that MUD to start at (optional) It uses the Naming lookup() method to obtain a RemoteMudServer object for the named MUD on the specified host Then it uses the getEntrance() or getNamedPlace() method of RemoteMudServer to obtain the starting RemoteMudPlace object It prompts the user for a their name and description and creates a MudPerson object Finally it passes the person and the place to runMud() to begin interaction with the MUD","comments":"Set the RMI security manager so that untrusted stub objects loaded Look up the RemoteMudServer object for the named MUD using the default registry on the specified host Note the use of the Mud mudPrefix constant to help prevent naming conflicts If the user did not specify a place in the mud use getEntrance() to get the initial place Otherwise call getNamedPlace() to find Greet the user and ask for their name and description Define an output stream that the MudPerson object will use to Create a MudPerson object to represent the user in the MUD Lower this thread's priority one notch so that broadcast messages can appear even when we're blocking for I/O This is necessary Finally put the MudPerson into the RemoteMudPlace and start Each MUD is uniquely identified by a host and a MUD name Each place within a MUD has a unique name over the network can't cause havoc in the registry the initial place This relies on getLine() and getMultiLine() defined below display messages sent to it to the user We'll use the console Use the specified name and description and the output stream on the Linux platform but may not be necessary on all platforms prompting the user for commands If anything goes wrong print a message and exit \n   * The main program.  It expects two or three arguments:\n   *   0) the name of the host on which the mud server is running\n   *   1) the name of the MUD on that host\n   *   2) the name of a place within that MUD to start at (optional).\n   *\n   * It uses the Naming.lookup() method to obtain a RemoteMudServer object\n   * for the named MUD on the specified host.  Then it uses the getEntrance()\n   * or getNamedPlace() method of RemoteMudServer to obtain the starting\n   * RemoteMudPlace object.  It prompts the user for a their name and \n   * description, and creates a MudPerson object.  Finally, it passes\n   * the person and the place to runMud() to begin interaction with the MUD.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RemoteMudPlace","MudPerson"],"returnType":"void","methodCalls":{"getPlaceName":2,"getName":1,"tell":1,"setDescription":1,"getDescription":1,"substring":2,"getMudName":2,"sleep":1,"act":1,"linkTo":1,"createPlace":1,"destroyThing":1,"speak":1,"enter":1,"dump":1,"indexOf":1,"close":1,"System.out.println":25,"getServer":3,"System.out.flush":1,"createThing":1,"toLowerCase":1,"getLine":8,"go":1,"length":5,"look":3,"getMultiLine":3,"exit":3,"getPerson":2,"equals":16,"examineThing":1},"annotations":[],"exceptions":["MudException","RemoteException","InterruptedException","Exception","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"RemoteMudPerson":2,"RemoteMudPlace":1,"String":15,"int":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":5,"VariableDeclarationExpr":19,"BinaryExpr":43,"NameExpr":387,"StringLiteralExpr":80,"CharLiteralExpr":2,"UnaryExpr":1,"InstanceOfExpr":10,"AssignExpr":10,"NullLiteralExpr":4,"FieldAccessExpr":26,"MethodCallExpr":93},"statements":{"IfStmt":33,"TryStmt":6,"BlockStmt":27,"ForStmt":1,"ThrowStmt":5,"ExpressionStmt":73},"text":"/**\n   * This method is the main loop of the MudClient.  It places the person\n   * into the place (using the enter() method of RemoteMudPlace).  Then it\n   * calls the look() method to describe the place to the user, and enters a\n   * command loop to prompt the user for a command and process the command\n   **/\npublic static void runMud(RemoteMudPlace entrance, MudPerson me) throws RemoteException {\n    // The current place\n    RemoteMudPlace location = entrance;\n    // The person's name\n    String myname = me.getName();\n    // The name of the current place\n    String placename = null;\n    // The name of the mud of that place\n    String mudname = null;\n    try {\n        // Enter the MUD\n        location.enter(me, myname, myname + \" has entered the MUD.\");\n        // Figure out where we are (for the prompt)\n        mudname = location.getServer().getMudName();\n        placename = location.getPlaceName();\n        // Describe the place to the user\n        look(location);\n    } catch (Exception e) {\n        System.out.println(e);\n        System.exit(1);\n    }\n    // could go wrong each time through the loop.\n    for (; ; ) {\n        // Loop until the user types \"quit\"\n        try {\n            // generated indirectly by the last command a chance to appear.\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n            }\n            // Display a prompt, and get the user's input\n            String line = getLine(mudname + '.' + placename + \"> \");\n            // Break the input into a command and an argument that consists \n            // of the rest of the line.  Convert the command to lowercase.\n            String cmd, arg;\n            int i = line.indexOf(' ');\n            if (i == -1) {\n                cmd = line;\n                arg = null;\n            } else {\n                cmd = line.substring(0, i).toLowerCase();\n                arg = line.substring(i + 1);\n            }\n            if (arg == null)\n                arg = \"\";\n            // LOOK: Describe the place and its things, people, and exits\n            if (cmd.equals(\"look\"))\n                look(location);\n            else // EXAMINE: Describe a named thing\n            if (cmd.equals(\"examine\"))\n                System.out.println(location.examineThing(arg));\n            else // DESCRIBE: Describe a named person\n            if (cmd.equals(\"describe\")) {\n                try {\n                    RemoteMudPerson p = location.getPerson(arg);\n                    System.out.println(p.getDescription());\n                } catch (RemoteException e) {\n                    System.out.println(arg + \" is having technical difficulties.  \" + \"No description is available.\");\n                }\n            } else // GO: Go in a named direction\n            if (cmd.equals(\"go\")) {\n                location = location.go(me, arg);\n                mudname = location.getServer().getMudName();\n                placename = location.getPlaceName();\n                look(location);\n            } else // SAY: Say something to everyone \n            if (cmd.equals(\"say\"))\n                location.speak(me, arg);\n            else // DO: Do something that will be described to everyone\n            if (cmd.equals(\"do\"))\n                location.act(me, arg);\n            else // TALK: Say something to one named person\n            if (cmd.equals(\"talk\")) {\n                try {\n                    RemoteMudPerson p = location.getPerson(arg);\n                    String msg = getLine(\"What do you want to say?: \");\n                    p.tell(myname + \" says \\\"\" + msg + \"\\\"\");\n                } catch (RemoteException e) {\n                    System.out.println(arg + \" is having technical difficulties.  \" + \"Can't talk to them.\");\n                }\n            } else // CHANGE: Change my own description \n            if (cmd.equals(\"change\"))\n                me.setDescription(getMultiLine(\"Describe yourself for others: \"));\n            else // CREATE: Create a new thing in this place\n            if (cmd.equals(\"create\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"name expected\");\n                String desc = getMultiLine(\"Please describe the \" + arg + \": \");\n                location.createThing(me, arg, desc);\n            } else // DESTROY: Destroy a named thing\n            if (cmd.equals(\"destroy\"))\n                location.destroyThing(me, arg);\n            else // the exit specified in the argument.\n            if (cmd.equals(\"open\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                String name = getLine(\"What is the name of place there?: \");\n                String back = getLine(\"What is the direction from \" + \"there back to here?: \");\n                String desc = getMultiLine(\"Please describe \" + name + \":\");\n                location.createPlace(me, arg, back, name, desc);\n            } else // uni-directionally, and does not destroy a place.\n            if (cmd.equals(\"close\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                location.close(me, arg);\n            } else // that may be in another MUD running on another host\n            if (cmd.equals(\"link\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                String host = getLine(\"What host are you linking to?: \");\n                String mud = getLine(\"What is the name of the MUD on that host?: \");\n                String place = getLine(\"What is the place name in that MUD?: \");\n                location.linkTo(me, arg, host, mud, place);\n                System.out.println(\"Don't forget to make a link from there \" + \"back to here!\");\n            } else // if the password is correct\n            if (cmd.equals(\"dump\")) {\n     // Now that we've entered the MUD, begin a command loop to process\n\n     // the user's commands.  Note that there is a huge block of catch\n\n     // statements at the bottom of the loop to handle all the things that\n\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"filename expected\");\n                // Catch any exceptions that occur in the loop\n\n         // Pause just a bit before printing the prompt, to give output\n\n                String password = getLine(\"Password: \");\n                location.getServer().dump(password, arg);\n            } else // QUIT: Quit the game\n            if (cmd.equals(\"quit\")) {\n                try {\n                    location.exit(me, myname + \" has quit.\");\n                } catch (Exception e) {\n                }\n                System.out.println(\"Bye.\");\n                System.out.flush();\n                System.exit(0);\n            } else // HELP: Print out a big help message\n            if (cmd.equals(\"help\")) {\n                String help = \"Commands are:\\n\" + \"look: Look around\\n\" + \"examine <thing>: examine the named thing in more detail\\n\" + \"describe <person>: describe the named person\\n\" + \"go <direction>: go in the named direction (i.e. a named exit)\\n\" + \"say <message>: say something to everyone\\n\" + \"do <message>: tell everyone that you are doing something\\n\" + \"talk <person>: talk to one person.  Will prompt for message\\n\" + \"change: change how you are described.  Will prompt for input\\n\" + \"create <thing>: create a new thing.  Prompts for description \\n\" + \"destroy <thing>: destroy a thing.\\n\" + \"open <direction>: create an adjoining place. Prompts for input\\n\" + \"close <direction>: close an exit from this place.\\n\" + \"link <direction>: create an exit to an existing place,\\n\" + \"     perhaps on another server.  Will prompt for input.\\n\" + \"dump <filename>: save server state.  Prompts for password\\n\" + \"quit: leave the Mud\\n\" + \"help: display this message\";\n                System.out.println(help);\n            } else\n                // Otherwise, this is an unrecognized command.\n         // Now go process the command.  What follows is a huge repeated \n\n         // if/else statement covering each of the commands supported by\n\n         // this client.  Many of these commands simply invoke one of the\n\n         // remote methods of the current RemoteMudPlace object.  Some have\n\n         // to do a bit of additional processing.\n\n                System.out.println(\"Unknown command.  Try 'help'.\");\n        }// Handle the many possible types of MudException\n         catch (MudException e) {\n            if (e instanceof NoSuchThing)\n                System.out.println(\"There isn't any such thing here.\");\n            else if (e instanceof NoSuchPerson)\n                System.out.println(\"There isn't anyone by that name here.\");\n            else if (e instanceof NoSuchExit)\n                System.out.println(\"There isn't an exit in that direction.\");\n            else if (e instanceof NoSuchPlace)\n                System.out.println(\"There isn't any such place.\");\n            else if (e instanceof ExitAlreadyExists)\n                System.out.println(\"There is already an exit in that direction.\");\n            else if (e instanceof PlaceAlreadyExists)\n                System.out.println(\"There is already a place with that name.\");\n            else if (e instanceof LinkFailed)\n                System.out.println(\"That exit is not functioning.\");\n            else if (e instanceof BadPassword)\n                System.out.println(\"Invalid password.\");\n            else if (e instanceof NotThere)\n                System.out.println(\"You can't do that when you're not there.\");\n            else if (e instanceof AlreadyThere)\n                System.out.println(\"You can't go there; you're already there.\");\n        }// Handle RMI exceptions\n         catch (RemoteException e) {\n            System.out.println(\"The MUD is having technical difficulties.\");\n            System.out.println(\"Perhaps the server has crashed:\");\n            System.out.println(e);\n        }// Handle everything else that could go wrong.\n         catch (Exception e) {\n            System.out.println(\"Syntax or other error:\");\n            System.out.println(e);\n            System.out.println(\"Try using the 'help' command.\");\n        }\n    }\n}\n         // OPEN: Create a new place and connect this place to it through\n\n         // CLOSE: Close a named exit.  Note: only closes an exit\n\n         // LINK: Create a new exit that connects to an existing place\n\n         // DUMP: Save the state of this MUD into the named file,\n\n                                              // Shouldn't happen\n\n                                              // Shouldn't happen\n\n","name":"runMud","className":"MudClient","variables":{"msg":2,"mudname":4,"e":18,"line":5,"i":3,"back":1,"myname":4,"placename":4,"System":2,"Thread":1,"p":4,"help":1,"password":1,"arg":13,"me":2,"name":2,"host":1,"location":20,"cmd":19,"place":1,"entrance":1,"mud":1,"desc":2},"constants":{"\"destroy <thing>: destroy a thing.\\n\"":1,"\"talk\"":1,"\"Please describe \"":1,"\"go <direction>: go in the named direction (i.e. a named exit)\\n\"":1,"\"do\"":1,"\"There isn't any such thing here.\"":1,"\"Don't forget to make a link from there \"":1,"\"do <message>: tell everyone that you are doing something\\n\"":1,"\"There is already a place with that name.\"":1,"\"Try using the 'help' command.\"":1,"\"create <thing>: create a new thing.  Prompts for description \\n\"":1,"\" has quit.\"":1,"\"examine\"":1,"\"Password: \"":1,"\"help: display this message\"":1,"\"Can't talk to them.\"":1,"\"     perhaps on another server.  Will prompt for input.\\n\"":1,"\" has entered the MUD.\"":1,"\"There isn't anyone by that name here.\"":1,"\"You can't do that when you're not there.\"":1,"'.'":1,"\"Unknown command.  Try 'help'.\"":1,"\"quit\"":1,"\"link <direction>: create an exit to an existing place,\\n\"":1,"\"What is the name of the MUD on that host?: \"":1,"\"close <direction>: close an exit from this place.\\n\"":1,"\"\\\"\"":1,"\"look\"":1,"\"say\"":1,"\"open <direction>: create an adjoining place. Prompts for input\\n\"":1,"\"there back to here?: \"":1,"\"link\"":1,"\"back to here!\"":1,"\"Syntax or other error:\"":1,"0":7,"1":3,"200":1,"\"There isn't an exit in that direction.\"":1,"\" says \\\"\"":1,"null":4,"\"What is the place name in that MUD?: \"":1,"\"There is already an exit in that direction.\"":1,"\"look: Look around\\n\"":1,"\"Perhaps the server has crashed:\"":1,"\"destroy\"":1,"\"Please describe the \"":1,"\"\"":1,"\"What is the name of place there?: \"":1,"\"What host are you linking to?: \"":1,"\"go\"":1,"\"direction expected\"":3,"\": \"":1,"\":\"":1,"\"What do you want to say?: \"":1,"\"> \"":1,"\"examine <thing>: examine the named thing in more detail\\n\"":1,"\"describe <person>: describe the named person\\n\"":1,"\"What is the direction from \"":1,"\"talk <person>: talk to one person.  Will prompt for message\\n\"":1,"\"name expected\"":1,"\"change: change how you are described.  Will prompt for input\\n\"":1,"\"change\"":1,"\"open\"":1,"\"Commands are:\\n\"":1,"\"close\"":1,"\"The MUD is having technical difficulties.\"":1,"\"dump <filename>: save server state.  Prompts for password\\n\"":1,"\" is having technical difficulties.  \"":2,"' '":1,"\"dump\"":1,"\"describe\"":1,"\"create\"":1,"\"help\"":1,"\"quit: leave the Mud\\n\"":1,"\"There isn't any such place.\"":1,"\"That exit is not functioning.\"":1,"\"You can't go there; you're already there.\"":1,"\"say <message>: say something to everyone\\n\"":1,"\"Describe yourself for others: \"":1,"\"No description is available.\"":1,"\"filename expected\"":1,"\"Invalid password.\"":1,"\"Bye.\"":1},"javaDoc":"This method is the main loop of the MudClient It places the person into the place (using the enter() method of RemoteMudPlace) Then it calls the look() method to describe the place to the user and enters a command loop to prompt the user for a command and process the command","comments":"Now that we've entered the MUD begin a command loop to process the user's commands Note that there is a huge block of catch statements at the bottom of the loop to handle all the things that The current place The person's name The name of the current place The name of the mud of that place Enter the MUD Figure out where we are (for the prompt) Describe the place to the user could go wrong each time through the loop Loop until the user types \"quit\" Catch any exceptions that occur in the loop Pause just a bit before printing the prompt to give output Break the input into a command and an argument that consists Now go process the command What follows is a huge repeated if/else statement covering each of the commands supported by this client Many of these commands simply invoke one of the remote methods of the current RemoteMudPlace object Some have to do a bit of additional processing generated indirectly by the last command a chance to appear Display a prompt and get the user's input of the rest of the line Convert the command to lowercase LOOK: Describe the place and its things people and exits EXAMINE: Describe a named thing DESCRIBE: Describe a named person GO: Go in a named direction SAY: Say something to everyone DO: Do something that will be described to everyone TALK: Say something to one named person CHANGE: Change my own description CREATE: Create a new thing in this place DESTROY: Destroy a named thing OPEN: Create a new place and connect this place to it through the exit specified in the argument CLOSE: Close a named exit Note: only closes an exit uni-directionally and does not destroy a place LINK: Create a new exit that connects to an existing place that may be in another MUD running on another host DUMP: Save the state of this MUD into the named file if the password is correct QUIT: Quit the game HELP: Print out a big help message Otherwise this is an unrecognized command Handle the many possible types of MudException Shouldn't happen Shouldn't happen Handle RMI exceptions Handle everything else that could go wrong \n   * This method is the main loop of the MudClient.  It places the person\n   * into the place (using the enter() method of RemoteMudPlace).  Then it\n   * calls the look() method to describe the place to the user, and enters a\n   * command loop to prompt the user for a command and process the command\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RemoteMudPlace"],"returnType":"void","methodCalls":{"getMudName":1,"getServer":1,"getPlaceName":1,"size":3,"System.out.flush":1,"elementAt":3,"getExits":1,"getNames":1,"getDescription":1,"System.out.print":9,"getThings":1,"System.out.println":3},"annotations":[],"exceptions":["MudException","RemoteException"],"concepts":[],"types":{"String":3,"Vector":3,"int":3},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":9,"BinaryExpr":9,"NameExpr":118,"StringLiteralExpr":8,"FieldAccessExpr":13,"UnaryExpr":3,"MethodCallExpr":26},"statements":{"IfStmt":3,"BlockStmt":3,"ForStmt":3,"ExpressionStmt":19},"text":"/** \n   * This convenience method is used in several places in the\n   * runMud() method above.  It displays the name and description of\n   * the current place (including the name of the mud the place is in), \n   * and also displays the list of things, people, and exits in\n   * the current place.\n   **/\npublic static void look(RemoteMudPlace p) throws RemoteException, MudException {\n    // Mud name\n    String mudname = p.getServer().getMudName();\n    // Place name\n    String placename = p.getPlaceName();\n    // Place description\n    String description = p.getDescription();\n    // List of things here\n    Vector things = p.getThings();\n    // List of people here\n    Vector names = p.getNames();\n    // List of exits from here\n    Vector exits = p.getExits();\n    // Print it all out\n    System.out.println(\"You are in: \" + placename + \" of the Mud: \" + mudname);\n    System.out.println(description);\n    System.out.print(\"Things here: \");\n    for (int i = 0; i < things.size(); i++) {\n        // Display list of things\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(things.elementAt(i));\n    }\n    System.out.print(\"\\nPeople here: \");\n    for (int i = 0; i < names.size(); i++) {\n        // Display list of people\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(names.elementAt(i));\n    }\n    System.out.print(\"\\nExits are: \");\n    for (int i = 0; i < exits.size(); i++) {\n        // Display list of exits\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(exits.elementAt(i));\n    }\n    // Blank line\n    System.out.println();\n    // Make it appear now!\n    System.out.flush();\n}\n","name":"look","className":"MudClient","variables":{"p":6,"exits":3,"names":3,"mudname":2,"things":3,"description":1,"i":12,"placename":2},"constants":{"0":6,"\"\\nExits are: \"":1,"\"You are in: \"":1,"\" of the Mud: \"":1,"\", \"":3,"\"Things here: \"":1,"\"\\nPeople here: \"":1},"javaDoc":"This convenience method is used in several places in the runMud() method above It displays the name and description of the current place (including the name of the mud the place is in) and also displays the list of things people and exits in the current place","comments":"Mud name Place name Place description List of things here List of people here List of exits from here Print it all out Display list of things Display list of people Display list of exits Blank line Make it appear now!  \n   * This convenience method is used in several places in the\n   * runMud() method above.  It displays the name and description of\n   * the current place (including the name of the mud the place is in), \n   * and also displays the list of things, people, and exits in\n   * the current place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":1,"System.out.flush":1,"length":1,"readLine":1,"System.out.print":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":25,"FieldAccessExpr":2,"EnclosedExpr":2,"MethodCallExpr":5,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":5,"DoStmt":1},"text":"/** \n   * A convenience method for prompting the user and getting a line of \n   * input.  It guarantees that the line is not empty and strips off \n   * whitespace at the beginning and end of the line.\n   **/\npublic static String getLine(String prompt) {\n    String line = null;\n    do {\n        // Loop until a non-empty line is entered\n        try {\n            // Display prompt\n            System.out.print(prompt);\n            // Display it right away\n            System.out.flush();\n            // Get a line of input\n            line = in.readLine();\n            // Strip off whitespace\n            if (line != null)\n                line = line.trim();\n        }// Ignore any errors\n         catch (Exception e) {\n        }\n    } while ((line == null) || (line.length() == 0));\n    return line;\n}\n","name":"getLine","className":"MudClient","variables":{"in":1,"e":1,"line":8},"constants":{"0":1,"null":3},"javaDoc":"A convenience method for prompting the user and getting a line of input It guarantees that the line is not empty and strips off whitespace at the beginning and end of the line","comments":"Loop until a non-empty line is entered Display prompt Display it right away Get a line of input Strip off whitespace Ignore any errors  \n   * A convenience method for prompting the user and getting a line of \n   * input.  It guarantees that the line is not empty and strips off \n   * whitespace at the beginning and end of the line.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":3,"System.out.flush":1,"equals":1,"length":1,"readLine":1,"substring":1,"System.out.println":4,"startsWith":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":3},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":55,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":13,"AssignExpr":3},"statements":{"ContinueStmt":1,"IfStmt":3,"WhileStmt":1,"BreakStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"/**\n   * A convenience method for getting multi-line input from the user.\n   * It prompts for the input, displays instructions, and guarantees that\n   * the input is not empty.  It also allows the user to enter the name of\n   * a file from which text will be read.\n   **/\npublic static String getMultiLine(String prompt) {\n    String text = \"\";\n    for (; ; ) {\n        // We'll break out of this loop when we get non-empty input\n        try {\n            // The stream to read from \n            BufferedReader br = in;\n            // Display the prompt\n            System.out.println(prompt);\n            // Display some instructions\n            System.out.println(\"You can enter multiple lines.  \" + \"End with a '.' on a line by itself.\\n\" + \"Or enter a '<<' followed by a filename\");\n            // Make the prompt and instructions appear now.\n            System.out.flush();\n            // Read lines\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Or until a dot by itself\n                if (line.equals(\".\"))\n                    break;\n                // from the console.\n                if (line.trim().startsWith(\"<<\")) {\n                    String filename = line.trim().substring(2).trim();\n                    br = new BufferedReader(new FileReader(filename));\n                    // Don't count the << line as part of the input\n                    continue;\n                } else\n                    // Add the line to the collected input\n                    text += line + \"\\n\";\n            }\n            // user and go back to the prompt and the instructions.\n            if (text.length() > 0)\n                return text;\n            else\n                System.out.println(\"Please enter at least one line.\");\n        }// display the error and loop again, displaying prompt and instructions\n         catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n}\n       // If there were errors, for example an IO error reading a file,\n\n         // If we got at least one line, return it.  Otherwise, chastise the\n\n                                                    // Until EOF\n\n           // Or, if a file is specified, start reading from it instead of\n\n","name":"getMultiLine","className":"MudClient","variables":{"br":3,"filename":2,"in":1,"e":1,"line":6,"text":4},"constants":{"\"\"":1,"\"<<\"":1,"0":1,"\"Or enter a '<<' followed by a filename\"":1,"2":1,"\"You can enter multiple lines.  \"":1,"null":1,"\"End with a '.' on a line by itself.\\n\"":1,"\".\"":1,"\"Please enter at least one line.\"":1,"\"\\n\"":1},"javaDoc":"A convenience method for getting multi-line input from the user It prompts for the input displays instructions and guarantees that the input is not empty It also allows the user to enter the name of a file from which text will be read","comments":"We'll break out of this loop when we get non-empty input If there were errors for example an IO error reading a file If we got at least one line return it Otherwise chastise the The stream to read from Display the prompt Display some instructions Make the prompt and instructions appear now Read lines Until EOF Or if a file is specified start reading from it instead of Or until a dot by itself from the console Don't count the << line as part of the input Add the line to the collected input user and go back to the prompt and the instructions display the error and loop again displaying prompt and instructions \n   * A convenience method for getting multi-line input from the user.\n   * It prompts for the input, displays instructions, and guarantees that\n   * the input is not empty.  It also allows the user to enter the name of\n   * a file from which text will be read.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["long"],"returnType":"Randomizer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n   * The constructor for the Randomizer() class.  It must be passed some\n   * arbitrary initial value or \"seed\" for its pseudo-randomness.\n   **/\npublic Randomizer(long seed) {\n    this.seed = seed;\n}\n","name":"Randomizer","className":"Randomizer","variables":{"seed":1},"constants":{},"javaDoc":"The constructor for the Randomizer() class It must be passed some arbitrary initial value or \"seed\" for its pseudo-randomness","comments":" \n   * The constructor for the Randomizer() class.  It must be passed some\n   * arbitrary initial value or \"seed\" for its pseudo-randomness.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":7,"CastExpr":2,"EnclosedExpr":1,"AssignExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This method computes a pseudo-random number between 0 and 1 using a very\n   * simple algorithm.  Math.random() and java.util.Random are actually a lot\n   * better at computing randomness.\n   **/\npublic float randomFloat() {\n    seed = (seed * a + c) % m;\n    return (float) seed / (float) m;\n}\n","name":"randomFloat","className":"Randomizer","variables":{"a":1,"c":1,"seed":3,"m":2},"constants":{},"javaDoc":"This method computes a pseudo-random number between 0 and 1 using a very simple algorithm Math random() and java util Random are actually a lot better at computing randomness","comments":"\n   * This method computes a pseudo-random number between 0 and 1 using a very\n   * simple algorithm.  Math.random() and java.util.Random are actually a lot\n   * better at computing randomness.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"randomFloat":1,"round":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n   * This method computes a pseudo-random integer between 0 and specified\n   * maximum.  It uses randomFloat() above.\n   **/\npublic int randomInt(int max) {\n    return Math.round(max * randomFloat());\n}\n","name":"randomInt","className":"Randomizer","variables":{"max":1,"Math":1},"constants":{},"javaDoc":"This method computes a pseudo-random integer between 0 and specified maximum It uses randomFloat() above","comments":" \n   * This method computes a pseudo-random integer between 0 and specified\n   * maximum.  It uses randomFloat() above.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Randomizer":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Randomizer r = new Randomizer(new java.util.Date().getTime());\n    for (int i = 0; i < 10; i++) System.out.println(r.randomInt(100));\n}\n","name":"main","className":"Test","variables":{"r":2,"i":3},"constants":{"0":1,"100":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int","int"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n   * The is the main constructor for the class.  It simply uses its arguments\n   * to initialize each of the fields of the new object.  Note that it has\n   * the same name as the class, and that it has no return value declared in\n   * its signature.\n   **/\npublic Rect(int x1, int y1, int x2, int y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Rect","className":"Rect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"The is the main constructor for the class It simply uses its arguments to initialize each of the fields of the new object Note that it has the same name as the class and that it has no return value declared in its signature","comments":"\n   * The is the main constructor for the class.  It simply uses its arguments\n   * to initialize each of the fields of the new object.  Note that it has\n   * the same name as the class, and that it has no return value declared in\n   * its signature.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n   * This is another constructor.  It defines itself in terms of the one above\n   **/\npublic Rect(int width, int height) {\n    this(0, 0, width, height);\n}\n","name":"Rect","className":"Rect","variables":{"width":1,"height":1},"constants":{"0":2},"javaDoc":"This is another constructor It defines itself in terms of the one above","comments":"\n   * This is another constructor.  It defines itself in terms of the one above\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** This is yet another constructor. */\npublic Rect() {\n    this(0, 0, 0, 0);\n}\n","name":"Rect","className":"Rect","variables":{},"constants":{"0":4},"javaDoc":"This is yet another constructor","comments":" This is yet another constructor. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Move the rectangle by the specified amounts */\npublic void move(int deltax, int deltay) {\n    x1 += deltax;\n    x2 += deltax;\n    y1 += deltay;\n    y2 += deltay;\n}\n","name":"move","className":"Rect","variables":{"deltax":2,"deltay":2,"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"Move the rectangle by the specified amounts","comments":" Move the rectangle by the specified amounts ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":8,"EnclosedExpr":5},"statements":{"ReturnStmt":1},"text":"/** Test whether the specified point is inside the rectangle */\npublic boolean isInside(int x, int y) {\n    return ((x >= x1) && (x <= x2) && (y >= y1) && (y <= y2));\n}\n","name":"isInside","className":"Rect","variables":{"x":2,"y1":1,"x1":1,"y":2,"y2":1,"x2":1},"constants":{},"javaDoc":"Test whether the specified point is inside the rectangle","comments":" Test whether the specified point is inside the rectangle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rect"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":40,"FieldAccessExpr":16,"ConditionalExpr":4,"EnclosedExpr":4,"ThisExpr":8},"statements":{"ReturnStmt":1},"text":"/** \n   * Return the union of this rectangle with another.  I.e. return the \n   * smallest rectangle that includes them both.\n   **/\npublic Rect union(Rect r) {\n    return new Rect((this.x1 < r.x1) ? this.x1 : r.x1, (this.y1 < r.y1) ? this.y1 : r.y1, (this.x2 > r.x2) ? this.x2 : r.x2, (this.y2 > r.y2) ? this.y2 : r.y2);\n}\n","name":"union","className":"Rect","variables":{},"constants":{},"javaDoc":"Return the union of this rectangle with another I e return the smallest rectangle that includes them both","comments":" \n   * Return the union of this rectangle with another.  I.e. return the \n   * smallest rectangle that includes them both.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rect"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rect":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":65,"FieldAccessExpr":24,"ConditionalExpr":4,"EnclosedExpr":4,"ThisExpr":8,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** \n   * Return the intersection of this rectangle with another. \n   * I.e. return their overlap.\n   **/\npublic Rect intersection(Rect r) {\n    Rect result = new Rect((this.x1 > r.x1) ? this.x1 : r.x1, (this.y1 > r.y1) ? this.y1 : r.y1, (this.x2 < r.x2) ? this.x2 : r.x2, (this.y2 < r.y2) ? this.y2 : r.y2);\n    if (result.x1 > result.x2) {\n        result.x1 = result.x2 = 0;\n    }\n    if (result.y1 > result.y2) {\n        result.y1 = result.y2 = 0;\n    }\n    return result;\n}\n","name":"intersection","className":"Rect","variables":{"result":2},"constants":{"0":2},"javaDoc":"Return the intersection of this rectangle with another I e return their overlap","comments":" \n   * Return the intersection of this rectangle with another. \n   * I.e. return their overlap.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"StringLiteralExpr":5,"NameExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n   * This is a method of our superclass, Object.  We override it so that\n   * Rect objects can be meaningfully converted to strings, can be \n   * concatenated to strings with the + operator, and can be passed to \n   * methods like System.out.println()\n   **/\npublic String toString() {\n    return \"[\" + x1 + \",\" + y1 + \"; \" + x2 + \",\" + y2 + \"]\";\n}\n","name":"toString","className":"Rect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{"\"]\"":1,"\",\"":2,"\"[\"":1,"\"; \"":1},"javaDoc":"This is a method of our superclass Object We override it so that Rect objects can be meaningfully converted to strings can be concatenated to strings with the + operator and can be passed to methods like System out println()","comments":"\n   * This is a method of our superclass, Object.  We override it so that\n   * Rect objects can be meaningfully converted to strings, can be \n   * concatenated to strings with the + operator, and can be passed to \n   * methods like System.out.println()\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":3,"NameExpr":28,"FieldAccessExpr":2,"UnaryExpr":2,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n   * This is a very simple sorting algorithm that is not very efficient\n   * when sorting large numbers of things\n   **/\npublic static void sort(double[] nums) {\n    // to the first unsorted position in the array.\n    for (int i = 0; i < nums.length; i++) {\n        // holds the index of the smallest element\n        int min = i;\n        // find the smallest one between i and the end of the array\n        for (int j = i; j < nums.length; j++) {\n            if (nums[j] < nums[min])\n                min = j;\n        }\n        // Now swap the smallest one with element i.  \n        // This leaves all elements between 0 and i sorted.\n     // Loop through each element of the array, sorting as we go.\n\n     // Each time through, find the smallest remaining element, and move it\n\n        double tmp;\n        tmp = nums[i];\n        nums[i] = nums[min];\n        nums[min] = tmp;\n    }\n}\n","name":"sort","className":"SortNumbers","variables":{"min":5,"tmp":3,"i":7,"j":5,"nums":6},"constants":{"0":1},"javaDoc":"This is a very simple sorting algorithm that is not very efficient when sorting large numbers of things","comments":"Loop through each element of the array sorting as we go Each time through find the smallest remaining element and move it to the first unsorted position in the array Now swap the smallest one with element i holds the index of the smallest element find the smallest one between i and the end of the array This leaves all elements between 0 and i sorted \n   * This is a very simple sorting algorithm that is not very efficient\n   * when sorting large numbers of things\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":25,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":2,"ExpressionStmt":4},"text":"/** This is a simple test program for the algorithm above */\npublic static void main(String[] args) {\n    // Create an array to hold numbers\n    double[] nums = new double[10];\n    for (// Generate random numbers\n    int i = 0; // Generate random numbers\n    i < nums.length; // Generate random numbers\n    i++) nums[i] = Math.random() * 100;\n    // Sort them\n    sort(nums);\n    for (// Print them out\n    int i = 0; // Print them out\n    i < nums.length; // Print them out\n    i++) System.out.println(nums[i]);\n}\n","name":"main","className":"SortNumbers","variables":{"i":8,"Math":1,"nums":3},"constants":{"0":2,"100":1,"10":1},"javaDoc":"This is a simple test program for the algorithm above","comments":"Create an array to hold numbers Generate random numbers Generate random numbers Generate random numbers Sort them Print them out Print them out Print them out  This is a simple test program for the algorithm above ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public void init() {\n    // Create and specify a layout manager for this applet.\n    // Layout components into a grid three columns wide, with the number\n    // of rows to depend on the number of components.  Leave 10 pixels\n    // of horizontal and vertical space between components\n    this.setLayout(new GridLayout(0, 3, 10, 10));\n    for (int i = 1; i <= 9; i++) this.add(new Button(\"Button #\" + i));\n}\n","name":"init","className":"GridLayoutExample","variables":{"i":4},"constants":{"0":1,"1":1,"3":1,"9":1,"\"Button #\"":1,"10":2},"javaDoc":"","comments":"Create and specify a layout manager for this applet Layout components into a grid three columns wide with the number of rows to depend on the number of components Leave 10 pixels of horizontal and vertical space between components ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getProperty":4,"forName":1,"prepareStatement":3,"readLine":1,"createStatement":1,"getConnection":1,"storeClass":1,"load":2,"size":1,"elementAt":1,"addElement":1,"System.err.println":3,"close":1,"executeUpdate":3},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"Connection":1,"BufferedReader":1,"String":5,"Properties":1,"Vector":1,"int":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":3,"VariableDeclarationExpr":11,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":97,"StringLiteralExpr":20,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":5,"NullLiteralExpr":2,"CastExpr":2,"FieldAccessExpr":3,"EnclosedExpr":2,"MethodCallExpr":25},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":4,"BlockStmt":9,"ForStmt":1,"ExpressionStmt":26},"text":"public static void main(String args[]) {\n    // The connection to the database\n    Connection c = null;\n    try {\n        // Read the names of classes to index from a file specified by args[0]\n        Vector classnames = new Vector();\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        String name;\n        while ((name = in.readLine()) != null) classnames.addElement(name);\n        // Now determine the values needed to set up the database connection\n        // The program attempts to read a property file named \"APIDB.props\",\n        // or optionally specified by args[1].  This property file (if any)\n        // may contain \"driver\", \"database\", \"user\", and \"password\" properties\n        // that specify the necessary values for connecting to the db.\n        // If the properties file does not exist, or does not contain the named\n        // properties, defaults will be used.\n        // Empty properties\n        Properties p = new Properties();\n        try // Try to load properties\n        {\n            p.load(new FileInputStream(args[1]));\n        } catch (Exception e1) {\n            try {\n                p.load(new FileInputStream(\"APIDB.props\"));\n            } catch (Exception e2) {\n            }\n        }\n        // Read values from Properties file, using the specified defaults if\n        // they are not found.  These defaults will probably not work for you!\n        String driver = p.getProperty(\"driver\", \"postgres95.PGDriver\");\n        String database = p.getProperty(\"database\", \"jdbc:postgres95:///APIDB\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // Load the database driver\n        Class.forName(driver);\n        // And set up a connection to the specified database\n        c = DriverManager.getConnection(database, user, password);\n        // Create three new tables for our data\n        // The package table contains a package id and a package name\n        // The class table contains a class id, a package id, and a class name\n        // The member table contains a class id, a member name, and an int\n        // that indicates whether the class member is a field or a method.\n        Statement s = c.createStatement();\n        s.executeUpdate(\"CREATE TABLE package \" + \"(id SMALLINT, name VARCHAR(80))\");\n        s.executeUpdate(\"CREATE TABLE class \" + \"(id SMALLINT, packageId SMALLINT, name VARCHAR(48))\");\n        s.executeUpdate(\"CREATE TABLE member \" + \"(classId SMALLINT,name VARCHAR(48),isField SMALLINT)\");\n        // Prepare some statements that will be used to insert records into\n        // these three tables.\n        insertpackage = c.prepareStatement(\"INSERT INTO package VALUES(?,?)\");\n        insertclass = c.prepareStatement(\"INSERT INTO class VALUES(?,?,?)\");\n        insertmember = c.prepareStatement(\"INSERT INTO member VALUES(?,?,?)\");\n        // Now loop through the list of classes and store them all in the tables\n        for (int i = 0; i < classnames.size(); i++) storeClass((String) classnames.elementAt(i));\n    } catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQLState: \" + ((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java MakeAPIDB <classlistfile> <propfile>\");\n    } finally // When we're done, close the connection to the database\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"MakeAPIDB","variables":{"insertpackage":1,"c":7,"in":2,"e":4,"insertmember":1,"i":3,"e1":1,"classnames":4,"e2":1,"args":2,"p":7,"insertclass":1,"database":1,"password":1,"s":4,"driver":1,"name":2,"Class":1,"user":1,"DriverManager":1},"constants":{"\"jdbc:postgres95:///APIDB\"":1,"\"\"":2,"\"SQLState: \"":1,"\"INSERT INTO package VALUES(?,?)\"":1,"\"CREATE TABLE member \"":1,"\"driver\"":1,"\"(classId SMALLINT,name VARCHAR(48),isField SMALLINT)\"":1,"\"CREATE TABLE class \"":1,"\"password\"":1,"\"INSERT INTO member VALUES(?,?,?)\"":1,"\"postgres95.PGDriver\"":1,"0":2,"1":1,"null":2,"\"APIDB.props\"":1,"\"(id SMALLINT, name VARCHAR(80))\"":1,"\"Usage: java MakeAPIDB <classlistfile> <propfile>\"":1,"\"CREATE TABLE package \"":1,"\"(id SMALLINT, packageId SMALLINT, name VARCHAR(48))\"":1,"\"user\"":1,"\"database\"":1,"\"INSERT INTO class VALUES(?,?,?)\"":1},"javaDoc":"","comments":"The connection to the database Now determine the values needed to set up the database connection The program attempts to read a property file named \"APIDB props\" or optionally specified by args[1] This property file (if any) may contain \"driver\" \"database\" \"user\" and \"password\" properties that specify the necessary values for connecting to the db If the properties file does not exist or does not contain the named properties defaults will be used Read values from Properties file using the specified defaults if Create three new tables for our data The package table contains a package id and a package name The class table contains a class id a package id and a class name The member table contains a class id a member name and an int Prepare some statements that will be used to insert records into Read the names of classes to index from a file specified by args[0] Empty properties Try to load properties they are not found These defaults will probably not work for you! Load the database driver And set up a connection to the specified database that indicates whether the class member is a field or a method these three tables Now loop through the list of classes and store them all in the tables When we're done close the connection to the database ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"forName":1,"intValue":1,"isPrivate":2,"substring":2,"put":1,"setInt":7,"lastIndexOf":1,"getDeclaredMethods":1,"getDeclaredFields":1,"setString":4,"get":1,"System.out.println":1,"executeUpdate":4},"annotations":[],"exceptions":["SQLException","ClassNotFoundException"],"concepts":[],"types":{"Integer":1,"Class":1,"String":1,"Method[]":1,"int":3,"Field[]":1},"expressions":{"IntegerLiteralExpr":18,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":132,"StringLiteralExpr":2,"CharLiteralExpr":1,"UnaryExpr":5,"AssignExpr":6,"NullLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":3,"MethodCallExpr":31},"statements":{"ContinueStmt":2,"IfStmt":4,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":29},"text":"/**\n   * Given a fully-qualified classname, this method stores the package name\n   * in the package table (if it is not already there), stores the class name\n   * in the class table, and then uses the Java Reflection API to look up all\n   * methods and fields of the class, and stores those in the member table.\n   **/\npublic static void storeClass(String name) throws SQLException, ClassNotFoundException {\n    String packagename, classname;\n    // Dynamically load the class.\n    Class c = Class.forName(name);\n    // Display output so the user knows that the program is progressing\n    System.out.println(\"Storing data for: \" + name);\n    // Figure out the packagename and the classname\n    int pos = name.lastIndexOf('.');\n    if (pos == -1) {\n        packagename = \"\";\n        classname = name;\n    } else {\n        packagename = name.substring(0, pos);\n        classname = name.substring(pos + 1);\n    }\n    // Figure out what the package id is.  If there is one, then this package\n    // has already been stored in the database.  Otherwise, assign an id, \n    // and store it and the packagename in the db.\n    Integer pid;\n    // Check hashtable\n    pid = (Integer) package_to_id.get(packagename);\n    if (pid == null) {\n        // Assign an id\n        pid = new Integer(++packageId);\n        // Remember it in the hashtable\n        package_to_id.put(packagename, pid);\n        // Set args to PreparedStatement\n        insertpackage.setInt(1, packageId);\n        insertpackage.setString(2, packagename);\n        // Insert the package into db\n        insertpackage.executeUpdate();\n    }\n    // Now, store the classname in the class table of the database.\n    // This record includes the package id, so that the class is linked to \n    // the package that contains it.  To store the class, we set arguments\n    // to the PreparedStatement, then execute that statement\n    // Set class identifier\n    insertclass.setInt(1, ++classId);\n    // Set package identifier\n    insertclass.setInt(2, pid.intValue());\n    // Set class name\n    insertclass.setString(3, classname);\n    // Insert the class record\n    insertclass.executeUpdate();\n    // Now, get a list of all non-private methods of the class, and\n    // insert those into the \"members\" table of the database.  Each\n    // record includes the class id of the containing class, and also\n    // a value that indicates that these are methods, not fields.\n    // Get a list of methods\n    Method[] methods = c.getDeclaredMethods();\n    for (int i = 0; i < methods.length; i++) {\n        // For all non-private\n        if (Modifier.isPrivate(methods[i].getModifiers()))\n            continue;\n        // Set the class id\n        insertmember.setInt(1, classId);\n        // Set the method name\n        insertmember.setString(2, methods[i].getName());\n        // It is not a field\n        insertmember.setInt(3, 0);\n        // Insert the record\n        insertmember.executeUpdate();\n    }\n    // Do the same thing for the non-private fields of the class\n    // Get a list of fields\n    Field[] fields = c.getDeclaredFields();\n    for (int i = 0; i < fields.length; i++) {\n        // For each non-private\n        if (Modifier.isPrivate(fields[i].getModifiers()))\n            continue;\n        // Set the class id\n        insertmember.setInt(1, classId);\n        // Set the field name\n        insertmember.setString(2, fields[i].getName());\n        // It is a field\n        insertmember.setInt(3, 1);\n        // Insert the record\n        insertmember.executeUpdate();\n    }\n}\n","name":"storeClass","className":"MakeAPIDB","variables":{"insertpackage":3,"c":3,"methods":3,"packagename":3,"packageId":1,"i":10,"insertmember":8,"pid":5,"insertclass":4,"classId":1,"package_to_id":2,"classname":3,"pos":3,"name":5,"Class":1,"fields":3,"Modifier":2},"constants":{"'.'":1,"\"\"":1,"0":4,"1":7,"2":4,"3":3,"null":1,"\"Storing data for: \"":1},"javaDoc":"Given a fully-qualified classname this method stores the package name in the package table (if it is not already there) stores the class name in the class table and then uses the Java Reflection API to look up all methods and fields of the class and stores those in the member table","comments":"Figure out what the package id is If there is one then this package has already been stored in the database Otherwise assign an id Now store the classname in the class table of the database This record includes the package id so that the class is linked to the package that contains it To store the class we set arguments to the PreparedStatement then execute that statement Now get a list of all non-private methods of the class and insert those into the \"members\" table of the database Each record includes the class id of the containing class and also a value that indicates that these are methods not fields Do the same thing for the non-private fields of the class Dynamically load the class Display output so the user knows that the program is progressing Figure out the packagename and the classname and store it and the packagename in the db Check hashtable Assign an id Remember it in the hashtable Set args to PreparedStatement Insert the package into db Set class identifier Set package identifier Set class name Insert the class record Get a list of methods For all non-private Set the class id Set the method name It is not a field Insert the record Get a list of fields For each non-private Set the class id Set the field name It is a field Insert the record \n   * Given a fully-qualified classname, this method stores the package name\n   * in the package table (if it is not already there), stores the class name\n   * in the class table, and then uses the Java Reflection API to look up all\n   * methods and fields of the class, and stores those in the member table.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String"],"returnType":"MudServer","methodCalls":{},"annotations":[],"exceptions":["PlaceAlreadyExists","RemoteException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":5,"AssignExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n   * Start a MUD from scratch, with the given name and password.  Create\n   * an initial MudPlace object as the entrance, giving it the specified\n   * name and description.\n   **/\npublic MudServer(String mudname, String password, String placename, String description) throws RemoteException {\n    this.mudname = mudname;\n    this.password = password;\n    this.places = new Hashtable();\n    // Create the entrance place\n    try {\n        this.entrance = new MudPlace(this, placename, description);\n    }// Should never happen\n     catch (PlaceAlreadyExists e) {\n    }\n}\n","name":"MudServer","className":"MudServer","variables":{"password":1,"mudname":1,"e":1,"description":1,"placename":1},"constants":{},"javaDoc":"Start a MUD from scratch with the given name and password Create an initial MudPlace object as the entrance giving it the specified name and description","comments":"Create the entrance place Should never happen \n   * Start a MUD from scratch, with the given name and password.  Create\n   * an initial MudPlace object as the entrance, giving it the specified\n   * name and description.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** For serialization only.  Never call this constructor. */\npublic MudServer() throws RemoteException {\n}\n","name":"MudServer","className":"MudServer","variables":{},"constants":{},"javaDoc":"For serialization only Never call this constructor","comments":" For serialization only.  Never call this constructor. ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the name of the MUD */\npublic String getMudName() throws RemoteException {\n    return mudname;\n}\n","name":"getMudName","className":"MudServer","variables":{"mudname":1},"constants":{},"javaDoc":"This remote method returns the name of the MUD","comments":" This remote method returns the name of the MUD ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the entrance place of the MUD */\npublic RemoteMudPlace getEntrance() throws RemoteException {\n    return entrance;\n}\n","name":"getEntrance","className":"MudServer","variables":{"entrance":1},"constants":{},"javaDoc":"This remote method returns the entrance place of the MUD","comments":" This remote method returns the entrance place of the MUD ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPlace","methodCalls":{"get":1},"annotations":[],"exceptions":["NoSuchPlace","RemoteException"],"concepts":["Casting"],"types":{"RemoteMudPlace":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This remote method returns a RemoteMudPlace object for the named place.\n   * In this sense, a MudServer acts as like an RMI Registry object, returning\n   * remote objects looked up by name.  It is simpler to do it this way than\n   * to use an actual Registry object.  If the named place does not exist,\n   * it throws a NoSuchPlace exception\n   **/\npublic RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace {\n    RemoteMudPlace p = (RemoteMudPlace) places.get(name);\n    if (p == null)\n        throw new NoSuchPlace();\n    return p;\n}\n","name":"getNamedPlace","className":"MudServer","variables":{"p":3,"places":1},"constants":{"null":1},"javaDoc":"This remote method returns a RemoteMudPlace object for the named place In this sense a MudServer acts as like an RMI Registry object returning remote objects looked up by name It is simpler to do it this way than to use an actual Registry object If the named place does not exist it throws a NoSuchPlace exception","comments":"\n   * This remote method returns a RemoteMudPlace object for the named place.\n   * In this sense, a MudServer acts as like an RMI Registry object, returning\n   * remote objects looked up by name.  It is simpler to do it this way than\n   * to use an actual Registry object.  If the named place does not exist,\n   * it throws a NoSuchPlace exception\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPlace","String"],"returnType":"void","methodCalls":{"containsKey":1,"put":1},"annotations":[],"exceptions":["PlaceAlreadyExists"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n   * Define a new placename to place mapping in our hashtable.  \n   * This is not a remote method.  The MudPlace() constructor calls it\n   * to register the new place it is creating.\n   **/\npublic void setPlaceName(RemoteMudPlace place, String name) throws PlaceAlreadyExists {\n    if (places.containsKey(name))\n        throw new PlaceAlreadyExists();\n    places.put(name, place);\n}\n","name":"setPlaceName","className":"MudServer","variables":{"places":2},"constants":{},"javaDoc":"Define a new placename to place mapping in our hashtable This is not a remote method The MudPlace() constructor calls it to register the new place it is creating","comments":"\n   * Define a new placename to place mapping in our hashtable.  \n   * This is not a remote method.  The MudPlace() constructor calls it\n   * to register the new place it is creating.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"writeObject":1,"this.password.equals":1,"close":1},"annotations":[],"exceptions":["BadPassword","IOException","RemoteException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"/**\n   * This remote method serializes and compresses the state of the MUD\n   * to a named file, if the specified password matches the one specified\n   * when the MUD was initially created.  Note that the state of a MUD\n   * consists of all places in the MUD, with all things and exits in those\n   * places.  The people in the MUD are not part of the state that is saved.\n   **/\npublic void dump(String password, String f) throws RemoteException, BadPassword, IOException {\n    if ((this.password != null) && !this.password.equals(password))\n        throw new BadPassword();\n    ObjectOutputStream out = new ObjectOutputStream(new GZIPOutputStream(new FileOutputStream(f)));\n    out.writeObject(this);\n    out.close();\n}\n","name":"dump","className":"MudServer","variables":{"f":1,"out":3},"constants":{"null":1},"javaDoc":"This remote method serializes and compresses the state of the MUD to a named file if the specified password matches the one specified when the MUD was initially created Note that the state of a MUD consists of all places in the MUD with all things and exits in those places The people in the MUD are not part of the state that is saved","comments":"\n   * This remote method serializes and compresses the state of the MUD\n   * to a named file, if the specified password matches the one specified\n   * when the MUD was initially created.  Note that the state of a MUD\n   * consists of all places in the MUD, with all things and exits in those\n   * places.  The people in the MUD are not part of the state that is saved.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"setSecurityManager":1,"rebind":1,"readObject":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"MudServer":1,"FileInputStream":1,"ObjectInputStream":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":4,"NameExpr":41,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":10},"text":"/**\n   * This main() method defines the standalone program that starts up a MUD\n   * server.  If invoked with a single argument, it treats that argument as\n   * the name of a file containing the serialized and compressed state of an\n   * existing MUD, and recreates it.  Otherwise, it expects four command-line\n   * arguments: the name of the MUD, the password, the name of the entrance\n   * place for the MUD, and a description of that entrance place.\n   * Besides creating the MudServer object, this program sets an appropriate\n   * security manager, and uses the default rmiregistry to register the\n   * the MudServer under its given name.\n   **/\npublic static void main(String[] args) {\n    try {\n        MudServer server;\n        if (args.length == 1) {\n            // Read the MUD state in from a file\n            FileInputStream f = new FileInputStream(args[0]);\n            ObjectInputStream in = new ObjectInputStream(new GZIPInputStream(f));\n            server = (MudServer) in.readObject();\n        } else\n            // Otherwise, create an initial MUD from scratch\n            server = new MudServer(args[0], args[1], args[2], args[3]);\n        System.setSecurityManager(new RMISecurityManager());\n        Naming.rebind(Mud.mudPrefix + server.mudname, server);\n    }// Display an error message if anything goes wrong.\n     catch (Exception e) {\n        System.out.println(e);\n        System.out.println(\"Usage: java MudServer <savefile>\\n\" + \"   or: java MudServer <mudname> <password> \" + \"<placename> <description>\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"MudServer","variables":{"args":5,"server":3,"in":2,"e":1,"f":2,"Naming":1,"System":2},"constants":{"0":2,"1":3,"2":1,"3":1,"\"   or: java MudServer <mudname> <password> \"":1,"\"Usage: java MudServer <savefile>\\n\"":1,"\"<placename> <description>\"":1},"javaDoc":"This main() method defines the standalone program that starts up a MUD server If invoked with a single argument it treats that argument as the name of a file containing the serialized and compressed state of an existing MUD and recreates it Otherwise it expects four command-line arguments: the name of the MUD the password the name of the entrance place for the MUD and a description of that entrance place Besides creating the MudServer object this program sets an appropriate security manager and uses the default rmiregistry to register the the MudServer under its given name","comments":"Read the MUD state in from a file Otherwise create an initial MUD from scratch Display an error message if anything goes wrong \n   * This main() method defines the standalone program that starts up a MUD\n   * server.  If invoked with a single argument, it treats that argument as\n   * the name of a file containing the serialized and compressed state of an\n   * existing MUD, and recreates it.  Otherwise, it expects four command-line\n   * arguments: the name of the MUD, the password, the name of the entrance\n   * place for the MUD, and a description of that entrance place.\n   * Besides creating the MudServer object, this program sets an appropriate\n   * security manager, and uses the default rmiregistry to register the\n   * the MudServer under its given name.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getConnection":1,"lookup":1,"getProperty":4,"load":1,"forName":1,"list":1,"close":1,"setReadOnly":1,"System.out.println":3},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"Connection":1,"String":6,"Properties":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":10,"ArrayAccessExpr":5,"BinaryExpr":4,"StringLiteralExpr":14,"NameExpr":86,"UnaryExpr":2,"InstanceOfExpr":1,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":6,"TryStmt":3,"BlockStmt":8,"ForStmt":1,"ThrowStmt":2,"ExpressionStmt":22},"text":"public static void main(String[] args) {\n    // JDBC connection to the database\n    Connection c = null;\n    try {\n        // Some default values\n        // The name to look up\n        String target = null;\n        // List members or lookup name?\n        boolean list = false;\n        // The properties file of db parameters\n        String propfile = \"APIDB.props\";\n        // Parse the command-line arguments\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-l\"))\n                list = true;\n            else if (args[i].equals(\"-p\"))\n                propfile = args[++i];\n            else if (target != null)\n                throw new IllegalArgumentException(\"Unexpected argument: \" + args[i]);\n            else\n                target = args[i];\n        }\n        if (target == null)\n            throw new IllegalArgumentException(\"No target specified\");\n        // Now determine the values needed to set up the database connection\n        // The program attempts to read a property file named \"APIDB.props\",\n        // or optionally specified with the -p argument.  This property file\n        // may contain \"driver\", \"database\", \"user\", and \"password\" properties\n        // that specify the necessary values for connecting to the db.\n        // If the properties file does not exist, or does not contain the named\n        // properties, defaults will be used.\n        // Empty properties\n        Properties p = new Properties();\n        try // Try to load props\n        {\n            p.load(new FileInputStream(propfile));\n        } catch (Exception e) {\n        }\n        // Read values from Properties file, using defaults if not found.\n        // These defaults will probably not work for you!\n        String driver = p.getProperty(\"driver\", \"postgres95.PGDriver\");\n        String database = p.getProperty(\"database\", \"jdbc:postgres95:///APIDB\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // Load the database driver\n        Class.forName(driver);\n        // And set up a connection to the specified database\n        c = DriverManager.getConnection(database, user, password);\n        // Tell it we will not do any updates.  This hint may improve efficiency.\n        c.setReadOnly(true);\n        // member, class, or package.\n        if (list)\n            list(c, target);\n        else\n            lookup(c, target);\n    }// a SQLException is thrown, display the extra state message it includes.\n     catch (Exception e) {\n        System.out.println(e);\n        if (e instanceof SQLException)\n            System.out.println(((SQLException) e).getSQLState());\n        System.out.println(\"Usage: java LookupAPI [-l] [-p <propfile>] target\");\n    } finally // Always close the DB connection when we're done with it.\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n       // If the \"-l\" option was given, then list the members of the named\n\n       // package or class.  Otherwise, lookup all matches for the specified\n\n        }\n    }\n}\n     // If anything goes wrong, print the exception and a usage message.  If\n\n","name":"main","className":"LookupAPI","variables":{"c":4,"e":5,"i":8,"list":3,"target":4,"args":5,"p":6,"propfile":3,"database":1,"password":1,"driver":1,"Class":1,"user":1,"DriverManager":1},"constants":{"\"jdbc:postgres95:///APIDB\"":1,"\"\"":2,"\"Unexpected argument: \"":1,"\"driver\"":1,"\"Usage: java LookupAPI [-l] [-p <propfile>] target\"":1,"false":1,"\"password\"":1,"\"postgres95.PGDriver\"":1,"\"-p\"":1,"0":1,"\"-l\"":1,"null":4,"\"APIDB.props\"":1,"true":2,"\"user\"":1,"\"No target specified\"":1,"\"database\"":1},"javaDoc":"","comments":"JDBC connection to the database If anything goes wrong print the exception and a usage message If Some default values Now determine the values needed to set up the database connection The program attempts to read a property file named \"APIDB props\" or optionally specified with the -p argument This property file may contain \"driver\" \"database\" \"user\" and \"password\" properties that specify the necessary values for connecting to the db If the properties file does not exist or does not contain the named properties defaults will be used Read values from Properties file using defaults if not found If the \"-l\" option was given then list the members of the named package or class Otherwise lookup all matches for the specified The name to look up List members or lookup name? The properties file of db parameters Parse the command-line arguments Empty properties Try to load props These defaults will probably not work for you! Load the database driver And set up a connection to the specified database Tell it we will not do any updates This hint may improve efficiency member class or package a SQLException is thrown display the extra state message it includes Always close the DB connection when we're done with it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection","String"],"returnType":"void","methodCalls":{"createStatement":1,"next":3,"getInt":1,"getResultSet":3,"getString":6,"close":1,"executeQuery":3,"System.out.println":3},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Statement":1,"ResultSet":1,"String":3,"int":1},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":6,"BinaryExpr":29,"NameExpr":80,"StringLiteralExpr":24,"FieldAccessExpr":3,"EnclosedExpr":2,"ConditionalExpr":1,"MethodCallExpr":21,"AssignExpr":2},"statements":{"WhileStmt":3,"BlockStmt":1,"ExpressionStmt":15},"text":"/**\n   * This method looks up all matches for the specified target string in the\n   * database.  First, it prints the full name of any members by that name.\n   * Then it prints the full name of any classes by that name.  Then it prints\n   * the name of any packages that contain the specified name\n   **/\npublic static void lookup(Connection c, String target) throws SQLException {\n    // Create the Statement object we'll use to query the database\n    Statement s = c.createStatement();\n    // Go find all class members with the specified name\n    s.executeQuery(\"SELECT DISTINCT \" + \"package.name, class.name, member.name, member.isField \" + \"FROM package, class, member \" + \"WHERE member.name='\" + target + \"' \" + \"  AND member.classId=class.id \" + \"  AND class.packageId=package.id\");\n    // Loop through the results, and print them out (if there are any).\n    ResultSet r = s.getResultSet();\n    while (r.next()) {\n        // package name\n        String pkg = r.getString(1);\n        // class name\n        String cls = r.getString(2);\n        // member name\n        String member = r.getString(3);\n        // is the member a field?\n        int isField = r.getInt(4);\n        // Display this match\n        System.out.println(pkg + \".\" + cls + \".\" + member + ((isField == 1) ? \"\" : \"()\"));\n    }\n    // Now look for a class with the specified name\n    s.executeQuery(\"SELECT package.name, class.name \" + \"FROM package, class \" + \"WHERE class.name='\" + target + \"' \" + \"  AND class.packageId=package.id\");\n    // Loop through the results and print them out\n    r = s.getResultSet();\n    while (r.next()) System.out.println(r.getString(1) + \".\" + r.getString(2));\n    // Finally, look for a package that matches a part of of the name.\n    // Note the use of the SQL LIKE keyword and % wildcard characters\n    s.executeQuery(\"SELECT name FROM package \" + \"WHERE name LIKE '%.\" + target + \".%' \" + \"   OR name LIKE '\" + target + \".%' \" + \"   OR name LIKE '%.\" + target + \"'\");\n    // Loop through the results and print them out\n    r = s.getResultSet();\n    while (r.next()) System.out.println(r.getString(1));\n    // Finally, close the Statement object\n    s.close();\n}\n","name":"lookup","className":"LookupAPI","variables":{"r":13,"s":8,"c":1,"isField":2,"member":2,"cls":2,"pkg":2,"target":5},"constants":{"\"\"":1,"\"WHERE name LIKE '%.\"":1,"\"WHERE member.name='\"":1,"\"FROM package, class \"":1,"\"   OR name LIKE '\"":1,"\"SELECT DISTINCT \"":1,"\"  AND member.classId=class.id \"":1,"\"package.name, class.name, member.name, member.isField \"":1,"\".%' \"":2,"\"()\"":1,"1":4,"2":2,"3":1,"4":1,"\"   OR name LIKE '%.\"":1,"\"  AND class.packageId=package.id\"":2,"\"FROM package, class, member \"":1,"\".\"":3,"\"' \"":2,"\"WHERE class.name='\"":1,"\"SELECT name FROM package \"":1,"\"'\"":1,"\"SELECT package.name, class.name \"":1},"javaDoc":"This method looks up all matches for the specified target string in the database First it prints the full name of any members by that name Then it prints the full name of any classes by that name Then it prints the name of any packages that contain the specified name","comments":"Finally look for a package that matches a part of of the name Create the Statement object we'll use to query the database Go find all class members with the specified name Loop through the results and print them out (if there are any) package name class name member name is the member a field? Display this match Now look for a class with the specified name Loop through the results and print them out Note the use of the SQL LIKE keyword and % wildcard characters Loop through the results and print them out Finally close the Statement object \n   * This method looks up all matches for the specified target string in the\n   * database.  First, it prints the full name of any members by that name.\n   * Then it prints the full name of any classes by that name.  Then it prints\n   * the name of any packages that contain the specified name\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection","String"],"returnType":"void","methodCalls":{"createStatement":2,"next":4,"getInt":1,"getResultSet":4,"getString":5,"close":2,"executeQuery":4,"System.out.println":5},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Statement":2,"ResultSet":3,"String":4,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":10,"BinaryExpr":39,"NameExpr":104,"StringLiteralExpr":36,"FieldAccessExpr":5,"EnclosedExpr":2,"ConditionalExpr":1,"MethodCallExpr":27,"AssignExpr":1},"statements":{"WhileStmt":4,"BlockStmt":3,"ExpressionStmt":22},"text":"/**\n   * This method looks for classes with the specified name, or packages\n   * that contain the specified name.  For each class it finds, it displays\n   * all methods and fields of the class.  For each package it finds, it\n   * displays all classes in the package.\n   **/\npublic static void list(Connection conn, String target) throws SQLException {\n    // Create two Statement objects to query the database with\n    Statement s = conn.createStatement();\n    Statement t = conn.createStatement();\n    // Look for a class with the given name\n    s.executeQuery(\"SELECT package.name, class.name \" + \"FROM package, class \" + \"WHERE class.name='\" + target + \"' \" + \"  AND class.packageId=package.id\");\n    // Loop through all matches\n    ResultSet r = s.getResultSet();\n    while (r.next()) {\n        // package name\n        String p = r.getString(1);\n        // class name\n        String c = r.getString(2);\n        // Print out the matching class name\n        System.out.println(\"class \" + p + \".\" + c + \" {\");\n        // Now query all members of the class\n        t.executeQuery(\"SELECT DISTINCT member.name, member.isField \" + \"FROM package, class, member \" + \"WHERE package.name = '\" + p + \"' \" + \"  AND class.name = '\" + c + \"' \" + \"  AND member.classId=class.id \" + \"  AND class.packageId=package.id \" + \"ORDER BY member.isField, member.name\");\n        // Loop through the ordered list of all members, and print them out\n        ResultSet r2 = t.getResultSet();\n        while (r2.next()) {\n            String m = r2.getString(1);\n            int isField = r2.getInt(2);\n            System.out.println(\"  \" + m + ((isField == 1) ? \"\" : \"()\"));\n        }\n        // End the class listing\n        System.out.println(\"}\");\n    }\n    // Now go look for a package that matches the specified name\n    s.executeQuery(\"SELECT name FROM package \" + \"WHERE name LIKE '%.\" + target + \".%' \" + \"   OR name LIKE '\" + target + \".%' \" + \"   OR name LIKE '%.\" + target + \"'\");\n    // Loop through any matching packages\n    r = s.getResultSet();\n    while (r.next()) {\n        // Display the name of the package\n        String p = r.getString(1);\n        System.out.println(\"Package \" + p + \": \");\n        // Get a list of all classes and interfaces in the package\n        t.executeQuery(\"SELECT class.name FROM package, class \" + \"WHERE package.name='\" + p + \"' \" + \"  AND class.packageId=package.id \" + \"ORDER BY class.name\");\n        // Loop through the list and print them out.\n        ResultSet r2 = t.getResultSet();\n        while (r2.next()) System.out.println(\"  \" + r2.getString(1));\n    }\n    // Finally, close both Statement objects\n    s.close();\n    t.close();\n}\n","name":"list","className":"LookupAPI","variables":{"p":6,"r2":7,"conn":2,"r":7,"s":6,"c":3,"t":6,"isField":2,"m":2,"target":4},"constants":{"\"\"":1,"\"WHERE name LIKE '%.\"":1,"\"SELECT DISTINCT member.name, member.isField \"":1,"\"   OR name LIKE '\"":1,"\"  AND member.classId=class.id \"":1,"\" {\"":1,"\": \"":1,"\"  \"":2,"\"()\"":1,"\"class \"":1,"\"ORDER BY member.isField, member.name\"":1,"\"ORDER BY class.name\"":1,"\"  AND class.packageId=package.id\"":1,"\".\"":1,"\"FROM package, class, member \"":1,"\"' \"":4,"\"WHERE class.name='\"":1,"\"Package \"":1,"\"SELECT name FROM package \"":1,"\"  AND class.name = '\"":1,"\"FROM package, class \"":1,"\"}\"":1,"\"SELECT class.name FROM package, class \"":1,"\"WHERE package.name='\"":1,"\".%' \"":2,"1":5,"2":2,"\"   OR name LIKE '%.\"":1,"\"  AND class.packageId=package.id \"":2,"\"'\"":1,"\"WHERE package.name = '\"":1,"\"SELECT package.name, class.name \"":1},"javaDoc":"This method looks for classes with the specified name or packages that contain the specified name For each class it finds it displays all methods and fields of the class For each package it finds it displays all classes in the package","comments":"Create two Statement objects to query the database with Look for a class with the given name Loop through all matches package name class name Print out the matching class name Now query all members of the class Loop through the ordered list of all members and print them out End the class listing Now go look for a package that matches the specified name Loop through any matching packages Display the name of the package Get a list of all classes and interfaces in the package Loop through the list and print them out Finally close both Statement objects \n   * This method looks for classes with the specified name, or packages\n   * that contain the specified name.  For each class it finds, it displays\n   * all methods and fields of the class.  For each package it finds, it\n   * displays all classes in the package.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":5,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"BinaryExpr":10,"NameExpr":37,"StringLiteralExpr":4,"FieldAccessExpr":6,"EnclosedExpr":6,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":3,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Every program must have main()\n    for (int i = 1; i <= 100; i++) {\n        // count from 1 to 100\n        if (// A multiple of both?\n        ((i % 5) == 0) && ((i % 7) == 0))\n            System.out.print(\"fizzbuzz\");\n        else if (// else a multiple of 5?\n        (i % 5) == 0)\n            // else a multiple of 5?\n            System.out.print(\"fizz\");\n        else if (// else a multiple of 7?\n        (i % 7) == 0)\n            // else a multiple of 7?\n            System.out.print(\"buzz\");\n        else\n            // else just print it\n            System.out.print(i);\n        System.out.print(\" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"FizzBuzz","variables":{"i":7},"constants":{"0":4,"1":1,"100":1,"\" \"":1,"5":2,"7":2,"\"buzz\"":1,"\"fizzbuzz\"":1,"\"fizz\"":1},"javaDoc":"","comments":"Every program must have main() count from 1 to 100 A multiple of both? else a multiple of 5? else a multiple of 5? else a multiple of 7? else a multiple of 7? else just print it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["URL"],"returnType":"void","methodCalls":{"getContentEncoding":1,"getLastModified":1,"getExpiration":1,"openConnection":1,"getResponseCode":1,"getContentType":1,"getDate":1,"getContentLength":1,"getResponseMessage":1,"getRequestMethod":1,"connect":1,"System.out.println":9},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"HttpURLConnection":1,"URLConnection":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":80,"StringLiteralExpr":9,"CastExpr":1,"FieldAccessExpr":9,"InstanceOfExpr":1,"MethodCallExpr":20},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"/** Use the URLConnection class to get info about the URL */\npublic static void printinfo(URL url) throws IOException {\n    // Get URLConnection from the URL\n    URLConnection c = url.openConnection();\n    // Open a connection to the URL\n    c.connect();\n    // Display some information about the URL contents\n    System.out.println(\"  Content Type: \" + c.getContentType());\n    System.out.println(\"  Content Encoding: \" + c.getContentEncoding());\n    System.out.println(\"  Content Length: \" + c.getContentLength());\n    System.out.println(\"  Date: \" + new Date(c.getDate()));\n    System.out.println(\"  Last Modified: \" + new Date(c.getLastModified()));\n    System.out.println(\"  Expiration: \" + new Date(c.getExpiration()));\n    // If it is an HTTP connection, display some additional information.\n    if (c instanceof HttpURLConnection) {\n        HttpURLConnection h = (HttpURLConnection) c;\n        System.out.println(\"  Request Method: \" + h.getRequestMethod());\n        System.out.println(\"  Response Message: \" + h.getResponseMessage());\n        System.out.println(\"  Response Code: \" + h.getResponseCode());\n    }\n}\n","name":"printinfo","className":"GetURLInfo","variables":{"c":10,"h":4,"url":1},"constants":{"\"  Content Encoding: \"":1,"\"  Response Message: \"":1,"\"  Content Type: \"":1,"\"  Response Code: \"":1,"\"  Last Modified: \"":1,"\"  Request Method: \"":1,"\"  Content Length: \"":1,"\"  Date: \"":1,"\"  Expiration: \"":1},"javaDoc":"Use the URLConnection class to get info about the URL","comments":"Get URLConnection from the URL Open a connection to the URL Display some information about the URL contents If it is an HTTP connection display some additional information  Use the URLConnection class to get info about the URL ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printinfo":1,"System.err.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** Create a URL object, call printinfo() to display information about it. */\npublic static void main(String[] args) {\n    try {\n        printinfo(new URL(args[0]));\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GetURLInfo <url>\");\n    }\n}\n","name":"main","className":"GetURLInfo","variables":{"args":1,"e":1},"constants":{"0":1,"\"Usage: java GetURLInfo <url>\"":1},"javaDoc":"Create a URL object call printinfo() to display information about it","comments":" Create a URL object, call printinfo() to display information about it. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Reader"],"returnType":"RemoveHTMLReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** A trivial constructor.  Just initialze our superclass */\npublic RemoveHTMLReader(Reader in) {\n    super(in);\n}\n","name":"RemoveHTMLReader","className":"RemoveHTMLReader","variables":{"in":1},"constants":{},"javaDoc":"A trivial constructor Just initialze our superclass","comments":" A trivial constructor.  Just initialze our superclass ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"int","methodCalls":{"read":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":4,"BinaryExpr":7,"BooleanLiteralExpr":2,"NameExpr":30,"CharLiteralExpr":2,"UnaryExpr":5,"AssignExpr":5,"MethodCallExpr":1},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":7},"text":"/** \n   * This is the implementation of the no-op read() method of FilterReader.\n   * It calls in.read() to get a buffer full of characters, then strips\n   * out the HTML tags.  (in is a protected field of the superclass).\n   **/\npublic int read(char[] buf, int from, int len) throws IOException {\n    // how many characters have been read\n    int numchars = 0;\n    // all out, leaving us with zero characters to return.\n    while (numchars == 0) {\n        // Read characters\n        numchars = in.read(buf, from, len);\n        // Check for EOF and handle it.\n        if (numchars == -1)\n            return -1;\n        // Loop through the characters we read, stripping out HTML tags.\n        // Characters not in tags are copied over any previous tags in the buffer\n        // Index of last non-HTML char\n        int last = from;\n        for (int i = from; i < from + numchars; i++) {\n            if (!intag) {\n                // If not in an HTML tag\n                if (//   check for start of a tag\n                buf[i] == '<')\n                    //   check for start of a tag\n                    intag = true;\n                else\n                    //   and copy the character\n                    buf[last++] = buf[i];\n     // Loop, because we might read a bunch of characters, then strip them\n\n            } else // Else, check for end of tag\n            if (buf[i] == '>')\n                intag = false;\n        }\n        // Figure out how many characters remain\n        numchars = last - from;\n    }\n    // Then return that number.\n    return numchars;\n}\n                                 // And if it is more than zero characters\n\n","name":"read","className":"RemoveHTMLReader","variables":{"buf":4,"last":3,"in":1,"numchars":7,"i":6,"from":4,"intag":3},"constants":{"0":2,"'>'":1,"1":2,"'<'":1,"true":1,"false":1},"javaDoc":"This is the implementation of the no-op read() method of FilterReader It calls in read() to get a buffer full of characters then strips out the HTML tags (in is a protected field of the superclass)","comments":"Loop because we might read a bunch of characters then strip them And if it is more than zero characters how many characters have been read all out leaving us with zero characters to return Loop through the characters we read stripping out HTML tags Characters not in tags are copied over any previous tags in the buffer Read characters Check for EOF and handle it Index of last non-HTML char If not in an HTML tag check for start of a tag check for start of a tag and copy the character Else check for end of tag Figure out how many characters remain Then return that number  \n   * This is the implementation of the no-op read() method of FilterReader.\n   * It calls in.read() to get a buffer full of characters, then strips\n   * out the HTML tags.  (in is a protected field of the superclass).\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"read":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":5,"CastExpr":1,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** \n   * This is another no-op read() method we have to implement.  We \n   * implement it in terms of the method above.  Our superclass implements\n   * the remaining read() methods in terms of these two.\n   **/\npublic int read() throws IOException {\n    char[] buf = new char[1];\n    int result = read(buf, 0, 1);\n    if (result == -1)\n        return -1;\n    else\n        return (int) buf[0];\n}\n","name":"read","className":"RemoveHTMLReader","variables":{"result":2,"buf":2},"constants":{"0":2,"1":4},"javaDoc":"This is another no-op read() method we have to implement We implement it in terms of the method above Our superclass implements the remaining read() methods in terms of these two","comments":" \n   * This is another no-op read() method we have to implement.  We \n   * implement it in terms of the method above.  Our superclass implements\n   * the remaining read() methods in terms of these two.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.err.println":2,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":2,"FieldAccessExpr":4,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":6},"text":"/** The test program: read a text file, strip HTML, print to console */\npublic static void main(String[] args) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Create a stream to read from the file and strip tags from it\n        BufferedReader in = new BufferedReader(new RemoveHTMLReader(new FileReader(args[0])));\n        // Read line by line, printing lines to the console\n        String line;\n        while ((line = in.readLine()) != null) System.out.println(line);\n        // Close the stream.\n        in.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java RemoveHTMLReader$Test <filename>\");\n    }\n}\n","name":"main","className":"Test","variables":{"args":1,"in":3,"e":1,"line":2},"constants":{"0":1,"1":1,"null":1,"\"Usage: java RemoveHTMLReader$Test <filename>\"":1,"\"Wrong number of arguments\"":1},"javaDoc":"The test program: read a text file strip HTML print to console","comments":"Create a stream to read from the file and strip tags from it Read line by line printing lines to the console Close the stream  The test program: read a text file, strip HTML, print to console ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"receive":1,"getHostName":1,"getLength":1,"getAddress":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"DatagramSocket":1,"DatagramPacket":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":42,"StringLiteralExpr":3,"FieldAccessExpr":5,"ArrayCreationExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"public static void main(String args[]) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Get the port from the command line\n        int port = Integer.parseInt(args[0]);\n        // Create a socket to listen on the port.\n        DatagramSocket dsocket = new DatagramSocket(port);\n        // Create a buffer to read datagrams into.  If anyone sends us a \n        // packet containing more than will fit into this buffer, the excess\n        // will simply be discarded!\n        byte[] buffer = new byte[2048];\n        // Now loop forever, waiting to receive packets and printing them out.\n        for (; ; ) {\n            // Create a packet with an empty buffer to receive data\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            // Wait to receive a datagram\n            dsocket.receive(packet);\n            // Convert the contents to a string, and display them\n            String msg = new String(buffer, 0, packet.getLength());\n            System.out.println(packet.getAddress().getHostName() + \": \" + msg);\n        }\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java UDPReceive <port>\");\n    }\n}\n","name":"main","className":"UDPReceive","variables":{"Integer":1,"args":1,"dsocket":2,"msg":2,"port":2,"e":1,"buffer":3,"packet":3},"constants":{"0":2,"\"Usage: java UDPReceive <port>\"":1,"1":1,"2048":1,"\"Wrong number of arguments\"":1,"\": \"":1},"javaDoc":"","comments":"Create a buffer to read datagrams into If anyone sends us a packet containing more than will fit into this buffer the excess Get the port from the command line Create a socket to listen on the port will simply be discarded! Now loop forever waiting to receive packets and printing them out Create a packet with an empty buffer to receive data Wait to receive a datagram Convert the contents to a string and display them ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"print":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    print();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"PrintScribble","methodCalls":{"exit":1,"print":1,"addActionListener":1,"enableEvents":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Button":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":5,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":34,"FieldAccessExpr":3,"ThisExpr":5,"MethodCallExpr":9},"statements":{"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":10},"text":"public PrintScribble() {\n    super(\"PrintScribble\");\n    // Add a print button.\n    this.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));\n    Button b = new Button(\"Print\");\n    this.add(b);\n    // Call the print() method when the button is clicked.\n    // Note anonymous class.\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            print();\n        }\n    });\n    // Exit when the user closes the window.\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Register other event types we're interested in -- for scribbling\n    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);\n    // Set our initial size and pop the window up.\n    this.setSize(400, 400);\n    this.show();\n}\n","name":"PrintScribble","className":"PrintScribble","variables":{"actionPerformed":1,"b":2,"e":2,"windowClosing":1,"System":1},"constants":{"0":1,"400":2,"5":2,"\"PrintScribble\"":1,"\"Print\"":1},"javaDoc":"","comments":"Call the print() method when the button is clicked Add a print button Note anonymous class Exit when the user closes the window Register other event types we're interested in -- for scribbling Set our initial size and pop the window up ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"CastExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** Redraw (or print) the scribble based on stored lines */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) {\n        Line l = (Line) lines.elementAt(i);\n        g.drawLine(l.x1, l.y1, l.x2, l.y2);\n    }\n}\n","name":"paint","className":"PrintScribble","variables":{"g":1,"i":3,"lines":2,"l":1},"constants":{"0":1},"javaDoc":"Redraw (or print) the scribble based on stored lines","comments":" Redraw (or print) the scribble based on stored lines ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getPrintJob":1,"setClip":1,"dispose":1,"end":1,"getGraphics":1,"drawRect":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"PrintJob":1,"Toolkit":1,"Dimension":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":42,"StringLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":2,"ThisExpr":4,"MethodCallExpr":10},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Print out the scribble */\nvoid print() {\n    // Obtain a PrintJob and a Graphics object to use with it\n    Toolkit toolkit = this.getToolkit();\n    PrintJob job = toolkit.getPrintJob(this, \"PrintScribble\", printprefs);\n    // If the user clicked Cancel in the print dialog\n    if (job == null)\n        return;\n    Graphics g = job.getGraphics();\n    // Give the output a larger top and left margin.  Otherwise it will\n    // be scrunched up in the upper-left corner of the page.\n    g.translate(100, 100);\n    // Draw a border around the output area.\n    Dimension size = this.getSize();\n    g.drawRect(-1, -1, size.width + 1, size.height + 1);\n    // Set a clipping region so our scribbles don't go outside the border\n    // On-screen this happens automatically, but not on paper.\n    g.setClip(0, 0, size.width, size.height);\n    // Print this component and all components it contains\n    // Use print() if you don't want the button to show\n    this.printAll(g);\n    // Finish up.\n    // End the page\n    g.dispose();\n    // End the job\n    job.end();\n}\n","name":"print","className":"PrintScribble","variables":{"size":1,"toolkit":2,"g":5,"job":4},"constants":{"0":2,"100":2,"1":4,"null":1,"\"PrintScribble\"":1},"javaDoc":"Print out the scribble","comments":"Give the output a larger top and left margin Otherwise it will Set a clipping region so our scribbles don't go outside the border Print this component and all components it contains Finish up Obtain a PrintJob and a Graphics object to use with it If the user clicked Cancel in the print dialog be scrunched up in the upper-left corner of the page Draw a border around the output area On-screen this happens automatically but not on paper Use print() if you don't want the button to show End the page End the job  Print out the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":17,"CastExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Called when the user clicks */\npublic void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // remember click position\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"PrintScribble","variables":{"e":3,"last_x":1,"last_y":1},"constants":{},"javaDoc":"Called when the user clicks","comments":"remember click position  Called when the user clicks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":3,"getY":3,"getID":1,"getGraphics":1,"drawLine":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":41,"CastExpr":4,"FieldAccessExpr":1,"MethodCallExpr":11,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/** Called when the the user drags the mouse: does the scribbling */\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        Graphics g = getGraphics();\n        // draw the line\n        g.drawLine(last_x, last_y, e.getX(), e.getY());\n        lines.addElement(new // and save the line\n        Line(// and save the line\n        last_x, // and save the line\n        last_y, (short) e.getX(), (short) e.getY()));\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"PrintScribble","variables":{"e":7,"g":2,"last_x":2,"last_y":2,"lines":1},"constants":{},"javaDoc":"Called when the the user drags the mouse: does the scribbling","comments":"draw the line and save the line and save the line and save the line  Called when the the user drags the mouse: does the scribbling ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"PrintScribble":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The main method.  Create a PrintScribble() object and away we go! */\npublic static void main(String[] args) {\n    PrintScribble s = new PrintScribble();\n}\n","name":"main","className":"PrintScribble","variables":{"s":1},"constants":{},"javaDoc":"The main method Create a PrintScribble() object and away we go!","comments":" The main method.  Create a PrintScribble() object and away we go! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["short","short","short","short"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Line(short x1, short y1, short x2, short y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Line","className":"Line","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"public void init() {\n    // Create and specify the layout manager for the applet container.\n    // Leave 10 pixels of horizontal and vertical space between components.\n    // Left justify rows.\n    this.setLayout(new FlowLayout(FlowLayout.LEFT, 10, 10));\n    // Used to make the buttons different sizes\n    String spaces = \"\";\n    for (int i = 1; i <= 9; i++) {\n        this.add(new Button(\"Button #\" + i + spaces));\n        spaces += \" \";\n    }\n}\n","name":"init","className":"FlowLayoutExample","variables":{"spaces":3,"i":4},"constants":{"\"\"":1,"1":1,"\" \"":1,"9":1,"\"Button #\"":1,"10":2},"javaDoc":"","comments":"Create and specify the layout manager for the applet container Leave 10 pixels of horizontal and vertical space between components Left justify rows Used to make the buttons different sizes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"getProtocol":1,"getFile":1,"getInputStream":1,"println":1,"getPort":1,"flush":1,"equals":1,"getOutputStream":1,"System.err.println":2,"write":1,"close":2,"getHost":1},"annotations":[],"exceptions":["// Report any errors that arise\nException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"String":3,"URL":1,"int":2,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":7,"VariableDeclarationExpr":11,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":75,"StringLiteralExpr":5,"UnaryExpr":3,"AssignExpr":4,"FieldAccessExpr":6,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":15},"statements":{"IfStmt":4,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":2,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    try {\n        // Check the arguments\n        if ((args.length != 1) && (args.length != 2))\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Get an output stream to write the URL contents to\n        OutputStream to_file;\n        if (args.length == 2)\n            to_file = new FileOutputStream(args[1]);\n        else\n            to_file = System.out;\n        // Now use the URL class to parse the user-specified URL into\n        // its various parts: protocol, host, port, filename.  Check the protocol\n        URL url = new URL(args[0]);\n        String protocol = url.getProtocol();\n        if (!protocol.equals(\"http\"))\n            throw new IllegalArgumentException(\"URL must use 'http:' protocol\");\n        String host = url.getHost();\n        int port = url.getPort();\n        // if no port, use the default HTTP port\n        if (port == -1)\n            port = 80;\n        String filename = url.getFile();\n        // Open a network socket connection to the specified host and port\n        Socket socket = new Socket(host, port);\n        // Get input and output streams for the socket\n        InputStream from_server = socket.getInputStream();\n        PrintWriter to_server = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n        // Send the HTTP GET command to the Web server, specifying the file.\n        // This uses an old and very simple version of the HTTP protocol\n        to_server.println(\"GET \" + filename);\n        // Send it right now!\n        to_server.flush();\n        // Now read the server's response, and write it to the file\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = from_server.read(buffer)) != -1) to_file.write(buffer, 0, bytes_read);\n        // When the server closes the connection, we close our stuff\n        socket.close();\n        to_file.close();\n    } catch (// Report any errors that arise\n    Exception // Report any errors that arise\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java HttpClient <URL> [<filename>]\");\n    }\n}\n","name":"main","className":"HttpClient","variables":{"e":1,"to_file":5,"from_server":2,"bytes_read":2,"url":5,"args":2,"to_server":3,"protocol":2,"filename":2,"port":4,"host":2,"socket":4,"buffer":1},"constants":{"0":2,"\"Usage: java HttpClient <URL> [<filename>]\"":1,"1":4,"4096":1,"2":2,"\"Wrong number of arguments\"":1,"80":1,"\"GET \"":1,"\"http\"":1,"\"URL must use 'http:' protocol\"":1},"javaDoc":"","comments":"Now use the URL class to parse the user-specified URL into Send the HTTP GET command to the Web server specifying the file Check the arguments Get an output stream to write the URL contents to its various parts: protocol host port filename Check the protocol if no port use the default HTTP port Open a network socket connection to the specified host and port Get input and output streams for the socket This uses an old and very simple version of the HTTP protocol Send it right now! Now read the server's response and write it to the file When the server closes the connection we close our stuff Report any errors that arise Report any errors that arise ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"MudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** A no-arg constructor for de-serialization only.  Do not call it */\npublic MudPlace() throws RemoteException {\n    super();\n}\n","name":"MudPlace","className":"MudPlace","variables":{},"constants":{},"javaDoc":"A no-arg constructor for de-serialization only Do not call it","comments":" A no-arg constructor for de-serialization only.  Do not call it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MudServer","String","String"],"returnType":"MudPlace","methodCalls":{"setPlaceName":1},"annotations":[],"exceptions":["PlaceAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":13,"FieldAccessExpr":3,"ThisExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n   * This constructor creates a place, and calls a server method\n   * to register the object so that it will be accessible by name\n   **/\npublic MudPlace(MudServer server, String placename, String description) throws RemoteException, PlaceAlreadyExists {\n    this.server = server;\n    this.placename = placename;\n    this.description = description;\n    // Register the place\n    server.setPlaceName(this, placename);\n}\n","name":"MudPlace","className":"MudPlace","variables":{"server":2,"description":1,"placename":1},"constants":{},"javaDoc":"This constructor creates a place and calls a server method to register the object so that it will be accessible by name","comments":"Register the place \n   * This constructor creates a place, and calls a server method\n   * to register the object so that it will be accessible by name\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the name of this place */\npublic String getPlaceName() throws RemoteException {\n    return placename;\n}\n","name":"getPlaceName","className":"MudPlace","variables":{"placename":1},"constants":{},"javaDoc":"This remote method returns the name of this place","comments":" This remote method returns the name of this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the description of this place */\npublic String getDescription() throws RemoteException {\n    return description;\n}\n","name":"getDescription","className":"MudPlace","variables":{"description":1},"constants":{},"javaDoc":"This remote method returns the description of this place","comments":" This remote method returns the description of this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of people in this place */\npublic Vector getNames() throws RemoteException {\n    return names;\n}\n","name":"getNames","className":"MudPlace","variables":{"names":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of people in this place","comments":" This remote method returns a Vector of names of people in this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of things in this place */\npublic Vector getThings() throws RemoteException {\n    return things;\n}\n","name":"getThings","className":"MudPlace","variables":{"things":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of things in this place","comments":" This remote method returns a Vector of names of things in this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of exits from this place */\npublic Vector getExits() throws RemoteException {\n    return exits;\n}\n","name":"getExits","className":"MudPlace","variables":{"exits":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of exits from this place","comments":" This remote method returns a Vector of names of exits from this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPerson","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NoSuchPerson","RemoteException"],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n   * This remote method returns a RemoteMudPerson object corresponding to\n   * the specified name, or throws an exception if no such person is here \n   **/\npublic RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson {\n    synchronized (names) {\n        // What about when there are 2 of the same name?\n        int i = names.indexOf(name);\n        if (i == -1)\n            throw new NoSuchPerson();\n        return (RemoteMudPerson) people.elementAt(i);\n    }\n}\n","name":"getPerson","className":"MudPlace","variables":{"names":2,"i":2,"people":1},"constants":{"1":1},"javaDoc":"This remote method returns a RemoteMudPerson object corresponding to the specified name or throws an exception if no such person is here","comments":"What about when there are 2 of the same name?  \n   * This remote method returns a RemoteMudPerson object corresponding to\n   * the specified name, or throws an exception if no such person is here \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NoSuchThing","RemoteException"],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n   * This remote method returns a description of the named thing, or\n   * throws an exception if no such thing is in this place.\n   **/\npublic String examineThing(String name) throws RemoteException, NoSuchThing {\n    synchronized (things) {\n        int i = things.indexOf(name);\n        if (i == -1)\n            throw new NoSuchThing();\n        return (String) descriptions.elementAt(i);\n    }\n}\n","name":"examineThing","className":"MudPlace","variables":{"things":2,"i":2,"descriptions":1},"constants":{"1":1},"javaDoc":"This remote method returns a description of the named thing or throws an exception if no such thing is in this place","comments":" \n   * This remote method returns a description of the named thing, or\n   * throws an exception if no such thing is in this place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"RemoteMudPlace","methodCalls":{"getMudName":1,"lookup":1,"getNamedPlace":1,"verifyPresence":1,"elementAt":1,"enter":1,"indexOf":2,"substring":2},"annotations":[],"exceptions":["LinkFailed","NotThere","NoSuchExit","AlreadyThere","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"Object":1,"String":5,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":10,"BinaryExpr":8,"NameExpr":59,"StringLiteralExpr":3,"CharLiteralExpr":1,"UnaryExpr":1,"InstanceOfExpr":2,"AssignExpr":5,"CastExpr":3,"ThisExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":3,"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":17},"text":"/** \n   * This remote method moves the specified RemoteMudPerson from this place\n   * in the named direction (i.e. through the named exit) to whatever place\n   * is there.  It throws exceptions if the specified person isn't in this\n   * place to begin with, or if they are already in the place through the exit\n   * or if the exit doesn't exist, or if the exit links to another MUD server\n   * and the server is not functioning.\n   **/\npublic RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed {\n    // Make sure the direction is valid, and get destination if it is\n    Object destination;\n    synchronized (exits) {\n        int i = exits.indexOf(direction);\n        if (i == -1)\n            throw new NoSuchExit();\n        destination = destinations.elementAt(i);\n    }\n    // If destination is a string, it is a place on another server, so connect \n    // to that server.  Otherwise, it is a place already on this server.  \n    // Throw an exception if we can't connect to the server.\n    RemoteMudPlace newplace;\n    if (destination instanceof String) {\n        try {\n            String t = (String) destination;\n            int pos = t.indexOf('@');\n            String url = t.substring(0, pos);\n            String placename = t.substring(pos + 1);\n            RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);\n            newplace = s.getNamedPlace(placename);\n        } catch (Exception e) {\n            throw new LinkFailed();\n        }\n    } else\n        // If the destination is not a string, then it is a Place\n        newplace = (RemoteMudPlace) destination;\n    // Make sure the person is here and get their name.  \n    // Throw an exception if they are not here\n    String name = verifyPresence(who);\n    // Move the person out of here, and tell everyone who remains about it.\n    this.exit(who, name + \" has gone \" + direction);\n    // Put the person into the new place.  \n    // Send a message to everyone already in that new place\n    String fromwhere;\n    if (// going to a local place\n    newplace instanceof MudPlace)\n        fromwhere = placename;\n    else\n        fromwhere = server.getMudName() + \".\" + placename;\n    newplace.enter(who, name, name + \" has arrived from: \" + fromwhere);\n    // know where they are now at.\n    return newplace;\n}\n     // Return the new RemoteMudPlace object to the client so they\n\n","name":"go","className":"MudPlace","variables":{"server":1,"newplace":6,"e":1,"fromwhere":4,"destinations":1,"destination":5,"i":2,"placename":3,"Naming":1,"url":1,"exits":2,"s":2,"t":4,"pos":2,"name":3,"direction":1},"constants":{"0":1,"1":2,"\" has arrived from: \"":1,"\" has gone \"":1,"\".\"":1,"'@'":1},"javaDoc":"This remote method moves the specified RemoteMudPerson from this place in the named direction (i e through the named exit) to whatever place is there It throws exceptions if the specified person isn't in this place to begin with or if they are already in the place through the exit or if the exit doesn't exist or if the exit links to another MUD server and the server is not functioning","comments":"If destination is a string it is a place on another server so connect to that server Otherwise it is a place already on this server Make sure the person is here and get their name Put the person into the new place Return the new RemoteMudPlace object to the client so they Make sure the direction is valid and get destination if it is Throw an exception if we can't connect to the server If the destination is not a string then it is a Place Throw an exception if they are not here Move the person out of here and tell everyone who remains about it Send a message to everyone already in that new place going to a local place know where they are now at  \n   * This remote method moves the specified RemoteMudPerson from this place\n   * in the named direction (i.e. through the named exit) to whatever place\n   * is there.  It throws exceptions if the specified person isn't in this\n   * place to begin with, or if they are already in the place through the exit\n   * or if the exit doesn't exist, or if the exit links to another MUD server\n   * and the server is not functioning.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n   * This remote method sends a message to everyone in the room.  Used to\n   * say things to everyone.  Requires that the speaker be in this place.\n   **/\npublic void speak(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere {\n    String name = verifyPresence(speaker);\n    tellEveryone(name + \":\" + msg);\n}\n","name":"speak","className":"MudPlace","variables":{"msg":1,"name":2},"constants":{"\":\"":1},"javaDoc":"This remote method sends a message to everyone in the room Used to say things to everyone Requires that the speaker be in this place","comments":" \n   * This remote method sends a message to everyone in the room.  Used to\n   * say things to everyone.  Requires that the speaker be in this place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n   * This remote method sends a message to everyone in the room.  Used to\n   * do things that people can see.  Requires that the actor be in this place.\n   **/\npublic void act(RemoteMudPerson actor, String msg) throws RemoteException, NotThere {\n    String name = verifyPresence(actor);\n    tellEveryone(name + \" \" + msg);\n}\n","name":"act","className":"MudPlace","variables":{"msg":1,"name":2},"constants":{"\" \"":1},"javaDoc":"This remote method sends a message to everyone in the room Used to do things that people can see Requires that the actor be in this place","comments":" \n   * This remote method sends a message to everyone in the room.  Used to\n   * do things that people can see.  Requires that the actor be in this place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","AlreadyThere","RemoteException"],"concepts":["Synchronization"],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":4},"text":"/** \n   * This remote method creates a new thing in this room.\n   * It requires that the creator be in this room.\n   **/\npublic void createThing(RemoteMudPerson creator, String name, String description) throws RemoteException, NotThere, AlreadyThere {\n    // Make sure the creator is here\n    String creatorname = verifyPresence(creator);\n    synchronized (things) {\n        // Make sure there isn't already something with this name.  \n        if (things.indexOf(name) != -1)\n            throw new AlreadyThere();\n        // Add the thing name and descriptions to the appropriate lists\n        things.addElement(name);\n        descriptions.addElement(description);\n    }\n    // Tell everyone about the new thing and its creator\n    tellEveryone(creatorname + \" has created a \" + name);\n}\n","name":"createThing","className":"MudPlace","variables":{"things":3,"name":1,"creatorname":2,"descriptions":1},"constants":{"1":1,"\" has created a \"":1},"javaDoc":"This remote method creates a new thing in this room It requires that the creator be in this room","comments":"Make sure the creator is here Make sure there isn't already something with this name Add the thing name and descriptions to the appropriate lists Tell everyone about the new thing and its creator  \n   * This remote method creates a new thing in this room.\n   * It requires that the creator be in this room.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchThing","RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n   * Remove a thing from this room.  Throws exceptions if the person\n   * who removes it isn't themselves in the room, or if there is no\n   * such thing here.\n   **/\npublic void destroyThing(RemoteMudPerson destroyer, String thing) throws RemoteException, NotThere, NoSuchThing {\n    // Verify that the destroyer is here\n    String name = verifyPresence(destroyer);\n    synchronized (things) {\n        // Verify that there is a thing by that name in this room\n        int i = things.indexOf(thing);\n        if (i == -1)\n            throw new NoSuchThing();\n        // And remove its name and description from the lists\n        things.removeElementAt(i);\n        descriptions.removeElementAt(i);\n    }\n    // Let everyone know of the demise of this thing.\n    tellEveryone(name + \" had destroyed the \" + thing);\n}\n","name":"destroyThing","className":"MudPlace","variables":{"name":2,"things":3,"i":2,"descriptions":1,"thing":1},"constants":{"1":1,"\" had destroyed the \"":1},"javaDoc":"Remove a thing from this room Throws exceptions if the person who removes it isn't themselves in the room or if there is no such thing here","comments":"Verify that the destroyer is here Verify that there is a thing by that name in this room And remove its name and description from the lists Let everyone know of the demise of this thing \n   * Remove a thing from this room.  Throws exceptions if the person\n   * who removes it isn't themselves in the room, or if there is no\n   * such thing here.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"destination.destinations.addElement":1,"verifyPresence":1,"destination.exits.addElement":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","PlaceAlreadyExists","ExitAlreadyExists","RemoteException"],"concepts":["Synchronization"],"types":{"MudPlace":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":34,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":7},"text":"/**\n   * Create a new place in this MUD, with the specified name an description. \n   * The new place is accessible from this place through\n   * the specified exit, and this place is accessible from the new place \n   * through the specified entrance.  The creator must be in this place\n   * in order to create a exit from this place.\n   **/\npublic void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists {\n    // Verify that the creator is actually here in this place\n    String creatorname = verifyPresence(creator);\n    synchronized (exits) {\n        // Check that the exit doesn't already exist.\n        if (exits.indexOf(exit) != -1)\n            throw new ExitAlreadyExists();\n        // Create the new place, registering its name with the server\n        MudPlace destination = new MudPlace(server, name, description);\n        // Link from there back to here\n        destination.exits.addElement(entrance);\n        destination.destinations.addElement(this);\n        // And link from here to there\n        exits.addElement(exit);\n        destinations.addElement(destination);\n    }\n    // Let everyone know about the new exit, and the new place beyond\n    tellEveryone(creatorname + \" has created a new place: \" + exit);\n}\n                            // Only allow one client to change exits at a time\n\n","name":"createPlace","className":"MudPlace","variables":{"server":1,"exit":1,"exits":3,"destinations":1,"destination":1,"name":1,"creatorname":2,"description":1},"constants":{"1":1,"\" has created a new place: \"":1},"javaDoc":"Create a new place in this MUD with the specified name an description The new place is accessible from this place through the specified exit and this place is accessible from the new place through the specified entrance The creator must be in this place in order to create a exit from this place","comments":"Verify that the creator is actually here in this place Only allow one client to change exits at a time Check that the exit doesn't already exist Create the new place registering its name with the server Link from there back to here And link from here to there Let everyone know about the new exit and the new place beyond \n   * Create a new place in this MUD, with the specified name an description. \n   * The new place is accessible from this place through\n   * the specified exit, and this place is accessible from the new place \n   * through the specified entrance.  The creator must be in this place\n   * in order to create a exit from this place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{"lookup":1,"tellEveryone":1,"getNamedPlace":1,"verifyPresence":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchPlace","ExitAlreadyExists","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"String":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":16,"NameExpr":37,"StringLiteralExpr":6,"CastExpr":1,"CharLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"SynchronizedStmt":1,"ThrowStmt":2,"ExpressionStmt":7},"text":"/**\n   * Create a new exit from this mud, linked to a named place in a named\n   * MUD on a named host (this can also be used to link to a named place in \n   * the current MUD, of course).  Because of the possibilities of deadlock,\n   * this method only links from here to there; it does not create a return\n   * exit from there to here.  That must be done with a separate call.\n   **/\npublic void linkTo(RemoteMudPerson linker, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace {\n    // Verify that the linker is actually here \n    String name = verifyPresence(linker);\n    // Check that the link target actually exists.  Throw NoSuchPlace if not.\n    // Note that NoSuchPlace may also mean \"NoSuchMud\" or \"MudNotResponding\".\n    String url = \"rmi://\" + hostname + '/' + Mud.mudPrefix + mudname;\n    try {\n        RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);\n        RemoteMudPlace destination = s.getNamedPlace(placename);\n    } catch (Exception e) {\n        throw new NoSuchPlace();\n    }\n    synchronized (exits) {\n        // Check that the exit doesn't already exist.\n        if (exits.indexOf(exit) != -1)\n            throw new ExitAlreadyExists();\n        // Add the exit, to the list of exit names\n        exits.addElement(exit);\n        // And add the destination to the list of destinations.  Note that\n        // the destination is stored as a string rather than as a RemoteMudPlace.\n        // This is because if the remote server goes down then comes back up\n        // again, a RemoteMudPlace is not valid, but the string still is.\n        destinations.addElement(url + '@' + placename);\n    }\n    // Let everyone know about the new exit and where it leads\n    tellEveryone(name + \" has linked \" + exit + \" to \" + \"'\" + placename + \"' in MUD '\" + mudname + \"' on host \" + hostname);\n}\n","name":"linkTo","className":"MudPlace","variables":{"exit":1,"hostname":2,"exits":3,"s":2,"mudname":2,"e":1,"destinations":1,"name":2,"destination":1,"Naming":1,"placename":2,"url":2},"constants":{"1":1,"\"rmi://\"":1,"\" to \"":1,"\" has linked \"":1,"\"' in MUD '\"":1,"\"' on host \"":1,"\"'\"":1,"'@'":1,"'/'":1},"javaDoc":"Create a new exit from this mud linked to a named place in a named MUD on a named host (this can also be used to link to a named place in the current MUD of course) Because of the possibilities of deadlock this method only links from here to there; it does not create a return exit from there to here That must be done with a separate call","comments":"Check that the link target actually exists Throw NoSuchPlace if not Verify that the linker is actually here Note that NoSuchPlace may also mean \"NoSuchMud\" or \"MudNotResponding\" And add the destination to the list of destinations Note that the destination is stored as a string rather than as a RemoteMudPlace This is because if the remote server goes down then comes back up Check that the exit doesn't already exist Add the exit to the list of exit names again a RemoteMudPlace is not valid but the string still is Let everyone know about the new exit and where it leads \n   * Create a new exit from this mud, linked to a named place in a named\n   * MUD on a named host (this can also be used to link to a named place in \n   * the current MUD, of course).  Because of the possibilities of deadlock,\n   * this method only links from here to there; it does not create a return\n   * exit from there to here.  That must be done with a separate call.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchExit","RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n   * Close an exit that leads out of this place.\n   * It does not close the return exit from there back to here.\n   * Note that this method does not destroy the place that the exit leads to.\n   * In the current implementation, there is no way to destroy a place.\n   **/\npublic void close(RemoteMudPerson who, String exit) throws RemoteException, NotThere, NoSuchExit {\n    // check that the person closing the exit is actually here\n    String name = verifyPresence(who);\n    synchronized (exits) {\n        // Check that the exit exists\n        int i = exits.indexOf(exit);\n        if (i == -1)\n            throw new NoSuchExit();\n        // Remove it and its destination from the lists\n        exits.removeElementAt(i);\n        destinations.removeElementAt(i);\n    }\n    // Let everyone know that the exit doesn't exist anymore\n    tellEveryone(name + \" has closed exit \" + exit);\n}\n","name":"close","className":"MudPlace","variables":{"exit":1,"exits":3,"destinations":1,"name":2,"i":2},"constants":{"1":1,"\" has closed exit \"":1},"javaDoc":"Close an exit that leads out of this place It does not close the return exit from there back to here Note that this method does not destroy the place that the exit leads to In the current implementation there is no way to destroy a place","comments":"check that the person closing the exit is actually here Check that the exit exists Remove it and its destination from the lists Let everyone know that the exit doesn't exist anymore \n   * Close an exit that leads out of this place.\n   * It does not close the return exit from there back to here.\n   * Note that this method does not destroy the place that the exit leads to.\n   * In the current implementation, there is no way to destroy a place.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":18,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n   * Remove a person from this place.  If there is a message, send it to \n   * everyone who is left in this place.  If the specified person is not here,\n   * this method does nothing and does not throw an exception.  This method\n   * is called by go(), and the client should call it when the user quits.\n   * The client should not allow the user to invoke it directly, however.\n   **/\npublic void exit(RemoteMudPerson who, String message) throws RemoteException {\n    String name;\n    synchronized (names) {\n        int i = people.indexOf(who);\n        if (i == -1)\n            return;\n        names.removeElementAt(i);\n        people.removeElementAt(i);\n    }\n    if (message != null)\n        tellEveryone(message);\n}\n","name":"exit","className":"MudPlace","variables":{"names":2,"name":1,"i":2,"message":1,"people":2},"constants":{"1":1,"null":1},"javaDoc":"Remove a person from this place If there is a message send it to everyone who is left in this place If the specified person is not here this method does nothing and does not throw an exception This method is called by go() and the client should call it when the user quits The client should not allow the user to invoke it directly however","comments":" \n   * Remove a person from this place.  If there is a message, send it to \n   * everyone who is left in this place.  If the specified person is not here,\n   * this method does nothing and does not throw an exception.  This method\n   * is called by go(), and the client should call it when the user quits.\n   * The client should not allow the user to invoke it directly, however.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["AlreadyThere","RemoteException"],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"/** \n   * This method puts a person into this place, assigning them the\n   * specified name, and displaying a message to anyone else who is in\n   * that place.  This method is called by go(), and the client should\n   * call it to initially place a person into the MUD.  Once the person\n   * is in the MUD, however, the client should restrict them to using go()\n   * and should not allow them to call this method directly.\n   * If there have been networking problems, a client might call this method\n   * to restore a person to this place, in case they've been bumped out.\n   * (A person will be bumped out of a place if the server tries to send\n   * a message to them and gets a RemoteException.)\n   **/\npublic void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere {\n    // Send the message to everyone who is already here.\n    if (message != null)\n        tellEveryone(message);\n    // Add the person to this place.\n    synchronized (names) {\n        if (people.indexOf(who) != -1)\n            throw new AlreadyThere();\n        names.addElement(name);\n        people.addElement(who);\n    }\n}\n","name":"enter","className":"MudPlace","variables":{"names":2,"message":1,"people":2},"constants":{"1":1,"null":1},"javaDoc":"This method puts a person into this place assigning them the specified name and displaying a message to anyone else who is in that place This method is called by go() and the client should call it to initially place a person into the MUD Once the person is in the MUD however the client should restrict them to using go() and should not allow them to call this method directly If there have been networking problems a client might call this method to restore a person to this place in case they've been bumped out (A person will be bumped out of a place if the server tries to send a message to them and gets a RemoteException )","comments":"Send the message to everyone who is already here Add the person to this place  \n   * This method puts a person into this place, assigning them the\n   * specified name, and displaying a message to anyone else who is in\n   * that place.  This method is called by go(), and the client should\n   * call it to initially place a person into the MUD.  Once the person\n   * is in the MUD, however, the client should restrict them to using go()\n   * and should not allow them to call this method directly.\n   * If there have been networking problems, a client might call this method\n   * to restore a person to this place, in case they've been bumped out.\n   * (A person will be bumped out of a place if the server tries to send\n   * a message to them and gets a RemoteException.)\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n   * This final remote method returns the server object for the MUD in which\n   * this place exists.  The client should not allow the user to invoke this\n   * method.\n   **/\npublic RemoteMudServer getServer() throws RemoteException {\n    return server;\n}\n","name":"getServer","className":"MudPlace","variables":{"server":1},"constants":{},"javaDoc":"This final remote method returns the server object for the MUD in which this place exists The client should not allow the user to invoke this method","comments":"\n   * This final remote method returns the server object for the MUD in which\n   * this place exists.  The client should not allow the user to invoke this\n   * method.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"tell":1,"elementAt":1},"annotations":[],"exceptions":["RemoteException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"RemoteMudPerson":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":17,"CastExpr":1,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":5,"TryStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    // Loop through the recipients\n    for (int i = 0; i < recipients.size(); i++) {\n        RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);\n        // Try to send the message to each one.\n        try {\n            person.tell(message);\n        }// failed, and silently remove them from this place.\n         catch (RemoteException e) {\n            try {\n                MudPlace.this.exit(person, null);\n            } catch (Exception ex) {\n            }\n        }\n    }\n}\n           // If it fails, assume that that person's client or network has\n\n","name":"run","className":"","variables":{"ex":1,"e":1,"recipients":2,"person":2,"i":3,"MudPlace":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Loop through the recipients Try to send the message to each one If it fails assume that that person's client or network has failed and silently remove them from this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":2,"tell":1,"clone":1,"elementAt":1},"annotations":[],"exceptions":["RemoteException","Exception"],"concepts":["Casting","InnerMethod","FinalVariables","ExceptionHandling"],"types":{"RemoteMudPerson":1,"Vector":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":27,"CastExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** \n   * Create and start a thread that sends out a message everyone in this place.\n   * If it gets a RemoteException talking to a person, it silently removes \n   * that person from this place.  This is not a remote method, but is used\n   * internally by a number of remote methods.\n   **/\nprotected void tellEveryone(final String message) {\n    // If there is no-one here, don't bother sending the message!\n    if (people.size() == 0)\n        return;\n    // Make a copy of the people here now.  The message is sent asynchronously\n    // and the list of people in the room may change before the message is\n    // sent to everyone.\n    final Vector recipients = (Vector) people.clone();\n    // Create and start a thread to send the message, using an anonymous\n    // class.  We do this because sending the message to everyone in this \n    // place might take some time, (particularly on a slow or flaky network) \n    // and we don't want to wait.\n    new Thread() {\n\n        public void run() {\n            // Loop through the recipients\n            for (int i = 0; i < recipients.size(); i++) {\n                RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);\n                // Try to send the message to each one.\n                try {\n                    person.tell(message);\n                }// failed, and silently remove them from this place.\n                 catch (RemoteException e) {\n                    try {\n                        MudPlace.this.exit(person, null);\n                    } catch (Exception ex) {\n                    }\n                }\n            }\n        }\n    }.start();\n}\n           // If it fails, assume that that person's client or network has\n\n","name":"tellEveryone","className":"MudPlace","variables":{"ex":1,"e":1,"recipients":3,"person":2,"i":3,"MudPlace":1,"run":1,"people":2},"constants":{"0":2,"null":1},"javaDoc":"Create and start a thread that sends out a message everyone in this place If it gets a RemoteException talking to a person it silently removes that person from this place This is not a remote method but is used internally by a number of remote methods","comments":"Make a copy of the people here now The message is sent asynchronously and the list of people in the room may change before the message is Create and start a thread to send the message using an anonymous class We do this because sending the message to everyone in this place might take some time (particularly on a slow or flaky network) If there is no-one here don't bother sending the message! sent to everyone and we don't want to wait Loop through the recipients Try to send the message to each one If it fails assume that that person's client or network has failed and silently remove them from this place  \n   * Create and start a thread that sends out a message everyone in this place.\n   * If it gets a RemoteException talking to a person, it silently removes \n   * that person from this place.  This is not a remote method, but is used\n   * internally by a number of remote methods.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["RemoteMudPerson"],"returnType":"String","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NotThere"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This convenience method checks whether the specified person is here.\n   * If so, it returns their name.  If not it throws a NotThere exception\n   **/\nprotected String verifyPresence(RemoteMudPerson who) throws NotThere {\n    int i = people.indexOf(who);\n    if (i == -1)\n        throw new NotThere();\n    else\n        return (String) names.elementAt(i);\n}\n","name":"verifyPresence","className":"MudPlace","variables":{"names":1,"i":2,"people":1},"constants":{"1":1},"javaDoc":"This convenience method checks whether the specified person is here If so it returns their name If not it throws a NotThere exception","comments":"\n   * This convenience method checks whether the specified person is here.\n   * If so, it returns their name.  If not it throws a NotThere exception\n   *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ObjectInputStream"],"returnType":"void","methodCalls":{"defaultReadObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n   * This method is used for custom de-serialization.  Since the vectors of\n   * people and of their names are transient, they are not serialized with\n   * the rest of this place.  Therefore, when the place is de-serialized, those\n   * vectors have to be recreated (empty).\n   **/\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Read most of the object as normal\n    in.defaultReadObject();\n    // Then recreate the names vector\n    names = new Vector();\n    // and recreate the people vector\n    people = new Vector();\n}\n","name":"readObject","className":"MudPlace","variables":{"names":1,"in":1,"people":1},"constants":{},"javaDoc":"This method is used for custom de-serialization Since the vectors of people and of their names are transient they are not serialized with the rest of this place Therefore when the place is de-serialized those vectors have to be recreated (empty)","comments":"Read most of the object as normal Then recreate the names vector and recreate the people vector \n   * This method is used for custom de-serialization.  Since the vectors of\n   * people and of their names are transient, they are not serialized with\n   * the rest of this place.  Therefore, when the place is de-serialized, those\n   * vectors have to be recreated (empty).\n   *","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String","String","String[]","ActionListener","boolean"],"returnType":"Menu","methodCalls":{"add":1,"addActionListener":1,"setActionCommand":1,"getString":3,"getBundle":1,"charAt":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"ResourceBundle":1,"MenuItem":1,"String":3,"Menu":1,"MenuShortcut":1,"int":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"NullLiteralExpr":5,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":11,"NameExpr":65,"StringLiteralExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":8,"AssignExpr":11},"statements":{"IfStmt":4,"TryStmt":3,"BlockStmt":8,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":21},"text":"/** The convenience method that creates menu panes */\npublic static Menu create(String bundlename, String menuname, String[] itemnames, ActionListener listener, boolean popup) {\n    // Get the resource bundle used for this menu.\n    ResourceBundle b = ResourceBundle.getBundle(bundlename);\n    // Get the menu title from the bundle.  Use name as default label.\n    String menulabel;\n    try {\n        menulabel = b.getString(menuname + \".label\");\n    } catch (MissingResourceException e) {\n        menulabel = menuname;\n    }\n    // Create the menu pane.\n    Menu m;\n    if (popup)\n        m = new PopupMenu(menulabel);\n    else\n        m = new Menu(menulabel);\n    // For each named item in the menu.\n    for (int i = 0; i < itemnames.length; i++) {\n        // Look up the label for the item, using name as default.\n        String itemlabel;\n        try {\n            itemlabel = b.getString(menuname + \".\" + itemnames[i] + \".label\");\n        } catch (MissingResourceException e) {\n            itemlabel = itemnames[i];\n        }\n        // Look up a shortcut for the item, and create the menu shortcut, if any.\n        String shortcut;\n        try {\n            shortcut = b.getString(menuname + \".\" + itemnames[i] + \".shortcut\");\n        } catch (MissingResourceException e) {\n            shortcut = null;\n        }\n        MenuShortcut ms = null;\n        if (shortcut != null)\n            ms = new MenuShortcut(shortcut.charAt(0));\n        // Create the menu item.\n        MenuItem mi;\n        if (ms != null)\n            mi = new MenuItem(itemlabel, ms);\n        else\n            mi = new MenuItem(itemlabel);\n        // Register an action listener and command for the item.\n        if (listener != null) {\n            mi.addActionListener(listener);\n            mi.setActionCommand(itemnames[i]);\n        }\n        // Add the item to the menu.\n        m.add(mi);\n    }\n    // Return the automatically created localized menu.\n    return m;\n}\n","name":"create","className":"SimpleMenu","variables":{"b":4,"menuname":4,"e":3,"ms":4,"listener":1,"i":7,"m":5,"itemlabel":5,"popup":1,"shortcut":5,"menulabel":5,"ResourceBundle":1,"mi":5,"itemnames":4},"constants":{"0":2,"null":5,"\".\"":2,"\".shortcut\"":1,"\".label\"":2},"javaDoc":"The convenience method that creates menu panes","comments":"Get the resource bundle used for this menu Get the menu title from the bundle Use name as default label Create the menu pane For each named item in the menu Look up the label for the item using name as default Look up a shortcut for the item and create the menu shortcut if any Create the menu item Register an action listener and command for the item Add the item to the menu Return the automatically created localized menu  The convenience method that creates menu panes ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setMenuBar":1,"setSize":1,"show":1,"create":1,"setDefault":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Frame":1,"MenuBar":1,"Menu":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":25,"StringLiteralExpr":6,"NullLiteralExpr":1,"ArrayInitializerExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ExpressionStmt":8},"text":"/** A simple test program for the above code */\npublic static void main(String[] args) {\n    // Set the default locale based on the command-line args.\n    if (args.length == 2)\n        Locale.setDefault(new Locale(args[0], args[1]));\n    // Create a window.\n    Frame f = new Frame(\"SimpleMenu Test\");\n    // Create a menubar.\n    MenuBar menubar = new MenuBar();\n    // Add menubar to window.\n    f.setMenuBar(menubar);\n    // Create a menu using our convenience routine (and the default locale).\n    Menu colors = SimpleMenu.create(\"Menus\", \"colors\", new String[] { \"red\", \"green\", \"blue\" }, null, false);\n    // Add the menu to the menubar.\n    menubar.add(colors);\n    // Set the window size.\n    f.setSize(300, 150);\n    // Pop the window up.\n    f.show();\n}\n","name":"main","className":"SimpleMenu","variables":{"Locale":1,"args":2,"menubar":2,"f":4,"SimpleMenu":1,"colors":1},"constants":{"\"SimpleMenu Test\"":1,"\"red\"":1,"false":1,"\"Menus\"":1,"150":1,"\"green\"":1,"0":1,"\"colors\"":1,"1":1,"2":1,"300":1,"null":1,"\"blue\"":1},"javaDoc":"A simple test program for the above code","comments":"Set the default locale based on the command-line args Create a window Create a menubar Add menubar to window Create a menu using our convenience routine (and the default locale) Add the menu to the menubar Set the window size Pop the window up  A simple test program for the above code ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"FileViewer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Convenience constructor: file viewer starts out blank */\npublic FileViewer() {\n    this(null, null);\n}\n","name":"FileViewer","className":"FileViewer","variables":{},"constants":{"null":2},"javaDoc":"Convenience constructor: file viewer starts out blank","comments":" Convenience constructor: file viewer starts out blank ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"FileViewer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Convenience constructor: display file from current directory */\npublic FileViewer(String filename) {\n    this(null, filename);\n}\n","name":"FileViewer","className":"FileViewer","variables":{"filename":1},"constants":{"null":1},"javaDoc":"Convenience constructor: display file from current directory","comments":" Convenience constructor: display file from current directory ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FileViewer","methodCalls":{"add":2,"getParent":1,"setEditable":1,"getName":1,"getProperty":1,"setFile":1,"addActionListener":2,"setActionCommand":2,"setFont":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":1,"Button":2,"File":1,"Font":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":6,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":80,"StringLiteralExpr":10,"AssignExpr":6,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"FieldAccessExpr":4,"EnclosedExpr":2,"ThisExpr":6,"MethodCallExpr":19},"statements":{"IfStmt":2,"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":25},"text":"/**\n   * The real constructor.  Create a FileViewer object to display the\n   * specified file from the specified directory \n   **/\npublic FileViewer(String directory, String filename) {\n    // Create the (closeable) frame\n    super();\n    // Create a TextArea to display the contents of the file in\n    textarea = new TextArea(\"\", 24, 80);\n    textarea.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 12));\n    textarea.setEditable(false);\n    this.add(\"Center\", textarea);\n    // Create a bottom panel to hold a couple of buttons in\n    Panel p = new Panel();\n    p.setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 5));\n    this.add(p, \"South\");\n    // Create the buttons and arrange to handle button clicks\n    Font font = new Font(\"SansSerif\", Font.BOLD, 14);\n    Button openfile = new Button(\"Open File\");\n    Button close = new Button(\"Close\");\n    openfile.addActionListener(this);\n    openfile.setActionCommand(\"open\");\n    openfile.setFont(font);\n    close.addActionListener(this);\n    close.setActionCommand(\"close\");\n    close.setFont(font);\n    p.add(openfile);\n    p.add(close);\n    this.pack();\n    // Figure out the directory, from filename or current dir, if necessary\n    if (directory == null) {\n        File f;\n        if ((filename != null) && (f = new File(filename)).isAbsolute()) {\n            directory = f.getParent();\n            filename = f.getName();\n        } else\n            directory = System.getProperty(\"user.dir\");\n    }\n    // Remember the directory, for FileDialog\n    this.directory = directory;\n    // Now load and display the file\n    setFile(directory, filename);\n}\n","name":"FileViewer","className":"FileViewer","variables":{"p":4,"filename":3,"openfile":4,"f":4,"textarea":3,"close":4,"directory":4,"System":1,"font":1},"constants":{"\"\"":1,"12":1,"24":1,"\"Close\"":1,"14":1,"\"open\"":1,"\"close\"":1,"false":1,"\"SansSerif\"":1,"\"Center\"":1,"\"MonoSpaced\"":1,"\"user.dir\"":1,"null":2,"5":1,"\"Open File\"":1,"80":1,"\"South\"":1,"10":1},"javaDoc":"The real constructor Create a FileViewer object to display the specified file from the specified directory","comments":"Create the (closeable) frame Create a TextArea to display the contents of the file in Create a bottom panel to hold a couple of buttons in Create the buttons and arrange to handle button clicks Figure out the directory from filename or current dir if necessary Remember the directory for FileDialog Now load and display the file \n   * The real constructor.  Create a FileViewer object to display the\n   * specified file from the specified directory \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"getClass":1,"read":1,"getName":1,"length":2,"getMessage":1,"close":1,"setText":2},"annotations":[],"exceptions":["IOException"],"concepts":["Casting","ExceptionHandling"],"types":{"FileReader":1,"File":1,"int":2,"char[]":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":11,"NameExpr":48,"StringLiteralExpr":4,"AssignExpr":3,"NullLiteralExpr":3,"CastExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":1,"ThisExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":13},"text":"/**\n   * Load and display the specified file (if any) from the specified directory\n   **/\npublic void setFile(String directory, String filename) {\n    if ((filename == null) || (filename.length() == 0))\n        return;\n    File f;\n    FileReader in = null;\n    // use a FileReader instead of a FileInputStream.\n    try {\n        // Create a file object\n        f = new File(directory, filename);\n        // Create a char stream to read  it\n        in = new FileReader(f);\n        // Check file size\n        int size = (int) f.length();\n        // Allocate an array big enough for it\n        char[] data = new char[size];\n        // How many chars read so far?\n        int chars_read = 0;\n        while (// Loop until we've read it all\n        chars_read < size) chars_read += in.read(data, chars_read, size - chars_read);\n        // Display chars in TextArea\n        textarea.setText(new String(data));\n        // Set the window title\n        this.setTitle(\"FileViewer: \" + filename);\n    }// Display messages if something goes wrong\n     catch (IOException e) {\n        textarea.setText(e.getClass().getName() + \": \" + e.getMessage());\n        this.setTitle(\"FileViewer: \" + filename + \": I/O Exception\");\n    } finally // Always be sure to close the input stream!\n    {\n        try {\n            if (in != null)\n                in.close();\n        } catch (IOException e) {\n        }\n    }\n}\n     // Read and display the file contents.  Since we're reading text, we\n\n","name":"setFile","className":"FileViewer","variables":{"chars_read":4,"filename":5,"size":4,"data":2,"in":5,"e":4,"f":4,"textarea":2,"directory":1},"constants":{"0":2,"\"FileViewer: \"":2,"null":3,"\": I/O Exception\"":1,"\": \"":1},"javaDoc":"Load and display the specified file (if any) from the specified directory","comments":"Read and display the file contents Since we're reading text we use a FileReader instead of a FileInputStream Create a file object Create a char stream to read it Check file size Allocate an array big enough for it How many chars read so far? Loop until we've read it all Display chars in TextArea Set the window title Display messages if something goes wrong Always be sure to close the input stream! \n   * Load and display the specified file (if any) from the specified directory\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setFile":1,"equals":2,"show":1,"setDirectory":1,"getDirectory":1,"dispose":1,"getActionCommand":1,"getFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"FileDialog":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":8},"text":"/**\n   * Handle button clicks\n   **/\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (cmd.equals(\"open\")) {\n        // If user clicked \"Open\" button\n        // Create a file dialog box to prompt for a new file to display\n        FileDialog f = new FileDialog(this, \"Open File\", FileDialog.LOAD);\n        // Set the default directory\n        f.setDirectory(directory);\n        // Display dialog and wait for response\n        f.show();\n        // Remember new default directory\n        directory = f.getDirectory();\n        // Load and display selection\n        setFile(directory, f.getFile());\n        // Get rid of the dialog box\n        f.dispose();\n    } else if (// If user clicked \"Close\" button\n    cmd.equals(\"close\"))\n        //    then close the window\n        this.dispose();\n}\n","name":"actionPerformed","className":"FileViewer","variables":{"e":1,"f":6,"cmd":3,"directory":1},"constants":{"\"open\"":1,"\"close\"":1,"\"Open File\"":1},"javaDoc":"Handle button clicks","comments":"If user clicked \"Open\" button Create a file dialog box to prompt for a new file to display Set the default directory Display dialog and wait for response Remember new default directory Load and display selection Get rid of the dialog box If user clicked \"Close\" button then close the window \n   * Handle button clicks\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosed(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addWindowListener":1,"exit":1,"show":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","PolyMorphism"],"types":{"Frame":1,"FileViewer":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":1,"ConditionalExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n   * The FileViewer can be used by other classes, or it can be\n   * used standalone with this main() method.\n   **/\npublic static void main(String[] args) throws IOException {\n    // Create a FileViewer object\n    Frame f = new FileViewer((args.length == 1) ? args[0] : null);\n    // Arrange to exit when the FileViewer window closes\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosed(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // And pop the window up\n    f.show();\n}\n","name":"main","className":"FileViewer","variables":{"args":1,"windowClosed":1,"e":1,"f":3,"System":1},"constants":{"0":2,"1":1,"null":1},"javaDoc":"The FileViewer can be used by other classes or it can be used standalone with this main() method","comments":"Create a FileViewer object Arrange to exit when the FileViewer window closes And pop the window up \n   * The FileViewer can be used by other classes, or it can be\n   * used standalone with this main() method.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Compare objects and return a value that indicates their relative order:\n     * if (a > b) return > 0; \n     * if (a == b) return 0;\n     * if (a < b) return < 0. \n     **/\npublic int compare(Object a, Object b);\n","name":"compare","className":"Comparer","variables":{},"constants":{},"javaDoc":"Compare objects and return a value that indicates their relative order: if (a > b) return > 0; if (a == b) return 0; if (a < b) return < 0","comments":"\n     * Compare objects and return a value that indicates their relative order:\n     * if (a > b) return > 0; \n     * if (a == b) return 0;\n     * if (a < b) return < 0. \n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * Compare objects and return a value that indicates their relative order:\n     * if (this > other) return > 0\n     * if (this == other) return 0\n     * if (this < other) return < 0\n     **/\npublic int compareTo(Object other);\n","name":"compareTo","className":"Comparable","variables":{},"constants":{},"javaDoc":"Compare objects and return a value that indicates their relative order: if (this > other) return > 0 if (this == other) return 0 if (this < other) return < 0","comments":" \n     * Compare objects and return a value that indicates their relative order:\n     * if (this > other) return > 0\n     * if (this == other) return 0\n     * if (this < other) return < 0\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((String) a).compareTo((String) b);\n}\n","name":"compare","className":"","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((Comparable) a).compareTo(b);\n}\n","name":"compare","className":"","variables":{"a":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of ASCII strings into ascending order */\npublic static void sortAscii(String[] a) {\n    // Note use of the ascii_comparer object\n    sort(a, null, 0, a.length - 1, true, ascii_comparer);\n}\n","name":"sortAscii","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of ASCII strings into ascending order","comments":"Note use of the ascii_comparer object  Sort an array of ASCII strings into ascending order ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n   * Sort a portion of an array of ASCII strings into ascending or descending\n   * order, depending on the argument up\n   **/\npublic static void sortAscii(String[] a, int from, int to, boolean up) {\n    // Note use of the ascii_comparer object\n    sort(a, null, from, to, up, ascii_comparer);\n}\n","name":"sortAscii","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of ASCII strings into ascending or descending order depending on the argument up","comments":"Note use of the ascii_comparer object  \n   * Sort a portion of an array of ASCII strings into ascending or descending\n   * order, depending on the argument up\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sortAsciiIgnoreCase":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of ASCII strings into ascending order, ignoring case */\npublic static void sortAsciiIgnoreCase(String[] a) {\n    sortAsciiIgnoreCase(a, 0, a.length - 1, true);\n}\n","name":"sortAsciiIgnoreCase","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"true":1},"javaDoc":"Sort an array of ASCII strings into ascending order ignoring case","comments":" Sort an array of ASCII strings into ascending order, ignoring case ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":26,"FieldAccessExpr":3,"EnclosedExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n   * Sort an portion of an array of ASCII strings, ignoring case.  Sort into\n   * ascending order if up is true, otherwise sort into descending order.\n   **/\npublic static void sortAsciiIgnoreCase(String[] a, int from, int to, boolean up) {\n    if ((a == null) || (a.length < 2))\n        return;\n    // Create a secondary array of strings that contains lowercase versions\n    // of all the specified strings. \n    String b[] = new String[a.length];\n    for (int i = 0; i < a.length; i++) b[i] = a[i].toLowerCase();\n    // Sort that secondary array, and rearrange the original array \n    // in exactly the same way, resulting in a case-insensitive sort.\n    // Note the use of the ascii_comparer object\n    sort(b, a, from, to, up, ascii_comparer);\n}\n","name":"sortAsciiIgnoreCase","className":"Sorter","variables":{"a":2,"b":2,"i":5},"constants":{"0":1,"2":1,"null":1},"javaDoc":"Sort an portion of an array of ASCII strings ignoring case Sort into ascending order if up is true otherwise sort into descending order","comments":"Create a secondary array of strings that contains lowercase versions Sort that secondary array and rearrange the original array in exactly the same way resulting in a case-insensitive sort of all the specified strings Note the use of the ascii_comparer object \n   * Sort an portion of an array of ASCII strings, ignoring case.  Sort into\n   * ascending order if up is true, otherwise sort into descending order.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n   * Sort an array of strings into ascending order, using the correct\n   * collation order for the default locale\n   **/\npublic static void sort(String[] a) {\n    sort(a, 0, a.length - 1, true, false, null);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1,"false":1},"javaDoc":"Sort an array of strings into ascending order using the correct collation order for the default locale","comments":" \n   * Sort an array of strings into ascending order, using the correct\n   * collation order for the default locale\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n   * Sort a portion of an array of strings, using the collation order of\n   * the default locale.   If up is true, sort ascending, otherwise, sort\n   * descending.  If ignorecase is true, ignore the capitalization of letters\n   **/\npublic static void sort(String[] a, int from, int to, boolean up, boolean ignorecase) {\n    sort(a, from, to, up, ignorecase, null);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of strings using the collation order of the default locale If up is true sort ascending otherwise sort descending If ignorecase is true ignore the capitalization of letters","comments":"\n   * Sort a portion of an array of strings, using the collation order of\n   * the default locale.   If up is true, sort ascending, otherwise, sort\n   * descending.  If ignorecase is true, ignore the capitalization of letters\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((CollationKey) a).compareTo((CollationKey) b);\n}\n","name":"compare","className":"","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]","int","int","boolean","boolean","Locale"],"returnType":"void","methodCalls":{"setStrength":1,"getCollationKey":1,"getInstance":2,"sort":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","Recursion"],"types":{"Comparer":1,"CollationKey[]":1,"int":1,"Collator":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":50,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":2,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":8},"text":"/**\n   * Sort a portion of an array of strings, using the collation order of\n   * the specified locale.   If up is true, sort ascending, otherwise, sort\n   * descending.  If ignorecase is true, ignore the capitalization of letters\n   **/\npublic static void sort(String[] a, int from, int to, boolean up, boolean ignorecase, Locale locale) {\n    // Don't sort if we don't have to\n    if ((a == null) || (a.length < 2))\n        return;\n    // The java.text.Collator object does internationalized string compares\n    // Create one for the specified, or the default locale.\n    Collator c;\n    if (locale == null)\n        c = Collator.getInstance();\n    else\n        c = Collator.getInstance(locale);\n    // using the default American English locale.\n    if (ignorecase)\n        c.setStrength(Collator.SECONDARY);\n    // Use the Collator object to create an array of CollationKey objects that\n    // correspond to each of the strings.  \n    // Comparing CollationKeys is much quicker than comparing Strings\n    CollationKey[] b = new CollationKey[a.length];\n    for (int i = 0; i < a.length; i++) b[i] = c.getCollationKey(a[i]);\n    // Now define a Comparer object to compare collation keys, using an\n    // anonymous class.\n    Comparer comp = new Comparer() {\n\n        public int compare(Object a, Object b) {\n            return ((CollationKey) a).compareTo((CollationKey) b);\n        }\n    };\n    // Finally, sort the array of CollationKey objects, rearranging the \n    // original array of strings in exactly the same way.\n    sort(b, a, from, to, up, comp);\n}\n     // Specify whether or not case should be taken into account in the sort.\n\n     // Note: this option does not seem to work correctly in JDK 1.1.1\n\n","name":"sort","className":"Sorter","variables":{"a":4,"ignorecase":1,"comp":1,"b":4,"compare":1,"c":5,"i":5,"locale":1,"Collator":2},"constants":{"0":1,"2":1,"null":2},"javaDoc":"Sort a portion of an array of strings using the collation order of the specified locale If up is true sort ascending otherwise sort descending If ignorecase is true ignore the capitalization of letters","comments":"The java text Collator object does internationalized string compares Specify whether or not case should be taken into account in the sort Note: this option does not seem to work correctly in JDK 1 1 1 Use the Collator object to create an array of CollationKey objects that correspond to each of the strings Now define a Comparer object to compare collation keys using an Finally sort the array of CollationKey objects rearranging the Don't sort if we don't have to Create one for the specified or the default locale using the default American English locale Comparing CollationKeys is much quicker than comparing Strings anonymous class original array of strings in exactly the same way \n   * Sort a portion of an array of strings, using the collation order of\n   * the specified locale.   If up is true, sort ascending, otherwise, sort\n   * descending.  If ignorecase is true, ignore the capitalization of letters\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of Comparable objects into ascending order */\npublic static void sort(Comparable[] a) {\n    sort(a, null, 0, a.length - 1, true);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of Comparable objects into ascending order","comments":" Sort an array of Comparable objects into ascending order ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n   * Sort a portion of an array of Comparable objects.  If up is true,\n   * sort into ascending order, otherwise sort into descending order.\n   **/\npublic static void sort(Comparable[] a, int from, int to, boolean up) {\n    sort(a, null, from, to, up, comparable_comparer);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of Comparable objects If up is true sort into ascending order otherwise sort into descending order","comments":"\n   * Sort a portion of an array of Comparable objects.  If up is true,\n   * sort into ascending order, otherwise sort into descending order.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]","Object[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n   * Sort a portion of array a of Comparable objects.  If up is true,\n   * sort into ascending order, otherwise sort into descending order.\n   * Re-arrange the array b in exactly the same way as a.\n   **/\npublic static void sort(Comparable[] a, Object[] b, int from, int to, boolean up) {\n    sort(a, b, from, to, up, comparable_comparer);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{},"javaDoc":"Sort a portion of array a of Comparable objects If up is true sort into ascending order otherwise sort into descending order Re-arrange the array b in exactly the same way as a","comments":"\n   * Sort a portion of array a of Comparable objects.  If up is true,\n   * sort into ascending order, otherwise sort into descending order.\n   * Re-arrange the array b in exactly the same way as a.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","Comparer"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n   * Sort an array of arbitrary objects into ascending order, using the \n   * comparison defined by the Comparer object c\n   **/\npublic static void sort(Object[] a, Comparer c) {\n    sort(a, null, 0, a.length - 1, true, c);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of arbitrary objects into ascending order using the comparison defined by the Comparer object c","comments":"\n   * Sort an array of arbitrary objects into ascending order, using the \n   * comparison defined by the Comparer object c\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","int","int","boolean","Comparer"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n   * Sort a portion of an array of objects, using the comparison defined by\n   * the Comparer object c.  If up is true, sort into ascending order, \n   * otherwise sort into descending order.\n   **/\npublic static void sort(Object[] a, int from, int to, boolean up, Comparer c) {\n    sort(a, null, from, to, up, c);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of objects using the comparison defined by the Comparer object c If up is true sort into ascending order otherwise sort into descending order","comments":"\n   * Sort a portion of an array of objects, using the comparison defined by\n   * the Comparer object c.  If up is true, sort into ascending order, \n   * otherwise sort into descending order.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","Object[]","int","int","boolean","Comparer"],"returnType":"void","methodCalls":{"compare":4,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Object":2,"int":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayAccessExpr":13,"BinaryExpr":23,"NameExpr":94,"FieldAccessExpr":1,"EnclosedExpr":11,"UnaryExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":7,"WhileStmt":4,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":16,"DoStmt":1},"text":"/**\n   * This is the main sort() routine.  It performs a quicksort on the elements\n   * of array a between the element from and the element to.  The up argument\n   * specifies whether the elements should be sorted into ascending (true) or\n   * descending (false) order.  The Comparer argument c is used to perform\n   * comparisons between elements of the array.  The elements of the array b\n   * are reordered in exactly the same way as the elements of array a are.\n   **/\npublic static void sort(Object[] a, Object[] b, int from, int to, boolean up, Comparer c) {\n    // If there is nothing to sort, return\n    if ((a == null) || (a.length < 2))\n        return;\n    // This is the basic quicksort algorithm, stripped of frills that can make\n    // it faster but even more confusing than it already is.  You should\n    // understand what the code does, but don't have to understand just \n    // why it is guaranteed to sort the array...\n    // Note the use of the compare() method of the Comparer object.\n    int i = from, j = to;\n    Object center = a[(from + to) / 2];\n    do {\n        if (up) {\n            // an ascending sort\n            while ((i < to) && (c.compare(center, a[i]) > 0)) i++;\n            while ((j > from) && (c.compare(center, a[j]) < 0)) j--;\n        } else {\n            // a descending sort\n            while ((i < to) && (c.compare(center, a[i]) < 0)) i++;\n            while ((j > from) && (c.compare(center, a[j]) > 0)) j--;\n        }\n        if (i < j) {\n            // swap elements\n            Object tmp = a[i];\n            // swap elements\n            a[i] = a[j];\n            // swap elements\n            a[j] = tmp;\n            // swap b, too\n            if (b != null) {\n                tmp = b[i];\n                b[i] = b[j];\n                b[j] = tmp;\n            }\n        }\n        if (i <= j) {\n            i++;\n            j--;\n        }\n    } while (i <= j);\n    // recursively sort the rest\n    if (from < j)\n        sort(a, b, from, j, up, c);\n    if (i < to)\n        sort(a, b, i, to, up, c);\n}\n","name":"sort","className":"Sorter","variables":{"a":10,"b":5,"c":4,"tmp":4,"center":1,"i":16,"from":5,"j":16,"to":5,"up":1},"constants":{"0":4,"2":2,"null":2},"javaDoc":"This is the main sort() routine It performs a quicksort on the elements of array a between the element from and the element to The up argument specifies whether the elements should be sorted into ascending (true) or descending (false) order The Comparer argument c is used to perform comparisons between elements of the array The elements of the array b are reordered in exactly the same way as the elements of array a are","comments":"This is the basic quicksort algorithm stripped of frills that can make it faster but even more confusing than it already is You should understand what the code does but don't have to understand just why it is guaranteed to sort the array If there is nothing to sort return Note the use of the compare() method of the Comparer object an ascending sort a descending sort swap elements swap elements swap elements swap b too recursively sort the rest \n   * This is the main sort() routine.  It performs a quicksort on the elements\n   * of array a between the element from and the element to.  The up argument\n   * specifies whether the elements should be sorted into ascending (true) or\n   * descending (false) order.  The Comparer argument c is used to perform\n   * comparisons between elements of the array.  The elements of the array b\n   * are reordered in exactly the same way as the elements of array a are.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"SortableComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortableComplexNumber(double x, double y) {\n    super(x, y);\n}\n","name":"SortableComplexNumber","className":"SortableComplexNumber","variables":{"x":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"sign":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compareTo(Object other) {\n    return sign(this.magnitude() - ((ComplexNumber) other).magnitude());\n}\n","name":"compareTo","className":"SortableComplexNumber","variables":{"other":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"imaginary":2,"sign":1,"real":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"ComplexNumber":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"CastExpr":2,"NameExpr":16,"EnclosedExpr":2,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public int compare(Object a, Object b) {\n    ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;\n    return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));\n}\n","name":"compare","className":"","variables":{"a":1,"b":1,"i":3,"j":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"imaginary":2,"sign":1,"real":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"ComplexNumber":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"CastExpr":2,"NameExpr":19,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public int compare(Object a, Object b) {\n    ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;\n    double result = i.real() - j.real();\n    if (result == 0)\n        result = i.imaginary() - j.imaginary();\n    return sign(result);\n}\n","name":"compare","className":"","variables":{"result":3,"a":1,"b":1,"i":3,"j":3},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":2,"imaginary":4,"sign":2,"sort":3,"real":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"double":1,"ComplexNumber":2,"int":4,"SortableComplexNumber[]":1},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":13,"NameExpr":118,"StringLiteralExpr":3,"UnaryExpr":4,"AssignExpr":2,"BooleanLiteralExpr":1,"CastExpr":4,"FieldAccessExpr":11,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":21},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":4,"ReturnStmt":2,"ExpressionStmt":15},"text":"/** This is the test program.  It sorts complex numbers in various ways. */\npublic static void main(String[] args) {\n    // Define an array of SortableComplexNumber objects.  Initialize it\n    // to contain random complex numbers.\n    SortableComplexNumber[] a = new SortableComplexNumber[5];\n    for (int i = 0; i < a.length; i++) a[i] = new SortableComplexNumber(Math.random() * 10, Math.random() * 10);\n    // Now sort it using the SortableComplexNumber compareTo() method, which\n    // sorts by magnitude, and print the results out.\n    System.out.println(\"Sorted by magnitude:\");\n    Sorter.sort(a);\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n    // Sort the complex numbers again, using a Comparer object that\n    // compares them based on the sum of their real and imaginary parts\n    System.out.println(\"Sorted by sum of real and imaginary parts:\");\n    Sorter.sort(a, new Sorter.Comparer() {\n\n        public int compare(Object a, Object b) {\n            ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;\n            return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));\n        }\n    });\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n    // Sort them again using a Comparer object that compares their real\n    // parts, and then their imaginary parts\n    System.out.println(\"Sorted descending by real part, then imaginary:\");\n    Sorter.sort(a, 0, a.length - 1, false, new Sorter.Comparer() {\n\n        public int compare(Object a, Object b) {\n            ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;\n            double result = i.real() - j.real();\n            if (result == 0)\n                result = i.imaginary() - j.imaginary();\n            return sign(result);\n        }\n    });\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n}\n","name":"main","className":"Test","variables":{"result":3,"a":9,"b":4,"compare":2,"Sorter":3,"i":22,"j":6,"Math":2},"constants":{"0":6,"1":1,"\"Sorted by magnitude:\"":1,"\"Sorted by sum of real and imaginary parts:\"":1,"5":1,"false":1,"10":2,"\"Sorted descending by real part, then imaginary:\"":1},"javaDoc":"This is the test program It sorts complex numbers in various ways","comments":"Define an array of SortableComplexNumber objects Initialize it Now sort it using the SortableComplexNumber compareTo() method which Sort the complex numbers again using a Comparer object that Sort them again using a Comparer object that compares their real to contain random complex numbers sorts by magnitude and print the results out compares them based on the sum of their real and imaginary parts parts and then their imaginary parts  This is the test program.  It sorts complex numbers in various ways. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"BinaryExpr":2,"NameExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"/** This is a convenience routine used by comparison routines */\npublic static int sign(double x) {\n    if (x > 0)\n        return 1;\n    else if (x < 0)\n        return -1;\n    else\n        return 0;\n}\n","name":"sign","className":"Test","variables":{"x":2},"constants":{"0":3,"1":2},"javaDoc":"This is a convenience routine used by comparison routines","comments":" This is a convenience routine used by comparison routines ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"addImage":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"ThisExpr":5,"MethodCallExpr":6,"AssignExpr":5},"statements":{"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/** Read the basename and num_frames parameters.\n   *  Then read in the images, using the specified base name.\n   *  For example, if basename is images/anim, read images/anim0,\n   *  images/anim1, etc.  These are relative to the current document URL.\n   */\npublic void init() {\n    String basename = this.getParameter(\"basename\");\n    try {\n        num_frames = Integer.parseInt(this.getParameter(\"num_frames\"));\n    } catch (NumberFormatException e) {\n        num_frames = 0;\n    }\n    // getImage() creates an Image object from a URL specification,\n    // but it doesn't actually load the images; that is done  asynchronously.\n    // Store all the images in a MediaTracker so we can block until\n    // they have all loaded.  This method must return promptly, so we don't\n    // wait for them to load here.\n    tracker = new MediaTracker(this);\n    frames = new Image[num_frames];\n    for (int i = 0; i < num_frames; i++) {\n        frames[i] = this.getImage(this.getDocumentBase(), basename + i);\n        // Add image to tracker, assigning an ID\n        tracker.addImage(frames[i], i);\n    }\n}\n","name":"init","className":"ImageAnimator","variables":{"Integer":1,"basename":2,"frames":3,"e":1,"num_frames":4,"tracker":2,"i":6},"constants":{"0":2,"\"basename\"":1,"\"num_frames\"":1},"javaDoc":"Read the basename and num_frames parameters Then read in the images using the specified base name For example if basename is images/anim read images/anim0 images/anim1 etc These are relative to the current document URL","comments":"getImage() creates an Image object from a URL specification but it doesn't actually load the images; that is done asynchronously Store all the images in a MediaTracker so we can block until they have all loaded This method must return promptly so we don't wait for them to load here Add image to tracker assigning an ID  Read the basename and num_frames parameters.\n   *  Then read in the images, using the specified base name.\n   *  For example, if basename is images/anim, read images/anim0,\n   *  images/anim1, etc.  These are relative to the current document URL.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ArrayAccessExpr":1,"NameExpr":5,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Draw the current frame of the animation */\npublic void paint(Graphics g) {\n    g.drawImage(frames[framenum], 0, 0, this);\n}\n","name":"paint","className":"ImageAnimator","variables":{"frames":1,"g":1,"framenum":1},"constants":{"0":2},"javaDoc":"Draw the current frame of the animation","comments":" Draw the current frame of the animation ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"paint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Don't clear the screen before calling paint() */\npublic void update(Graphics g) {\n    paint(g);\n}\n","name":"update","className":"ImageAnimator","variables":{},"constants":{},"javaDoc":"Don't clear the screen before calling paint()","comments":" Don't clear the screen before calling paint() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":5,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** Create the animation thread and start it running */\npublic void start() {\n    if (animator_thread == null) {\n        animator_thread = new Thread(this);\n        animator_thread.start();\n    }\n}\n","name":"start","className":"ImageAnimator","variables":{"animator_thread":3},"constants":{"null":1},"javaDoc":"Create the animation thread and start it running","comments":" Create the animation thread and start it running ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isAlive":1,"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"BinaryExpr":2,"NameExpr":8,"EnclosedExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Stop the animation thread */\npublic void stop() {\n    if ((animator_thread != null) && animator_thread.isAlive())\n        animator_thread.stop();\n    animator_thread = null;\n}\n","name":"stop","className":"ImageAnimator","variables":{"animator_thread":4},"constants":{"null":2},"javaDoc":"Stop the animation thread","comments":" Stop the animation thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isErrorID":1,"sleep":1,"repaint":1,"waitForID":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":29,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":2,"ThisExpr":3,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":7,"TryStmt":2,"EmptyStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** This is the body of the thread--the method that does the animation. */\npublic void run() {\n    // First, wait until all images have loaded completely.\n    for (int i = 0; i < num_frames; i++) {\n        this.showStatus(\"Loading frame: \" + i);\n        // one we passed to addImage().\n        try {\n            tracker.waitForID(i);\n        } catch (InterruptedException e) {\n            ;\n        }\n        // Check for errors loading it.  Display an error message if necessary\n        if (tracker.isErrorID(i)) {\n            this.showStatus(\"Error loading frame \" + i + \"; quitting.\");\n            return;\n        }\n    }\n    // Done loading all frames\n    this.showStatus(\"Loading frames: done.\");\n    // Now do the animation: increment the framenumber, redraw, pause\n    while (true) {\n        if (++framenum >= frames.length)\n            framenum = 0;\n        repaint();\n        try {\n            Thread.sleep(200);\n        } catch (InterruptedException e) {\n            ;\n        }\n    }\n}\n       // Block until the specified image is loaded.  The ID argument is the\n\n","name":"run","className":"ImageAnimator","variables":{"e":2,"num_frames":1,"tracker":2,"i":5,"framenum":2,"Thread":1},"constants":{"0":2,"\"Loading frame: \"":1,"200":1,"\"; quitting.\"":1,"\"Loading frames: done.\"":1,"true":1,"\"Error loading frame \"":1},"javaDoc":"This is the body of the thread--the method that does the animation","comments":"First wait until all images have loaded completely Block until the specified image is loaded The ID argument is the one we passed to addImage() Check for errors loading it Display an error message if necessary Done loading all frames Now do the animation: increment the framenumber redraw pause  This is the body of the thread--the method that does the animation. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Account","methodCalls":{"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"Account(String password) {\n    this.password = password;\n    transactions.addElement(\"Account opened at \" + new Date());\n}\n","name":"Account","className":"Account","variables":{"password":1,"transactions":1},"constants":{"\"Account opened at \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"RemoteBankServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n   * This constructor doesn't do anything, but because it throws the\n   * same exception that the superclass constructor throws, it must be\n   * declared.\n   **/\npublic RemoteBankServer() throws RemoteException {\n    super();\n}\n","name":"RemoteBankServer","className":"RemoteBankServer","variables":{},"constants":{},"javaDoc":"This constructor doesn't do anything but because it throws the same exception that the superclass constructor throws it must be declared","comments":"\n   * This constructor doesn't do anything, but because it throws the\n   * same exception that the superclass constructor throws, it must be\n   * declared.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"get":1,"put":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/** \n   * Open a bank account with the specified name and password \n   * This method is synchronized to make it thread safe, since it \n   * manipulates the accounts hashtable.\n   **/\npublic synchronized void openAccount(String name, String password) throws RemoteException, BankingException {\n    // Check if there is already an account under that name\n    if (accounts.get(name) != null)\n        throw new BankingException(\"Account already exists.\");\n    // Otherwise, it doesn't exist, so create it.\n    Account acct = new Account(password);\n    // And register it\n    accounts.put(name, acct);\n}\n","name":"openAccount","className":"RemoteBankServer","variables":{"password":1,"accounts":2,"acct":1},"constants":{"null":1,"\"Account already exists.\"":1},"javaDoc":"Open a bank account with the specified name and password This method is synchronized to make it thread safe since it manipulates the accounts hashtable","comments":"Check if there is already an account under that name Otherwise it doesn't exist so create it And register it  \n   * Open a bank account with the specified name and password \n   * This method is synchronized to make it thread safe, since it \n   * manipulates the accounts hashtable.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"Account","methodCalls":{"get":1,"equals":1},"annotations":[],"exceptions":["BankingException"],"concepts":["Casting","Synchronization"],"types":{"Account":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This convenience method is not a remote method.  Given a name and password\n   * it checks to see if an account with that name and password exists.  If\n   * so, it returns the Account object.  Otherwise, it throws an exception.\n   **/\npublic Account verify(String name, String password) throws BankingException {\n    synchronized (accounts) {\n        Account acct = (Account) accounts.get(name);\n        if (acct == null)\n            throw new BankingException(\"No such account\");\n        if (!password.equals(acct.password))\n            throw new BankingException(\"Invalid password\");\n        return acct;\n    }\n}\n","name":"verify","className":"RemoteBankServer","variables":{"password":1,"accounts":2,"acct":3},"constants":{"\"Invalid password\"":1,"null":1,"\"No such account\"":1},"javaDoc":"This convenience method is not a remote method Given a name and password it checks to see if an account with that name and password exists If so it returns the Account object Otherwise it throws an exception","comments":"\n   * This convenience method is not a remote method.  Given a name and password\n   * it checks to see if an account with that name and password exists.  If\n   * so, it returns the Account object.  Otherwise, it throws an exception.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{"verify":1,"remove":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":17,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n   * Close the named account.  This method is synchronized to make it \n   * thread safe, since it manipulates the accounts hashtable.\n   **/\npublic synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {\n    Account acct;\n    acct = verify(name, password);\n    accounts.remove(name);\n    // have to obtain a lock on that account to be thread safe.\n    synchronized (acct) {\n        int balance = acct.balance;\n        acct.balance = 0;\n        return new FunnyMoney(balance);\n    }\n}\n     // Before changing the balance or transactions of any account, we first\n\n","name":"closeAccount","className":"RemoteBankServer","variables":{"balance":2,"accounts":1,"acct":3},"constants":{"0":1},"javaDoc":"Close the named account This method is synchronized to make it thread safe since it manipulates the accounts hashtable","comments":"Before changing the balance or transactions of any account we first have to obtain a lock on that account to be thread safe  \n   * Close the named account.  This method is synchronized to make it \n   * thread safe, since it manipulates the accounts hashtable.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{"acct.transactions.addElement":1,"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":3},"text":"/** Deposit the specified FunnyMoney to the named account */\npublic void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        acct.balance += money.amount;\n        acct.transactions.addElement(\"Deposited \" + money.amount + \" on \" + new Date());\n    }\n}\n","name":"deposit","className":"RemoteBankServer","variables":{"acct":2},"constants":{"\"Deposited \"":1,"\" on \"":1},"javaDoc":"Deposit the specified FunnyMoney to the named account","comments":" Deposit the specified FunnyMoney to the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{"acct.transactions.addElement":1,"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Withdraw the specified amount from the named account */\npublic FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        if (acct.balance < amount)\n            throw new BankingException(\"Insufficient Funds\");\n        acct.balance -= amount;\n        acct.transactions.addElement(\"Withdrew \" + amount + \" on \" + new Date());\n        return new FunnyMoney(amount);\n    }\n}\n","name":"withdraw","className":"RemoteBankServer","variables":{"amount":4,"acct":2},"constants":{"\"Insufficient Funds\"":1,"\" on \"":1,"\"Withdrew \"":1},"javaDoc":"Withdraw the specified amount from the named account","comments":" Withdraw the specified amount from the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Return the current balance in the named account */\npublic int getBalance(String name, String password) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        return acct.balance;\n    }\n}\n","name":"getBalance","className":"RemoteBankServer","variables":{"acct":2},"constants":{},"javaDoc":"Return the current balance in the named account","comments":" Return the current balance in the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"Vector","methodCalls":{"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n   * Return a Vector of strings containing the transaction history\n   * for the named account\n   **/\npublic Vector getTransactionHistory(String name, String password) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        return acct.transactions;\n    }\n}\n","name":"getTransactionHistory","className":"RemoteBankServer","variables":{"acct":2},"constants":{},"javaDoc":"Return a Vector of strings containing the transaction history for the named account","comments":" \n   * Return a Vector of strings containing the transaction history\n   * for the named account\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getProperty":1,"rebind":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"RemoteBankServer":1,"String":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":28,"StringLiteralExpr":4,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n   * The main program that runs this RemoteBankServer.\n   * Create a RemoteBankServer object and give it a name in the registry.\n   * Read a system property to determine the name, but use \"FirstRemote\"\n   * as the default name.  This is all that is necessary to set up the\n   * service.  RMI takes care of the rest.\n   **/\npublic static void main(String[] args) {\n    try {\n        // Create a bank server object\n        RemoteBankServer bank = new RemoteBankServer();\n        // Figure out what to name it\n        String name = System.getProperty(\"bankname\", \"FirstRemote\");\n        // Name it that\n        Naming.rebind(name, bank);\n        // Tell the world we're up and running\n        System.out.println(name + \" is open and ready for customers.\");\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java [-Dbankname=<name>] RemoteBankServer\");\n        System.exit(1);\n    }\n}\n                       // Force an exit because there might be other threads\n\n","name":"main","className":"RemoteBankServer","variables":{"bank":1,"e":1,"name":2,"Naming":1,"System":2},"constants":{"\"FirstRemote\"":1,"\"Usage: java [-Dbankname=<name>] RemoteBankServer\"":1,"1":1,"\" is open and ready for customers.\"":1,"\"bankname\"":1},"javaDoc":"The main program that runs this RemoteBankServer Create a RemoteBankServer object and give it a name in the registry Read a system property to determine the name but use \"FirstRemote\" as the default name This is all that is necessary to set up the service RMI takes care of the rest","comments":"Create a bank server object Figure out what to name it Name it that Tell the world we're up and running Force an exit because there might be other threads \n   * The main program that runs this RemoteBankServer.\n   * Create a RemoteBankServer object and give it a name in the registry.\n   * Read a system property to determine the name, but use \"FirstRemote\"\n   * as the default name.  This is all that is necessary to set up the\n   * service.  RMI takes care of the rest.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"actionPerformed":1,"getID":1,"getActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":14,"ThisExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    // pop down dialog\n    YesNoDialog.this.dispose();\n    if (// notify all registered listeners\n    listeners != null)\n        listeners.actionPerformed(new ActionEvent(YesNoDialog.this, e.getID(), e.getActionCommand()));\n}\n","name":"actionPerformed","className":"","variables":{"listeners":2,"e":2,"YesNoDialog":2},"constants":{"null":1},"javaDoc":"","comments":"pop down dialog notify all registered listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame","String","String","String","String","String"],"returnType":"YesNoDialog","methodCalls":{"add":3,"actionPerformed":1,"addActionListener":3,"setActionCommand":3,"getID":1,"getActionCommand":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Panel":1,"ActionListener":1,"Button":3},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":6,"NullLiteralExpr":4,"VariableDeclarationExpr":5,"BooleanLiteralExpr":1,"BinaryExpr":4,"NameExpr":73,"StringLiteralExpr":5,"FieldAccessExpr":1,"ThisExpr":6,"MethodCallExpr":18},"statements":{"IfStmt":4,"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":21},"text":"public YesNoDialog(Frame parent, String title, String message, String yes_label, String no_label, String cancel_label) {\n    // Create a modal dialog with the specified title and parent\n    super(parent, title, true);\n    // Specify a LayoutManager for it\n    this.setLayout(new BorderLayout(15, 15));\n    // Put the message label in the middle of the window.\n    // Note: MultiLineLabel is a custom component defined later in the chapter\n    this.add(\"Center\", new MultiLineLabel(message, 20, 20));\n    // Create an action listener for use by the buttons of the dialog.\n    // When a button is pressed, this listener first closes the dialog box.\n    // Then, it passes the event on to the listeners registered for the\n    // dialog box, after changing the event source from the individual button\n    // to the dialog box itself.  Since events are immutable, it must create\n    // a new ActionEvent object in order to change the source.  It passes\n    // this new event to the listeners by calling actionPerformed() on the\n    // AWTEventMulticaster object stored in the listeners field (see below).\n    ActionListener listener = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // pop down dialog\n            YesNoDialog.this.dispose();\n            if (// notify all registered listeners\n            listeners != null)\n                listeners.actionPerformed(new ActionEvent(YesNoDialog.this, e.getID(), e.getActionCommand()));\n        }\n    };\n    // Create a panel for the dialog buttons and put it at the bottom\n    // of the dialog.  Specify a FlowLayout layout manager for it.\n    Panel buttonbox = new Panel();\n    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));\n    this.add(\"South\", buttonbox);\n    // and action command for each, and adding them to the buttonbox\n    if (yes_label != null) {\n        // if a label was specified...\n        //   create button\n        Button yes = new Button(yes_label);\n        //   set action command\n        yes.setActionCommand(\"yes\");\n        //   set listener\n        yes.addActionListener(listener);\n        //   add button to the panel\n        buttonbox.add(yes);\n    }\n    if (no_label != null) {\n        Button no = new Button(no_label);\n        no.setActionCommand(\"no\");\n        no.addActionListener(listener);\n        buttonbox.add(no);\n     // Create each specified button, specifying the action listener\n\n    }\n    if (cancel_label != null) {\n        Button cancel = new Button(cancel_label);\n        cancel.setActionCommand(\"cancel\");\n        cancel.addActionListener(listener);\n        buttonbox.add(cancel);\n    }\n    // Finally, set the dialog to its preferred size.\n    this.pack();\n}\n","name":"YesNoDialog","className":"YesNoDialog","variables":{"cancel":3,"parent":1,"no":3,"listeners":2,"e":3,"yes":3,"no_label":2,"listener":1,"buttonbox":5,"yes_label":2,"title":1,"message":1,"actionPerformed":1,"YesNoDialog":2,"cancel_label":2},"constants":{"25":1,"15":3,"null":4,"\"cancel\"":1,"true":1,"\"yes\"":1,"\"Center\"":1,"20":2,"\"South\"":1,"\"no\"":1},"javaDoc":"","comments":"Put the message label in the middle of the window Create an action listener for use by the buttons of the dialog When a button is pressed this listener first closes the dialog box Then it passes the event on to the listeners registered for the dialog box after changing the event source from the individual button to the dialog box itself Since events are immutable it must create a new ActionEvent object in order to change the source It passes this new event to the listeners by calling actionPerformed() on the Create a panel for the dialog buttons and put it at the bottom Create each specified button specifying the action listener Create a modal dialog with the specified title and parent Specify a LayoutManager for it Note: MultiLineLabel is a custom component defined later in the chapter AWTEventMulticaster object stored in the listeners field (see below) pop down dialog notify all registered listeners of the dialog Specify a FlowLayout layout manager for it and action command for each and adding them to the buttonbox if a label was specified create button set action command set listener add button to the panel Finally set the dialog to its preferred size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionListener"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Register an action listener to be notified when a button is pressed\n   *  AWTEventMulticaster makes this easy. */\npublic void addActionListener(ActionListener l) {\n    listeners = AWTEventMulticaster.add(listeners, l);\n}\n","name":"addActionListener","className":"YesNoDialog","variables":{"listeners":1,"AWTEventMulticaster":1},"constants":{},"javaDoc":"Register an action listener to be notified when a button is pressed AWTEventMulticaster makes this easy","comments":" Register an action listener to be notified when a button is pressed\n   *  AWTEventMulticaster makes this easy. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionListener"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Remove an action listener from our list of interested listeners */\npublic void removeActionListener(ActionListener l) {\n    listeners = AWTEventMulticaster.remove(listeners, l);\n}\n","name":"removeActionListener","className":"YesNoDialog","variables":{"listeners":1,"AWTEventMulticaster":1},"constants":{},"javaDoc":"Remove an action listener from our list of interested listeners","comments":" Remove an action listener from our list of interested listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getActionCommand":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.out.println(\"The user pressed: \" + e.getActionCommand());\n}\n","name":"actionPerformed","className":"","variables":{"e":1},"constants":{"\"The user pressed: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setSize":1,"addActionListener":1,"show":2,"getActionCommand":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Frame":1,"YesNoDialog":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":2,"StringLiteralExpr":8,"NameExpr":23,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"BlockStmt":1,"ExpressionStmt":7},"text":"/**\n   * A main method that demonstrates how to use this class, and allows testing\n   */\npublic static void main(String[] args) {\n    // Create, size, and show a frame because dialogs require a frame parent.\n    Frame f = new Frame(\"InfoDialog Test\");\n    f.setSize(100, 100);\n    f.show();\n    // Create an instance of InfoDialog, with title and message specified\n    YesNoDialog d = new YesNoDialog(f, \"YesNoDialog Test\", \"There are unsaved files.\\n\" + \"Do you want to save them before quitting?\", \"Yes, save and quit\", \"No, quit without saving\", \"Cancel; don't quit\");\n    // Register an action listener for the dialog.  This one just prints\n    // the results out to the console.\n    d.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.out.println(\"The user pressed: \" + e.getActionCommand());\n        }\n    });\n    // Now pop the dialog up.  It will pop itself down automatically.\n    d.show();\n}\n","name":"main","className":"YesNoDialog","variables":{"actionPerformed":1,"d":3,"e":2,"f":4},"constants":{"100":2,"\"Yes, save and quit\"":1,"\"YesNoDialog Test\"":1,"\"InfoDialog Test\"":1,"\"There are unsaved files.\\n\"":1,"\"Do you want to save them before quitting?\"":1,"\"No, quit without saving\"":1,"\"Cancel; don't quit\"":1,"\"The user pressed: \"":1},"javaDoc":"A main method that demonstrates how to use this class and allows testing","comments":"Register an action listener for the dialog This one just prints Create size and show a frame because dialogs require a frame parent Create an instance of InfoDialog with title and message specified the results out to the console Now pop the dialog up It will pop itself down automatically \n   * A main method that demonstrates how to use this class, and allows testing\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"System.err.println":2,"openStream":1,"write":1,"close":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"URL":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":47,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":4,"NullLiteralExpr":2,"FieldAccessExpr":6,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ThrowStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        // Check the arguments\n        if ((args.length != 1) && (args.length != 2))\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        // Set up the streams\n        // Create the URL\n        URL url = new URL(args[0]);\n        // Open a stream to it\n        in = url.openStream();\n        if (// Get an appropriate output stream\n        args.length == 2)\n            out = new FileOutputStream(args[1]);\n        else\n            out = System.out;\n        // Now copy bytes from the URL to the output stream\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n    }// On exceptions, print error message and usage message.\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GetURL <URL> [<filename>]\");\n    } finally {\n        // Always close the streams, no matter what.\n        try {\n            in.close();\n            out.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"GetURL","variables":{"args":2,"in":4,"e":2,"bytes_read":2,"buffer":1,"url":2,"out":5},"constants":{"0":2,"1":3,"4096":1,"2":2,"null":2,"\"Wrong number of arguments\"":1,"\"Usage: java GetURL <URL> [<filename>]\"":1},"javaDoc":"","comments":"Set up the streams Check the arguments Create the URL Open a stream to it Get an appropriate output stream Now copy bytes from the URL to the output stream On exceptions print error message and usage message Always close the streams no matter what ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"init":1,"addWindowListener":1,"exit":1,"setSize":1,"show":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"Frame":1,"Applet":1,"StandaloneScribble":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"NameExpr":21,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"BlockStmt":1,"ExpressionStmt":8},"text":"/**\n   * The main() method.  If this program is invoked as an application, this\n   * method will create the necessary window, add the applet to it, and\n   * call init(), below.  Note that Frame uses a PanelLayout by default.\n   */\npublic static void main(String[] args) {\n    // Create a window\n    Frame f = new Frame();\n    // Create the applet panel\n    Applet a = new StandaloneScribble();\n    // Add applet to window\n    f.add(a, \"Center\");\n    // Initialize the applet\n    a.init();\n    // Set the size of the window\n    f.setSize(400, 400);\n    // Make the window visible\n    f.show();\n    f.addWindowListener(new // Handle window close requests\n    WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n}\n","name":"main","className":"StandaloneScribble","variables":{"a":2,"e":1,"windowClosing":1,"f":5,"System":1},"constants":{"0":1,"400":2,"\"Center\"":1},"javaDoc":"The main() method If this program is invoked as an application this method will create the necessary window add the applet to it and call init() below Note that Frame uses a PanelLayout by default","comments":"Create a window Create the applet panel Add applet to window Initialize the applet Set the size of the window Make the window visible Handle window close requests \n   * The main() method.  If this program is invoked as an application, this\n   * method will create the necessary window, add the applet to it, and\n   * call init(), below.  Note that Frame uses a PanelLayout by default.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    lastx = e.getX();\n    lasty = e.getY();\n}\n","name":"mousePressed","className":"","variables":{"e":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"setColor":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":25,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public void mouseDragged(MouseEvent e) {\n    Graphics g = getGraphics();\n    int x = e.getX(), y = e.getY();\n    g.setColor(Color.black);\n    g.drawLine(lastx, lasty, x, y);\n    lastx = x;\n    lasty = y;\n}\n","name":"mouseDragged","className":"","variables":{"e":2,"g":3,"x":2,"y":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSize":2,"setColor":1,"getGraphics":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":18,"FieldAccessExpr":2,"MethodCallExpr":6},"statements":{"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    // clear the scribble\n    Graphics g = getGraphics();\n    g.setColor(getBackground());\n    g.fillRect(0, 0, getSize().width, getSize().height);\n}\n","name":"actionPerformed","className":"","variables":{"g":3},"constants":{"0":2},"javaDoc":"","comments":"clear the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getX":2,"getSize":2,"getY":2,"setColor":2,"addActionListener":1,"getGraphics":2,"drawLine":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Graphics":2,"Button":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"NameExpr":67,"StringLiteralExpr":1,"FieldAccessExpr":3,"ThisExpr":3,"MethodCallExpr":17,"AssignExpr":4},"statements":{"BlockStmt":3,"ExpressionStmt":16},"text":"/**\n   * The init() method.  If the program is invoked as an applet, the browser\n   * allocates screen space for it and calls this method to set things up\n   */\npublic void init() {\n    // Define, instantiate and register a MouseListener object\n    this.addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            lastx = e.getX();\n            lasty = e.getY();\n        }\n    });\n    // Define, instantiate and register a MouseMotionListener object\n    this.addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            Graphics g = getGraphics();\n            int x = e.getX(), y = e.getY();\n            g.setColor(Color.black);\n            g.drawLine(lastx, lasty, x, y);\n            lastx = x;\n            lasty = y;\n        }\n    });\n    // Create a clear button\n    Button b = new Button(\"Clear\");\n    // Define, instantiate, and register a listener to handle button presses\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // clear the scribble\n            Graphics g = getGraphics();\n            g.setColor(getBackground());\n            g.fillRect(0, 0, getSize().width, getSize().height);\n        }\n    });\n    // And add the button to the applet\n    this.add(b);\n}\n","name":"init","className":"StandaloneScribble","variables":{"actionPerformed":1,"b":2,"mouseDragged":1,"e":7,"g":6,"x":2,"y":2,"lasty":2,"lastx":2,"mousePressed":1},"constants":{"0":2,"\"Clear\"":1},"javaDoc":"The init() method If the program is invoked as an applet the browser allocates screen space for it and calls this method to set things up","comments":"Define instantiate and register a MouseListener object Define instantiate and register a MouseMotionListener object Create a clear button Define instantiate and register a listener to handle button presses clear the scribble And add the button to the applet \n   * The init() method.  If the program is invoked as an applet, the browser\n   * allocates screen space for it and calls this method to set things up\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1,"setActionCommand":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":3,"FieldAccessExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/**\n   * The init method just creates a button to display in the applet.\n   * When the user clicks the button, we'll check who is logged on.\n   **/\npublic void init() {\n    who = new Button(\"Who?\");\n    who.setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n    who.addActionListener(this);\n    who.setActionCommand(\"who\");\n    this.add(who);\n}\n","name":"init","className":"Who","variables":{"who":4},"constants":{"\"Who?\"":1,"\"who\"":1,"14":1,"\"SansSerif\"":1},"javaDoc":"The init method just creates a button to display in the applet When the user clicks the button we'll check who is logged on","comments":"\n   * The init method just creates a button to display in the applet.\n   * When the user clicks the button, we'll check who is logged on.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"equals":1,"getActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":7,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"/** \n   * When the button is clicked, start a thread that will connect to\n   * the finger server and display who is logged on\n   **/\npublic void actionPerformed(ActionEvent e) {\n    if (e.getActionCommand().equals(\"who\"))\n        new Thread(this).start();\n}\n","name":"actionPerformed","className":"Who","variables":{"e":1},"constants":{"\"who\"":1},"javaDoc":"When the button is clicked start a thread that will connect to the finger server and display who is logged on","comments":" \n   * When the button is clicked, start a thread that will connect to\n   * the finger server and display who is logged on\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"show":1,"setTitle":2,"readLine":1,"pack":1,"getInputStream":1,"setEnabled":2,"println":1,"flush":1,"getOutputStream":1,"toString":1,"setFont":1,"close":3,"getHost":1,"append":3},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"CloseableFrame":1,"Frame":1,"TextArea":1,"BufferedReader":1,"String":2,"Socket":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":2,"NameExpr":75,"StringLiteralExpr":6,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"ThisExpr":1,"MethodCallExpr":22},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":6,"ExpressionStmt":26},"text":"/**\n   * This is the method that does the networking and displays the results.\n   * It is implemented as the body of a separate thread because it might\n   * take some time to complete, and applet methods need to return promptly.\n   **/\npublic void run() {\n    // Disable the button so we don't get multiple queries at once...\n    who.setEnabled(false);\n    // Create a window to display the output in\n    Frame f = new CloseableFrame(\"Who's Logged On: Connecting...\");\n    TextArea t = new TextArea(10, 80);\n    t.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 10));\n    f.add(t, \"Center\");\n    f.pack();\n    f.show();\n    // Find out  who's logged on\n    Socket s = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n    try {\n        // Connect to port 79 (the standard finger port) on the host\n        // that the applet was loaded from.\n        String hostname = this.getCodeBase().getHost();\n        s = new Socket(hostname, 79);\n        // Set up the streams\n        out = new PrintWriter(new OutputStreamWriter(s.getOutputStream()));\n        in = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        // Send a blank line to the finger server, telling it that we want\n        // a listing of everyone logged on instead of information about an\n        // individual user.\n        out.println();\n        // Send it now!\n        out.flush();\n        // Now read the server's response and display it in the textarea\n        String line;\n        while ((line = in.readLine()) != null) {\n            t.append(line);\n            t.append(\"\\n\");\n        }\n        f.setTitle(\"Who's Logged On: \" + hostname);\n    }// If something goes wrong, we'll just display the exception message\n     catch (IOException e) {\n        t.append(e.toString());\n        f.setTitle(\"Who's Logged On: Error\");\n    } finally // And finally, don't forget to close the streams!\n    {\n        try {\n            in.close();\n            out.close();\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // And enable the button again\n    who.setEnabled(true);\n}\n","name":"run","className":"Who","variables":{"hostname":3,"s":5,"t":5,"in":4,"e":3,"f":6,"line":2,"who":2,"out":5},"constants":{"\"MonoSpaced\"":1,"79":1,"null":4,"false":1,"80":1,"true":1,"\"Who's Logged On: \"":1,"\"Who's Logged On: Connecting...\"":1,"\"Center\"":1,"\"Who's Logged On: Error\"":1,"\"\\n\"":1,"10":2},"javaDoc":"This is the method that does the networking and displays the results It is implemented as the body of a separate thread because it might take some time to complete and applet methods need to return promptly","comments":"Disable the button so we don't get multiple queries at once Create a window to display the output in Find out who's logged on Connect to port 79 (the standard finger port) on the host Send a blank line to the finger server telling it that we want a listing of everyone logged on instead of information about an that the applet was loaded from Set up the streams individual user Send it now! Now read the server's response and display it in the textarea If something goes wrong we'll just display the exception message And finally don't forget to close the streams! And enable the button again \n   * This is the method that does the networking and displays the results.\n   * It is implemented as the body of a separate thread because it might\n   * take some time to complete, and applet methods need to return promptly.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Tell the system we're interested in mouse events, mouse motion events,\n   *  and keyboard events.  This is a required or events won't be sent.\n   */\npublic void init() {\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\n    // Ask for keyboard focus so we get key events\n    this.requestFocus();\n}\n","name":"init","className":"Scribble6","variables":{},"constants":{},"javaDoc":"Tell the system we're interested in mouse events mouse motion events and keyboard events This is a required or events won't be sent","comments":"Ask for keyboard focus so we get key events  Tell the system we're interested in mouse events, mouse motion events,\n   *  and keyboard events.  This is a required or events won't be sent.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Invoked when a mouse event of some type occurs */\npublic void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // check the event type\n        lastx = e.getX();\n        lasty = e.getY();\n    } else\n        // pass unhandled events to our superclass\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"Scribble6","variables":{"e":3,"lasty":1,"lastx":1},"constants":{},"javaDoc":"Invoked when a mouse event of some type occurs","comments":"check the event type pass unhandled events to our superclass  Invoked when a mouse event of some type occurs ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":1,"NameExpr":28,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/** Invoked when a mouse motion event occurs */\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        // check type\n        int x = e.getX(), y = e.getY();\n        Graphics g = this.getGraphics();\n        g.drawLine(lastx, lasty, x, y);\n        lastx = x;\n        lasty = y;\n    } else\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"Scribble6","variables":{"e":3,"g":2,"x":2,"y":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"Invoked when a mouse motion event occurs","comments":"check type  Invoked when a mouse motion event occurs ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"setColor":1,"getKeyChar":1,"getID":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":3,"NameExpr":30,"FieldAccessExpr":3,"CharLiteralExpr":1,"EnclosedExpr":2,"ThisExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/** Called on key events:  clear the screen when 'c' is typed */\npublic void processKeyEvent(KeyEvent e) {\n    if ((e.getID() == KeyEvent.KEY_TYPED) && (e.getKeyChar() == 'c')) {\n        Graphics g = this.getGraphics();\n        g.setColor(this.getBackground());\n        g.fillRect(0, 0, this.getSize().width, this.getSize().height);\n    } else\n        // pass unhandled events to our superclass\n        super.processKeyEvent(e);\n}\n","name":"processKeyEvent","className":"Scribble6","variables":{"e":2,"g":3},"constants":{"0":2,"'c'":1},"javaDoc":"Called on key events: clear the screen when 'c' is typed","comments":"pass unhandled events to our superclass  Called on key events:  clear the screen when 'c' is typed ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":8,"setBackground":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":4},"expressions":{"ObjectCreationExpr":15,"IntegerLiteralExpr":13,"VariableDeclarationExpr":4,"NameExpr":54,"StringLiteralExpr":7,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":16},"statements":{"ExpressionStmt":20},"text":"public void init() {\n    // The applet is white\n    this.setBackground(Color.white);\n    this.setFont(new Font(\"Dialog\", Font.BOLD, 24));\n    Panel p1 = new Panel();\n    // Panel1 is darker than applet\n    p1.setBackground(new Color(200, 200, 200));\n    // Panel 1 is contained in applet\n    this.add(p1);\n    // Button 1 is contained in Panel 1\n    p1.add(new Button(\"#1\"));\n    Panel p2 = new Panel();\n    // Panel2 is darker than Panel1\n    p2.setBackground(new Color(150, 150, 150));\n    // Panel 2 is contained in Panel 1\n    p1.add(p2);\n    // Button 2 is contained in Panel 2\n    p2.add(new Button(\"#2\"));\n    Panel p3 = new Panel();\n    // Panel3 is darker than Panel2\n    p3.setBackground(new Color(100, 100, 100));\n    // Panel 3 is contained in Panel 2\n    p2.add(p3);\n    // Button 3 is contained in Panel 3\n    p3.add(new Button(\"#3\"));\n    Panel p4 = new Panel();\n    // Panel4 is darker than Panel1\n    p4.setBackground(new Color(150, 150, 150));\n    // Panel4 is contained in Panel 1\n    p1.add(p4);\n    // Button4 is contained in Panel4\n    p4.add(new Button(\"#4\"));\n    // Button5 is contained in Panel4\n    p4.add(new Button(\"#5\"));\n    // Button6 is contained in applet\n    this.add(new Button(\"#6\"));\n}\n","name":"init","className":"Containers","variables":{"p1":5,"p2":4,"p3":3,"p4":4},"constants":{"\"#4\"":1,"100":3,"\"#5\"":1,"24":1,"200":3,"\"#6\"":1,"150":6,"\"#1\"":1,"\"Dialog\"":1,"\"#2\"":1,"\"#3\"":1},"javaDoc":"","comments":"The applet is white Panel1 is darker than applet Panel 1 is contained in applet Button 1 is contained in Panel 1 Panel2 is darker than Panel1 Panel 2 is contained in Panel 1 Button 2 is contained in Panel 2 Panel3 is darker than Panel2 Panel 3 is contained in Panel 2 Button 3 is contained in Panel 3 Panel4 is darker than Panel1 Panel4 is contained in Panel 1 Button4 is contained in Panel4 Button5 is contained in Panel4 Button6 is contained in applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"initSign":1,"getIdentity":1,"writeObject":1,"toByteArray":1,"sign":1,"update":1,"getSystemScope":1,"getInstance":1,"getPrivateKey":1},"annotations":[],"exceptions":["IOException","SignatureException","NoSuchAlgorithmException","InvalidKeyException"],"concepts":["Casting","Synchronization"],"types":{"Signer":1,"Signature":1,"ByteArrayOutputStream":1,"ObjectOutputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BooleanLiteralExpr":2,"NameExpr":39,"CastExpr":1,"FieldAccessExpr":3,"ThisExpr":4,"AssignExpr":5,"MethodCallExpr":9},"statements":{"ExpressionStmt":12},"text":"/**\n   * This method computes a digital signature for the current state of the\n   * object, excluding the signature-related state of this class.\n   * That is, the signature is based only on the state of the subclasses.\n   * The arguments specify who is signing the object, and what digital \n   * signature algorithm to use.\n   * \n   * Note that no other threads should be modifying the object while\n   * this computation is being performed.  If a subclass will be used in a \n   * multi-threaded environment, this means that methods of the subclass\n   * that modify its state should be synchronized like this one is.\n   **/\npublic synchronized void sign(String signername, String algorithm) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {\n    // Save the arguments for use by verify()\n    this.signername = signername;\n    this.algorithm = algorithm;\n    // Get a Signature object to compute the signature with\n    Signature s = Signature.getInstance(algorithm);\n    // Get a Signer object representing the signer\n    Signer signer = (Signer) IdentityScope.getSystemScope().getIdentity(signername);\n    // Initialize the Signature object using the PrivateKey of the Signer\n    s.initSign(signer.getPrivateKey());\n    // Create an ObjectOutputStream that writes its output to a \n    // ByteArrayStream.  This is how we capture the state of the object\n    // so that it can be signed.\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n    ObjectOutputStream out = new ObjectOutputStream(bout);\n    // Now serialize the object, capturing its state.  We have to set a flag\n    // before we do this, so that the signer name, algorithm, and signature\n    // itself are not included in this serialized state.  See writeObject()\n    // below to see how this works.\n    signing = true;\n    out.writeObject(this);\n    signing = false;\n    // Now tell the Signature object about the bytes of serialized state\n    // that were stored by the ByteArrayOutputStream\n    s.update(bout.toByteArray());\n    // And finally, compute the signature\n    this.signature = s.sign();\n}\n","name":"sign","className":"SignedObject","variables":{"bout":3,"s":4,"IdentityScope":1,"Signature":1,"signername":1,"signing":2,"algorithm":1,"signer":2,"out":2},"constants":{"true":1,"false":1},"javaDoc":"This method computes a digital signature for the current state of the object excluding the signature-related state of this class That is the signature is based only on the state of the subclasses The arguments specify who is signing the object and what digital signature algorithm to use Note that no other threads should be modifying the object while this computation is being performed If a subclass will be used in a multi-threaded environment this means that methods of the subclass that modify its state should be synchronized like this one is","comments":"Create an ObjectOutputStream that writes its output to a ByteArrayStream This is how we capture the state of the object Now serialize the object capturing its state We have to set a flag before we do this so that the signer name algorithm and signature itself are not included in this serialized state See writeObject() Now tell the Signature object about the bytes of serialized state Save the arguments for use by verify() Get a Signature object to compute the signature with Get a Signer object representing the signer Initialize the Signature object using the PrivateKey of the Signer so that it can be signed below to see how this works that were stored by the ByteArrayOutputStream And finally compute the signature \n   * This method computes a digital signature for the current state of the\n   * object, excluding the signature-related state of this class.\n   * That is, the signature is based only on the state of the subclasses.\n   * The arguments specify who is signing the object, and what digital \n   * signature algorithm to use.\n   * \n   * Note that no other threads should be modifying the object while\n   * this computation is being performed.  If a subclass will be used in a \n   * multi-threaded environment, this means that methods of the subclass\n   * that modify its state should be synchronized like this one is.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"sign":1},"annotations":[],"exceptions":["IOException","SignatureException","NoSuchAlgorithmException","InvalidKeyException"],"concepts":["Recursion","Synchronization"],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** A simpler version of sign(), that defaults to using the DSA algorithm */\npublic synchronized void sign(String signername) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {\n    sign(signername, \"DSA\");\n}\n","name":"sign","className":"SignedObject","variables":{},"constants":{"\"DSA\"":1},"javaDoc":"A simpler version of sign() that defaults to using the DSA algorithm","comments":" A simpler version of sign(), that defaults to using the DSA algorithm ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"initVerify":1,"getIdentity":1,"writeObject":1,"toByteArray":1,"update":1,"verify":1,"getSystemScope":1,"getInstance":1,"getPublicKey":1},"annotations":[],"exceptions":["IOException","SignatureException","NoSuchAlgorithmException","InvalidKeyException"],"concepts":["Casting","Synchronization"],"types":{"Signature":1,"ByteArrayOutputStream":1,"Identity":1,"ObjectOutputStream":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":34,"StringLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":9,"AssignExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n   * This method verifies the signature of any SignedObject subclass.\n   * It works much like the sign() method, and is also synchronized.\n   **/\npublic synchronized boolean verify() throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {\n    // Make sure the object is actually signed.\n    if (signature == null)\n        throw new SignatureException(\"Object is not signed\");\n    // Get the signature, signer and public key, and initialize, like above,\n    // except that this time use a PublicKey instead of a PrivateKey\n    Signature s = Signature.getInstance(algorithm);\n    Identity signer = (Identity) IdentityScope.getSystemScope().getIdentity(signername);\n    s.initVerify(signer.getPublicKey());\n    // Create streams and capture the current state of the object \n    // (excluding the signature bytes themselves) in a byte array\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n    ObjectOutputStream out = new ObjectOutputStream(bout);\n    signing = true;\n    out.writeObject(this);\n    signing = false;\n    // Pass state of the object to the Signature, and verify the stored\n    // signature bytes against that state.  Return the result of verification.\n    s.update(bout.toByteArray());\n    return s.verify(this.signature);\n}\n","name":"verify","className":"SignedObject","variables":{"bout":3,"s":4,"IdentityScope":1,"signature":1,"Signature":1,"signing":2,"signer":2,"out":2},"constants":{"\"Object is not signed\"":1,"null":1,"true":1,"false":1},"javaDoc":"This method verifies the signature of any SignedObject subclass It works much like the sign() method and is also synchronized","comments":"Get the signature signer and public key and initialize like above Create streams and capture the current state of the object Pass state of the object to the Signature and verify the stored Make sure the object is actually signed except that this time use a PublicKey instead of a PrivateKey (excluding the signature bytes themselves) in a byte array signature bytes against that state Return the result of verification \n   * This method verifies the signature of any SignedObject subclass.\n   * It works much like the sign() method, and is also synchronized.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/**\n   * When the contents of the object change, the signature becomes invalid.\n   * When this happens, the signature should be erased, because validation\n   * is guaranteed to fail.\n   **/\npublic void removeSignature() {\n    signature = null;\n    signername = null;\n    algorithm = null;\n}\n","name":"removeSignature","className":"SignedObject","variables":{"signature":1,"signername":1,"algorithm":1},"constants":{"null":3},"javaDoc":"When the contents of the object change the signature becomes invalid When this happens the signature should be erased because validation is guaranteed to fail","comments":"\n   * When the contents of the object change, the signature becomes invalid.\n   * When this happens, the signature should be erased, because validation\n   * is guaranteed to fail.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ObjectOutputStream"],"returnType":"void","methodCalls":{"defaultWriteObject":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"/**\n   * This method is invoked to allow custom serialization.\n   * We only write out our signature-related state when we are not computing\n   * or verifying a signature.  When we are computing or verifying, only our\n   * subclass state gets written out.  If we don't do this, verification will\n   * fail because the signature[] array will obviously be different on\n   * verification than it is when the signature is generated.\n   **/\nprivate void writeObject(ObjectOutputStream out) throws IOException {\n    if (!signing)\n        out.defaultWriteObject();\n}\n","name":"writeObject","className":"SignedObject","variables":{"signing":1,"out":1},"constants":{},"javaDoc":"This method is invoked to allow custom serialization We only write out our signature-related state when we are not computing or verifying a signature When we are computing or verifying only our subclass state gets written out If we don't do this verification will fail because the signature[] array will obviously be different on verification than it is when the signature is generated","comments":"\n   * This method is invoked to allow custom serialization.\n   * We only write out our signature-related state when we are not computing\n   * or verifying a signature.  When we are computing or verifying, only our\n   * subclass state gets written out.  If we don't do this, verification will\n   * fail because the signature[] array will obviously be different on\n   * verification than it is when the signature is generated.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"SignedString","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public SignedString(String s) {\n    this.s = s;\n}\n","name":"SignedString","className":"SignedString","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SignedString","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public SignedString getString() throws RemoteException;\n","name":"getString","className":"RemoteSignedString","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SignedString"],"returnType":"SignedStringServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The constructor.  Initialize the SignedString */\npublic SignedStringServer(SignedString s) throws RemoteException {\n    this.s = s;\n}\n","name":"SignedStringServer","className":"SignedStringServer","variables":{"s":1},"constants":{},"javaDoc":"The constructor Initialize the SignedString","comments":" The constructor.  Initialize the SignedString ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SignedString","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is the remote method exported by the server */\npublic SignedString getString() throws RemoteException {\n    return s;\n}\n","name":"getString","className":"SignedStringServer","variables":{"s":1},"constants":{},"javaDoc":"This is the remote method exported by the server","comments":" This is the remote method exported by the server ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"rebind":1,"sign":1,"System.out.println":1},"annotations":[],"exceptions":["NoSuchAlgorithmException","IOException","SignatureException","InvalidKeyException"],"concepts":[],"types":{"SignedString":1,"SignedStringServer":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"/** The main program that creates and registers the server object */\npublic static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException {\n    // create object\n    SignedString ss = new SignedString(args[0]);\n    // sign it\n    ss.sign(args[1]);\n    // start server\n    SignedStringServer sss = new SignedStringServer(ss);\n    // register server\n    Naming.rebind(\"SignedStringServer\", sss);\n    // up and running!\n    System.out.println(\"Ready for clients\");\n}\n","name":"main","className":"SignedStringServer","variables":{"ss":3,"args":2,"sss":1,"Naming":1},"constants":{"0":1,"1":1,"\"Ready for clients\"":1,"\"SignedStringServer\"":1},"javaDoc":"The main program that creates and registers the server object","comments":"create object sign it start server register server up and running!  The main program that creates and registers the server object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookup":1,"verify":1,"getString":1,"System.out.println":2},"annotations":[],"exceptions":["NotBoundException","NoSuchAlgorithmException","IOException","SignatureException","InvalidKeyException"],"concepts":["Casting"],"types":{"SignedString":1,"RemoteSignedString":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"CastExpr":1,"NameExpr":26,"StringLiteralExpr":5,"FieldAccessExpr":4,"EnclosedExpr":2,"ConditionalExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException, NotBoundException {\n    // Look up the server\n    RemoteSignedString rss = (RemoteSignedString) Naming.lookup(\"rmi://\" + ((args.length > 0) ? args[0] : \"\") + \"/SignedStringServer\");\n    // Invoke a remote method of the server to get a SignedString\n    SignedString ss = rss.getString();\n    // Now verify the signature on that SignedString.\n    if (ss.verify())\n        System.out.println(\"Verified SignedString: \" + ss.s);\n    else\n        System.out.println(\"SignedString failed verification\");\n}\n","name":"main","className":"SignedStringClient","variables":{"args":1,"ss":2,"rss":2,"Naming":1},"constants":{"0":2,"\"\"":1,"\"Verified SignedString: \"":1,"\"/SignedStringServer\"":1,"\"rmi://\"":1,"\"SignedString failed verification\"":1},"javaDoc":"","comments":"Look up the server Invoke a remote method of the server to get a SignedString Now verify the signature on that SignedString ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":7,"StringLiteralExpr":1,"ThisExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Initialize the button and the Graphics object */\npublic void init() {\n    clear_button = new Button(\"Clear\");\n    this.add(clear_button);\n    g = this.getGraphics();\n}\n","name":"init","className":"Scribble1","variables":{"g":1,"clear_button":1},"constants":{"\"Clear\"":1},"javaDoc":"Initialize the button and the Graphics object","comments":" Initialize the button and the Graphics object ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Respond to mouse clicks */\npublic boolean mouseDown(Event e, int x, int y) {\n    lastx = x;\n    lasty = y;\n    return true;\n}\n","name":"mouseDown","className":"Scribble1","variables":{"x":1,"y":1,"lasty":1,"lastx":1},"constants":{"true":1},"javaDoc":"Respond to mouse clicks","comments":" Respond to mouse clicks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"setColor":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Respond to mouse drags */\npublic boolean mouseDrag(Event e, int x, int y) {\n    g.setColor(Color.black);\n    g.drawLine(lastx, lasty, x, y);\n    lastx = x;\n    lasty = y;\n    return true;\n}\n","name":"mouseDrag","className":"Scribble1","variables":{"g":2,"x":1,"y":1,"lasty":1,"lastx":1},"constants":{"true":1},"javaDoc":"Respond to mouse drags","comments":" Respond to mouse drags ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":9,"FieldAccessExpr":2,"CharLiteralExpr":1,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** Respond to key presses */\npublic boolean keyDown(Event e, int key) {\n    if ((e.id == Event.KEY_PRESS) && (key == 'c')) {\n        clear();\n        return true;\n    } else\n        return false;\n}\n","name":"keyDown","className":"Scribble1","variables":{"key":1},"constants":{"true":1,"false":1,"'c'":1},"javaDoc":"Respond to key presses","comments":" Respond to key presses ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** Respond to Button clicks */\npublic boolean action(Event e, Object arg) {\n    if (e.target == clear_button) {\n        clear();\n        return true;\n    } else\n        return false;\n}\n","name":"action","className":"Scribble1","variables":{"clear_button":1},"constants":{"true":1,"false":1},"javaDoc":"Respond to Button clicks","comments":" Respond to Button clicks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setColor":1,"bounds":2,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":16,"FieldAccessExpr":2,"ThisExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":2},"text":"/** convenience method to erase the scribble */\npublic void clear() {\n    g.setColor(this.getBackground());\n    g.fillRect(0, 0, bounds().width, bounds().height);\n}\n","name":"clear","className":"Scribble1","variables":{"g":2},"constants":{"0":2},"javaDoc":"convenience method to erase the scribble","comments":" convenience method to erase the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"createMenuItems":2,"init":1,"setMenuBar":1,"addWindowListener":1,"exit":1,"setSize":1,"addActionListener":2,"show":1,"setActionCommand":2,"setHelpMenu":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Frame":1,"MenuScribble":1,"MenuBar":1,"MenuItem":2,"Menu":3},"expressions":{"ObjectCreationExpr":11,"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"ArrayInitializerExpr":6,"NameExpr":92,"StringLiteralExpr":18,"FieldAccessExpr":7,"ArrayCreationExpr":6,"MethodCallExpr":19},"statements":{"BlockStmt":1,"ExpressionStmt":27},"text":"/**\n   * The main() method.  If this program is invoked as an application, this\n   * method will create a window and pulldown menu system for it.\n   */\npublic static void main(String[] args) {\n    // Create a window\n    Frame f = new Frame();\n    // Create the applet panel\n    MenuScribble applet = new MenuScribble();\n    // Add applet to window\n    f.add(applet, \"Center\");\n    // Initialize the applet\n    applet.init();\n    // Create a menubar and tell the frame about it\n    MenuBar menubar = new MenuBar();\n    f.setMenuBar(menubar);\n    // Create three pulldown menus for the menubar\n    Menu file = new Menu(\"File\");\n    Menu colors = new Menu(\"Colors\");\n    Menu help = new Menu(\"Help\");\n    // Add the menus to the bar, and treat Help menu specially.\n    menubar.add(file);\n    menubar.add(colors);\n    menubar.add(help);\n    menubar.setHelpMenu(help);\n    // Add two items, with a keyboard shortcuts to the File menu\n    MenuItem clear = new MenuItem(\"Clear\", new MenuShortcut(KeyEvent.VK_C));\n    // Say who's listening for the events\n    clear.addActionListener(applet);\n    // A detail to go along with the events\n    clear.setActionCommand(\"clear\");\n    // Add item to menu pane\n    file.add(clear);\n    MenuItem quit = new MenuItem(\"Quit\", new MenuShortcut(KeyEvent.VK_Q));\n    quit.addActionListener(applet);\n    quit.setActionCommand(\"quit\");\n    file.add(quit);\n    // Add items to the other two menus, this time using a  convenience\n    // method defined below.  Note use of new anonymous array syntax.\n    createMenuItems(colors, applet, new String[] { \"Red\", \"Green\", \"Blue\", \"Black\" }, new String[] { \"red\", \"green\", \"blue\", \"black\" }, new int[] { KeyEvent.VK_R, KeyEvent.VK_G, KeyEvent.VK_B, KeyEvent.VK_L });\n    createMenuItems(help, applet, new String[] { \"About\" }, new String[] { \"about\" }, new int[] { KeyEvent.VK_A });\n    // Handle window close requests\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Set the size of the window\n    f.setSize(400, 400);\n    // Finally, pop the window up.\n    f.show();\n}\n","name":"main","className":"MenuScribble","variables":{"menubar":5,"help":1,"file":3,"e":1,"windowClosing":1,"f":6,"clear":3,"quit":3,"applet":2,"colors":1,"System":1},"constants":{"\"Quit\"":1,"\"quit\"":1,"\"about\"":1,"\"red\"":1,"\"Colors\"":1,"\"black\"":1,"\"Center\"":1,"\"green\"":1,"\"About\"":1,"\"Green\"":1,"0":1,"\"clear\"":1,"\"File\"":1,"400":2,"\"Help\"":1,"\"Red\"":1,"\"Black\"":1,"\"blue\"":1,"\"Clear\"":1,"\"Blue\"":1},"javaDoc":"The main() method If this program is invoked as an application this method will create a window and pulldown menu system for it","comments":"Add items to the other two menus this time using a convenience Create a window Create the applet panel Add applet to window Initialize the applet Create a menubar and tell the frame about it Create three pulldown menus for the menubar Add the menus to the bar and treat Help menu specially Add two items with a keyboard shortcuts to the File menu Say who's listening for the events A detail to go along with the events Add item to menu pane method defined below Note use of new anonymous array syntax Handle window close requests Set the size of the window Finally pop the window up \n   * The main() method.  If this program is invoked as an application, this\n   * method will create a window and pulldown menu system for it.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    lastx = e.getX();\n    lasty = e.getY();\n}\n","name":"mousePressed","className":"","variables":{"e":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"setColor":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"int":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":23,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":6},"text":"public void mouseDragged(MouseEvent e) {\n    Graphics g = getGraphics();\n    int x = e.getX(), y = e.getY();\n    // draw with the specified color\n    g.setColor(color);\n    g.drawLine(lastx, lasty, x, y);\n    lastx = x;\n    lasty = y;\n}\n","name":"mouseDragged","className":"","variables":{"e":2,"g":3,"x":2,"y":2,"lasty":1,"lastx":1},"constants":{},"javaDoc":"","comments":"draw with the specified color ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"createMenuItems":1,"getX":2,"getY":2,"setColor":1,"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Graphics":1,"int":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"NameExpr":63,"StringLiteralExpr":11,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":5,"ArrayInitializerExpr":3,"FieldAccessExpr":5,"EnclosedExpr":1,"ArrayCreationExpr":3,"ThisExpr":5,"MethodCallExpr":12},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":13},"text":"/**\n   * The init() method.  If the program is invoked as an applet, the browser\n   * allocates screen space for it and calls this method to set things up.\n   * If running as an applet, this method creates a popup menu and adds\n   * it to the applet.\n   */\npublic void init() {\n    // If we are not in a frame (i.e. we are an applet), create a popup menu\n    if (!(this.getParent() instanceof Frame)) {\n        // Create the popup menu\n        popup = new PopupMenu(\"File\");\n        // Add items to it using the convenience routine below\n        createMenuItems(popup, this, new String[] { \"Clear\", \"Red\", \"Green\", \"Blue\", \"Black\" }, new String[] { \"clear\", \"red\", \"green\", \"blue\", \"black\" }, new int[] { KeyEvent.VK_C, KeyEvent.VK_R, KeyEvent.VK_G, KeyEvent.VK_B, KeyEvent.VK_L });\n        // Add the popup menu to the component it will appear over.\n        this.add(popup);\n    }\n    // Define, instantiate and register the Listener objects for scribbling\n    this.addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            lastx = e.getX();\n            lasty = e.getY();\n        }\n    });\n    this.addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            Graphics g = getGraphics();\n            int x = e.getX(), y = e.getY();\n            // draw with the specified color\n            g.setColor(color);\n            g.drawLine(lastx, lasty, x, y);\n            lastx = x;\n            lasty = y;\n        }\n    });\n}\n","name":"init","className":"MenuScribble","variables":{"popup":1,"mouseDragged":1,"e":6,"g":3,"x":2,"y":2,"lasty":2,"lastx":2,"mousePressed":1},"constants":{"\"Green\"":1,"\"clear\"":1,"\"File\"":1,"\"Red\"":1,"\"Black\"":1,"\"red\"":1,"\"blue\"":1,"\"black\"":1,"\"green\"":1,"\"Clear\"":1,"\"Blue\"":1},"javaDoc":"The init() method If the program is invoked as an applet the browser allocates screen space for it and calls this method to set things up If running as an applet this method creates a popup menu and adds it to the applet","comments":"If we are not in a frame (i e we are an applet) create a popup menu Create the popup menu Add items to it using the convenience routine below Add the popup menu to the component it will appear over Define instantiate and register the Listener objects for scribbling draw with the specified color \n   * The init() method.  If the program is invoked as an applet, the browser\n   * allocates screen space for it and calls this method to set things up.\n   * If running as an applet, this method creates a popup menu and adds\n   * it to the applet.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Menu","ActionListener","String[]","String[]","int[]"],"returnType":"void","methodCalls":{"setShortcut":1,"add":1,"addActionListener":1,"setActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MenuItem":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":5,"BinaryExpr":7,"NameExpr":31,"FieldAccessExpr":1,"EnclosedExpr":4,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/**\n   * This is the convenience routine for adding menu items to a menu pane.\n   * It works for pulldown or popup menu panes, since PopupMenu extends Menu.\n   */\nprotected static void createMenuItems(Menu pane, ActionListener listener, String[] labels, String[] commands, int[] shortcuts) {\n    for (int i = 0; i < labels.length; i++) {\n        MenuItem mi = new MenuItem(labels[i]);\n        mi.addActionListener(listener);\n        if ((commands != null) && (commands[i] != null))\n            mi.setActionCommand(commands[i]);\n        if ((shortcuts != null) && (shortcuts[i] != 0))\n            mi.setShortcut(new MenuShortcut(shortcuts[i]));\n        pane.add(mi);\n    }\n}\n","name":"createMenuItems","className":"MenuScribble","variables":{"shortcuts":3,"i":8,"mi":4,"pane":1,"commands":3,"labels":1},"constants":{"0":2,"null":3},"javaDoc":"This is the convenience routine for adding menu items to a menu pane It works for pulldown or popup menu panes since PopupMenu extends Menu","comments":"\n   * This is the convenience routine for adding menu items to a menu pane.\n   * It works for pulldown or popup menu panes, since PopupMenu extends Menu.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":12}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"show":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"SuperExpr":1,"BinaryExpr":2,"NameExpr":16,"EnclosedExpr":1,"ThisExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/**\n   * This method is required to make the popup menu, if any, pop up.  It\n   * uses the low-level Java 1.1 event handling mechanism to test all mouse\n   * events (except mouse motion events) to see if they are the platform-\n   * dependent popup menu trigger.  If so, it calls show() to pop the\n   * popup up.  If not, it passes the event to the superclass version of\n   * this method so that it is dispatched as usual and can be passed to\n   * the listener object registered by the init method for scribbling.\n   */\npublic void processMouseEvent(MouseEvent e) {\n    if ((popup != null) && e.isPopupTrigger())\n        popup.show(this, e.getX(), e.getY());\n    else\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"MenuScribble","variables":{"popup":2,"e":3},"constants":{"null":1},"javaDoc":"This method is required to make the popup menu if any pop up It uses the low-level Java 1 1 event handling mechanism to test all mouse events (except mouse motion events) to see if they are the platform- dependent popup menu trigger If so it calls show() to pop the popup up If not it passes the event to the superclass version of this method so that it is dispatched as usual and can be passed to the listener object registered by the init method for scribbling","comments":"\n   * This method is required to make the popup menu, if any, pop up.  It\n   * uses the low-level Java 1.1 event handling mechanism to test all mouse\n   * events (except mouse motion events) to see if they are the platform-\n   * dependent popup menu trigger.  If so, it calls show() to pop the\n   * popup up.  If not, it passes the event to the superclass version of\n   * this method so that it is dispatched as usual and can be passed to\n   * the listener object registered by the init method for scribbling.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"equals":7,"clear":1,"getActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":45,"StringLiteralExpr":7,"FieldAccessExpr":4,"MethodCallExpr":10,"AssignExpr":4},"statements":{"IfStmt":7,"EmptyStmt":1,"ExpressionStmt":7},"text":"/**\n   * This is the method defined by the ActionListener interface.  All\n   * the menu item commands are handled here because the applet was specified\n   * as the listener for all menu items.  Note the use of getActionCommand()\n   * to determine the command string registered with the individual items.\n   */\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (// Don't do this in an applet\n    cmd.equals(\"quit\"))\n        // Don't do this in an applet\n        System.exit(0);\n    else if (// defined below\n    cmd.equals(\"clear\"))\n        // defined below\n        clear();\n    else if (cmd.equals(\"about\"))\n        /* not yet implemented */\n        ;\n    else if (cmd.equals(\"red\"))\n        color = Color.red;\n    else if (cmd.equals(\"green\"))\n        color = Color.green;\n    else if (cmd.equals(\"blue\"))\n        color = Color.blue;\n    else if (cmd.equals(\"black\"))\n        color = color.black;\n}\n","name":"actionPerformed","className":"MenuScribble","variables":{"color":4,"e":1,"cmd":8,"System":1},"constants":{"0":1,"\"quit\"":1,"\"clear\"":1,"\"about\"":1,"\"red\"":1,"\"blue\"":1,"\"black\"":1,"\"green\"":1},"javaDoc":"This is the method defined by the ActionListener interface All the menu item commands are handled here because the applet was specified as the listener for all menu items Note the use of getActionCommand() to determine the command string registered with the individual items","comments":"Don't do this in an applet Don't do this in an applet defined below defined below not yet implemented \n   * This is the method defined by the ActionListener interface.  All\n   * the menu item commands are handled here because the applet was specified\n   * as the listener for all menu items.  Note the use of getActionCommand()\n   * to determine the command string registered with the individual items.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":18,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":6},"statements":{"ExpressionStmt":3},"text":"/** Clear the applet area.  Used by actionPerformed() above */\nprotected void clear() {\n    Graphics g = this.getGraphics();\n    g.setColor(this.getBackground());\n    g.fillRect(0, 0, this.getSize().width, this.getSize().height);\n}\n","name":"clear","className":"MenuScribble","variables":{"g":3},"constants":{"0":2},"javaDoc":"Clear the applet area Used by actionPerformed() above","comments":" Clear the applet area.  Used by actionPerformed() above ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"exit":1,"setSecurityManager":1,"addService":1,"loadClass":1,"newInstance":1,"System.err.println":2},"annotations":[],"exceptions":["// Display a message if anything goes wrong\nException"],"concepts":["Casting","ExceptionHandling"],"types":{"Server":1,"Service":1,"Class":1,"int":2,"LocalClassLoader":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":40,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    try {\n        // Install the Security manager\n        System.setSecurityManager(new ServiceSecurityManager());\n        // Create the ClassLoader that we'll use to load Service classes.\n        // The classes should be stored in (or beneath) the directory specified\n        // as the first command-line argument\n        LocalClassLoader loader = new LocalClassLoader(args[0]);\n        // Create a Server object that does no logging and\n        // has a limit of five concurrent connections at once.\n        Server server = new Server(null, 5);\n        // Parse the argument list, which should contain Service name/port pairs.\n        // For each pair, load the named Service using the class loader, then\n        // instantiate it with newInstance(), then tell the server to start\n        // running it.\n        int i = 1;\n        while (i < args.length) {\n            // dynamic load\n            Class serviceClass = loader.loadClass(args[i++]);\n            // instantiate\n            Service service = (Service) serviceClass.newInstance();\n            // get port\n            int port = Integer.parseInt(args[i++]);\n            // run service\n            server.addService(service, port);\n        }\n    } catch (// Display a message if anything goes wrong\n    Exception // Display a message if anything goes wrong\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java SafeServer \" + \"<servicedir> <servicename> <port>\\n\" + \"\\t\\t[<servicename> <port> ... ]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"SafeServer","variables":{"args":3,"Integer":1,"server":2,"serviceClass":2,"port":1,"e":1,"loader":2,"service":1,"i":4,"System":2},"constants":{"0":1,"1":2,"null":1,"\"\\t\\t[<servicename> <port> ... ]\"":1,"5":1,"\"<servicedir> <servicename> <port>\\n\"":1,"\"Usage: java SafeServer \"":1},"javaDoc":"","comments":"Create the ClassLoader that we'll use to load Service classes The classes should be stored in (or beneath) the directory specified Create a Server object that does no logging and Parse the argument list which should contain Service name/port pairs For each pair load the named Service using the class loader then instantiate it with newInstance() then tell the server to start Install the Security manager as the first command-line argument has a limit of five concurrent connections at once running it dynamic load instantiate get port run service Display a message if anything goes wrong Display a message if anything goes wrong ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"inClassLoader":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1},"text":"/**\n     * This is the basic method that tests whether there is a class loaded\n     * by a ClassLoader anywhere on the stack.  If so, it means that that\n     * untrusted code is trying to perform some kind of sensitive operation.\n     * We prevent it from performing that operation by throwing an exception.\n     * trusted() is called by most of the check...() methods below.\n     **/\nprotected void trusted() {\n    if (inClassLoader())\n        throw new SecurityException();\n}\n","name":"trusted","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"This is the basic method that tests whether there is a class loaded by a ClassLoader anywhere on the stack If so it means that that untrusted code is trying to perform some kind of sensitive operation We prevent it from performing that operation by throwing an exception trusted() is called by most of the check () methods below","comments":"\n     * This is the basic method that tests whether there is a class loaded\n     * by a ClassLoader anywhere on the stack.  If so, it means that that\n     * untrusted code is trying to perform some kind of sensitive operation.\n     * We prevent it from performing that operation by throwing an exception.\n     * trusted() is called by most of the check...() methods below.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"classLoaderDepth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1},"text":"/**\n     * This is a variant on the trusted() method above.  There are a couple\n     * of methods that loaded code should not be able to call directly, but\n     * which system methods invoked by the loaded code still need to be\n     * able to call.  So for these, we only throw an exception if a\n     * loaded class is the third thing on the call stack.  I.e. right above\n     * this method and the check...() method that invoked it\n     **/\nprotected void trustedOrIndirect() {\n    if (classLoaderDepth() == 3)\n        throw new SecurityException();\n}\n","name":"trustedOrIndirect","className":"ServiceSecurityManager","variables":{},"constants":{"3":1},"javaDoc":"This is a variant on the trusted() method above There are a couple of methods that loaded code should not be able to call directly but which system methods invoked by the loaded code still need to be able to call So for these we only throw an exception if a loaded class is the third thing on the call stack I e right above this method and the check () method that invoked it","comments":"\n     * This is a variant on the trusted() method above.  There are a couple\n     * of methods that loaded code should not be able to call directly, but\n     * which system methods invoked by the loaded code still need to be\n     * able to call.  So for these, we only throw an exception if a\n     * loaded class is the third thing on the call stack.  I.e. right above\n     * this method and the check...() method that invoked it\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"classLoaderDepth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":4,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n     * Here's another variant.  It denies access if a loaded class attempts\n     * the operation directly or through one level of indirection.  It is used\n     * to prevent loaded code from calling Runtime.load(), or \n     * System.loadLibrary() (which calls Runtime.load()).\n     **/\nprotected void trustedOrIndirect2() {\n    int depth = classLoaderDepth();\n    if ((depth == 3) || (depth == 4))\n        throw new SecurityException();\n}\n","name":"trustedOrIndirect2","className":"ServiceSecurityManager","variables":{"depth":3},"constants":{"3":1,"4":1},"javaDoc":"Here's another variant It denies access if a loaded class attempts the operation directly or through one level of indirection It is used to prevent loaded code from calling Runtime load() or System loadLibrary() (which calls Runtime load())","comments":"\n     * Here's another variant.  It denies access if a loaded class attempts\n     * the operation directly or through one level of indirection.  It is used\n     * to prevent loaded code from calling Runtime.load(), or \n     * System.loadLibrary() (which calls Runtime.load()).\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"trustedOrIndirect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * These are all the specific checks that a security manager can\n     * perform.  They all just call one of the methods above and throw a\n     * SecurityException if the operation is not allowed.  This \n     * SecurityManager subclass is perhaps a little too restrictive.  For\n     * example, it doesn't allow loaded code to read *any* system properties,\n     * even though some of them are quite harmless.\n     **/\npublic void checkCreateClassLoader() {\n    trustedOrIndirect();\n}\n","name":"checkCreateClassLoader","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"These are all the specific checks that a security manager can perform They all just call one of the methods above and throw a SecurityException if the operation is not allowed This SecurityManager subclass is perhaps a little too restrictive For example it doesn't allow loaded code to read any system properties even though some of them are quite harmless","comments":"\n     * These are all the specific checks that a security manager can\n     * perform.  They all just call one of the methods above and throw a\n     * SecurityException if the operation is not allowed.  This \n     * SecurityManager subclass is perhaps a little too restrictive.  For\n     * example, it doesn't allow loaded code to read *any* system properties,\n     * even though some of them are quite harmless.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Thread"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkAccess(Thread g) {\n    trusted();\n}\n","name":"checkAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ThreadGroup"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkAccess(ThreadGroup g) {\n    trusted();\n}\n","name":"checkAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkExit(int status) {\n    trusted();\n}\n","name":"checkExit","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkExec(String cmd) {\n    trusted();\n}\n","name":"checkExec","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trustedOrIndirect2":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkLink(String lib) {\n    trustedOrIndirect2();\n}\n","name":"checkLink","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["FileDescriptor"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkRead(FileDescriptor fd) {\n    trusted();\n}\n","name":"checkRead","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkRead(String file) {\n    trusted();\n}\n","name":"checkRead","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Object"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkRead(String file, Object context) {\n    trusted();\n}\n","name":"checkRead","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["FileDescriptor"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkWrite(FileDescriptor fd) {\n    trusted();\n}\n","name":"checkWrite","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkWrite(String file) {\n    trusted();\n}\n","name":"checkWrite","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkDelete(String file) {\n    trusted();\n}\n","name":"checkDelete","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkConnect(String host, int port) {\n    trusted();\n}\n","name":"checkConnect","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","Object"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkConnect(String host, int port, Object context) {\n    trusted();\n}\n","name":"checkConnect","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkListen(int port) {\n    trusted();\n}\n","name":"checkListen","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkAccept(String host, int port) {\n    trusted();\n}\n","name":"checkAccept","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InetAddress"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkMulticast(InetAddress maddr) {\n    trusted();\n}\n","name":"checkMulticast","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InetAddress","byte"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkMulticast(InetAddress maddr, byte ttl) {\n    trusted();\n}\n","name":"checkMulticast","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"trustedOrIndirect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkPropertiesAccess() {\n    trustedOrIndirect();\n}\n","name":"checkPropertiesAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trustedOrIndirect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkPropertyAccess(String key) {\n    trustedOrIndirect();\n}\n","name":"checkPropertyAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkPrintJobAccess() {\n    trusted();\n}\n","name":"checkPrintJobAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkSystemClipboardAccess() {\n    trusted();\n}\n","name":"checkSystemClipboardAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkAwtEventQueueAccess() {\n    trusted();\n}\n","name":"checkAwtEventQueueAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkSetFactory() {\n    trusted();\n}\n","name":"checkSetFactory","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Class","int"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkMemberAccess(Class clazz, int which) {\n    trusted();\n}\n","name":"checkMemberAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void checkSecurityAccess(String provider) {\n    trusted();\n}\n","name":"checkSecurityAccess","className":"ServiceSecurityManager","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"inClassLoader":1,"startsWith":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":5,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1},"text":"/** Loaded code can only load classes from java.* packages */\npublic void checkPackageAccess(String pkg) {\n    if (inClassLoader() && !pkg.startsWith(\"java.\"))\n        throw new SecurityException();\n}\n","name":"checkPackageAccess","className":"ServiceSecurityManager","variables":{"pkg":1},"constants":{"\"java.\"":1},"javaDoc":"Loaded code can only load classes from java packages","comments":" Loaded code can only load classes from java.* packages ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"inClassLoader":1,"startsWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":2,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"ThrowStmt":1},"text":"/** Loaded code can't define classes in java.* or sun.* packages */\npublic void checkPackageDefinition(String pkg) {\n    if (inClassLoader() && (pkg.startsWith(\"java.\") || pkg.startsWith(\"sun.\")))\n        throw new SecurityException();\n}\n","name":"checkPackageDefinition","className":"ServiceSecurityManager","variables":{"pkg":2},"constants":{"\"java.\"":1,"\"sun.\"":1},"javaDoc":"Loaded code can't define classes in java or sun packages","comments":" Loaded code can't define classes in java.* or sun.* packages ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"trusted":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n     * This is the one SecurityManager method that is different from the\n     * others.  It indicates whether a top-level window should display an\n     * \"untrusted\" warning.  The window is always allowed to be created, so\n     * this method is not normally meant to throw an exception.  It should\n     * return true if the window does not need to display the warning, and\n     * false if it does.  In this example, however, our text-based Service\n     * classes should never need to create windows, so we will actually\n     * throw an exception to prevent any windows from being opened.\n     **/\npublic boolean checkTopLevelWindow(Object window) {\n    trusted();\n    return true;\n}\n","name":"checkTopLevelWindow","className":"ServiceSecurityManager","variables":{},"constants":{"true":1},"javaDoc":"This is the one SecurityManager method that is different from the others It indicates whether a top-level window should display an \"untrusted\" warning The window is always allowed to be created so this method is not normally meant to throw an exception It should return true if the window does not need to display the warning and false if it does In this example however our text-based Service classes should never need to create windows so we will actually throw an exception to prevent any windows from being opened","comments":" \n     * This is the one SecurityManager method that is different from the\n     * others.  It indicates whether a top-level window should display an\n     * \"untrusted\" warning.  The window is always allowed to be created, so\n     * this method is not normally meant to throw an exception.  It should\n     * return true if the window does not need to display the warning, and\n     * false if it does.  In this example, however, our text-based Service\n     * classes should never need to create windows, so we will actually\n     * throw an exception to prevent any windows from being opened.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"LocalClassLoader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The constructor.  Just initialize the directory */\npublic LocalClassLoader(String dir) {\n    directory = dir;\n}\n","name":"LocalClassLoader","className":"LocalClassLoader","variables":{"dir":1,"directory":1},"constants":{},"javaDoc":"The constructor Just initialize the directory","comments":" The constructor.  Just initialize the directory ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Class","methodCalls":{"loadClass":1},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":["Recursion"],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** A convenience method that calls the 2-argument form of this method */\npublic Class loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, true);\n}\n","name":"loadClass","className":"LocalClassLoader","variables":{},"constants":{"true":1},"javaDoc":"A convenience method that calls the 2-argument form of this method","comments":" A convenience method that calls the 2-argument form of this method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"Class","methodCalls":{"findSystemClass":1,"defineClass":1,"readFully":1,"resolveClass":1,"findLoadedClass":1,"replace":1,"length":1,"toString":1,"close":1},"annotations":[],"exceptions":["ClassNotFoundException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":1,"Class":1,"String":1,"DataInputStream":1,"File":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":1,"CharLiteralExpr":1,"AssignExpr":2,"NullLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":3,"TryStmt":2,"BlockStmt":6,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":11},"text":"/**\n     * This is one abstract method of ClassLoader that all subclasses must\n     * define.  Its job is to load an array of bytes from somewhere and to\n     * pass them to defineClass().  If the resolve argument is true, it must\n     * also call resolveClass(), which will do things like verify the presence\n     * of the superclass.  Because of this second step, this method may be\n     * called to load superclasses that are system classes, and it must take \n     * this into account.\n     **/\npublic Class loadClass(String classname, boolean resolve) throws ClassNotFoundException {\n    try {\n        // Our ClassLoader superclass has a built-in cache of classes it has\n        // already loaded.  So, first check the cache.\n        Class c = findLoadedClass(classname);\n        // a system class (i.e. from the CLASSPATH) and ignore any errors\n        if (c == null) {\n            try {\n                c = findSystemClass(classname);\n            } catch (Exception e) {\n            }\n        }\n        // \".class\" extension.\n        if (c == null) {\n            // Figure out the filename\n            String filename = classname.replace('.', File.separatorChar) + \".class\";\n            // Create a File object.  Interpret the filename relative to the\n            // directory specified for this ClassLoader.\n            File f = new File(directory, filename);\n            // Get the length of the class file, allocate an array of bytes for\n            // it, and read it in all at once.\n            int length = (int) f.length();\n            byte[] classbytes = new byte[length];\n            DataInputStream in = new DataInputStream(new FileInputStream(f));\n            in.readFully(classbytes);\n            in.close();\n            // Now call an inherited method to convert those bytes into a Class\n            c = defineClass(classname, classbytes, 0, length);\n        }\n        // method.\n        if (resolve)\n            resolveClass(c);\n        // And we're done.  Return the Class object we've loaded.\n        return c;\n    }// If anything goes wrong, throw a ClassNotFoundException error\n     catch (Exception e) {\n        throw new ClassNotFoundException(e.toString());\n    }\n}\n         // After this method loads a class, it will be called again to\n\n         // load the superclasses.  Since these may be system classes, we've\n\n         // got to be able to load those too.  So try to load the class as\n\n         // If the class wasn't found by either of the above attempts, then\n\n         // try to load it from a file in (or beneath) the directory\n\n         // specified when this ClassLoader object was created.  Form the\n\n         // filename by replacing all dots in the class name with\n\n         // (platform-independent) file separators and by adding the\n\n         // If the resolve argument is true, call the inherited resolveClass\n\n","name":"loadClass","className":"LocalClassLoader","variables":{"c":6,"filename":2,"classname":1,"resolve":1,"e":3,"in":3,"f":3,"length":2,"classbytes":1,"directory":1},"constants":{"'.'":1,"\".class\"":1,"0":1,"null":2},"javaDoc":"This is one abstract method of ClassLoader that all subclasses must define Its job is to load an array of bytes from somewhere and to pass them to defineClass() If the resolve argument is true it must also call resolveClass() which will do things like verify the presence of the superclass Because of this second step this method may be called to load superclasses that are system classes and it must take this into account","comments":"Our ClassLoader superclass has a built-in cache of classes it has After this method loads a class it will be called again to load the superclasses Since these may be system classes we've got to be able to load those too So try to load the class as If the class wasn't found by either of the above attempts then try to load it from a file in (or beneath) the directory specified when this ClassLoader object was created Form the filename by replacing all dots in the class name with (platform-independent) file separators and by adding the If the resolve argument is true call the inherited resolveClass already loaded So first check the cache a system class (i e from the CLASSPATH) and ignore any errors \" class\" extension Create a File object Interpret the filename relative to the Get the length of the class file allocate an array of bytes for Figure out the filename directory specified for this ClassLoader it and read it in all at once Now call an inherited method to convert those bytes into a Class method And we're done Return the Class object we've loaded If anything goes wrong throw a ClassNotFoundException error \n     * This is one abstract method of ClassLoader that all subclasses must\n     * define.  Its job is to load an array of bytes from somewhere and to\n     * pass them to defineClass().  If the resolve argument is true, it must\n     * also call resolveClass(), which will do things like verify the presence\n     * of the superclass.  Because of this second step, this method may be\n     * called to load superclasses that are system classes, and it must take \n     * this into account.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":4,"println":4,"getProperty":1,"load":1,"getRuntime":1,"close":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":43,"StringLiteralExpr":12,"MethodCallExpr":13},"statements":{"TryStmt":4,"BlockStmt":8,"ExpressionStmt":15},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));\n    out.print(\"Attempting to read a file...\");\n    try {\n        new FileInputStream(\"testfile\");\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    out.print(\"Attempting to write a file...\");\n    try {\n        new FileOutputStream(\"testfile\");\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    out.print(\"Attempting to read system property...\");\n    try {\n        System.getProperty(\"java.version\");\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    out.print(\"Attempting to load a library...\");\n    try {\n        Runtime.getRuntime().load(\"testlib\");\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    out.close();\n    i.close();\n}\n","name":"serve","className":"ProhibitedService","variables":{"Runtime":1,"e":8,"i":1,"System":1,"out":10,"o":1},"constants":{"\"Attempting to read system property...\"":1,"\"Attempting to read a file...\"":1,"\"testfile\"":2,"\"testlib\"":1,"\"Attempting to write a file...\"":1,"\"java.version\"":1,"\"Attempting to load a library...\"":1,"\"Failed: \"":4},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"GridBagConstraints":1},"expressions":{"ObjectCreationExpr":12,"IntegerLiteralExpr":40,"VariableDeclarationExpr":1,"DoubleLiteralExpr":2,"NameExpr":158,"StringLiteralExpr":9,"FieldAccessExpr":43,"ThisExpr":10,"MethodCallExpr":10,"AssignExpr":42},"statements":{"ExpressionStmt":51},"text":"public void init() {\n    // Create and specify a layout manager\n    this.setLayout(new GridBagLayout());\n    // Create a constraints object, and specify some default values\n    GridBagConstraints c = new GridBagConstraints();\n    // components grow in both dimensions\n    c.fill = GridBagConstraints.BOTH;\n    // 5-pixel margins on all sides\n    c.insets = new Insets(5, 5, 5, 5);\n    // Create and add a bunch of buttons, specifying different grid\n    // position, and size for each.\n    // Give the first button a resize weight of 1.0 and all others\n    // a weight of 0.0.  The first button will get all extra space.\n    c.gridx = 0;\n    c.gridy = 0;\n    c.gridwidth = 4;\n    c.gridheight = 4;\n    c.weightx = c.weighty = 1.0;\n    this.add(new Button(\"Button #1\"), c);\n    c.gridx = 4;\n    c.gridy = 0;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    c.weightx = c.weighty = 0.0;\n    this.add(new Button(\"Button #2\"), c);\n    c.gridx = 4;\n    c.gridy = 1;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #3\"), c);\n    c.gridx = 4;\n    c.gridy = 2;\n    c.gridwidth = 1;\n    c.gridheight = 2;\n    this.add(new Button(\"Button #4\"), c);\n    c.gridx = 0;\n    c.gridy = 4;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #5\"), c);\n    c.gridx = 2;\n    c.gridy = 4;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #6\"), c);\n    c.gridx = 3;\n    c.gridy = 4;\n    c.gridwidth = 2;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #7\"), c);\n    c.gridx = 1;\n    c.gridy = 5;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #8\"), c);\n    c.gridx = 3;\n    c.gridy = 5;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new Button(\"Button #9\"), c);\n}\n","name":"init","className":"GridBagLayoutExample","variables":{"c":1},"constants":{"0":4,"\"Button #2\"":1,"1":16,"\"Button #3\"":1,"0.0":1,"2":4,"\"Button #4\"":1,"1.0":1,"\"Button #5\"":1,"3":2,"4":8,"\"Button #6\"":1,"5":6,"\"Button #7\"":1,"\"Button #8\"":1,"\"Button #9\"":1,"\"Button #1\"":1},"javaDoc":"","comments":"Create and add a bunch of buttons specifying different grid position and size for each Give the first button a resize weight of 1 0 and all others Create and specify a layout manager Create a constraints object and specify some default values components grow in both dimensions 5-pixel margins on all sides a weight of 0 0 The first button will get all extra space ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"usage":2,"display":1,"convert":1},"annotations":[],"exceptions":["// Handle possible exceptions.\nException"],"concepts":["ExceptionHandling"],"types":{"String":2,"int":1},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":8,"BinaryExpr":3,"NameExpr":54,"StringLiteralExpr":4,"FieldAccessExpr":2,"UnaryExpr":5,"MethodCallExpr":9,"AssignExpr":4},"statements":{"IfStmt":5,"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String from = null, to = null;\n    String infile = null, outfile = null;\n    for (int i = 0; i < args.length; i++) {\n        // All legal args require another.\n        if (i == args.length - 1)\n            usage();\n        if (args[i].equals(\"-from\"))\n            from = args[++i];\n        else if (args[i].equals(\"-to\"))\n            to = args[++i];\n        else if (args[i].equals(\"-in\"))\n            infile = args[++i];\n        else if (args[i].equals(\"-out\"))\n                                             // Parse command-line arguments.\n\n            outfile = args[++i];\n        else\n            usage();\n    }\n    try // Attempt conversion.\n    {\n        convert(infile, outfile, from, to);\n    } catch (// Handle possible exceptions.\n    Exception // Handle possible exceptions.\n    e) {\n                                   // Defined at the end of this chapter.\n\n        LocalizedError.display(e);\n        System.exit(1);\n    }\n}\n","name":"main","className":"ConvertEncoding","variables":{"args":8,"e":1,"outfile":2,"LocalizedError":1,"i":12,"from":2,"to":2,"infile":2,"System":1},"constants":{"0":1,"1":2,"null":4,"\"-in\"":1,"\"-to\"":1,"\"-out\"":1,"\"-from\"":1},"javaDoc":"","comments":"Parse command-line arguments All legal args require another Attempt conversion Defined at the end of this chapter Handle possible exceptions Handle possible exceptions ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void usage() {\n    System.err.println(\"Usage: java ConvertEncoding <options>\\n\" + \"Options:\\n\\t-from <encoding>\\n\\t-to <encoding>\\n\\t\" + \"-in <file>\\n\\t-out <file>\");\n    System.exit(1);\n}\n","name":"usage","className":"ConvertEncoding","variables":{"System":1},"constants":{"1":1,"\"Options:\\n\\t-from <encoding>\\n\\t-to <encoding>\\n\\t\"":1,"\"Usage: java ConvertEncoding <options>\\n\"":1,"\"-in <file>\\n\\t-out <file>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String"],"returnType":"void","methodCalls":{"getProperty":2,"read":1,"flush":1,"write":1,"close":2},"annotations":[],"exceptions":["UnsupportedEncodingException","IOException"],"concepts":["PolyMorphism"],"types":{"InputStream":1,"OutputStream":1,"BufferedReader":1,"Reader":1,"Writer":1,"int":1,"BufferedWriter":1,"char[]":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":47,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":7,"NullLiteralExpr":4,"FieldAccessExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":4,"WhileStmt":1,"ExpressionStmt":16},"text":"public static void convert(String infile, String outfile, String from, String to) throws IOException, UnsupportedEncodingException {\n    // Set up byte streams.\n    InputStream in;\n    if (infile != null)\n        in = new FileInputStream(infile);\n    else\n        in = System.in;\n    OutputStream out;\n    if (outfile != null)\n        out = new FileOutputStream(outfile);\n    else\n        out = System.out;\n    // Use default encoding if no encoding is specified.\n    if (from == null)\n        from = System.getProperty(\"file.encoding\");\n    if (to == null)\n        to = System.getProperty(\"file.encoding\");\n    // Set up character streams.\n    Reader r = new BufferedReader(new InputStreamReader(in, from));\n    Writer w = new BufferedWriter(new OutputStreamWriter(out, to));\n    // Copy characters from input to output.  The InputStreamReader converts\n    // from the input encoding to Unicode, and the OutputStreamWriter converts\n    // from Unicode to the output encoding.  Characters that cannot be\n    // represented in the output encoding are output as '?'\n    char[] buffer = new char[4096];\n    int len;\n    while (// Read a block of input.\n    (len = r.read(buffer)) != -1) // And write it out.\n    w.write(buffer, 0, len);\n    // Close the input.\n    r.close();\n    // Flush and close output.\n    w.flush();\n    w.close();\n}\n","name":"convert","className":"ConvertEncoding","variables":{"r":3,"len":2,"in":4,"outfile":2,"w":4,"from":3,"infile":2,"to":3,"buffer":1,"System":2,"out":4},"constants":{"0":1,"4096":1,"1":1,"null":4,"\"file.encoding\"":2},"javaDoc":"","comments":"Copy characters from input to output The InputStreamReader converts from the input encoding to Unicode and the OutputStreamWriter converts from Unicode to the output encoding Characters that cannot be Set up byte streams Use default encoding if no encoding is specified Set up character streams represented in the output encoding are output as '?' Read a block of input And write it out Close the input Flush and close output ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/** \n   * This method adds a new datum into the average.\n   **/\npublic void addDatum(double x) {\n    n++;\n    sum += x;\n    sumOfSquares += x * x;\n}\n","name":"addDatum","className":"Averager","variables":{"sumOfSquares":1,"x":3,"sum":1,"n":1},"constants":{},"javaDoc":"This method adds a new datum into the average","comments":" \n   * This method adds a new datum into the average.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** This method returns the average of all numbers passed to addDatum() */\npublic double getAverage() {\n    return sum / n;\n}\n","name":"getAverage","className":"Averager","variables":{"sum":1,"n":1},"constants":{},"javaDoc":"This method returns the average of all numbers passed to addDatum()","comments":" This method returns the average of all numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":8,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the standard deviation of the data */\npublic double getStandardDeviation() {\n    return Math.sqrt(((sumOfSquares - sum * sum / n) / n));\n}\n","name":"getStandardDeviation","className":"Averager","variables":{"sumOfSquares":1,"sum":2,"Math":1,"n":2},"constants":{},"javaDoc":"This method returns the standard deviation of the data","comments":" This method returns the standard deviation of the data ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the number of numbers passed to addDatum() */\npublic double getNum() {\n    return n;\n}\n","name":"getNum","className":"Averager","variables":{"n":1},"constants":{},"javaDoc":"This method returns the number of numbers passed to addDatum()","comments":" This method returns the number of numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the sum of all numbers passed to addDatum() */\npublic double getSum() {\n    return sum;\n}\n","name":"getSum","className":"Averager","variables":{"sum":1},"constants":{},"javaDoc":"This method returns the sum of all numbers passed to addDatum()","comments":" This method returns the sum of all numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the sum of the squares of all numbers. */\npublic double getSumOfSquares() {\n    return sumOfSquares;\n}\n","name":"getSumOfSquares","className":"Averager","variables":{"sumOfSquares":1},"constants":{},"javaDoc":"This method returns the sum of the squares of all numbers","comments":" This method returns the sum of the squares of all numbers. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/** This method resets the Averager object to begin from scratch */\npublic void reset() {\n    n = 0;\n    sum = 0.0;\n    sumOfSquares = 0.0;\n}\n","name":"reset","className":"Averager","variables":{"sumOfSquares":1,"sum":1,"n":1},"constants":{"0":1,"0.0":2},"javaDoc":"This method resets the Averager object to begin from scratch","comments":" This method resets the Averager object to begin from scratch ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getStandardDeviation":1,"getSumOfSquares":1,"getNum":1,"getAverage":1,"getSum":1,"addDatum":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"Averager":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":46,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String args[]) {\n    Averager a = new Averager();\n    for (int i = 1; i <= 100; i++) a.addDatum(i);\n    System.out.println(\"Average: \" + a.getAverage());\n    System.out.println(\"Standard Deviation: \" + a.getStandardDeviation());\n    System.out.println(\"N: \" + a.getNum());\n    System.out.println(\"Sum: \" + a.getSum());\n    System.out.println(\"Sum of squares: \" + a.getSumOfSquares());\n}\n","name":"main","className":"Test","variables":{"a":7,"i":3},"constants":{"100":1,"1":1,"\"Standard Deviation: \"":1,"\"N: \"":1,"\"Sum: \"":1,"\"Sum of squares: \"":1,"\"Average: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":10,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public void init() {\n    // Create and specify a BorderLayout layout manager that leaves\n    // 10 pixels of horizontal and vertical space between components\n    this.setLayout(new BorderLayout(10, 10));\n    for (int i = 0; i < 5; i++) {\n        // Swap the order of these arguments in Java 1.1\n        this.add(borders[i], new Button(borders[i]));\n    }\n}\n","name":"init","className":"BorderLayoutExample","variables":{"borders":2,"i":5},"constants":{"0":1,"5":1,"10":2},"javaDoc":"","comments":"Create and specify a BorderLayout layout manager that leaves 10 pixels of horizontal and vertical space between components Swap the order of these arguments in Java 1 1 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":2,"ExpressionStmt":3},"text":"public void run() {\n    // Lock resource 1\n    synchronized (resource1) {\n        System.out.println(\"Thread 1: locked resource 1\");\n        // trying to force deadlock to happen here...\n        try {\n            Thread.sleep(50);\n        } catch (InterruptedException e) {\n        }\n        // Now wait 'till we can get a lock on resource 2\n        synchronized (resource2) {\n            System.out.println(\"Thread 1: locked resource 2\");\n        }\n    }\n}\n           // Pause for a bit, simulating some file I/O or something.  \n\n           // Basically, we just want to give the other thread a chance to\n\n           // run.  Threads and deadlock are asynchronous things, but we're\n\n","name":"run","className":"","variables":{"e":1,"resource2":1,"resource1":1,"Thread":1},"constants":{"\"Thread 1: locked resource 2\"":1,"50":1,"\"Thread 1: locked resource 1\"":1},"javaDoc":"","comments":"Lock resource 1 Pause for a bit simulating some file I/O or something Basically we just want to give the other thread a chance to run Threads and deadlock are asynchronous things but we're trying to force deadlock to happen here Now wait 'till we can get a lock on resource 2 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":2,"ExpressionStmt":3},"text":"public void run() {\n    // This thread locks resource 2 right away\n    synchronized (resource2) {\n        System.out.println(\"Thread 2: locked resource 2\");\n        // Then it pauses, for the same reason as the first thread does\n        try {\n            Thread.sleep(50);\n        } catch (InterruptedException e) {\n        }\n        // thread can run, and the program freezes up.\n        synchronized (resource1) {\n            System.out.println(\"Thread 2: locked resource 1\");\n        }\n    }\n}\n           // Then it tries to lock resource1.  But wait!  Thread 1 locked\n\n           // resource1, and won't release it 'till it gets a lock on\n\n           // resource2.  This thread holds the lock on resource2, and won't\n\n           // release it 'till it gets resource1.  We're at an impasse. Neither\n\n","name":"run","className":"","variables":{"e":1,"resource2":1,"Thread":1,"resource1":1},"constants":{"\"Thread 2: locked resource 1\"":1,"\"Thread 2: locked resource 2\"":1,"50":1},"javaDoc":"","comments":"This thread locks resource 2 right away Then it tries to lock resource1 But wait! Thread 1 locked resource1 and won't release it 'till it gets a lock on resource2 This thread holds the lock on resource2 and won't release it 'till it gets resource1 We're at an impasse Neither Then it pauses for the same reason as the first thread does thread can run and the program freezes up ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":2,"start":2,"System.out.println":4},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling","Synchronization"],"types":{"Object":2,"Thread":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"StringLiteralExpr":6,"NameExpr":40,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"BlockStmt":10,"TryStmt":2,"SynchronizedStmt":4,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    // These are the two resource objects we'll try to get locks for\n    final Object resource1 = \"resource1\";\n    final Object resource2 = \"resource2\";\n    // Here's the first thread.  It tries to lock resource1 then resource2\n    Thread t1 = new Thread() {\n\n        public void run() {\n            // Lock resource 1\n            synchronized (resource1) {\n                System.out.println(\"Thread 1: locked resource 1\");\n                // trying to force deadlock to happen here...\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                }\n                // Now wait 'till we can get a lock on resource 2\n                synchronized (resource2) {\n                    System.out.println(\"Thread 1: locked resource 2\");\n                }\n            }\n        }\n    };\n    // Here's the second thread.  It tries to lock resource2 then resource1\n    Thread t2 = new Thread() {\n\n           // Pause for a bit, simulating some file I/O or something.  \n\n           // Basically, we just want to give the other thread a chance to\n\n           // run.  Threads and deadlock are asynchronous things, but we're\n\n        public void run() {\n            // This thread locks resource 2 right away\n            synchronized (resource2) {\n                System.out.println(\"Thread 2: locked resource 2\");\n                // Then it pauses, for the same reason as the first thread does\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                }\n                // thread can run, and the program freezes up.\n                synchronized (resource1) {\n                    System.out.println(\"Thread 2: locked resource 1\");\n                }\n            }\n        }\n    };\n    // Start the two threads. If all goes as planned, deadlock will occur, \n    // and the program will never exit.\n    t1.start();\n    t2.start();\n}\n           // Then it tries to lock resource1.  But wait!  Thread 1 locked\n\n           // resource1, and won't release it 'till it gets a lock on\n\n           // resource2.  This thread holds the lock on resource2, and won't\n\n           // release it 'till it gets resource1.  We're at an impasse. Neither\n\n","name":"main","className":"Deadlock","variables":{"e":2,"resource2":3,"run":2,"t1":2,"t2":2,"resource1":3,"Thread":2},"constants":{"\"Thread 1: locked resource 2\"":1,"\"Thread 2: locked resource 1\"":1,"\"Thread 2: locked resource 2\"":1,"\"resource2\"":1,"\"resource1\"":1,"50":2,"\"Thread 1: locked resource 1\"":1},"javaDoc":"","comments":"Start the two threads If all goes as planned deadlock will occur These are the two resource objects we'll try to get locks for Here's the first thread It tries to lock resource1 then resource2 Lock resource 1 Pause for a bit simulating some file I/O or something Basically we just want to give the other thread a chance to run Threads and deadlock are asynchronous things but we're trying to force deadlock to happen here Now wait 'till we can get a lock on resource 2 Here's the second thread It tries to lock resource2 then resource1 This thread locks resource 2 right away Then it tries to lock resource1 But wait! Thread 1 locked resource1 and won't release it 'till it gets a lock on resource2 This thread holds the lock on resource2 and won't release it 'till it gets resource1 We're at an impasse Neither Then it pauses for the same reason as the first thread does thread can run and the program freezes up and the program will never exit ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["long"],"returnType":"long","methodCalls":{"factorial":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":3,"NameExpr":5,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"public static long factorial(long x) {\n    if (x == 1)\n        return 1;\n    else\n        return x * factorial(x - 1);\n}\n","name":"factorial","className":"Factorial2","variables":{"x":3},"constants":{"1":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"getColorParameter":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":2},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":2,"NameExpr":14,"StringLiteralExpr":2,"ThisExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":2,"ExpressionStmt":5},"text":"// Read in two color parameters and set the colors.\npublic void init() {\n    super.init();\n    Color foreground = getColorParameter(\"foreground\");\n    Color background = getColorParameter(\"background\");\n    if (foreground != null)\n        this.setForeground(foreground);\n    if (background != null)\n        this.setBackground(background);\n}\n","name":"init","className":"ColorScribble","variables":{"background":2,"foreground":2},"constants":{"\"foreground\"":1,"null":2,"\"background\"":1},"javaDoc":"","comments":" Read in two color parameters and set the colors.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Color","methodCalls":{"parseInt":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"ThisExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"// Read the specified parameter.  Interpret it as a hexadecimal\n// number of the form RRGGBB and convert it to a color.\nprotected Color getColorParameter(String name) {\n    String value = this.getParameter(name);\n    try {\n        return new Color(Integer.parseInt(value, 16));\n    } catch (Exception e) {\n        return null;\n    }\n}\n","name":"getColorParameter","className":"ColorScribble","variables":{"Integer":1,"e":1,"value":1},"constants":{"null":1,"16":1},"javaDoc":"","comments":" number of the form RRGGBB and convert it to a color.","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Return information suitable for display in an About dialog box.\npublic String getAppletInfo() {\n    return \"ColorScribble v. 0.02.  Written by David Flanagan.\";\n}\n","name":"getAppletInfo","className":"ColorScribble","variables":{},"constants":{"\"ColorScribble v. 0.02.  Written by David Flanagan.\"":1},"javaDoc":"","comments":" Return information suitable for display in an About dialog box.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[][]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Return info about the supported parameters.  Web browsers and applet\n// viewers should display this information, and may also allow users to\n// set the parameter values.\npublic String[][] getParameterInfo() {\n    return info;\n}\n","name":"getParameterInfo","className":"ColorScribble","variables":{"info":1},"constants":{},"javaDoc":"","comments":" set the parameter values.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Returns the next element in the list\npublic Linkable getNext();\n","name":"getNext","className":"Linkable","variables":{},"constants":{},"javaDoc":"","comments":" Returns the next element in the list","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Sets the next element in the list\npublic void setNext(Linkable node);\n","name":"setNext","className":"Linkable","variables":{},"constants":{},"javaDoc":"","comments":" Sets the next element in the list","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the first node in the list */\npublic synchronized Linkable getHead() {\n    return head;\n}\n","name":"getHead","className":"LinkedList","variables":{"head":1},"constants":{},"javaDoc":"Return the first node in the list","comments":" Return the first node in the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"setNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Insert a node at the beginning of the list */\npublic synchronized void insertAtHead(Linkable node) {\n    node.setNext(head);\n    head = node;\n}\n","name":"insertAtHead","className":"LinkedList","variables":{"head":1,"node":2},"constants":{},"javaDoc":"Insert a node at the beginning of the list","comments":" Insert a node at the beginning of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"setNext":1,"getNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":15,"EnclosedExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"EmptyStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/** Insert a node at the end of the list */\npublic synchronized void insertAtTail(Linkable node) {\n    if (head == null)\n        head = node;\n    else {\n        Linkable p, q;\n        for (p = head; (q = p.getNext()) != null; p = q) ;\n        p.setNext(node);\n    }\n}\n","name":"insertAtTail","className":"LinkedList","variables":{"head":3,"p":5,"node":1,"q":3},"constants":{"null":2},"javaDoc":"Insert a node at the end of the list","comments":" Insert a node at the end of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{"setNext":1,"getNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"AssignExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Remove and return the node at the head of the list */\npublic synchronized Linkable removeFromHead() {\n    Linkable node = head;\n    if (node != null) {\n        head = node.getNext();\n        node.setNext(null);\n    }\n    return node;\n}\n","name":"removeFromHead","className":"LinkedList","variables":{"head":2,"node":5},"constants":{"null":2},"javaDoc":"Remove and return the node at the head of the list","comments":" Remove and return the node at the head of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{"setNext":1,"getNext":2},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":7,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"EnclosedExpr":1,"MethodCallExpr":3,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":5},"text":"/** Remove and return the node at the end of the list */\npublic synchronized Linkable removeFromTail() {\n    if (head == null)\n        return null;\n    Linkable p = head, q = null, next = head.getNext();\n    if (next == null) {\n        head = null;\n        return p;\n    }\n    while ((next = p.getNext()) != null) {\n        q = p;\n        p = next;\n    }\n    q.setNext(null);\n    return p;\n}\n","name":"removeFromTail","className":"LinkedList","variables":{"head":4,"p":6,"next":4,"q":3},"constants":{"null":7},"javaDoc":"Remove and return the node at the end of the list","comments":" Remove and return the node at the end of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"equals":2,"setNext":1,"getNext":3},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":26,"EnclosedExpr":1,"MethodCallExpr":6,"AssignExpr":3},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":4},"text":"/** \n   * Remove a node matching the specified node from the list.  \n   * Use equals() instead of == to test for a matched node.\n   **/\npublic synchronized void remove(Linkable node) {\n    if (head == null)\n        return;\n    if (node.equals(head)) {\n        head = head.getNext();\n        return;\n    }\n    Linkable p = head, q = null;\n    while ((q = p.getNext()) != null) {\n        if (node.equals(q)) {\n            p.setNext(q.getNext());\n            return;\n        }\n        p = q;\n    }\n}\n","name":"remove","className":"LinkedList","variables":{"head":4,"p":4,"node":2,"q":4},"constants":{"null":3},"javaDoc":"Remove a node matching the specified node from the list Use equals() instead of == to test for a matched node","comments":" \n   * Remove a node matching the specified node from the list.  \n   * Use equals() instead of == to test for a matched node.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["int"],"returnType":"LinkableInteger","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Constructor method\npublic LinkableInteger(int i) {\n    this.i = i;\n}\n","name":"LinkableInteger","className":"LinkableInteger","variables":{"i":1},"constants":{},"javaDoc":"","comments":" Constructor method","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Part of Linkable\npublic Linkable getNext() {\n    return next;\n}\n","name":"getNext","className":"LinkableInteger","variables":{"next":1},"constants":{},"javaDoc":"","comments":" Part of Linkable","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Part of Linkable\npublic void setNext(Linkable node) {\n    next = node;\n}\n","name":"setNext","className":"LinkableInteger","variables":{"next":1,"node":1},"constants":{},"javaDoc":"","comments":" Part of Linkable","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":1,"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// For easy printing\npublic String toString() {\n    return i + \"\";\n}\n","name":"toString","className":"LinkableInteger","variables":{"i":1},"constants":{"\"\"":1},"javaDoc":"","comments":" For easy printing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"BooleanLiteralExpr":4,"NameExpr":7,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":2,"UnaryExpr":1,"InstanceOfExpr":1,"ThisExpr":2},"statements":{"IfStmt":3,"ReturnStmt":4},"text":"public boolean equals(Object o) {\n    // For comparison\n    if (this == o)\n        return true;\n    if (!(o instanceof LinkableInteger))\n        return false;\n    if (((LinkableInteger) o).i == this.i)\n        return true;\n    return false;\n}\n","name":"equals","className":"LinkableInteger","variables":{"o":3},"constants":{"true":2,"false":2},"javaDoc":"","comments":"For comparison ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"insertAtTail":2,"getHead":1,"removeFromTail":1,"insertAtHead":4,"getNext":1,"remove":1,"System.out.println":3,"removeFromHead":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Linkable":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":7,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":51,"FieldAccessExpr":3,"MethodCallExpr":14,"AssignExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":11},"text":"/**\n     * The test program.  Insert some nodes, remove some nodes, then\n     * print out all elements in the list.  It should print out the\n     * numbers 4, 6, 3, 1, and 5\n     **/\npublic static void main(String[] args) {\n    // Create a list\n    LinkedList ll = new LinkedList();\n    // Insert some stuff\n    ll.insertAtHead(new LinkableInteger(1));\n    ll.insertAtHead(new LinkableInteger(2));\n    ll.insertAtHead(new LinkableInteger(3));\n    ll.insertAtHead(new LinkableInteger(4));\n    // Insert some more stuff\n    ll.insertAtTail(new LinkableInteger(5));\n    ll.insertAtTail(new LinkableInteger(6));\n    // Remove and print a node\n    System.out.println(ll.removeFromHead());\n    // Remove and print another\n    System.out.println(ll.removeFromTail());\n    // Remove another one\n    ll.remove(new LinkableInteger(2));\n    // Now print out the contents of the list.\n    for (Linkable l = ll.getHead(); l != null; l = l.getNext()) System.out.println(l);\n}\n","name":"main","className":"Test","variables":{"ll":11,"l":4},"constants":{"1":1,"2":2,"3":1,"4":1,"null":1,"5":1,"6":1},"javaDoc":"The test program Insert some nodes remove some nodes then print out all elements in the list It should print out the numbers 4 6 3 1 and 5","comments":"Create a list Insert some stuff Insert some more stuff Remove and print a node Remove and print another Remove another one Now print out the contents of the list \n     * The test program.  Insert some nodes, remove some nodes, then\n     * print out all elements in the list.  It should print out the\n     * numbers 4, 6, 3, 1, and 5\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":2,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    textarea.append(\"You clicked: \" + ((Button) e.getSource()).getLabel() + \"\\n\");\n}\n","name":"actionPerformed","className":"","variables":{"e":1,"textarea":1},"constants":{"\"You clicked: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getSource":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":2,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    textarea.append(\"Your name is: \" + ((TextField) e.getSource()).getText() + \"\\n\");\n}\n","name":"actionPerformed","className":"","variables":{"e":1,"textarea":1},"constants":{"\"Your name is: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TextEvent"],"returnType":"void","methodCalls":{"getSource":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":2,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void textValueChanged(TextEvent e) {\n    textarea.append(\"You have typed: \" + ((TextField) e.getSource()).getText() + \"\\n\");\n}\n","name":"textValueChanged","className":"","variables":{"e":1,"textarea":1},"constants":{"\"You have typed: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"getItem":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":6,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void itemStateChanged(ItemEvent e) {\n    textarea.append(\"Your favorite color is: \" + e.getItem() + \"\\n\");\n}\n","name":"itemStateChanged","className":"","variables":{"e":1,"textarea":1},"constants":{"\"Your favorite color is: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"getItemSelectable":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":8,"StringLiteralExpr":2,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void itemStateChanged(ItemEvent e) {\n    textarea.append(\"Your favorite flavor is: \" + ((Checkbox) e.getItemSelectable()).getLabel() + \"\\n\");\n}\n","name":"itemStateChanged","className":"","variables":{"e":1,"textarea":1},"constants":{"\"Your favorite flavor is: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"getItemSelectable":1,"append":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"String[]":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":25,"StringLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public void itemStateChanged(ItemEvent e) {\n    textarea.append(\"Your favorite languages are: \");\n    String[] languages = ((List) e.getItemSelectable()).getSelectedItems();\n    for (int i = 0; i < languages.length; i++) {\n        if (i > 0)\n            textarea.append(\",\");\n        textarea.append(languages[i]);\n    }\n    textarea.append(\"\\n\");\n}\n","name":"itemStateChanged","className":"","variables":{"languages":2,"e":1,"textarea":4,"i":5},"constants":{"0":2,"\",\"":1,"\"Your favorite languages are: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"AllComponents","methodCalls":{"add":20,"addActionListener":6,"setActionCommand":3,"getItem":1,"setLayout":3,"exit":1,"addItem":10,"setEditable":1,"setSize":1,"getSource":3,"getItemSelectable":2,"addItemListener":2,"setFont":1,"addTextListener":1,"setHelpMenu":1,"append":9},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Choice":1,"CheckboxGroup":1,"MenuBar":1,"MenuItem":3,"String[]":1,"String":1,"int":3,"Checkbox[]":1,"Panel":3,"ActionListener":1,"Button":2,"ScrollPane":1,"TextField":1,"ItemListener":1,"List":1,"Menu":2,"MultiLineLabel":1},"expressions":{"ObjectCreationExpr":43,"IntegerLiteralExpr":27,"VariableDeclarationExpr":25,"ArrayAccessExpr":6,"BinaryExpr":20,"NameExpr":314,"StringLiteralExpr":53,"UnaryExpr":3,"AssignExpr":4,"BooleanLiteralExpr":5,"CastExpr":5,"FieldAccessExpr":12,"EnclosedExpr":5,"ArrayCreationExpr":1,"ThisExpr":10,"MethodCallExpr":78},"statements":{"IfStmt":1,"BlockStmt":8,"ExplicitConstructorInvocationStmt":1,"ForStmt":3,"ExpressionStmt":93},"text":"/** Create the whole GUI, and set up event listeners */\npublic AllComponents(String title) {\n    // set frame title.\n    super(title);\n    // Arrange to detect window close events\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Set a default font\n    this.setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n    // Create the menubar.  Tell the frame about it.\n    MenuBar menubar = new MenuBar();\n    this.setMenuBar(menubar);\n    // Create the file menu.  Add to menubar.\n    Menu file = new Menu(\"File\");\n    menubar.add(file);\n    // Create two items for the file menu, setting their label, shortcut,\n    // action command and listener.  Add them to File menu.\n    // Note that we use the frame itself as the action listener\n    MenuItem open = new MenuItem(\"Open\", new MenuShortcut(KeyEvent.VK_O));\n    open.setActionCommand(\"open\");\n    open.addActionListener(this);\n    file.add(open);\n    MenuItem quit = new MenuItem(\"Quit\", new MenuShortcut(KeyEvent.VK_Q));\n    quit.setActionCommand(\"quit\");\n    quit.addActionListener(this);\n    file.add(quit);\n    // Create Help menu; add an item; add to menubar\n    // Display the help menu in a special reserved place.\n    Menu help = new Menu(\"Help\");\n    menubar.add(help);\n    menubar.setHelpMenu(help);\n    // Create and add an item to the Help menu\n    MenuItem about = new MenuItem(\"About\", new MenuShortcut(KeyEvent.VK_A));\n    about.setActionCommand(\"about\");\n    about.addActionListener(this);\n    help.add(about);\n    // Now that we've done the menu, we can begin work on the contents of\n    // the frame.  Assign a BorderLayout manager with margins for this frame.\n    this.setLayout(new BorderLayout(10, 10));\n    // Create two panels to contain two columns of components.  Use our custom\n    // ColumnLayout layout manager for each.  Add them on the west and\n    // center of the frame's border layout\n    Panel column1 = new Panel();\n    column1.setLayout(new ColumnLayout(5, 10, 2, ColumnLayout.LEFT));\n    this.add(column1, \"West\");\n    Panel column2 = new Panel();\n    column2.setLayout(new ColumnLayout(5, 10, 2, ColumnLayout.LEFT));\n    this.add(column2, \"Center\");\n    // Create a panel to contain the buttons at the bottom of the window\n    // Give it a FlowLayout layout manager, and add it along the south border\n    Panel buttonbox = new Panel();\n    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 100, 10));\n    this.add(buttonbox, \"South\");\n    // Create pushbuttons and add them to the buttonbox\n    Button okay = new Button(\"Okay\");\n    Button cancel = new Button(\"Cancel\");\n    buttonbox.add(okay);\n    buttonbox.add(cancel);\n    // Handle events on the buttons\n    ActionListener buttonlistener = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            textarea.append(\"You clicked: \" + ((Button) e.getSource()).getLabel() + \"\\n\");\n        }\n    };\n    okay.addActionListener(buttonlistener);\n    cancel.addActionListener(buttonlistener);\n    // Now start filling the left column.\n    // Create a 1-line text field and add to left column, with a label\n    TextField textfield = new TextField(15);\n    column1.add(new Label(\"Name:\"));\n    column1.add(textfield);\n    // Handle events on the TextField\n    textfield.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            textarea.append(\"Your name is: \" + ((TextField) e.getSource()).getText() + \"\\n\");\n        }\n    });\n    textfield.addTextListener(new TextListener() {\n\n        public void textValueChanged(TextEvent e) {\n            textarea.append(\"You have typed: \" + ((TextField) e.getSource()).getText() + \"\\n\");\n        }\n    });\n    // Create a dropdown list or option menu of choices\n    Choice choice = new Choice();\n    choice.addItem(\"red\");\n    choice.addItem(\"green\");\n    choice.addItem(\"blue\");\n    column1.add(new Label(\"Favorite color:\"));\n    column1.add(choice);\n    // Handle events on this choice\n    choice.addItemListener(new ItemListener() {\n\n        public void itemStateChanged(ItemEvent e) {\n            textarea.append(\"Your favorite color is: \" + e.getItem() + \"\\n\");\n        }\n    });\n    // Create checkboxes, and group them in a CheckboxGroup to give them\n    // \"radio button\" behavior.\n    CheckboxGroup checkbox_group = new CheckboxGroup();\n    Checkbox[] checkboxes = new Checkbox[3];\n    checkboxes[0] = new Checkbox(\"vanilla\", checkbox_group, false);\n    checkboxes[1] = new Checkbox(\"chocolate\", checkbox_group, true);\n    checkboxes[2] = new Checkbox(\"strawberry\", checkbox_group, false);\n    column1.add(new Label(\"Favorite flavor:\"));\n    for (int i = 0; i < checkboxes.length; i++) column1.add(checkboxes[i]);\n    // Handle events on the checkboxes\n    ItemListener checkbox_listener = new ItemListener() {\n\n        public void itemStateChanged(ItemEvent e) {\n            textarea.append(\"Your favorite flavor is: \" + ((Checkbox) e.getItemSelectable()).getLabel() + \"\\n\");\n        }\n    };\n    for (int i = 0; i < checkboxes.length; i++) checkboxes[i].addItemListener(checkbox_listener);\n    // Create a list of choices.\n    List list = new List(4, true);\n    list.addItem(\"Java\");\n    list.addItem(\"C\");\n    list.addItem(\"C++\");\n    list.addItem(\"Smalltalk\");\n    list.addItem(\"Lisp\");\n    list.addItem(\"Modula-3\");\n    list.addItem(\"Forth\");\n    column1.add(new Label(\"Favorite languages:\"));\n    column1.add(list);\n    // Handle events on this list\n    list.addItemListener(new ItemListener() {\n\n        public void itemStateChanged(ItemEvent e) {\n            textarea.append(\"Your favorite languages are: \");\n            String[] languages = ((List) e.getItemSelectable()).getSelectedItems();\n            for (int i = 0; i < languages.length; i++) {\n                if (i > 0)\n                    textarea.append(\",\");\n                textarea.append(languages[i]);\n            }\n            textarea.append(\"\\n\");\n        }\n    });\n    // Create a multi-line text area in column 2\n    textarea = new TextArea(6, 40);\n    textarea.setEditable(false);\n    column2.add(new Label(\"Messages\"));\n    column2.add(textarea);\n    // Create a scrollpane that displays portions of a larger component\n    ScrollPane scrollpane = new ScrollPane();\n    scrollpane.setSize(300, 150);\n    column2.add(new Label(\"Scrolling Window\"));\n    column2.add(scrollpane);\n    // Create a custom MultiLineLabel with a really big font and make it\n    // a child of the ScrollPane container\n    String message = \"/*************************************************\\n\" + \" * AllComponents.java                            *\\n\" + \" * Written by David Flanagan                     *\\n\" + \" * Copyright (c) 1997 by O'Reilly & Associates   *\\n\" + \" *                                               *\\n\" + \" *************************************************/\\n\";\n    MultiLineLabel biglabel = new MultiLineLabel(message);\n    biglabel.setFont(new Font(\"Monospaced\", Font.BOLD + Font.ITALIC, 24));\n    scrollpane.add(biglabel);\n}\n","name":"AllComponents","className":"AllComponents","variables":{"column1":10,"cancel":2,"buttonlistener":1,"column2":6,"about":3,"textarea":11,"title":1,"System":1,"actionPerformed":2,"file":3,"windowClosing":1,"okay":2,"textValueChanged":1,"itemStateChanged":3,"languages":2,"e":13,"textfield":3,"buttonbox":4,"i":13,"list":9,"message":2,"biglabel":2,"menubar":4,"help":2,"checkboxes":6,"checkbox_group":4,"scrollpane":3,"checkbox_listener":1,"quit":3,"choice":5,"open":3},"constants":{"\"Quit\"":1,"\" * AllComponents.java                            *\\n\"":1,"\"Name:\"":1,"\"Open\"":1,"\"Favorite color:\"":1,"\"Favorite languages:\"":1,"\"Cancel\"":1,"\"Messages\"":1,"\" *************************************************/\\n\"":1,"150":1,"\"Your favorite flavor is: \"":1,"\",\"":1,"\"Okay\"":1,"\"Favorite flavor:\"":1,"10":5,"12":1,"\"quit\"":1,"\"Lisp\"":1,"15":1,"\"Your name is: \"":1,"\"Your favorite languages are: \"":1,"\"Monospaced\"":1,"\"Center\"":1,"\"West\"":1,"0":6,"\"Smalltalk\"":1,"1":1,"2":3,"3":1,"\"File\"":1,"4":1,"5":2,"6":1,"true":2,"\"blue\"":1,"\"strawberry\"":1,"\"South\"":1,"\"/*************************************************\\n\"":1,"\"C++\"":1,"\"chocolate\"":1,"\"Your favorite color is: \"":1,"24":1,"\"Scrolling Window\"":1,"\"red\"":1,"\"SansSerif\"":1,"\"You clicked: \"":1,"\"Help\"":1,"\" *                                               *\\n\"":1,"\"Forth\"":1,"\"C\"":1,"\"open\"":1,"\"about\"":1,"\"vanilla\"":1,"\"You have typed: \"":1,"false":3,"\"green\"":1,"\"About\"":1,"100":1,"\" * Written by David Flanagan                     *\\n\"":1,"\" * Copyright (c) 1997 by O'Reilly & Associates   *\\n\"":1,"300":1,"\"Java\"":1,"40":1,"\"\\n\"":6,"\"Modula-3\"":1},"javaDoc":"Create the whole GUI and set up event listeners","comments":"Create two items for the file menu setting their label shortcut action command and listener Add them to File menu Create Help menu; add an item; add to menubar Now that we've done the menu we can begin work on the contents of Create two panels to contain two columns of components Use our custom ColumnLayout layout manager for each Add them on the west and Create a panel to contain the buttons at the bottom of the window Now start filling the left column Create checkboxes and group them in a CheckboxGroup to give them Create a custom MultiLineLabel with a really big font and make it set frame title Arrange to detect window close events Set a default font Create the menubar Tell the frame about it Create the file menu Add to menubar Note that we use the frame itself as the action listener Display the help menu in a special reserved place Create and add an item to the Help menu the frame Assign a BorderLayout manager with margins for this frame center of the frame's border layout Give it a FlowLayout layout manager and add it along the south border Create pushbuttons and add them to the buttonbox Handle events on the buttons Create a 1-line text field and add to left column with a label Handle events on the TextField Create a dropdown list or option menu of choices Handle events on this choice \"radio button\" behavior Handle events on the checkboxes Create a list of choices Handle events on this list Create a multi-line text area in column 2 Create a scrollpane that displays portions of a larger component a child of the ScrollPane container  Create the whole GUI, and set up event listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"equals":1,"getActionCommand":1,"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":11,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    if (e.getActionCommand().equals(\"yes\"))\n        System.exit(0);\n    else\n        textarea.append(\"Quit not confirmed\\n\");\n}\n","name":"actionPerformed","className":"","variables":{"e":1,"textarea":1,"System":1},"constants":{"0":1,"\"yes\"":1,"\"Quit not confirmed\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"equals":4,"addActionListener":1,"show":3,"dispose":1,"getActionCommand":2,"getFile":1,"append":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"InfoDialog":1,"YesNoDialog":1,"String":1,"FileDialog":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":49,"StringLiteralExpr":15,"FieldAccessExpr":1,"ThisExpr":3,"MethodCallExpr":15},"statements":{"IfStmt":4,"BlockStmt":4,"ExpressionStmt":12},"text":"/** This is the action listener method that the menu items invoke */\npublic void actionPerformed(ActionEvent e) {\n    String command = e.getActionCommand();\n    if (command.equals(\"quit\")) {\n        YesNoDialog d = new YesNoDialog(this, \"Really Quit?\", \"Are you sure you want to quit?\", \"Yes\", \"No\", null);\n        d.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                if (e.getActionCommand().equals(\"yes\"))\n                    System.exit(0);\n                else\n                    textarea.append(\"Quit not confirmed\\n\");\n            }\n        });\n        d.show();\n    } else if (command.equals(\"open\")) {\n        FileDialog d = new FileDialog(this, \"Open File\", FileDialog.LOAD);\n        // display the dialog and block until answered\n        d.show();\n        textarea.append(\"You selected file: \" + d.getFile() + \"\\n\");\n        d.dispose();\n    } else if (command.equals(\"about\")) {\n        InfoDialog d = new InfoDialog(this, \"About\", \"This demo was written by David Flanagan\\n\" + \"Copyright (c) 1997 O'Reilly & Associates\");\n        d.show();\n    }\n}\n","name":"actionPerformed","className":"AllComponents","variables":{"actionPerformed":1,"d":9,"e":3,"textarea":2,"command":4,"System":1},"constants":{"\"quit\"":1,"\"open\"":1,"\"about\"":1,"\"This demo was written by David Flanagan\\n\"":1,"\"yes\"":1,"\"Copyright (c) 1997 O'Reilly & Associates\"":1,"\"No\"":1,"\"About\"":1,"\"Really Quit?\"":1,"0":1,"\"You selected file: \"":1,"\"Yes\"":1,"null":1,"\"Open File\"":1,"\"Quit not confirmed\\n\"":1,"\"Are you sure you want to quit?\"":1,"\"\\n\"":1},"javaDoc":"This is the action listener method that the menu items invoke","comments":"display the dialog and block until answered  This is the action listener method that the menu items invoke ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Frame":1,"AllComponents":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    Frame f = new AllComponents(\"AWT Demo\");\n    f.pack();\n    f.show();\n}\n","name":"main","className":"AllComponents","variables":{"f":3},"constants":{"\"AWT Demo\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"equals":1,"factorial":1,"readLine":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":34,"StringLiteralExpr":4,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    // This is how we set things up to read lines of text from the user.\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    // Loop forever\n    for (; ; ) {\n        // Display a prompt to the user\n        System.out.print(\"FactQuoter> \");\n        // Read a line from the user\n        String line = in.readLine();\n        // If we reach the end-of-file, or if the user types \"quit\", then quit\n        if ((line == null) || line.equals(\"quit\"))\n            break;\n        // Try to parse the user's input, and compute and print the factorial\n        try {\n            int x = Integer.parseInt(line);\n            System.out.println(x + \"! = \" + Factorial4.factorial(x));\n        }// If anything goes wrong, display a generic error message\n         catch (Exception e) {\n            System.out.println(\"Invalid Input\");\n        }\n    }\n}\n","name":"main","className":"FactQuoter","variables":{"Integer":1,"Factorial4":1,"in":2,"e":1,"line":3,"x":2},"constants":{"\"quit\"":1,"null":1,"\"FactQuoter> \"":1,"\"! = \"":1,"\"Invalid Input\"":1},"javaDoc":"","comments":"This is how we set things up to read lines of text from the user Loop forever Display a prompt to the user Read a line from the user If we reach the end-of-file or if the user types \"quit\" then quit Try to parse the user's input and compute and print the factorial If anything goes wrong display a generic error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int","int","Color","Color"],"returnType":"ColoredRect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"/**\n   * This constructor uses super() to invoke the superclass constructor, and\n   * also does some initialization of its own.\n   **/\npublic ColoredRect(int x1, int y1, int x2, int y2, Color border, Color fill) {\n    super(x1, y1, x2, y2);\n    this.border = border;\n    this.fill = fill;\n}\n","name":"ColoredRect","className":"ColoredRect","variables":{"border":1,"y1":1,"x1":1,"y2":1,"x2":1,"fill":1},"constants":{},"javaDoc":"This constructor uses super() to invoke the superclass constructor and also does some initialization of its own","comments":"\n   * This constructor uses super() to invoke the superclass constructor, and\n   * also does some initialization of its own.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillRect":1,"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":22,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n   * This method overrides the draw() method of our superclass so that it\n   * can make use of the colors that have been specified.\n   **/\npublic void draw(Graphics g) {\n    g.setColor(fill);\n    g.fillRect(x1, y1, x2, y2);\n    g.setColor(border);\n    g.drawRect(x1, y1, x2, y2);\n}\n","name":"draw","className":"ColoredRect","variables":{"g":4},"constants":{},"javaDoc":"This method overrides the draw() method of our superclass so that it can make use of the colors that have been specified","comments":"\n   * This method overrides the draw() method of our superclass so that it\n   * can make use of the colors that have been specified.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Applet","int","int"],"returnType":"HTMLWriter","methodCalls":{"call":1,"eval":1,"forName":1,"getWindow":1,"getMember":1},"annotations":[],"exceptions":["NoClassDefFoundError","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Class":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":10,"NameExpr":22,"StringLiteralExpr":12,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n   * When you create a new HTMLWriter, it pops up a new, blank, Web browser\n   * window to display the output in.  You must specify the applet\n   * (this specifies the main browser window) and the desired size\n   * for the new window.\n   **/\npublic HTMLWriter(Applet applet, int width, int height) {\n    // Verify that we can find the JSObject class we need.  Warn if not.\n    try {\n        Class c = Class.forName(\"netscape.javascript.JSObject\");\n    } catch (ClassNotFoundException e) {\n        throw new NoClassDefFoundError(\"HTMLWriter requires \" + \"Netscape Navigator 4.0 or higher\");\n    }\n    // Get a reference to the main browser window from the applet.\n    main_window = JSObject.getWindow(applet);\n    // Create a new window to display output in.\n    window = (JSObject) main_window.eval(\"self.open('',\" + \"'HTMLWriter\" + window_num++ + \"',\" + \"'menubar,status,resizable,scrollbars,\" + \"width=\" + width + \",height=\" + height + \"')\");\n    // Obtain the Document object of this new window, and open it.\n    document = (JSObject) window.getMember(\"document\");\n    document.call(\"open\", null);\n}\n","name":"HTMLWriter","className":"HTMLWriter","variables":{"c":1,"main_window":2,"e":1,"document":2,"width":1,"JSObject":1,"Class":1,"window":2,"window_num":1,"height":1},"constants":{"\"netscape.javascript.JSObject\"":1,"\"'menubar,status,resizable,scrollbars,\"":1,"\"open\"":1,"\"Netscape Navigator 4.0 or higher\"":1,"\"HTMLWriter requires \"":1,"\"'HTMLWriter\"":1,"\"',\"":1,"\",height=\"":1,"\"self.open('',\"":1,"\"')\"":1,"null":1,"\"width=\"":1,"\"document\"":1},"javaDoc":"When you create a new HTMLWriter it pops up a new blank Web browser window to display the output in You must specify the applet (this specifies the main browser window) and the desired size for the new window","comments":"Verify that we can find the JSObject class we need Warn if not Get a reference to the main browser window from the applet Create a new window to display output in Obtain the Document object of this new window and open it \n   * When you create a new HTMLWriter, it pops up a new, blank, Web browser\n   * window to display the output in.  You must specify the applet\n   * (this specifies the main browser window) and the desired size\n   * for the new window.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"call":1,"getMember":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":14,"CastExpr":1,"StringLiteralExpr":2,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n   * This is the write() method required for all Writer subclasses.\n   * Writer defines all its other write() methods in terms of this one.\n   **/\npublic void write(char[] buf, int offset, int length) {\n    // has been closed, or if the code is not running in Navigator.\n    if ((window == null) || (document == null))\n        return;\n    // If the window has been closed by the user, do nothing\n    if (((Boolean) window.getMember(\"closed\")).booleanValue())\n        return;\n    // Otherwise, create a string from the specified bytes\n    String s = new String(buf, offset, length);\n    // And pass it to the JS document.write() method to output the HTML\n    document.call(\"write\", new String[] { s });\n}\n     // If no window or document, do nothing.   This occurs if the stream\n\n","name":"write","className":"HTMLWriter","variables":{"buf":1,"s":2,"offset":1,"document":2,"length":1,"window":2},"constants":{"null":2,"\"write\"":1,"\"closed\"":1},"javaDoc":"This is the write() method required for all Writer subclasses Writer defines all its other write() methods in terms of this one","comments":"If no window or document do nothing This occurs if the stream has been closed or if the code is not running in Navigator If the window has been closed by the user do nothing Otherwise create a string from the specified bytes And pass it to the JS document write() method to output the HTML \n   * This is the write() method required for all Writer subclasses.\n   * Writer defines all its other write() methods in terms of this one.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n   * There is no general way to force JavaScript to flush all pending output,\n   * so this method does nothing.  To flush, output a <P> tag or some other\n   * HTML tag that forces a line break in the output.\n   **/\npublic void flush() {\n}\n","name":"flush","className":"HTMLWriter","variables":{},"constants":{},"javaDoc":"There is no general way to force JavaScript to flush all pending output so this method does nothing To flush output a <P> tag or some other HTML tag that forces a line break in the output","comments":"\n   * There is no general way to force JavaScript to flush all pending output,\n   * so this method does nothing.  To flush, output a <P> tag or some other\n   * HTML tag that forces a line break in the output.\n   *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"call":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n   * When the stream is closed, close the JavaScript Document object\n   * (But don't close the window yet.)\n   **/\npublic void close() {\n    document.call(\"close\", null);\n    document = null;\n}\n","name":"close","className":"HTMLWriter","variables":{"document":2},"constants":{"null":2,"\"close\"":1},"javaDoc":"When the stream is closed close the JavaScript Document object (But don't close the window yet )","comments":"\n   * When the stream is closed, close the JavaScript Document object\n   * (But don't close the window yet.)\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"call":1,"getMember":1,"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":1,"NameExpr":12,"CastExpr":1,"StringLiteralExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"/**\n   * If the browser window is still open, close it.\n   * This method is unique to HTMLWriter.  \n   **/\npublic void closeWindow() {\n    if (document != null)\n        close();\n    if (!((Boolean) window.getMember(\"closed\")).booleanValue())\n        window.call(\"close\", null);\n    window = null;\n}\n","name":"closeWindow","className":"HTMLWriter","variables":{"document":1,"window":3},"constants":{"null":3,"\"close\"":1,"\"closed\"":1},"javaDoc":"If the browser window is still open close it This method is unique to HTMLWriter","comments":"\n   * If the browser window is still open, close it.\n   * This method is unique to HTMLWriter.  \n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"closeWindow":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** A finalizer method to close the window in case we forget. */\npublic void finalize() {\n    closeWindow();\n}\n","name":"finalize","className":"HTMLWriter","variables":{},"constants":{},"javaDoc":"A finalizer method to close the window in case we forget","comments":" A finalizer method to close the window in case we forget. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"openStream":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"InputStreamReader":1,"Reader":1,"URL":1,"int":1,"char[]":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":5,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":7,"AssignExpr":2},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/** When the applet starts, read and display specified URL */\npublic void init() {\n    try {\n        // Get the URL specified in the <PARAM> tag\n        URL url = new URL(this.getDocumentBase(), this.getParameter(\"url\"));\n        // Get a stream to read its contents\n        Reader in = new InputStreamReader(url.openStream());\n        // Create an HTMLWriter stream for out output\n        out = new HTMLWriter(this, 400, 200);\n        // Read buffers of characters and output them to the HTMLWriter \n        char[] buffer = new char[4096];\n        int numchars;\n        while ((numchars = in.read(buffer)) != -1) out.write(buffer, 0, numchars);\n        // Close the streams\n        in.close();\n        out.close();\n    } catch (IOException e) {\n    }\n}\n","name":"init","className":"Test","variables":{"in":3,"e":1,"numchars":2,"buffer":1,"url":2,"out":3},"constants":{"0":1,"4096":1,"1":1,"200":1,"\"url\"":1,"400":1},"javaDoc":"When the applet starts read and display specified URL","comments":"Get the URL specified in the <PARAM> tag Get a stream to read its contents Create an HTMLWriter stream for out output Read buffers of characters and output them to the HTMLWriter Close the streams  When the applet starts, read and display specified URL ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"closeWindow":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** When the applet terminates, close the window we created */\npublic void destroy() {\n    out.closeWindow();\n}\n","name":"destroy","className":"Test","variables":{"out":1},"constants":{},"javaDoc":"When the applet terminates close the window we created","comments":" When the applet terminates, close the window we created ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter","Thread","String"],"returnType":"void","methodCalls":{"isAlive":1,"println":1,"getName":1,"isDaemon":1,"getPriority":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":7,"NameExpr":17,"StringLiteralExpr":6,"EnclosedExpr":2,"ConditionalExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Display information about a thread. */\nprivate static void printThreadInfo(PrintWriter out, Thread t, String indent) {\n    if (t == null)\n        return;\n    out.println(indent + \"Thread: \" + t.getName() + \"  Priority: \" + t.getPriority() + (t.isDaemon() ? \" Daemon\" : \"\") + (t.isAlive() ? \"\" : \" Not Alive\"));\n}\n","name":"printThreadInfo","className":"ThreadLister","variables":{"t":5,"indent":1,"out":1},"constants":{"\"\"":2,"null":1,"\"Thread: \"":1,"\" Not Alive\"":1,"\" Daemon\"":1,"\"  Priority: \"":1},"javaDoc":"Display information about a thread","comments":" Display information about a thread. ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["PrintWriter","ThreadGroup","String"],"returnType":"void","methodCalls":{"activeCount":1,"println":1,"printGroupInfo":1,"getName":1,"getMaxPriority":1,"printThreadInfo":1,"isDaemon":1,"activeGroupCount":1,"enumerate":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"ThreadGroup[]":1,"Thread[]":1,"int":4},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":48,"StringLiteralExpr":6,"ConditionalExpr":1,"UnaryExpr":2,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":9},"text":"/** Display info about a thread group and its threads and groups */\nprivate static void printGroupInfo(PrintWriter out, ThreadGroup g, String indent) {\n    if (g == null)\n        return;\n    int num_threads = g.activeCount();\n    int num_groups = g.activeGroupCount();\n    Thread[] threads = new Thread[num_threads];\n    ThreadGroup[] groups = new ThreadGroup[num_groups];\n    g.enumerate(threads, false);\n    g.enumerate(groups, false);\n    out.println(indent + \"Thread Group: \" + g.getName() + \"  Max Priority: \" + g.getMaxPriority() + (g.isDaemon() ? \" Daemon\" : \"\"));\n    for (int i = 0; i < num_threads; i++) printThreadInfo(out, threads[i], indent + \"    \");\n    for (int i = 0; i < num_groups; i++) printGroupInfo(out, groups[i], indent + \"    \");\n}\n","name":"printGroupInfo","className":"ThreadLister","variables":{"indent":3,"g":8,"num_threads":3,"threads":2,"groups":2,"i":8,"num_groups":3,"out":1},"constants":{"\"\"":1,"0":2,"null":1,"\"Thread Group: \"":1,"\"    \"":2,"\"  Max Priority: \"":1,"false":2,"\" Daemon\"":1},"javaDoc":"Display info about a thread group and its threads and groups","comments":" Display info about a thread group and its threads and groups ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"currentThread":1,"getParent":2,"printGroupInfo":1,"getThreadGroup":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ThreadGroup":3},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":1,"AssignExpr":5,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"/** Find the root thread group and list it recursively */\npublic static void listAllThreads(PrintWriter out) {\n    ThreadGroup current_thread_group;\n    ThreadGroup root_thread_group;\n    ThreadGroup parent;\n    // Get the current thread group\n    current_thread_group = Thread.currentThread().getThreadGroup();\n    // Now go find the root thread group\n    root_thread_group = current_thread_group;\n    parent = root_thread_group.getParent();\n    while (parent != null) {\n        root_thread_group = parent;\n        parent = parent.getParent();\n    }\n    // And list it, recursively\n    printGroupInfo(out, root_thread_group, \"\");\n}\n","name":"listAllThreads","className":"ThreadLister","variables":{"parent":6,"root_thread_group":4,"current_thread_group":3,"Thread":1},"constants":{"\"\"":1,"null":1},"javaDoc":"Find the root thread group and list it recursively","comments":"Get the current thread group Now go find the root thread group And list it recursively  Find the root thread group and list it recursively ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"flush":1,"listAllThreads":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n   * The main() method:  just print the list of threads to the console\n   **/\npublic static void main(String[] args) {\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n    ThreadLister.listAllThreads(out);\n    out.flush();\n}\n","name":"main","className":"ThreadLister","variables":{"ThreadLister":1,"out":2},"constants":{},"javaDoc":"The main() method: just print the list of threads to the console","comments":"\n   * The main() method:  just print the list of threads to the console\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":6,"StringLiteralExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Create a text area to put our listing in */\npublic void init() {\n    textarea = new java.awt.TextArea();\n    this.setLayout(new java.awt.BorderLayout());\n    this.add(\"Center\", textarea);\n}\n","name":"init","className":"Applet","variables":{"textarea":1},"constants":{"\"Center\"":1},"javaDoc":"Create a text area to put our listing in","comments":" Create a text area to put our listing in ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1,"toString":1,"listAllThreads":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringWriter":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"NameExpr":14,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/** When the applet starts, list all the threads */\npublic void start() {\n    // Capture listing in a string\n    StringWriter sout = new StringWriter();\n    PrintWriter out = new PrintWriter(sout);\n    ThreadLister.listAllThreads(out);\n    out.flush();\n    // Display the listing\n    textarea.setText(sout.toString());\n}\n","name":"start","className":"Applet","variables":{"ThreadLister":1,"textarea":1,"sout":3,"out":2},"constants":{},"javaDoc":"When the applet starts list all the threads","comments":"Capture listing in a string Display the listing  When the applet starts, list all the threads ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"size":1,"verify":1,"create":1,"addElement":1,"System.err.println":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"String":4,"Vector":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"ArrayAccessExpr":11,"BinaryExpr":11,"StringLiteralExpr":14,"NameExpr":74,"UnaryExpr":9,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":7,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":16},"text":"/**\n   * This program creates a manifest file for the specified files, or verifies\n   * an existing manifest file.  By default the manifest file is named\n   * MANIFEST, but the -m option can be used to override this.  The -v\n   * option specifies that the manifest should be verified.  Verification is\n   * also the default option if no files are specified.\n   **/\npublic static void main(String[] args) {\n    try {\n        // Set the default values of the command-line arguments\n        // Verify manifest or create one?\n        boolean verify = false;\n        // Manifest file name\n        String manifestfile = \"MANIFEST\";\n        // Algorithm for message digests\n        String digestAlgorithm = \"MD5\";\n        // Signer.  No signature by default\n        String signername = null;\n        // Algorithm for digital signatures\n        String signatureAlgorithm = \"DSA\";\n        // The list of files to digest\n        Vector filelist = new Vector();\n        // Parse the command-line arguments, overriding the defaults above\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-v\"))\n                verify = true;\n            else if (args[i].equals(\"-m\"))\n                manifestfile = args[++i];\n            else if (args[i].equals(\"-da\") && !verify)\n                digestAlgorithm = args[++i];\n            else if (args[i].equals(\"-s\") && !verify)\n                signername = args[++i];\n            else if (args[i].equals(\"-sa\") && !verify)\n                signatureAlgorithm = args[++i];\n            else if (!verify)\n                filelist.addElement(args[i]);\n            else\n                throw new IllegalArgumentException(args[i]);\n        }\n        // Otherwise, create a new manifest for the specified files\n        if (verify || (filelist.size() == 0))\n       // If -v was specified or no file were given, verify a manifest\n\n            verify(manifestfile);\n        else\n            create(manifestfile, digestAlgorithm, signername, signatureAlgorithm, filelist);\n    }// If anything goes wrong, display the exception, and print a usage message\n     catch (Exception e) {\n        System.err.println(\"\\n\" + e);\n        System.err.println(\"Usage: java Manifest [-v] [-m <manifestfile>]\\n\" + \"   or: java Manifest \" + \"[-m <manifestfile>] [-da <digest algorithm>]\\n\" + \"\\t\\t[-s <signer>] [-sa <signature algorithm>] \" + \"files...\");\n    }\n}\n","name":"main","className":"Manifest","variables":{"args":11,"manifestfile":2,"e":2,"verify":7,"filelist":3,"i":14,"digestAlgorithm":2,"signername":2,"signatureAlgorithm":2},"constants":{"\"Usage: java Manifest [-v] [-m <manifestfile>]\\n\"":1,"\"MANIFEST\"":1,"\"   or: java Manifest \"":1,"\"MD5\"":1,"\"-v\"":1,"false":1,"\"[-m <manifestfile>] [-da <digest algorithm>]\\n\"":1,"\"-s\"":1,"\"files...\"":1,"\"DSA\"":1,"\"\\t\\t[-s <signer>] [-sa <signature algorithm>] \"":1,"\"-da\"":1,"0":2,"\"-m\"":1,"null":1,"true":1,"\"-sa\"":1,"\"\\n\"":1},"javaDoc":"This program creates a manifest file for the specified files or verifies an existing manifest file By default the manifest file is named MANIFEST but the -m option can be used to override this The -v option specifies that the manifest should be verified Verification is also the default option if no files are specified","comments":"Set the default values of the command-line arguments If -v was specified or no file were given verify a manifest Verify manifest or create one? Manifest file name Algorithm for message digests Signer No signature by default Algorithm for digital signatures The list of files to digest Parse the command-line arguments overriding the defaults above Otherwise create a new manifest for the specified files If anything goes wrong display the exception and print a usage message \n   * This program creates a manifest file for the specified files, or verifies\n   * an existing manifest file.  By default the manifest file is named\n   * MANIFEST, but the -m option can be used to override this.  The -v\n   * option specifies that the manifest should be verified.  Verification is\n   * also the default option if no files are specified.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String","Vector"],"returnType":"void","methodCalls":{"System.out.flush":3,"copyInto":1,"sign":1,"save":2,"update":2,"getSystemScope":1,"put":5,"sortAscii":1,"initSign":1,"size":1,"getIdentity":1,"getInstance":2,"hexEncode":2,"getPrivateKey":1,"System.err.println":1,"getFileDigest":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":["NoSuchAlgorithmException","SignatureException","IOException","InvalidKeyException"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":2,"Signer":1,"Signature":1,"FileOutputStream":1,"String[]":1,"Properties":1,"MessageDigest":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":9,"ArrayAccessExpr":4,"BinaryExpr":8,"NameExpr":145,"StringLiteralExpr":12,"CharLiteralExpr":1,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":10,"ArrayCreationExpr":1,"MethodCallExpr":32},"statements":{"ContinueStmt":1,"IfStmt":4,"BlockStmt":7,"TryStmt":1,"ForStmt":1,"ExpressionStmt":32},"text":"/**\n   * This method creates a manifest file with the specified name, for\n   * the specified vector of files, using the named message digest\n   * algorithm.  If signername is non-null, it adds a digital signature\n   * to the manifest, using the named signature algorithm.  This method can\n   * throw a bunch of exceptions.\n   **/\npublic static void create(String manifestfile, String digestAlgorithm, String signername, String signatureAlgorithm, Vector filelist) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException, IOException {\n    // For computing a signature, we have to process the files in a fixed,\n    // repeatable order, so copy the filenames into an array and sort it.\n    // Use the Sorter class from Chapter 2.\n    String[] files = new String[filelist.size()];\n    filelist.copyInto(files);\n    Sorter.sortAscii(files);\n    Properties manifest = new Properties(), metadata = new Properties();\n    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n    Signature signature = null;\n    byte[] digest;\n    // If a signer name has been specified, then prepare to sign the manifest\n    if (signername != null) {\n        // Look up the signer object\n        Signer signer = (Signer) IdentityScope.getSystemScope().getIdentity(signername);\n        // Get a Signature object\n        signature = Signature.getInstance(signatureAlgorithm);\n        // And prepare to create a signature for the specified signer\n        signature.initSign(signer.getPrivateKey());\n    }\n    // Now, loop through the files, in a well-known alphabetical order\n    System.out.print(\"Computing message digests\");\n    for (int i = 0; i < files.length; i++) {\n        // Compute the digest for each one, and skip files that don't exist.\n        try {\n            digest = getFileDigest(files[i], md);\n        } catch (IOException e) {\n            System.err.println(\"\\nSkipping \" + files[i] + \": \" + e);\n            continue;\n        }\n        // of the digest as part of the data to sign.\n        if (signature != null) {\n            signature.update(files[i].getBytes());\n            signature.update(digest);\n        }\n        // Store the filename and the encoded digest bytes in the manifest\n        manifest.put(files[i], hexEncode(digest));\n        System.out.print('.');\n        System.out.flush();\n    }\n    // If a signer was specified, compute digital signature for the manifest\n    byte[] signaturebytes = null;\n    if (signature != null) {\n        System.out.print(\"done\\nComputing digital signature...\");\n        System.out.flush();\n        // Compute the digital signature by encrypting a message digest of all\n        // the bytes passed to the update() method using the private key of the\n        // signer.  This is a time consuming operation.\n        signaturebytes = signature.sign();\n    }\n    // Tell the user what comes next\n    System.out.print(\"done\\nWriting manifest...\");\n    System.out.flush();\n    // Store some metadata about this manifest, including the name of the\n    // message digest algorithm it uses\n    metadata.put(\"__META.DIGESTALGORITHM\", digestAlgorithm);\n    // If we're signing the manifest, store some more metadata\n    if (signername != null) {\n        // Store the name of the signer\n        metadata.put(\"__META.SIGNER\", signername);\n        // Store the name of the algorithm\n        metadata.put(\"__META.SIGNATUREALGORITHM\", signatureAlgorithm);\n        // And generate the signature, encode it, and store it\n        metadata.put(\"__META.SIGNATURE\", hexEncode(signaturebytes));\n    }\n    // Now, save the manifest data and the metadata to the manifest file\n    FileOutputStream f = new FileOutputStream(manifestfile);\n    manifest.save(f, \"Manifest message digests\");\n    metadata.save(f, \"Manifest metadata\");\n    System.out.println(\"done\");\n}\n       // If we're computing a signature, use the bytes of the filename and\n\n","name":"create","className":"Manifest","variables":{"metadata":6,"IdentityScope":1,"manifestfile":1,"signature":8,"e":2,"manifest":3,"f":1,"filelist":2,"i":7,"signaturebytes":2,"md":1,"Signature":1,"Sorter":1,"digest":2,"files":5,"MessageDigest":1,"signername":2,"signer":2},"constants":{"'.'":1,"\"done\\nComputing digital signature...\"":1,"\"done\"":1,"\"__META.SIGNER\"":1,"\": \"":1,"\"Computing message digests\"":1,"\"done\\nWriting manifest...\"":1,"0":1,"\"__META.SIGNATURE\"":1,"\"__META.SIGNATUREALGORITHM\"":1,"\"__META.DIGESTALGORITHM\"":1,"null":6,"\"Manifest message digests\"":1,"\"\\nSkipping \"":1,"\"Manifest metadata\"":1},"javaDoc":"This method creates a manifest file with the specified name for the specified vector of files using the named message digest algorithm If signername is non-null it adds a digital signature to the manifest using the named signature algorithm This method can throw a bunch of exceptions","comments":"For computing a signature we have to process the files in a fixed repeatable order so copy the filenames into an array and sort it Store some metadata about this manifest including the name of the Use the Sorter class from Chapter 2 If a signer name has been specified then prepare to sign the manifest Look up the signer object Get a Signature object And prepare to create a signature for the specified signer Now loop through the files in a well-known alphabetical order If we're computing a signature use the bytes of the filename and Compute the digest for each one and skip files that don't exist of the digest as part of the data to sign Store the filename and the encoded digest bytes in the manifest If a signer was specified compute digital signature for the manifest Compute the digital signature by encrypting a message digest of all the bytes passed to the update() method using the private key of the signer This is a time consuming operation Tell the user what comes next message digest algorithm it uses If we're signing the manifest store some more metadata Store the name of the signer Store the name of the algorithm And generate the signature encode it and store it Now save the manifest data and the metadata to the manifest file \n   * This method creates a manifest file with the specified name, for\n   * the specified vector of files, using the named message digest\n   * algorithm.  If signername is non-null, it adds a digital signature\n   * to the manifest, using the named signature algorithm.  This method can\n   * throw a bunch of exceptions.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"update":2,"getSystemScope":1,"initVerify":1,"load":1,"hasMoreElements":1,"verify":1,"hexEncode":1,"System.out.print":3,"System.out.println":5,"getProperty":6,"System.out.flush":3,"copyInto":1,"getPublicKey":1,"sortAscii":1,"exit":1,"size":1,"propertyNames":1,"getIdentity":1,"equals":1,"addElement":1,"getInstance":2,"getFileDigest":1,"hexDecode":2,"nextElement":1,"startsWith":1},"annotations":[],"exceptions":["NoSuchAlgorithmException","SignatureException","IOException","InvalidKeyException"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":1,"Enumeration":1,"Signature":1,"String":6,"String[]":1,"Properties":1,"Identity":1,"MessageDigest":1,"Vector":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":16,"ArrayAccessExpr":6,"BinaryExpr":8,"NameExpr":177,"StringLiteralExpr":15,"UnaryExpr":5,"AssignExpr":1,"NullLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":13,"ArrayCreationExpr":1,"MethodCallExpr":42},"statements":{"ContinueStmt":1,"IfStmt":4,"WhileStmt":1,"BlockStmt":7,"TryStmt":1,"ForStmt":2,"ExpressionStmt":34},"text":"/**\n   * This method verifies the digital signature of the named manifest\n   * file, if it has one, and if that verification succeeds, it verifies\n   * the message digest of each file in filelist that is also named in the\n   * manifest.  This method can throw a bunch of exceptions\n   **/\npublic static void verify(String manifestfile) throws NoSuchAlgorithmException, SignatureException, InvalidKeyException, IOException {\n    Properties manifest = new Properties();\n    manifest.load(new FileInputStream(manifestfile));\n    String digestAlgorithm = manifest.getProperty(\"__META.DIGESTALGORITHM\");\n    String signername = manifest.getProperty(\"__META.SIGNER\");\n    String signatureAlgorithm = manifest.getProperty(\"__META.SIGNATUREALGORITHM\");\n    String hexsignature = manifest.getProperty(\"__META.SIGNATURE\");\n    // Get a list of filenames in the manifest.  Use an Enumeration to\n    // get them into a Vector, then allocate an array and copy them into that.\n    Vector filelist = new Vector();\n    Enumeration names = manifest.propertyNames();\n    while (names.hasMoreElements()) {\n        String s = (String) names.nextElement();\n        if (!s.startsWith(\"__META\"))\n            filelist.addElement(s);\n    }\n    String[] files = new String[filelist.size()];\n    filelist.copyInto(files);\n    // verify that signature first\n    if (signername != null) {\n        System.out.print(\"Verifying digital signature...\");\n        System.out.flush();\n        // To verify the signature, we must process the files in exactly the\n        // same order we did when we created the signature.  We guarantee\n        // this order by sorting the filenames.\n        Sorter.sortAscii(files);\n        // Get the Signer identity, create a Signature object, and initialize\n        // it for signature verification, using the signer's public key\n        Identity signer = (Identity) IdentityScope.getSystemScope().getIdentity(signername);\n        Signature signature = Signature.getInstance(signatureAlgorithm);\n        signature.initVerify(signer.getPublicKey());\n        // verifying the signature as it was done when creating the signature.\n        for (int i = 0; i < files.length; i++) {\n            signature.update(files[i].getBytes());\n            signature.update(hexDecode(manifest.getProperty(files[i])));\n        }\n        // is not verified, print an error message and exit.\n        if (!signature.verify(hexDecode(hexsignature))) {\n            System.out.println(\"\\nManifest has an invalid digital signature\");\n            System.exit(0);\n        }\n        // Tell the user we're done with this lengthy computation\n        System.out.println(\"verified.\");\n    }\n    // Tell the user we're starting the next phase of verification\n    System.out.print(\"Verifying file message digests\");\n    System.out.flush();\n    // Get a MessageDigest object to compute digests\n    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n    // Loop through all files\n    for (int i = 0; i < files.length; i++) {\n        // Look up the encoded digest from the manifest file\n        String hexdigest = manifest.getProperty(files[i]);\n        // Compute the digest for the file.\n        byte[] digest;\n        try {\n            digest = getFileDigest(files[i], md);\n        } catch (IOException e) {\n            System.out.println(\"\\nSkipping \" + files[i] + \": \" + e);\n            continue;\n        }\n        // from the manifest.  If they are not equal, print an error message.\n        if (!hexdigest.equals(hexEncode(digest)))\n            System.out.println(\"\\nFile '\" + files[i] + \"' failed verification.\");\n        // Send one dot of output for each file we process.  Since computing\n        // message digests takes some time, this lets the user know that the\n        // program is functioning and making progress\n        System.out.print(\".\");\n        System.out.flush();\n    }\n    // And tell the user we're done with verification.\n    System.out.println(\"done.\");\n}\n     // If the manifest contained metadata about a digital signature, then\n\n       // Now loop through these files in their known sorted order\n\n       // For each one, send the bytes of the filename and of the digest\n\n       // to the signature object for use in computing the signature.\n\n       // It is important that this be done in exactly the same order when\n\n       // Now decode the signature read from the manifest file and pass it\n\n       // to the verify() method of the signature object.  If the signature\n\n       // Encode the computed digest and compare it to the encoded digest\n\n","name":"verify","className":"Manifest","variables":{"manifestfile":1,"IdentityScope":1,"signature":5,"e":2,"manifest":9,"filelist":4,"i":12,"digestAlgorithm":1,"hexsignature":1,"signatureAlgorithm":1,"System":1,"names":3,"s":2,"hexdigest":2,"Signature":1,"md":1,"Sorter":1,"digest":2,"files":7,"signername":2,"MessageDigest":1,"signer":2},"constants":{"\"Verifying digital signature...\"":1,"\"__META.SIGNER\"":1,"\"__META\"":1,"\"\\nManifest has an invalid digital signature\"":1,"\": \"":1,"\"verified.\"":1,"\"__META.SIGNATURE\"":1,"0":3,"\"\\nFile '\"":1,"\"done.\"":1,"\"Verifying file message digests\"":1,"\"__META.SIGNATUREALGORITHM\"":1,"\"__META.DIGESTALGORITHM\"":1,"null":1,"\"' failed verification.\"":1,"\".\"":1,"\"\\nSkipping \"":1},"javaDoc":"This method verifies the digital signature of the named manifest file if it has one and if that verification succeeds it verifies the message digest of each file in filelist that is also named in the manifest This method can throw a bunch of exceptions","comments":"Get a list of filenames in the manifest Use an Enumeration to If the manifest contained metadata about a digital signature then get them into a Vector then allocate an array and copy them into that verify that signature first To verify the signature we must process the files in exactly the same order we did when we created the signature We guarantee Get the Signer identity create a Signature object and initialize Now loop through these files in their known sorted order For each one send the bytes of the filename and of the digest to the signature object for use in computing the signature It is important that this be done in exactly the same order when Now decode the signature read from the manifest file and pass it to the verify() method of the signature object If the signature this order by sorting the filenames it for signature verification using the signer's public key verifying the signature as it was done when creating the signature is not verified print an error message and exit Tell the user we're done with this lengthy computation Tell the user we're starting the next phase of verification Get a MessageDigest object to compute digests Loop through all files Encode the computed digest and compare it to the encoded digest Send one dot of output for each file we process Since computing message digests takes some time this lets the user know that the Look up the encoded digest from the manifest file Compute the digest for the file from the manifest If they are not equal print an error message program is functioning and making progress And tell the user we're done with verification \n   * This method verifies the digital signature of the named manifest\n   * file, if it has one, and if that verification succeeds, it verifies\n   * the message digest of each file in filelist that is also named in the\n   * manifest.  This method can throw a bunch of exceptions\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","MessageDigest"],"returnType":"byte[]","methodCalls":{"read":1,"digest":1,"reset":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"DigestInputStream":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"EmptyStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n   * This convenience method is used by both create() and verify().  It\n   * reads the contents of a named file and computes a message digest\n   * for it, using the specified MessageDigest object.\n   **/\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) /* do nothing */\n    ;\n    // Finally, compute and return the digest value.\n    return md.digest();\n}\n     // Read to the end of the file, discarding everything we read.\n\n     // The DigestInputStream automatically passes all the bytes read to\n\n","name":"getFileDigest","className":"Manifest","variables":{"filename":1,"in":2,"md":3},"constants":{"1":1},"javaDoc":"This convenience method is used by both create() and verify() It reads the contents of a named file and computes a message digest for it using the specified MessageDigest object","comments":"Read to the end of the file discarding everything we read The DigestInputStream automatically passes all the bytes read to Make sure there is nothing left behind in the MessageDigest Create a stream to read from the file and compute the digest the update() method of the MessageDigest do nothing Finally compute and return the digest value \n   * This convenience method is used by both create() and verify().  It\n   * reads the contents of a named file and computes a message digest\n   * for it, using the specified MessageDigest object.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["byte[]"],"returnType":"String","methodCalls":{"toString":1,"append":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"byte":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":5,"NameExpr":23,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n   * A convenience method to convert an array of bytes to a String.  We do\n   * this simply by converting each byte to two hexadecimal digits.  Something\n   * like Base 64 encoding is more compact, but harder to encode.\n   **/\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}\n","name":"hexEncode","className":"Manifest","variables":{"b":3,"s":4,"bytes":1,"i":4,"digits":2},"constants":{"0":1,"2":1,"4":1,"0xf0":1,"0x0f":1},"javaDoc":"A convenience method to convert an array of bytes to a String We do this simply by converting each byte to two hexadecimal digits Something like Base 64 encoding is more compact but harder to encode","comments":"\n   * A convenience method to convert an array of bytes to a String.  We do\n   * this simply by converting each byte to two hexadecimal digits.  Something\n   * like Base 64 encoding is more compact, but harder to encode.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"byte[]","methodCalls":{"length":1,"charAt":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":21,"NameExpr":34,"StringLiteralExpr":1,"CharLiteralExpr":12,"UnaryExpr":1,"AssignExpr":5,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":10,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":4,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":8},"text":"/**\n   * A convenience method to convert in the other direction, from a string\n   * of hexadecimal digits to an array of bytes.\n   **/\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9'))\n                digit1 -= '0';\n            else if ((digit1 >= 'a') && (digit1 <= 'f'))\n                digit1 -= 'a' - 10;\n            if ((digit2 >= '0') && (digit2 <= '9'))\n                digit2 -= '0';\n            else if ((digit2 >= 'a') && (digit2 <= 'f'))\n                digit2 -= 'a' - 10;\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}\n","name":"hexDecode","className":"Manifest","variables":{"r":3,"s":3,"len":2,"e":1,"digit1":8,"i":6,"digit2":8},"constants":{"0":1,"1":1,"2":3,"4":1,"'9'":2,"\"hexDecode(): invalid input\"":1,"'f'":2,"'a'":4,"'0'":4,"10":2},"javaDoc":"A convenience method to convert in the other direction from a string of hexadecimal digits to an array of bytes","comments":"\n   * A convenience method to convert in the other direction, from a string\n   * of hexadecimal digits to an array of bytes.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["AdjustmentEvent"],"returnType":"void","methodCalls":{"getValue":1,"setBase":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"CastExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void adjustmentValueChanged(AdjustmentEvent e) {\n    page = e.getValue();\n    p.setBase((char) (page * 0x100));\n}\n","name":"adjustmentValueChanged","className":"","variables":{"p":1,"e":1,"page":2},"constants":{"0x100":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void windowClosing(WindowEvent e) {\n    UnicodeDisplay.this.dispose();\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"UnicodeDisplay":1,"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"setValue":1,"setBase":1,"getKeyCode":1,"isShiftDown":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":2,"BinaryExpr":10,"NameExpr":44,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":5,"MethodCallExpr":5,"AssignExpr":6},"statements":{"IfStmt":7,"BlockStmt":3,"ExpressionStmt":10},"text":"public void keyPressed(KeyEvent e) {\n    int code = e.getKeyCode();\n    int oldpage = page;\n    if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {\n        if (e.isShiftDown())\n            page -= 0x10;\n        else\n            page -= 1;\n        if (page < 0)\n            page = 0;\n    } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {\n        if (e.isShiftDown())\n            page += 0x10;\n        else\n            page += 1;\n        if (page > 0xff)\n            page = 0xff;\n    }\n    if (page != oldpage) {\n        // if anything has changed...\n        // update the display\n        p.setBase((char) (page * 0x100));\n        // and update scrollbar to match\n        b.setValue(page);\n    }\n}\n","name":"keyPressed","className":"","variables":{"p":1,"oldpage":2,"b":1,"code":5,"e":3,"page":11},"constants":{"0x10":2,"0":2,"1":2,"0x100":1,"0xff":2},"javaDoc":"","comments":"if anything has changed update the display and update scrollbar to match ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"UnicodeDisplay","methodCalls":{"add":2,"getValue":1,"exit":1,"setUnitIncrement":1,"addAdjustmentListener":1,"setValue":1,"makemenu":2,"setBlockIncrement":1,"setBase":3,"getKeyCode":1,"isShiftDown":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"MenuBar":1,"int":2},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":18,"VariableDeclarationExpr":3,"BinaryExpr":12,"NameExpr":108,"StringLiteralExpr":11,"AssignExpr":9,"ArrayInitializerExpr":2,"CastExpr":3,"FieldAccessExpr":5,"EnclosedExpr":7,"ArrayCreationExpr":2,"ThisExpr":9,"MethodCallExpr":23},"statements":{"IfStmt":7,"BlockStmt":6,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":29},"text":"/** \n   * This constructor creates the frame, menubar, and scrollbar\n   * that work along with the UnicodePanel class, defined below\n   **/\npublic UnicodeDisplay(String name) {\n    super(name);\n    this.setLayout(new BorderLayout());\n    // Create the panel\n    p = new UnicodePanel();\n    // Initialize it\n    p.setBase((char) (page * 0x100));\n    // Center it\n    this.add(p, \"Center\");\n    // Create and set up a scrollbar, and put it on the right\n    b = new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 0xFF);\n    b.setUnitIncrement(1);\n    b.setBlockIncrement(0x10);\n    b.addAdjustmentListener(new AdjustmentListener() {\n\n        public void adjustmentValueChanged(AdjustmentEvent e) {\n            page = e.getValue();\n            p.setBase((char) (page * 0x100));\n        }\n    });\n    this.add(b, \"East\");\n    // Set things up so we respond to window close requests\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            UnicodeDisplay.this.dispose();\n            System.exit(0);\n        }\n    });\n    // Handle Page Up and Page Down and the up and down arrow keys\n    this.addKeyListener(new KeyAdapter() {\n\n        public void keyPressed(KeyEvent e) {\n            int code = e.getKeyCode();\n            int oldpage = page;\n            if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {\n                if (e.isShiftDown())\n                    page -= 0x10;\n                else\n                    page -= 1;\n                if (page < 0)\n                    page = 0;\n            } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {\n                if (e.isShiftDown())\n                    page += 0x10;\n                else\n                    page += 1;\n                if (page > 0xff)\n                    page = 0xff;\n            }\n            if (page != oldpage) {\n                // if anything has changed...\n                // update the display\n                p.setBase((char) (page * 0x100));\n                // and update scrollbar to match\n                b.setValue(page);\n            }\n        }\n    });\n    // Set up a menu system to change fonts.  Use a convenience method.\n    MenuBar menubar = new MenuBar();\n    this.setMenuBar(menubar);\n    menubar.add(makemenu(\"Font Family\", new String[] { \"Serif\", \"SansSerif\", \"Monospaced\" }, this));\n    menubar.add(makemenu(\"Font Style\", new String[] { \"Plain\", \"Italic\", \"Bold\", \"BoldItalic\" }, this));\n}\n","name":"UnicodeDisplay","className":"UnicodeDisplay","variables":{"b":5,"oldpage":2,"UnicodeDisplay":1,"keyPressed":1,"code":5,"e":7,"adjustmentValueChanged":1,"System":1,"p":4,"menubar":3,"windowClosing":1,"name":1,"page":14},"constants":{"\"Bold\"":1,"\"SansSerif\"":1,"\"Font Family\"":1,"\"Monospaced\"":1,"\"Center\"":1,"\"Font Style\"":1,"\"Plain\"":1,"0":5,"0x10":3,"1":4,"0x100":3,"\"BoldItalic\"":1,"\"Italic\"":1,"\"East\"":1,"\"Serif\"":1,"0xFF":1,"0xff":2},"javaDoc":"This constructor creates the frame menubar and scrollbar that work along with the UnicodePanel class defined below","comments":"Create the panel Initialize it Center it Create and set up a scrollbar and put it on the right Set things up so we respond to window close requests Handle Page Up and Page Down and the up and down arrow keys if anything has changed update the display and update scrollbar to match Set up a menu system to change fonts Use a convenience method  \n   * This constructor creates the frame, menubar, and scrollbar\n   * that work along with the UnicodePanel class, defined below\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"equals":7,"getActionCommand":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":51,"StringLiteralExpr":10,"FieldAccessExpr":5,"MethodCallExpr":9,"AssignExpr":7},"statements":{"IfStmt":7,"ExpressionStmt":9},"text":"/** This method handles the items in the menubars */\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (cmd.equals(\"Serif\"))\n        fontfamily = \"Serif\";\n    else if (cmd.equals(\"SansSerif\"))\n        fontfamily = \"SansSerif\";\n    else if (cmd.equals(\"Monospaced\"))\n        fontfamily = \"Monospaced\";\n    else if (cmd.equals(\"Plain\"))\n        fontstyle = Font.PLAIN;\n    else if (cmd.equals(\"Italic\"))\n        fontstyle = Font.ITALIC;\n    else if (cmd.equals(\"Bold\"))\n        fontstyle = Font.BOLD;\n    else if (cmd.equals(\"BoldItalic\"))\n        fontstyle = Font.BOLD + Font.ITALIC;\n    p.setFont(fontfamily, fontstyle);\n}\n","name":"actionPerformed","className":"UnicodeDisplay","variables":{"p":1,"fontstyle":4,"e":1,"fontfamily":3,"cmd":8},"constants":{"\"Bold\"":1,"\"BoldItalic\"":1,"\"SansSerif\"":2,"\"Italic\"":1,"\"Monospaced\"":2,"\"Serif\"":2,"\"Plain\"":1},"javaDoc":"This method handles the items in the menubars","comments":" This method handles the items in the menubars ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String[]","ActionListener"],"returnType":"Menu","methodCalls":{"add":1,"addActionListener":1,"setActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"MenuItem":1,"Menu":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":22,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** A convenience method to create a Menu from an array of items */\nprivate Menu makemenu(String name, String[] itemnames, ActionListener listener) {\n    Menu m = new Menu(name);\n    for (int i = 0; i < itemnames.length; i++) {\n        MenuItem item = new MenuItem(itemnames[i]);\n        item.addActionListener(listener);\n        // okay here, though\n        item.setActionCommand(itemnames[i]);\n        m.add(item);\n    }\n    return m;\n}\n","name":"makemenu","className":"UnicodeDisplay","variables":{"item":3,"name":1,"i":5,"m":3,"itemnames":2},"constants":{"0":1},"javaDoc":"A convenience method to create a Menu from an array of items","comments":"okay here though  A convenience method to create a Menu from an array of items ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"UnicodeDisplay":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** The main() program just create a window, packs it, and shows it */\npublic static void main(String[] args) {\n    UnicodeDisplay f = new UnicodeDisplay(\"Unicode Displayer\");\n    f.pack();\n    f.show();\n}\n","name":"main","className":"UnicodeDisplay","variables":{"f":3},"constants":{"\"Unicode Displayer\"":1},"javaDoc":"The main() program just create a window packs it and shows it","comments":" The main() program just create a window, packs it, and shows it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Specify where to begin displaying, and re-display */\npublic void setBase(char base) {\n    this.base = base;\n    repaint();\n}\n","name":"setBase","className":"UnicodePanel","variables":{"base":1},"constants":{},"javaDoc":"Specify where to begin displaying and re-display","comments":" Specify where to begin displaying, and re-display ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Set a new font name or style, and redisplay */\npublic void setFont(String family, int style) {\n    this.font = new Font(family, style, 18);\n    repaint();\n}\n","name":"setFont","className":"UnicodePanel","variables":{"style":1,"family":1},"constants":{"18":1},"javaDoc":"Set a new font name or style and redisplay","comments":" Set a new font name or style, and redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawChars":1,"toString":2,"setFont":2,"drawString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":6,"char[]":1},"expressions":{"IntegerLiteralExpr":19,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":19,"CastExpr":2,"NameExpr":56,"EnclosedExpr":1,"UnaryExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":7,"AssignExpr":1},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":11},"text":"/**\n     * The paint() method actually draws the page of glyphs \n     **/\npublic void paint(Graphics g) {\n    // Start on a 16-character boundary\n    int start = (int) base & 0xFFF0;\n    // Draw the headings in a special font\n    g.setFont(headingfont);\n    // Draw 0..F on top\n    for (int i = 0; i < 16; i++) {\n        String s = Integer.toString(i, 16);\n        g.drawString(s, x0 + i * charspacing, y0 - 20);\n    }\n    // Draw column down left.\n    for (int i = 0; i < 16; i++) {\n        int j = start + i * 16;\n        String s = Integer.toString(j, 16);\n        g.drawString(s, 10, y0 + i * lineheight);\n    }\n    // Now draw the characters\n    g.setFont(font);\n    char[] c = new char[1];\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 16; j++) {\n            c[0] = (char) (start + j * 16 + i);\n            g.drawChars(c, 0, 1, x0 + i * charspacing, y0 + j * lineheight);\n        }\n    }\n}\n","name":"paint","className":"UnicodePanel","variables":{"Integer":2,"charspacing":2,"s":2,"c":2,"g":5,"y0":3,"lineheight":2,"start":3,"x0":2,"i":14,"j":6,"base":1},"constants":{"0":6,"1":2,"16":8,"0xFFF0":1,"20":1,"10":1},"javaDoc":"The paint() method actually draws the page of glyphs","comments":"Start on a 16-character boundary Draw the headings in a special font Draw 0 F on top Draw column down left Now draw the characters \n     * The paint() method actually draws the page of glyphs \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"/** Custom components like this one should always have this method */\npublic Dimension getPreferredSize() {\n    return new Dimension(410, 430);\n}\n","name":"getPreferredSize","className":"UnicodePanel","variables":{},"constants":{"430":1,"410":1},"javaDoc":"Custom components like this one should always have this method","comments":" Custom components like this one should always have this method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"fillOval":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Draw the circle at its current position */\npublic void paint(Graphics g) {\n    g.setColor(Color.red);\n    g.fillOval(x - r, y - r, r * 2, r * 2);\n}\n","name":"paint","className":"BouncingCircle","variables":{"r":4,"g":2,"x":1,"y":1},"constants":{"2":2},"javaDoc":"Draw the circle at its current position","comments":" Draw the circle at its current position ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"bounds":2,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":14,"NameExpr":30,"FieldAccessExpr":2,"EnclosedExpr":4,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":4},"statements":{"IfStmt":2,"ExpressionStmt":5},"text":"/** Move and bounce the circle and request a redraw.\n   *  The timer calls this method periodically. */\npublic void animate() {\n    // Bounce if we've hit an edge.\n    if ((x - r + dx < 0) || (x + r + dx > bounds().width))\n        dx = -dx;\n    if ((y - r + dy < 0) || (y + r + dy > bounds().height))\n        dy = -dy;\n    // Move the circle.\n    x += dx;\n    y += dy;\n    // Ask the browser to call our paint() method to draw the circle\n    // at its new position.\n    repaint();\n}\n","name":"animate","className":"BouncingCircle","variables":{"r":4,"dx":5,"dy":5,"x":3,"y":3},"constants":{"0":2},"javaDoc":"Move and bounce the circle and request a redraw The timer calls this method periodically","comments":"Ask the browser to call our paint() method to draw the circle Bounce if we've hit an edge Move the circle at its new position  Move and bounce the circle and request a redraw.\n   *  The timer calls this method periodically. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start_animation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Start the timer when the browser starts the applet */\npublic void start() {\n    timer.start_animation();\n}\n","name":"start","className":"BouncingCircle","variables":{"timer":1},"constants":{},"javaDoc":"Start the timer when the browser starts the applet","comments":" Start the timer when the browser starts the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"pause_animation":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Pause the timer when browser pauses the applet */\npublic void stop() {\n    timer.pause_animation();\n}\n","name":"stop","className":"BouncingCircle","variables":{"timer":1},"constants":{},"javaDoc":"Pause the timer when browser pauses the applet","comments":" Pause the timer when browser pauses the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void animate();\n","name":"animate","className":"Animation","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Animation","int"],"returnType":"AnimationTimer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public AnimationTimer(Animation animation, int delay) {\n    this.animation = animation;\n    this.delay = delay;\n}\n","name":"AnimationTimer","className":"AnimationTimer","variables":{"delay":1,"animation":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isAlive":1,"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":6,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void start_animation() {\n    if (isAlive())\n        super.resume();\n    else\n        start();\n}\n","name":"start_animation","className":"AnimationTimer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"suspend":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void pause_animation() {\n    suspend();\n}\n","name":"pause_animation","className":"AnimationTimer","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"animate":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"BlockStmt":3,"TryStmt":1,"EmptyStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** Loop forever, calling animate(), and then pausing the specified time. */\npublic void run() {\n    for (; ; ) {\n        animation.animate();\n        try {\n            Thread.sleep(delay);\n        } catch (InterruptedException e) {\n            ;\n        }\n    }\n}\n","name":"run","className":"AnimationTimer","variables":{"e":1,"animation":1,"Thread":1},"constants":{},"javaDoc":"Loop forever calling animate() and then pausing the specified time","comments":" Loop forever, calling animate(), and then pausing the specified time. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame","String","int","double","double","double","double"],"returnType":"HardcopyWriter","methodCalls":{"charWidth":1,"getProperty":1,"System.out.flush":1,"format":1,"regionMatches":1,"getDefault":1,"getPageDimension":1,"getToolkit":1,"getFontMetrics":2,"getAscent":2,"getScreenResolution":1,"getHeight":2,"getDateTimeInstance":1,"getPrintJob":1,"setTimeZone":1,"getPageResolution":1,"System.out.println":3},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException","PrintCanceledException"],"concepts":["Synchronization"],"types":{"DateFormat":1,"Toolkit":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":19,"NameExpr":150,"StringLiteralExpr":5,"CharLiteralExpr":1,"AssignExpr":23,"NullLiteralExpr":1,"DoubleLiteralExpr":2,"BooleanLiteralExpr":1,"CastExpr":6,"FieldAccessExpr":12,"EnclosedExpr":8,"ThisExpr":2,"MethodCallExpr":22},"statements":{"IfStmt":2,"BlockStmt":2,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":30},"text":"/**\n   * The constructor for this class has a bunch of arguments:  \n   * The frame argument is required for all printing in Java.\n   * The jobname appears left justified at the top of each printed page.\n   * The font size is specified in points, as on-screen font sizes are.\n   * The margins are specified in inches (or fractions of inches).\n   **/\npublic HardcopyWriter(Frame frame, String jobname, int fontsize, double leftmargin, double rightmargin, double topmargin, double bottommargin) throws HardcopyWriter.PrintCanceledException {\n    // Get the PrintJob object with which we'll do all the printing.\n    // The call is synchronized on the static printprops object, which \n    // means that only one print dialog can be popped up at a time.\n    // If the user clicks Cancel in the print dialog, throw an exception.\n    // get Toolkit from Frame\n    Toolkit toolkit = frame.getToolkit();\n    synchronized (printprops) {\n        job = toolkit.getPrintJob(frame, jobname, printprops);\n    }\n    if (job == null)\n        throw new PrintCanceledException(\"User cancelled print request\");\n    // query the page size\n    pagesize = job.getPageDimension();\n    // query the page resolution\n    pagedpi = job.getPageResolution();\n    // we've got to fake them.\n    if (System.getProperty(\"os.name\").regionMatches(true, 0, \"windows\", 0, 7)) {\n        // Use screen dpi, which is what the PrintJob tries to emulate, anyway\n        pagedpi = toolkit.getScreenResolution();\n        System.out.println(pagedpi);\n        // Assume a 8.5\" x 11\" page size.  A4 paper users have to change this.\n        pagesize = new Dimension((int) (8.5 * pagedpi), 11 * pagedpi);\n        System.out.println(pagesize);\n        // We also have to adjust the fontsize.  It is specified in points, \n        // (1 point = 1/72 of an inch) but Windows measures it in pixels.\n        fontsize = fontsize * pagedpi / 72;\n        System.out.println(fontsize);\n        System.out.flush();\n    }\n    // Compute coordinates of the upper-left corner of the page.\n    // I.e. the coordinates of (leftmargin, topmargin).  Also compute\n    // the width and height inside of the margins.\n    x0 = (int) (leftmargin * pagedpi);\n    y0 = (int) (topmargin * pagedpi);\n    width = pagesize.width - (int) ((leftmargin + rightmargin) * pagedpi);\n    height = pagesize.height - (int) ((topmargin + bottommargin) * pagedpi);\n    // Get body font and font size\n    font = new Font(\"Monospaced\", Font.PLAIN, fontsize);\n    metrics = toolkit.getFontMetrics(font);\n    lineheight = metrics.getHeight();\n    lineascent = metrics.getAscent();\n    // Assumes a monospaced font!\n    charwidth = metrics.charWidth('0');\n    // Now compute columns and lines will fit inside the margins\n    chars_per_line = width / charwidth;\n    lines_per_page = height / lineheight;\n    // Get header font information\n    // And compute baseline of page header: 1/8\" above the top margin\n    headerfont = new Font(\"SansSerif\", Font.ITALIC, fontsize);\n    headermetrics = toolkit.getFontMetrics(headerfont);\n    headery = y0 - (int) (0.125 * pagedpi) - headermetrics.getHeight() + headermetrics.getAscent();\n    // Compute the date/time string to display in the page header\n    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT);\n    df.setTimeZone(TimeZone.getDefault());\n    time = df.format(new Date());\n    // save name\n    this.jobname = jobname;\n    // save font size\n    this.fontsize = fontsize;\n}\n     // Bug Workaround:\n\n     // On windows, getPageDimension() and getPageResolution don't work, so\n\n","name":"HardcopyWriter","className":"HardcopyWriter","variables":{"df":3,"charwidth":2,"lineheight":2,"fontsize":5,"System":1,"rightmargin":1,"printprops":1,"y0":2,"pagesize":2,"jobname":1,"height":2,"chars_per_line":1,"lines_per_page":1,"lineascent":1,"leftmargin":2,"topmargin":2,"headery":1,"headermetrics":3,"TimeZone":1,"bottommargin":1,"pagedpi":10,"toolkit":5,"DateFormat":1,"x0":1,"width":2,"headerfont":1,"metrics":4,"time":1,"job":4,"frame":1,"font":1},"constants":{"11":1,"\"SansSerif\"":1,"\"Monospaced\"":1,"\"User cancelled print request\"":1,"0.125":1,"\"os.name\"":1,"0":2,"null":1,"7":1,"true":1,"\"windows\"":1,"72":1,"'0'":1,"8.5":1},"javaDoc":"The constructor for this class has a bunch of arguments: The frame argument is required for all printing in Java The jobname appears left justified at the top of each printed page The font size is specified in points as on-screen font sizes are The margins are specified in inches (or fractions of inches)","comments":"Get the PrintJob object with which we'll do all the printing The call is synchronized on the static printprops object which means that only one print dialog can be popped up at a time If the user clicks Cancel in the print dialog throw an exception Bug Workaround: On windows getPageDimension() and getPageResolution don't work so Compute coordinates of the upper-left corner of the page I e the coordinates of (leftmargin topmargin) Also compute Get header font information get Toolkit from Frame query the page size query the page resolution we've got to fake them We also have to adjust the fontsize It is specified in points Use screen dpi which is what the PrintJob tries to emulate anyway Assume a 8 5\" x 11\" page size A4 paper users have to change this (1 point = 1/72 of an inch) but Windows measures it in pixels the width and height inside of the margins Get body font and font size Assumes a monospaced font! Now compute columns and lines will fit inside the margins And compute baseline of page header: 1/8\" above the top margin Compute the date/time string to display in the page header save name save font size \n   * The constructor for this class has a bunch of arguments:  \n   * The frame argument is required for all printing in Java.\n   * The jobname appears left justified at the top of each printed page.\n   * The font size is specified in points, as on-screen font sizes are.\n   * The margins are specified in inches (or fractions of inches).\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"newline":3,"drawChars":1,"newpage":2,"isSpaceChar":2,"isWhitespace":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":7,"BinaryExpr":18,"NameExpr":63,"CharLiteralExpr":4,"UnaryExpr":5,"AssignExpr":3,"NullLiteralExpr":2,"BooleanLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":3,"ThisExpr":1,"MethodCallExpr":9},"statements":{"ContinueStmt":3,"IfStmt":9,"BlockStmt":6,"SynchronizedStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"/**\n   * This is the write() method of the stream.  All Writer subclasses \n   * implement this.  All other versions of write() are variants of this one\n   **/\npublic void write(char[] buffer, int index, int len) {\n    synchronized (this.lock) {\n        // Loop through all the characters passed to us\n        for (int i = index; i < index + len; i++) {\n            // If we haven't begun a page (or a new page), do that now.\n            if (page == null)\n                newpage();\n            // unless it is a \\n immediately after a \\r.\n            if (buffer[i] == '\\n') {\n                if (!last_char_was_return)\n                    newline();\n                continue;\n            }\n            if (buffer[i] == '\\r') {\n                newline();\n                last_char_was_return = true;\n                continue;\n            } else\n                last_char_was_return = false;\n            // If it some other non-printing character, ignore it.\n            if (Character.isWhitespace(buffer[i]) && !Character.isSpaceChar(buffer[i]) && (buffer[i] != '\\t'))\n                continue;\n            // If no more characters will fit on the line, start a new line.\n            if (charnum >= chars_per_line) {\n                newline();\n                // and start a new page, if necessary\n                if (page == null)\n                    newpage();\n            }\n            // printer uses we need to position each character individually.\n            if (Character.isSpaceChar(buffer[i]))\n                charnum++;\n            else if (buffer[i] == '\\t')\n                charnum += 8 - (charnum % 8);\n            else {\n                page.drawChars(buffer, i, 1, x0 + charnum * charwidth, y0 + (linenum * lineheight) + lineascent);\n                charnum++;\n            }\n        }\n    }\n}\n         // If the character is a line terminator, then begin new line, \n\n         // Now print the character:\n\n         // If it is a space, skip one space, without output.\n\n         // If it is a tab, skip the necessary number of spaces.\n\n         // Otherwise, print the character.\n\n         // It is inefficient to draw only one character at a time, but\n\n         // because our FontMetrics don't match up exactly to what the\n\n","name":"write","className":"HardcopyWriter","variables":{"chars_per_line":1,"lineascent":1,"last_char_was_return":3,"Character":3,"charwidth":1,"lineheight":1,"i":10,"index":2,"len":1,"y0":1,"x0":1,"linenum":1,"page":3,"buffer":7,"charnum":6},"constants":{"1":1,"null":2,"true":1,"false":1,"8":2,"'\\r'":1,"'\\t'":2,"'\\n'":1},"javaDoc":"This is the write() method of the stream All Writer subclasses implement this All other versions of write() are variants of this one","comments":"Loop through all the characters passed to us If the character is a line terminator then begin new line Now print the character: If it is a space skip one space without output If it is a tab skip the necessary number of spaces Otherwise print the character It is inefficient to draw only one character at a time but because our FontMetrics don't match up exactly to what the If we haven't begun a page (or a new page) do that now unless it is a \\n immediately after a \\r If it some other non-printing character ignore it If no more characters will fit on the line start a new line and start a new page if necessary printer uses we need to position each character individually \n   * This is the write() method of the stream.  All Writer subclasses \n   * implement this.  All other versions of write() are variants of this one\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n   * This is the flush() method that all Writer subclasses must implement.\n   * There is no way to flush a PrintJob without prematurely printing the\n   * page, so we don't do anything.\n   **/\npublic void flush() {\n/* do nothing */\n}\n","name":"flush","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"This is the flush() method that all Writer subclasses must implement There is no way to flush a PrintJob without prematurely printing the page so we don't do anything","comments":"do nothing  \n   * This is the flush() method that all Writer subclasses must implement.\n   * There is no way to flush a PrintJob without prematurely printing the\n   * page, so we don't do anything.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"dispose":1,"end":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":2},"text":"/**\n   * This is the close() method that all Writer subclasses must implement.\n   * Print the pending page (if any) and terminate the PrintJob.\n   */\npublic void close() {\n    synchronized (this.lock) {\n        // Send page to the printer\n        if (page != null)\n            page.dispose();\n        // Terminate the job\n        job.end();\n    }\n}\n","name":"close","className":"HardcopyWriter","variables":{"page":2,"job":1},"constants":{"null":1},"javaDoc":"This is the close() method that all Writer subclasses must implement Print the pending page (if any) and terminate the PrintJob","comments":"Send page to the printer Terminate the job \n   * This is the close() method that all Writer subclasses must implement.\n   * Print the pending page (if any) and terminate the PrintJob.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Font":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"SynchronizedStmt":1,"ExpressionStmt":4},"text":"/**\n   * Set the font style.  The argument should be one of the font style \n   * constants defined by the java.awt.Font class.  All subsequent output\n   * will be in that style.  This method relies on all styles of the\n   * Monospaced font having the same metrics.\n   **/\npublic void setFontStyle(int style) {\n    synchronized (this.lock) {\n        // Try to set a new font, but restore current one if it fails\n        Font current = font;\n        try {\n            font = new Font(\"Monospaced\", style, fontsize);\n        } catch (Exception e) {\n            font = current;\n        }\n        // If a page is pending, set the new font.  Otherwise newpage() will.\n        if (page != null)\n            page.setFont(font);\n    }\n}\n","name":"setFontStyle","className":"HardcopyWriter","variables":{"current":2,"e":1,"fontsize":1,"style":1,"page":2,"font":3},"constants":{"null":1,"\"Monospaced\"":1},"javaDoc":"Set the font style The argument should be one of the font style constants defined by the java awt Font class All subsequent output will be in that style This method relies on all styles of the Monospaced font having the same metrics","comments":"Try to set a new font but restore current one if it fails If a page is pending set the new font Otherwise newpage() will \n   * Set the font style.  The argument should be one of the font style \n   * constants defined by the java.awt.Font class.  All subsequent output\n   * will be in that style.  This method relies on all styles of the\n   * Monospaced font having the same metrics.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"newpage":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":1},"text":"/** End the current page.  Subsequent output will be on a new page. */\npublic void pageBreak() {\n    synchronized (this.lock) {\n        newpage();\n    }\n}\n","name":"pageBreak","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"End the current page Subsequent output will be on a new page","comments":" End the current page.  Subsequent output will be on a new page. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"FieldAccessExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of columns of characters that fit on the page */\npublic int getCharactersPerLine() {\n    return this.chars_per_line;\n}\n","name":"getCharactersPerLine","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"Return the number of columns of characters that fit on the page","comments":" Return the number of columns of characters that fit on the page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"FieldAccessExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of lines that fit on a page */\npublic int getLinesPerPage() {\n    return this.lines_per_page;\n}\n","name":"getLinesPerPage","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"Return the number of lines that fit on a page","comments":" Return the number of lines that fit on a page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/** This internal method begins a new line */\nprotected void newline() {\n    // Reset character number to 0\n    charnum = 0;\n    // Increment line number\n    linenum++;\n    if (linenum >= lines_per_page) {\n        // If we've reached the end of the page\n        //    send page to printer\n        page.dispose();\n        //    but don't start a new page yet.\n        page = null;\n    }\n}\n","name":"newline","className":"HardcopyWriter","variables":{"lines_per_page":1,"linenum":2,"page":2,"charnum":1},"constants":{"0":1,"null":1},"javaDoc":"This internal method begins a new line","comments":"Reset character number to 0 Increment line number If we've reached the end of the page send page to printer but don't start a new page yet  This internal method begins a new line ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"stringWidth":2,"getGraphics":1,"setFont":2,"drawLine":1,"getDescent":1,"drawString":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":10,"NameExpr":60,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":4,"MethodCallExpr":10},"statements":{"ExpressionStmt":14},"text":"/** This internal method begins a new page and prints the header. */\nprotected void newpage() {\n    // Begin the new page\n    page = job.getGraphics();\n    // Reset line and char number\n    linenum = 0;\n    // Reset line and char number\n    charnum = 0;\n    // Increment page number\n    pagenum++;\n    // Set the header font.\n    page.setFont(headerfont);\n    // Print job name left justified\n    page.drawString(jobname, x0, headery);\n    // Print the page number centered.\n    String s = \"- \" + pagenum + \" -\";\n    int w = headermetrics.stringWidth(s);\n    page.drawString(s, x0 + (this.width - w) / 2, headery);\n    // Print date right justified\n    w = headermetrics.stringWidth(time);\n    page.drawString(time, x0 + width - w, headery);\n    // Draw a line beneath the header\n    int y = headery + headermetrics.getDescent() + 1;\n    page.drawLine(x0, y, x0 + width, y);\n    // Set the basic monospaced font for the rest of the page.\n    page.setFont(font);\n}\n","name":"newpage","className":"HardcopyWriter","variables":{"headermetrics":3,"s":1,"w":4,"x0":3,"width":2,"linenum":1,"y":1,"page":7,"headery":1,"job":1,"pagenum":2,"charnum":1},"constants":{"0":2,"1":1,"2":1,"\" -\"":1,"\"- \"":1},"javaDoc":"This internal method begins a new page and prints the header","comments":"Begin the new page Reset line and char number Reset line and char number Increment page number Set the header font Print job name left justified Print the page number centered Print date right justified Draw a line beneath the header Set the basic monospaced font for the rest of the page  This internal method begins a new page and prints the header. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"PrintCanceledException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public PrintCanceledException(String msg) {\n    super(msg);\n}\n","name":"PrintCanceledException","className":"PrintCanceledException","variables":{"msg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"exit":3,"setSize":1,"read":1,"show":1,"System.err.println":2,"write":1,"close":1},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"Frame":1,"FileReader":1,"HardcopyWriter":1,"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":13,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":50,"StringLiteralExpr":3,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"DoubleLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ExpressionStmt":16},"text":"public static void main(String[] args) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        FileReader in = new FileReader(args[0]);\n        HardcopyWriter out = null;\n        Frame f = new Frame(\"PrintFile: \" + args[0]);\n        f.setSize(200, 50);\n        f.show();\n        try {\n            out = new HardcopyWriter(f, args[0], 10, .75, .75, .75, .75);\n        } catch (HardcopyWriter.PrintCanceledException e) {\n            System.exit(0);\n        }\n        f.setVisible(false);\n        char[] buffer = new char[4096];\n        int numchars;\n        while ((numchars = in.read(buffer)) != -1) out.write(buffer, 0, numchars);\n        out.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java HardcopyWriter$PrintFile <filename>\");\n        System.exit(1);\n    }\n    System.exit(0);\n}\n","name":"main","className":"PrintFile","variables":{"args":3,"in":2,"e":2,"f":5,"numchars":2,"buffer":1,"System":3,"out":4},"constants":{"0":6,"1":3,"4096":1,"200":1,"null":1,"\"PrintFile: \"":1,"\"Wrong number of arguments\"":1,"false":1,"\"Usage: java HardcopyWriter$PrintFile <filename>\"":1,"50":1,".75":4,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Frame":1,"Demo":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** The main method of the program.  Create a test window and display it */\npublic static void main(String[] args) {\n    Frame f = new Demo();\n    f.show();\n}\n","name":"main","className":"Demo","variables":{"f":2},"constants":{},"javaDoc":"The main method of the program Create a test window and display it","comments":" The main method of the program.  Create a test window and display it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Demo","methodCalls":{"add":2,"addActionListener":2,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":5,"NameExpr":27,"FieldAccessExpr":1,"ThisExpr":4,"MethodCallExpr":7,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":10},"text":"/** Constructor for the test program's window. */\npublic Demo() {\n    // Call frame constructor\n    super(\"HardcopyWriter Test\");\n    // Add a panel to the frame\n    Panel p = new Panel();\n    // Center it\n    this.add(p, \"Center\");\n    p.setFont(new // Set a default font\n    Font(// Set a default font\n    \"SansSerif\", Font.BOLD, 18));\n    // Create a Print button\n    print = new Button(\"Print Test Page\");\n    // Create a Quit button\n    quit = new Button(\"Quit\");\n    // Specify that we'll handle\n    print.addActionListener(this);\n    //   button presses\n    quit.addActionListener(this);\n    // Add the buttons to the panel\n    p.add(print);\n    p.add(quit);\n    // Set the size of everything\n    this.pack();\n}\n","name":"Demo","className":"Demo","variables":{"p":4,"print":2,"quit":2},"constants":{"\"Quit\"":1,"\"HardcopyWriter Test\"":1,"18":1,"\"Center\"":1,"\"Print Test Page\"":1},"javaDoc":"Constructor for the test program's window","comments":"Call frame constructor Add a panel to the frame Center it Set a default font Set a default font Create a Print button Create a Quit button Specify that we'll handle button presses Add the buttons to the panel Set the size of everything  Constructor for the test program's window. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"getSource":1,"printDemoPage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":12,"MethodCallExpr":3},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"/** Handle the button presses */\npublic void actionPerformed(ActionEvent e) {\n    Object o = e.getSource();\n    if (o == quit)\n        System.exit(0);\n    else if (o == print)\n        printDemoPage();\n}\n","name":"actionPerformed","className":"Demo","variables":{"print":1,"e":1,"quit":1,"System":1,"o":3},"constants":{"0":1},"javaDoc":"Handle the button presses","comments":" Handle the button presses ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":6,"println":19,"getCharactersPerLine":1,"getLinesPerPage":1,"close":1,"setFontStyle":8},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException"],"concepts":["ExceptionHandling"],"types":{"int[]":1,"HardcopyWriter":1,"int":5,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":8,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":17,"NameExpr":186,"StringLiteralExpr":26,"UnaryExpr":4,"AssignExpr":1,"DoubleLiteralExpr":4,"ArrayInitializerExpr":1,"FieldAccessExpr":21,"ThisExpr":1,"MethodCallExpr":36},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":4,"ExpressionStmt":39},"text":"/** Print the demo page */\npublic void printDemoPage() {\n    // Create the HardcopyWriter, using a 10 point font and 3/4\" margins.\n    HardcopyWriter hw;\n    try {\n        hw = new HardcopyWriter(this, \"Demo Page\", 14, .75, .75, .75, .75);\n    } catch (HardcopyWriter.PrintCanceledException e) {\n        return;\n    }\n    // Send output to it through a PrintWriter stream\n    PrintWriter out = new PrintWriter(hw);\n    // Figure out the size of the page\n    int rows = hw.getLinesPerPage(), cols = hw.getCharactersPerLine();\n    // Mark upper left and upper-right corners\n    out.print(\"+\");\n    for (int i = 0; i < cols - 2; i++) out.print(\" \");\n    out.print(\"+\");\n    // Display a title\n    hw.setFontStyle(Font.BOLD + Font.ITALIC);\n    out.println(\"\\n\\n\\n\\t\\tHardcopy Writer Demo Page\\n\\n\\n\\n\\n\");\n    // Demonstrate font styles\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Font Styles:\");\n    int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC, Font.ITALIC + Font.BOLD };\n    for (int i = 0; i < styles.length; i++) {\n        hw.setFontStyle(styles[i]);\n        out.println(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\");\n        out.println(\"1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\\\`'\\\"_~|\");\n    }\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"\\n\\n\");\n    // Demonstrate tab stops\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Tab Stops:\");\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"          1         2         3         4         5\");\n    out.println(\"01234567890123456789012345678901234567890123456789012345\");\n    out.println(\"^\\t^\\t^\\t^\\t^\\t^\\t^\");\n    out.println(\"\\n\\n\");\n    // Output some information about page dimensions and resolution\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Dimensions:\");\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"\\tResolution: \" + hw.pagedpi + \" dots per inch\");\n    out.println(\"\\tPage width (pixels): \" + hw.pagesize.width);\n    out.println(\"\\tPage height (pixels): \" + hw.pagesize.height);\n    out.println(\"\\tWidth inside margins (pixels): \" + hw.width);\n    out.println(\"\\tHeight inside margins (pixels): \" + hw.height);\n    out.println(\"\\tCharacters per line: \" + cols);\n    out.println(\"\\tLines per page: \" + rows);\n    // Skip down to the bottom of the page\n    for (int i = 0; i < rows - 37; i++) out.println();\n    // And mark the lower left and lower right\n    out.print(\"+\");\n    for (int i = 0; i < cols - 2; i++) out.print(\" \");\n    out.print(\"+\");\n    // Close the output stream, forcing the page to be printed\n    out.close();\n}\n","name":"printDemoPage","className":"Demo","variables":{"e":1,"i":13,"styles":2,"rows":3,"cols":4,"hw":13,"out":27},"constants":{"\"Font Styles:\"":1,"\"^\\t^\\t^\\t^\\t^\\t^\\t^\"":1,"\"\\tPage width (pixels): \"":1,"\"\\tResolution: \"":1,"\"\\tPage height (pixels): \"":1,"\"\\tCharacters per line: \"":1,".75":4,"\"\\n\\n\"":2,"\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"":1,"\"Tab Stops:\"":1,"\"Demo Page\"":1,"\"\\tLines per page: \"":1,"\"01234567890123456789012345678901234567890123456789012345\"":1,"14":1,"\"\\n\\n\\n\\t\\tHardcopy Writer Demo Page\\n\\n\\n\\n\\n\"":1,"\" \"":2,"\"          1         2         3         4         5\"":1,"\"Dimensions:\"":1,"37":1,"\"\\tHeight inside margins (pixels): \"":1,"\"\\tWidth inside margins (pixels): \"":1,"0":4,"\" dots per inch\"":1,"2":2,"\"1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\\\`'\\\"_~|\"":1,"\"+\"":4},"javaDoc":"Print the demo page","comments":"Create the HardcopyWriter using a 10 point font and 3/4\" margins Send output to it through a PrintWriter stream Figure out the size of the page Mark upper left and upper-right corners Display a title Demonstrate font styles Demonstrate tab stops Output some information about page dimensions and resolution Skip down to the bottom of the page And mark the lower left and lower right Close the output stream forcing the page to be printed  Print the demo page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    // Initialize the loop variable\n    int i = 0;\n    while (i < args.length) {\n        // Loop until we reach end of array\n        // Print each argument out\n        System.out.print(args[i] + \" \");\n        // Increment the loop variable\n        i++;\n    }\n    // Terminate the line\n    System.out.println();\n}\n","name":"main","className":"Echo","variables":{"args":1,"i":4},"constants":{"0":1,"\" \"":1},"javaDoc":"","comments":"Initialize the loop variable Loop until we reach end of array Print each argument out Increment the loop variable Terminate the line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","int","int"],"returnType":"MultiLineLabel","methodCalls":{"newLabel":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":14,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":5},"text":"// Here are five versions of the constructor\npublic MultiLineLabel(String label, int margin_width, int margin_height, int alignment) {\n    // Remember all the properties\n    this.label = label;\n    this.margin_width = margin_width;\n    this.margin_height = margin_height;\n    this.alignment = alignment;\n    // Break the label up into lines\n    newLabel();\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"label":1,"alignment":1,"margin_width":1},"constants":{},"javaDoc":"","comments":"Remember all the properties Break the label up into lines  Here are five versions of the constructor","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","int"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, int margin_width, int margin_height) {\n    this(label, margin_width, margin_height, LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"LEFT":1,"label":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, int alignment) {\n    this(label, 10, 10, alignment);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"label":1,"alignment":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label) {\n    this(label, 10, 10, LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"LEFT":1,"label":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel() {\n    this(\"\");\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"newLabel":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"// Methods to set and query the various attributes of the component\n// Note that some query methods are inherited from the superclass.\npublic void setLabel(String label) {\n    this.label = label;\n    // Break the label into lines\n    newLabel();\n    // Note that we need to measure lines\n    measured = false;\n    // Request a redraw\n    repaint();\n}\n","name":"setLabel","className":"MultiLineLabel","variables":{"measured":1,"label":1},"constants":{"false":1},"javaDoc":"","comments":"Break the label into lines Note that we need to measure lines Request a redraw  Note that some query methods are inherited from the superclass.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public void setFont(Font f) {\n    // tell our superclass about the new font\n    super.setFont(f);\n    // Note that we need to remeasure lines\n    measured = false;\n    // Request a redraw\n    repaint();\n}\n","name":"setFont","className":"MultiLineLabel","variables":{"measured":1},"constants":{"false":1},"javaDoc":"","comments":"tell our superclass about the new font Note that we need to remeasure lines Request a redraw ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void setForeground(Color c) {\n    // tell our superclass about the new color\n    super.setForeground(c);\n    // Request a redraw (size is unchanged)\n    repaint();\n}\n","name":"setForeground","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"","comments":"tell our superclass about the new color Request a redraw (size is unchanged) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setAlignment(int a) {\n    alignment = a;\n    repaint();\n}\n","name":"setAlignment","className":"MultiLineLabel","variables":{"a":1,"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginWidth(int mw) {\n    margin_width = mw;\n    repaint();\n}\n","name":"setMarginWidth","className":"MultiLineLabel","variables":{"mw":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginHeight(int mh) {\n    margin_height = mh;\n    repaint();\n}\n","name":"setMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1,"mh":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getLabel() {\n    return label;\n}\n","name":"getLabel","className":"MultiLineLabel","variables":{"label":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAlignment() {\n    return alignment;\n}\n","name":"getAlignment","className":"MultiLineLabel","variables":{"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginWidth() {\n    return margin_width;\n}\n","name":"getMarginWidth","className":"MultiLineLabel","variables":{"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginHeight() {\n    return margin_height;\n}\n","name":"getMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":8,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This method is called by a layout manager when it wants to\n   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n   * the preferred version of this method.  We use this deprecated version\n   * so that this component can interoperate with 1.0 components.\n   */\npublic Dimension preferredSize() {\n    if (!measured)\n        measure();\n    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);\n}\n","name":"preferredSize","className":"MultiLineLabel","variables":{"max_width":1,"margin_height":1,"measured":1,"line_height":1,"margin_width":1,"num_lines":1},"constants":{"2":2},"javaDoc":"This method is called by a layout manager when it wants to know how big we'd like to be In Java 1 1 getPreferredSize() is the preferred version of this method We use this deprecated version so that this component can interoperate with 1 0 components","comments":"\n   * This method is called by a layout manager when it wants to\n   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n   * the preferred version of this method.  We use this deprecated version\n   * so that this component can interoperate with 1.0 components.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"preferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n   * This method is called when the layout manager wants to know\n   * the bare minimum amount of space we need to get by.\n   * For Java 1.1, we'd use getMinimumSize().\n   */\npublic Dimension minimumSize() {\n    return preferredSize();\n}\n","name":"minimumSize","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"This method is called when the layout manager wants to know the bare minimum amount of space we need to get by For Java 1 1 we'd use getMinimumSize()","comments":"\n   * This method is called when the layout manager wants to know\n   * the bare minimum amount of space we need to get by.\n   * For Java 1.1, we'd use getMinimumSize().\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"measure":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":9,"NameExpr":43,"FieldAccessExpr":3,"EnclosedExpr":2,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":5},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":4,"ForStmt":1,"ExpressionStmt":8},"text":"/**\n   * This method draws the label (same method that applets use).\n   * Note that it handles the margins and the alignment, but that\n   * it doesn't have to worry about the color or font--the superclass\n   * takes care of setting those in the Graphics object we're passed.\n   */\npublic void paint(Graphics g) {\n    int x, y;\n    // use getSize() in Java 1.1\n    Dimension size = this.size();\n    if (!measured)\n        measure();\n    y = line_ascent + (size.height - num_lines * line_height) / 2;\n    for (int i = 0; i < num_lines; i++, y += line_height) {\n        switch(alignment) {\n            default:\n            case LEFT:\n                x = margin_width;\n                break;\n            case CENTER:\n                x = (size.width - line_widths[i]) / 2;\n                break;\n            case RIGHT:\n                x = size.width - margin_width - line_widths[i];\n                break;\n        }\n        g.drawString(lines[i], x, y);\n    }\n}\n","name":"paint","className":"MultiLineLabel","variables":{"measured":1,"LEFT":1,"g":1,"line_widths":2,"i":6,"CENTER":1,"line_height":2,"size":1,"line_ascent":1,"x":4,"y":3,"RIGHT":1,"alignment":1,"lines":1,"num_lines":2,"margin_width":2},"constants":{"0":1,"2":2},"javaDoc":"This method draws the label (same method that applets use) Note that it handles the margins and the alignment but that it doesn't have to worry about the color or font--the superclass takes care of setting those in the Graphics object we're passed","comments":"use getSize() in Java 1 1 \n   * This method draws the label (same method that applets use).\n   * Note that it handles the margins and the alignment, but that\n   * it doesn't have to worry about the color or font--the superclass\n   * takes care of setting those in the Graphics object we're passed.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"countTokens":1,"nextToken":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"StringTokenizer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":1,"ArrayCreationExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":5},"text":"/** This internal method breaks a specified label up into an array of lines.\n   *  It uses the StringTokenizer utility class. */\nprotected synchronized void newLabel() {\n    StringTokenizer t = new StringTokenizer(label, \"\\n\");\n    num_lines = t.countTokens();\n    lines = new String[num_lines];\n    line_widths = new int[num_lines];\n    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();\n}\n","name":"newLabel","className":"MultiLineLabel","variables":{"t":3,"line_widths":1,"i":4,"label":1,"lines":2,"num_lines":4},"constants":{"0":1,"\"\\n\"":1},"javaDoc":"This internal method breaks a specified label up into an array of lines It uses the StringTokenizer utility class","comments":" This internal method breaks a specified label up into an array of lines.\n   *  It uses the StringTokenizer utility class. ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":[],"returnType":"void","methodCalls":{"getFontMetrics":1,"getAscent":1,"stringWidth":1,"getHeight":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"FontMetrics":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":6,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"/** This internal method figures out how the font is, and how wide each\n   *  line of the label is, and how wide the widest line is. */\nprotected synchronized void measure() {\n    FontMetrics fm = this.getToolkit().getFontMetrics(this.getFont());\n    line_height = fm.getHeight();\n    line_ascent = fm.getAscent();\n    max_width = 0;\n    for (int i = 0; i < num_lines; i++) {\n        line_widths[i] = fm.stringWidth(lines[i]);\n        if (line_widths[i] > max_width)\n            max_width = line_widths[i];\n    }\n    measured = true;\n}\n","name":"measure","className":"MultiLineLabel","variables":{"max_width":3,"measured":1,"line_height":1,"fm":4,"line_ascent":1,"line_widths":3,"i":7,"lines":1,"num_lines":1},"constants":{"0":2,"true":1},"javaDoc":"This internal method figures out how the font is and how wide each line of the label is and how wide the widest line is","comments":" This internal method figures out how the font is, and how wide each\n   *  line of the label is, and how wide the widest line is. ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["Reader","String"],"returnType":"GrepReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** Pass the stream to our superclass, and remember the pattern ourself */\npublic GrepReader(Reader in, String pattern) {\n    super(in);\n    this.pattern = pattern;\n}\n","name":"GrepReader","className":"GrepReader","variables":{"in":1,"pattern":1},"constants":{},"javaDoc":"Pass the stream to our superclass and remember the pattern ourself","comments":" Pass the stream to our superclass, and remember the pattern ourself ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"indexOf":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":3,"NameExpr":9,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2,"DoStmt":1},"text":"/**\n   * This is the filter: call our superclass's readLine() to get the\n   * actual lines, but only return lines that contain the pattern.\n   * When the superclass readLine() returns null (EOF), we return null.\n   **/\npublic final String readLine() throws IOException {\n    String line;\n    do {\n        line = super.readLine();\n    } while ((line != null) && line.indexOf(pattern) == -1);\n    return line;\n}\n","name":"readLine","className":"GrepReader","variables":{"line":5},"constants":{"1":1,"null":1},"javaDoc":"This is the filter: call our superclass's readLine() to get the actual lines but only return lines that contain the pattern When the superclass readLine() returns null (EOF) we return null","comments":"\n   * This is the filter: call our superclass's readLine() to get the\n   * actual lines, but only return lines that contain the pattern.\n   * When the superclass readLine() returns null (EOF), we return null.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":17}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.err.println":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"GrepReader":1,"String":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":29,"StringLiteralExpr":2,"FieldAccessExpr":4,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":6},"text":"public static void main(String args[]) {\n    try {\n        if (args.length != 2)\n            throw new IllegalArgumentException(\"Wrong number of arguments\");\n        GrepReader in = new GrepReader(new FileReader(args[1]), args[0]);\n        String line;\n        while ((line = in.readLine()) != null) System.out.println(line);\n        in.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.out.println(\"Usage: java GrepReader$Test <pattern> <file>\");\n    }\n}\n","name":"main","className":"Test","variables":{"args":2,"in":3,"e":1,"line":2},"constants":{"0":1,"1":1,"2":1,"null":1,"\"Wrong number of arguments\"":1,"\"Usage: java GrepReader$Test <pattern> <file>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void yes(AnswerEvent e);\n","name":"yes","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void no(AnswerEvent e);\n","name":"no","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void cancel(AnswerEvent e);\n","name":"cancel","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"getCancelLabel":1,"add":3,"setSize":1,"getYesLabel":1,"getMessage":1,"setLayout":2,"getNoLabel":1,"addTextListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":2,"String[]":2,"int":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":9,"VariableDeclarationExpr":5,"ArrayAccessExpr":5,"BinaryExpr":1,"NameExpr":62,"StringLiteralExpr":9,"UnaryExpr":1,"AssignExpr":4,"ArrayInitializerExpr":2,"CastExpr":1,"ArrayCreationExpr":3,"ThisExpr":6,"MethodCallExpr":16},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":20},"text":"// Default constructor: YesNoDialogCustomizer() { super(); }\n// The bean box calls this method to tell us what object to customize.\n// This method will always be called before the customizer is displayed,\n// so it is safe to create the customizer GUI here.\npublic void setObject(Object o) {\n    // save the object we're customizing\n    bean = (YesNoDialog) o;\n    // Put a label at the top of the panel.\n    this.setLayout(new BorderLayout());\n    this.add(new Label(\"Enter the message to appear in the dialog:\"), \"North\");\n    // And a big text area below it for entering the dialog message.\n    message = new TextArea(bean.getMessage());\n    message.addTextListener(this);\n    // TextAreas don't know how big they want to be.  You must tell them.\n    message.setSize(400, 200);\n    this.add(message, \"Center\");\n    // Then add a row of textfields for entering the button labels.\n    // The row container\n    Panel buttonbox = new Panel();\n    // Equally spaced items\n    buttonbox.setLayout(new GridLayout(1, 0, 25, 10));\n    // Put row on bottom\n    this.add(buttonbox, \"South\");\n    // Now go create three TextFields to put in this row.  But actually\n    // position a Label above each, so create an container for each\n    // TextField+Label combination.\n    // Array of TextFields.\n    fields = new TextComponent[3];\n    String[] labels = new String[] { // Labels for each.\n    \"Yes Button Label\", \"No Button Label\", \"Cancel Button Label\" };\n    String[] values = new String[] { // Initial values of each.\n    bean.getYesLabel(), bean.getNoLabel(), bean.getCancelLabel() };\n    for (int i = 0; i < 3; i++) {\n        // Create a container.\n        Panel p = new Panel();\n        // Give it a BorderLayout.\n        p.setLayout(new BorderLayout());\n        // Put a label on the top.\n        p.add(new Label(labels[i]), \"North\");\n        // Create the text field.\n        fields[i] = new TextField(values[i]);\n        // Put it below the label.\n        p.add(fields[i], \"Center\");\n        // Set the event listener.\n        fields[i].addTextListener(this);\n        // Add container to row.\n        buttonbox.add(p);\n    }\n}\n","name":"setObject","className":"YesNoDialogCustomizer","variables":{"p":4,"values":2,"buttonbox":3,"i":8,"message":3,"fields":4,"bean":5,"o":1,"labels":2},"constants":{"\"North\"":2,"\"Enter the message to appear in the dialog:\"":1,"25":1,"\"Cancel Button Label\"":1,"\"Center\"":2,"0":2,"1":1,"200":1,"3":2,"400":1,"\"No Button Label\"":1,"\"South\"":1,"10":1},"javaDoc":"","comments":"Then add a row of textfields for entering the button labels Now go create three TextFields to put in this row But actually position a Label above each so create an container for each TextField+Label combination save the object we're customizing Put a label at the top of the panel And a big text area below it for entering the dialog message TextAreas don't know how big they want to be You must tell them The row container Equally spaced items Put row on bottom Array of TextFields Labels for each Initial values of each Create a container Give it a BorderLayout Put a label on the top Create the text field Put it below the label Set the event listener Add container to row  so it is safe to create the customizer GUI here.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Insets","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"// Add some space around the outside of the panel.\npublic Insets getInsets() {\n    return new Insets(10, 10, 10, 10);\n}\n","name":"getInsets","className":"YesNoDialogCustomizer","variables":{},"constants":{"10":4},"javaDoc":"","comments":" Add some space around the outside of the panel.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TextEvent"],"returnType":"void","methodCalls":{"setCancelLabel":1,"setNoLabel":1,"firePropertyChange":1,"getSource":1,"getText":1,"setMessage":1,"setYesLabel":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"TextComponent":1,"String":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":4,"CastExpr":1,"NameExpr":33,"MethodCallExpr":7},"statements":{"IfStmt":4,"ExpressionStmt":7},"text":"// This is the method defined by the TextListener interface.  Whenever the\n// user types a character in the TextArea or TextFields, this will get\n// called.  It updates the appropriate property of the bean and fires a\n// property changed event, as all customizers are required to do.\n// Note that we are not required to fire an event for every keystroke.\n// Instead we could include an \"Apply\" button that would make all the\n// changes at once, with a single property changed event.\npublic void textValueChanged(TextEvent e) {\n    TextComponent t = (TextComponent) e.getSource();\n    String s = t.getText();\n    if (t == message)\n        bean.setMessage(s);\n    else if (t == fields[0])\n        bean.setYesLabel(s);\n    else if (t == fields[1])\n        bean.setNoLabel(s);\n    else if (t == fields[2])\n        bean.setCancelLabel(s);\n    listeners.firePropertyChange(null, null, null);\n}\n","name":"textValueChanged","className":"YesNoDialogCustomizer","variables":{"s":1,"t":6,"listeners":1,"e":1,"message":1,"fields":3,"bean":4},"constants":{"0":1,"1":1,"2":1,"null":3},"javaDoc":"","comments":" changes at once, with a single property changed event.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"addPropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addPropertyChangeListener(PropertyChangeListener l) {\n    listeners.addPropertyChangeListener(l);\n}\n","name":"addPropertyChangeListener","className":"YesNoDialogCustomizer","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"removePropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void removePropertyChangeListener(PropertyChangeListener l) {\n    listeners.removePropertyChangeListener(l);\n}\n","name":"removePropertyChangeListener","className":"YesNoDialogCustomizer","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","int"],"returnType":"AnswerEvent","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public AnswerEvent(Object source, int id) {\n    super(source);\n    this.id = id;\n}\n","name":"AnswerEvent","className":"AnswerEvent","variables":{"source":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getID() {\n    return id;\n}\n","name":"getID","className":"AnswerEvent","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Image","methodCalls":{"loadImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return an icon for the bean.  We should really check the kind argument\n   *  to see what size icon the beanbox wants, but since we only have one\n   *  icon to offer, we just return it and let the beanbox deal with it */\npublic Image getIcon(int kind) {\n    return loadImage(\"YesNoDialogIcon.gif\");\n}\n","name":"getIcon","className":"YesNoDialogBeanInfo","variables":{},"constants":{"\"YesNoDialogIcon.gif\"":1},"javaDoc":"Return an icon for the bean We should really check the kind argument to see what size icon the beanbox wants but since we only have one icon to offer we just return it and let the beanbox deal with it","comments":" Return an icon for the bean.  We should really check the kind argument\n   *  to see what size icon the beanbox wants, but since we only have one\n   *  icon to offer, we just return it and let the beanbox deal with it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BeanDescriptor","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ClassExpr":2},"statements":{"ReturnStmt":1},"text":"/** Return a descriptor for the bean itself.  It specifies a customizer\n   *  for the bean class.  We could also add a description string here */\npublic BeanDescriptor getBeanDescriptor() {\n    return new BeanDescriptor(YesNoDialog.class, YesNoDialogCustomizer.class);\n}\n","name":"getBeanDescriptor","className":"YesNoDialogBeanInfo","variables":{},"constants":{},"javaDoc":"Return a descriptor for the bean itself It specifies a customizer for the bean class We could also add a description string here","comments":" Return a descriptor for the bean itself.  It specifies a customizer\n   *  for the bean class.  We could also add a description string here ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"PropertyDescriptor","methodCalls":{"setShortDescription":1},"annotations":[],"exceptions":["IntrospectionException"],"concepts":[],"types":{"PropertyDescriptor":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"ClassExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** This is a convenience routine for creating PropertyDescriptor objects */\npublic static PropertyDescriptor property(String name, String description) throws IntrospectionException {\n    PropertyDescriptor p = new PropertyDescriptor(name, YesNoDialog.class);\n    p.setShortDescription(description);\n    return p;\n}\n","name":"property","className":"YesNoDialogBeanInfo","variables":{"p":3,"name":1},"constants":{},"javaDoc":"This is a convenience routine for creating PropertyDescriptor objects","comments":" This is a convenience routine for creating PropertyDescriptor objects ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"PropertyDescriptor[]","methodCalls":{"property":9},"annotations":[],"exceptions":["IntrospectionException"],"concepts":["ExceptionHandling"],"types":{"PropertyDescriptor[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"SuperExpr":1,"ArrayInitializerExpr":1,"ArrayAccessExpr":2,"NameExpr":27,"StringLiteralExpr":18,"ClassExpr":2,"MethodCallExpr":12},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** This method returns an array of PropertyDescriptor objects that specify\n   *  additional information about the properties supported by the bean.\n   *  By explicitly specifying property descriptors, we are able to provide\n   *  simple help strings for each property; these would not be available to\n   *  the beanbox through simple introspection.  We are also able to register\n   *  special property editors for two of the properties\n   */\npublic PropertyDescriptor[] getPropertyDescriptors() {\n    try {\n        PropertyDescriptor[] props = { property(\"title\", \"The string that appears in the dialog title bar\"), property(\"message\", \"The string that appears in the dialog body\"), property(\"yesLabel\", \"The label for the 'Yes' button, if any\"), property(\"noLabel\", \"The label for the 'No' button, if any\"), property(\"cancelLabel\", \"The label for the 'Cancel' button, if any\"), property(\"alignment\", \"The alignment of the message text\"), property(\"font\", \"The font to use for message and buttons\"), property(\"background\", \"The background color for the dialog\"), property(\"foreground\", \"The text color for message and buttons\") };\n        props[1].setPropertyEditorClass(YesNoDialogMessageEditor.class);\n        props[5].setPropertyEditorClass(YesNoDialogAlignmentEditor.class);\n        return props;\n    } catch (IntrospectionException e) {\n        return super.getPropertyDescriptors();\n    }\n}\n","name":"getPropertyDescriptors","className":"YesNoDialogBeanInfo","variables":{"e":1,"props":4},"constants":{"\"yesLabel\"":1,"\"foreground\"":1,"\"The text color for message and buttons\"":1,"\"The label for the 'Cancel' button, if any\"":1,"\"font\"":1,"\"title\"":1,"\"The string that appears in the dialog body\"":1,"\"The font to use for message and buttons\"":1,"\"The label for the 'Yes' button, if any\"":1,"\"noLabel\"":1,"\"The alignment of the message text\"":1,"\"The string that appears in the dialog title bar\"":1,"1":1,"\"alignment\"":1,"5":1,"\"message\"":1,"\"background\"":1,"\"The label for the 'No' button, if any\"":1,"\"The background color for the dialog\"":1,"\"cancelLabel\"":1},"javaDoc":"This method returns an array of PropertyDescriptor objects that specify additional information about the properties supported by the bean By explicitly specifying property descriptors we are able to provide simple help strings for each property; these would not be available to the beanbox through simple introspection We are also able to register special property editors for two of the properties","comments":" This method returns an array of PropertyDescriptor objects that specify\n   *  additional information about the properties supported by the bean.\n   *  By explicitly specifying property descriptors, we are able to provide\n   *  simple help strings for each property; these would not be available to\n   *  the beanbox through simple introspection.  We are also able to register\n   *  special property editors for two of the properties\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** The message property is most often customized; make it the default */\npublic int getDefaultPropertyIndex() {\n    return 1;\n}\n","name":"getDefaultPropertyIndex","className":"YesNoDialogBeanInfo","variables":{},"constants":{"1":1},"javaDoc":"The message property is most often customized; make it the default","comments":" The message property is most often customized; make it the default ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"MethodDescriptor","methodCalls":{"setShortDescription":1},"annotations":[],"exceptions":["SecurityException","NoSuchMethodException"],"concepts":[],"types":{"Method":1,"MethodDescriptor":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"NameExpr":9,"ClassExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":3},"text":"/** This is a convenience method for creating MethodDescriptors.  Note that\n   *  it assumes we are talking about methods with no arguments */\npublic static MethodDescriptor method(String name, String description) throws NoSuchMethodException, SecurityException {\n    Method m = YesNoDialog.class.getMethod(name, new Class[] {});\n    MethodDescriptor md = new MethodDescriptor(m);\n    md.setShortDescription(description);\n    return md;\n}\n","name":"method","className":"YesNoDialogBeanInfo","variables":{"md":3,"m":2},"constants":{},"javaDoc":"This is a convenience method for creating MethodDescriptors Note that it assumes we are talking about methods with no arguments","comments":" This is a convenience method for creating MethodDescriptors.  Note that\n   *  it assumes we are talking about methods with no arguments ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"MethodDescriptor[]","methodCalls":{"method":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"MethodDescriptor[]":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"ArrayInitializerExpr":1,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** This method returns an array of method descriptors for the supported\n   *  methods of a bean. This allows us to provide useful description strings,\n   *  but it also allows us to filter out non-useful methods like wait()\n   *  and notify() that the bean inherits and which might otherwise be\n   *  displayed by the beanbox.\n   */\npublic MethodDescriptor[] getMethodDescriptors() {\n    try {\n        MethodDescriptor[] methods = { method(\"display\", \"Pop up the dialog; make it visible\") };\n        return methods;\n    } catch (Exception e) {\n        return super.getMethodDescriptors();\n    }\n}\n","name":"getMethodDescriptors","className":"YesNoDialogBeanInfo","variables":{"e":1,"methods":2},"constants":{"\"display\"":1,"\"Pop up the dialog; make it visible\"":1},"javaDoc":"This method returns an array of method descriptors for the supported methods of a bean This allows us to provide useful description strings but it also allows us to filter out non-useful methods like wait() and notify() that the bean inherits and which might otherwise be displayed by the beanbox","comments":" This method returns an array of method descriptors for the supported\n   *  methods of a bean. This allows us to provide useful description strings,\n   *  but it also allows us to filter out non-useful methods like wait()\n   *  and notify() that the bean inherits and which might otherwise be\n   *  displayed by the beanbox.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayInitializerExpr":1,"StringLiteralExpr":3,"ArrayCreationExpr":1},"statements":{"ReturnStmt":1},"text":"// These two methods allow the property to be edited in a dropdown list.\n// Return the list of value names for the enumerated type.\npublic String[] getTags() {\n    return new String[] { \"left\", \"center\", \"right\" };\n}\n","name":"getTags","className":"YesNoDialogAlignmentEditor","variables":{},"constants":{"\"center\"":1,"\"right\"":1,"\"left\"":1},"javaDoc":"","comments":" Return the list of value names for the enumerated type.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"equals":3,"setValue":3},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":25,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":3,"ThrowStmt":1,"ExpressionStmt":3},"text":"// Convert each of those value names into the actual value.\npublic void setAsText(String s) {\n    if (s.equals(\"left\"))\n        setValue(new Integer(YesNoDialog.LEFT));\n    else if (s.equals(\"center\"))\n        setValue(new Integer(YesNoDialog.CENTER));\n    else if (s.equals(\"right\"))\n        setValue(new Integer(YesNoDialog.RIGHT));\n    else\n        throw new IllegalArgumentException(s);\n}\n","name":"setAsText","className":"YesNoDialogAlignmentEditor","variables":{"s":4},"constants":{"\"center\"":1,"\"right\"":1,"\"left\"":1},"javaDoc":"","comments":" Convert each of those value names into the actual value.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":13,"StringLiteralExpr":3,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"SwitchStmt":1,"SwitchEntryStmt":4,"ReturnStmt":3},"text":"// This is an important method for code generation.\npublic String getJavaInitializationString() {\n    switch(((Number) getValue()).intValue()) {\n        default:\n        case YesNoDialog.LEFT:\n            return \"oreilly.beans.yesno.YesNoDialog.LEFT\";\n        case YesNoDialog.CENTER:\n            return \"oreilly.beans.yesno.YesNoDialog.CENTER\";\n        case YesNoDialog.RIGHT:\n            return \"oreilly.beans.yesno.YesNoDialog.RIGHT\";\n    }\n}\n","name":"getJavaInitializationString","className":"YesNoDialogAlignmentEditor","variables":{},"constants":{"\"oreilly.beans.yesno.YesNoDialog.LEFT\"":1,"\"oreilly.beans.yesno.YesNoDialog.CENTER\"":1,"\"oreilly.beans.yesno.YesNoDialog.RIGHT\"":1},"javaDoc":"","comments":" This is an important method for code generation.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Methods to query all of the bean properties.\npublic String getMessage() {\n    return message;\n}\n","name":"getMessage","className":"YesNoDialog","variables":{"message":1},"constants":{},"javaDoc":"","comments":" Methods to query all of the bean properties.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getTitle() {\n    return title;\n}\n","name":"getTitle","className":"YesNoDialog","variables":{"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getYesLabel() {\n    return yesLabel;\n}\n","name":"getYesLabel","className":"YesNoDialog","variables":{"yesLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getNoLabel() {\n    return noLabel;\n}\n","name":"getNoLabel","className":"YesNoDialog","variables":{"noLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCancelLabel() {\n    return cancelLabel;\n}\n","name":"getCancelLabel","className":"YesNoDialog","variables":{"cancelLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAlignment() {\n    return alignment;\n}\n","name":"getAlignment","className":"YesNoDialog","variables":{"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Font","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Font getFont() {\n    return font;\n}\n","name":"getFont","className":"YesNoDialog","variables":{"font":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Color getBackground() {\n    return background;\n}\n","name":"getBackground","className":"YesNoDialog","variables":{"background":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Color getForeground() {\n    return foreground;\n}\n","name":"getForeground","className":"YesNoDialog","variables":{"foreground":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Methods to set all of the bean properties.\npublic void setMessage(String m) {\n    message = m;\n}\n","name":"setMessage","className":"YesNoDialog","variables":{"message":1,"m":1},"constants":{},"javaDoc":"","comments":" Methods to set all of the bean properties.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setTitle(String t) {\n    title = t;\n}\n","name":"setTitle","className":"YesNoDialog","variables":{"t":1,"title":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setYesLabel(String l) {\n    yesLabel = l;\n}\n","name":"setYesLabel","className":"YesNoDialog","variables":{"yesLabel":1,"l":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setNoLabel(String l) {\n    noLabel = l;\n}\n","name":"setNoLabel","className":"YesNoDialog","variables":{"noLabel":1,"l":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setCancelLabel(String l) {\n    cancelLabel = l;\n}\n","name":"setCancelLabel","className":"YesNoDialog","variables":{"cancelLabel":1,"l":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAlignment(int a) {\n    alignment = a;\n}\n","name":"setAlignment","className":"YesNoDialog","variables":{"a":1,"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setFont(Font f) {\n    font = f;\n}\n","name":"setFont","className":"YesNoDialog","variables":{"f":1,"font":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBackground(Color bg) {\n    background = bg;\n}\n","name":"setBackground","className":"YesNoDialog","variables":{"bg":1,"background":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setForeground(Color fg) {\n    foreground = fg;\n}\n","name":"setForeground","className":"YesNoDialog","variables":{"fg":1,"foreground":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerListener"],"returnType":"void","methodCalls":{"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Register an action listener to be notified when a button is pressed */\npublic void addAnswerListener(AnswerListener l) {\n    listeners.addElement(l);\n}\n","name":"addAnswerListener","className":"YesNoDialog","variables":{"listeners":1},"constants":{},"javaDoc":"Register an action listener to be notified when a button is pressed","comments":" Register an action listener to be notified when a button is pressed ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerListener"],"returnType":"void","methodCalls":{"removeElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Remove an Answer listener from our list of interested listeners */\npublic void removeAnswerListener(AnswerListener l) {\n    listeners.removeElement(l);\n}\n","name":"removeAnswerListener","className":"YesNoDialog","variables":{"listeners":1},"constants":{},"javaDoc":"Remove an Answer listener from our list of interested listeners","comments":" Remove an Answer listener from our list of interested listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"cancel":1,"no":1,"size":1,"yes":1,"clone":1,"elementAt":1,"getID":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"AnswerListener":1,"Vector":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"CastExpr":2,"NameExpr":36,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"SwitchStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"/** Send an event to all registered listeners */\npublic void fireEvent(AnswerEvent e) {\n    // Make a copy of the list and fire the events using that copy.\n    // This means that listeners can be added or removed from the original\n    // list in response to this event.  We ought to be able to just use an\n    // enumeration for the vector, but that doesn't copy the list internally.\n    Vector list = (Vector) listeners.clone();\n    for (int i = 0; i < list.size(); i++) {\n        AnswerListener listener = (AnswerListener) list.elementAt(i);\n        switch(e.getID()) {\n            case AnswerEvent.YES:\n                listener.yes(e);\n                break;\n            case AnswerEvent.NO:\n                listener.no(e);\n                break;\n            case AnswerEvent.CANCEL:\n                listener.cancel(e);\n                break;\n        }\n    }\n}\n","name":"fireEvent","className":"YesNoDialog","variables":{"listeners":1,"e":1,"listener":4,"i":3,"list":3},"constants":{"0":1},"javaDoc":"Send an event to all registered listeners","comments":"Make a copy of the list and fire the events using that copy This means that listeners can be added or removed from the original list in response to this event We ought to be able to just use an enumeration for the vector but that doesn't copy the list internally  Send an event to all registered listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"YesNoDialog","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":5,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** The no-argument bean constructor, with default property values */\npublic YesNoDialog() {\n    this(\"Question\", \"Your\\nMessage\\nHere\", \"Yes\", \"No\", \"Cancel\", LEFT);\n}\n","name":"YesNoDialog","className":"YesNoDialog","variables":{"LEFT":1},"constants":{"\"Question\"":1,"\"Yes\"":1,"\"Your\\nMessage\\nHere\"":1,"\"Cancel\"":1,"\"No\"":1},"javaDoc":"The no-argument bean constructor with default property values","comments":" The no-argument bean constructor, with default property values ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String","String","String","int"],"returnType":"YesNoDialog","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":18,"FieldAccessExpr":6,"ThisExpr":6,"AssignExpr":6},"statements":{"ExpressionStmt":6},"text":"/** A constructor for programmers using this class \"by hand\" */\npublic YesNoDialog(String title, String message, String yesLabel, String noLabel, String cancelLabel, int alignment) {\n    this.title = title;\n    this.message = message;\n    this.yesLabel = yesLabel;\n    this.noLabel = noLabel;\n    this.cancelLabel = cancelLabel;\n    this.alignment = alignment;\n}\n","name":"YesNoDialog","className":"YesNoDialog","variables":{"yesLabel":1,"noLabel":1,"cancelLabel":1,"title":1,"message":1,"alignment":1},"constants":{},"javaDoc":"A constructor for programmers using this class \"by hand\"","comments":" A constructor for programmers using this class \"by hand\" ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"fireEvent":1,"equals":2,"dispose":1,"getActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":29,"StringLiteralExpr":2,"FieldAccessExpr":3,"ThisExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":7},"text":"public void actionPerformed(ActionEvent e) {\n    // pop down window\n    frame.dispose();\n    if (listeners != null) {\n        // notify any registered listeners\n        String cmd = e.getActionCommand();\n        int type;\n        if (cmd.equals(\"yes\"))\n            type = AnswerEvent.YES;\n        else if (cmd.equals(\"no\"))\n            type = AnswerEvent.NO;\n        else\n            type = AnswerEvent.CANCEL;\n        fireEvent(new AnswerEvent(YesNoDialog.this, type));\n    }\n}\n","name":"actionPerformed","className":"","variables":{"listeners":1,"e":1,"YesNoDialog":1,"cmd":3,"type":5,"frame":1},"constants":{"null":1,"\"yes\"":1,"\"no\"":1},"javaDoc":"","comments":"pop down window notify any registered listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":5,"fireEvent":1,"addActionListener":3,"setForeground":1,"length":3,"show":1,"setActionCommand":3,"setLayout":2,"setBackground":1,"pack":1,"equals":2,"dispose":1,"setFont":1,"getActionCommand":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"Panel":1,"Frame":1,"ActionListener":1,"Button":3,"String":1,"int":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":9,"NullLiteralExpr":7,"VariableDeclarationExpr":8,"BinaryExpr":13,"NameExpr":119,"StringLiteralExpr":7,"FieldAccessExpr":4,"EnclosedExpr":6,"ThisExpr":1,"MethodCallExpr":26,"AssignExpr":3},"statements":{"IfStmt":9,"BlockStmt":5,"ExpressionStmt":31},"text":"/** This method makes the bean display the dialog box */\npublic void display() {\n    // Create a frame with the specified title.  It would be nice to\n    // use a Dialog, but that needs to be passed a Frame argument, and\n    // the BDK beanbox tool only seems to work with no-argument methods.\n    final Frame frame = new Frame(title);\n    // Specify a LayoutManager for it.\n    frame.setLayout(new BorderLayout(15, 15));\n    // Specify font and colors, if any are specified.\n    if (font != null)\n        frame.setFont(font);\n    if (background != null)\n        frame.setBackground(background);\n    if (foreground != null)\n        frame.setForeground(foreground);\n    // Put the message label in the middle of the window.\n    frame.add(\"Center\", new MultiLineLabel(message, 20, 20, alignment));\n    // Create an action listener for use by the buttons of the dialog.\n    // When a button is pressed, this listener first closes the dialog box.\n    // Then, it creates an AnswerEvent object that corresponds to the\n    // button that was pressed, and send that new event to all registered\n    // listeners, using the fireEvent() method defined above.\n    ActionListener listener = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // pop down window\n            frame.dispose();\n            if (listeners != null) {\n                // notify any registered listeners\n                String cmd = e.getActionCommand();\n                int type;\n                if (cmd.equals(\"yes\"))\n                    type = AnswerEvent.YES;\n                else if (cmd.equals(\"no\"))\n                    type = AnswerEvent.NO;\n                else\n                    type = AnswerEvent.CANCEL;\n                fireEvent(new AnswerEvent(YesNoDialog.this, type));\n            }\n        }\n    };\n    // Create a panel for the dialog buttons and put it at the bottom\n    // of the dialog.  Specify a FlowLayout layout manager for it.\n    Panel buttonbox = new Panel();\n    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));\n    frame.add(\"South\", buttonbox);\n    // and action command for each, and adding them to the buttonbox\n    if ((yesLabel != null) && (yesLabel.length() > 0)) {\n        // Create button.\n        Button yes = new Button(yesLabel);\n        // Set action command.\n        yes.setActionCommand(\"yes\");\n        // Set listener.\n        yes.addActionListener(listener);\n        // Add button to the panel.\n        buttonbox.add(yes);\n    }\n    if ((noLabel != null) && (noLabel.length() > 0)) {\n        Button no = new Button(noLabel);\n        no.setActionCommand(\"no\");\n        no.addActionListener(listener);\n        buttonbox.add(no);\n    }\n    if ((cancelLabel != null) && (cancelLabel.length() > 0)) {\n        Button cancel = new Button(cancelLabel);\n        cancel.setActionCommand(\"cancel\");\n        cancel.addActionListener(listener);\n        buttonbox.add(cancel);\n    }\n    // Finally, set the dialog to its preferred size and display it.\n    frame.pack();\n    frame.show();\n}\n     // Create each specified button, specifying the action listener\n\n","name":"display","className":"YesNoDialog","variables":{"noLabel":3,"cancel":3,"no":3,"listeners":1,"cancelLabel":3,"e":2,"yes":3,"listener":1,"buttonbox":5,"foreground":1,"title":1,"message":1,"type":5,"yesLabel":3,"actionPerformed":1,"background":1,"YesNoDialog":1,"cmd":3,"alignment":1,"frame":10,"font":1},"constants":{"0":3,"25":1,"15":3,"null":7,"\"cancel\"":1,"\"yes\"":2,"\"Center\"":1,"20":2,"\"no\"":2,"\"South\"":1},"javaDoc":"This method makes the bean display the dialog box","comments":"Create a frame with the specified title It would be nice to use a Dialog but that needs to be passed a Frame argument and Create an action listener for use by the buttons of the dialog When a button is pressed this listener first closes the dialog box Then it creates an AnswerEvent object that corresponds to the button that was pressed and send that new event to all registered Create a panel for the dialog buttons and put it at the bottom Create each specified button specifying the action listener the BDK beanbox tool only seems to work with no-argument methods Specify a LayoutManager for it Specify font and colors if any are specified Put the message label in the middle of the window listeners using the fireEvent() method defined above pop down window notify any registered listeners of the dialog Specify a FlowLayout layout manager for it and action command for each and adding them to the buttonbox Create button Set action command Set listener Add button to the panel Finally set the dialog to its preferred size and display it  This method makes the bean display the dialog box ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void yes(AnswerEvent e) {\n    System.out.println(\"Yes\");\n}\n","name":"yes","className":"","variables":{},"constants":{"\"Yes\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void no(AnswerEvent e) {\n    System.out.println(\"No\");\n}\n","name":"no","className":"","variables":{},"constants":{"\"No\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void cancel(AnswerEvent e) {\n    System.out.println(\"Cancel\");\n}\n","name":"cancel","className":"","variables":{},"constants":{"\"Cancel\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addAnswerListener":1,"display":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"YesNoDialog":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"StringLiteralExpr":9,"NameExpr":30,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"BlockStmt":3,"ExpressionStmt":6},"text":"/**\n   * A main method that demonstrates how to use this class, and allows testing\n   */\npublic static void main(String[] args) {\n    // Create an instance of InfoDialog, with title and message specified:\n    YesNoDialog d = new YesNoDialog(\"YesNoDialog Test\", \"There are unsaved files.\\n\" + \"Do you want to save them before quitting?\", \"Yes, save and quit\", \"No, quit without saving\", \"Cancel; don't quit\", YesNoDialog.CENTER);\n    // Register an action listener for the dialog.  This one just prints\n    // the results out to the console.\n    d.addAnswerListener(new AnswerListener() {\n\n        public void yes(AnswerEvent e) {\n            System.out.println(\"Yes\");\n        }\n\n        public void no(AnswerEvent e) {\n            System.out.println(\"No\");\n        }\n\n        public void cancel(AnswerEvent e) {\n            System.out.println(\"Cancel\");\n        }\n    });\n    // Now pop the dialog up.  It will pop itself down automatically.\n    d.display();\n}\n","name":"main","className":"YesNoDialog","variables":{"cancel":1,"no":1,"d":3,"e":3,"yes":1},"constants":{"\"Yes, save and quit\"":1,"\"YesNoDialog Test\"":1,"\"Yes\"":1,"\"There are unsaved files.\\n\"":1,"\"Cancel\"":1,"\"Do you want to save them before quitting?\"":1,"\"No, quit without saving\"":1,"\"Cancel; don't quit\"":1,"\"No\"":1},"javaDoc":"A main method that demonstrates how to use this class and allows testing","comments":"Register an action listener for the dialog This one just prints Create an instance of InfoDialog with title and message specified: the results out to the console Now pop the dialog up It will pop itself down automatically \n   * A main method that demonstrates how to use this class, and allows testing\n   ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","int","int"],"returnType":"MultiLineLabel","methodCalls":{"newLabel":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":14,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":5},"text":"// Here are five versions of the constructor.\npublic MultiLineLabel(String label, int margin_width, int margin_height, int alignment) {\n    // Remember all the properties.\n    this.label = label;\n    this.margin_width = margin_width;\n    this.margin_height = margin_height;\n    this.alignment = alignment;\n    // Break the label up into lines.\n    newLabel();\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"label":1,"alignment":1,"margin_width":1},"constants":{},"javaDoc":"","comments":"Remember all the properties Break the label up into lines  Here are five versions of the constructor.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","int"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, int margin_width, int margin_height) {\n    this(label, margin_width, margin_height, LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"LEFT":1,"label":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, int alignment) {\n    this(label, 10, 10, alignment);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"label":1,"alignment":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label) {\n    this(label, 10, 10, LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"LEFT":1,"label":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel() {\n    this(\"\");\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"newLabel":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"// Methods to set and query the various attributes of the component.\n// Note that some query methods are inherited from the superclass.\npublic void setLabel(String label) {\n    this.label = label;\n    // Break the label into lines.\n    newLabel();\n    // Note that we need to measure lines.\n    measured = false;\n    // Request a redraw.\n    repaint();\n}\n","name":"setLabel","className":"MultiLineLabel","variables":{"measured":1,"label":1},"constants":{"false":1},"javaDoc":"","comments":"Break the label into lines Note that we need to measure lines Request a redraw  Note that some query methods are inherited from the superclass.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public void setFont(Font f) {\n    // Tell our superclass about the new font.\n    super.setFont(f);\n    // Note that we need to remeasure lines.\n    measured = false;\n    // Request a redraw.\n    repaint();\n}\n","name":"setFont","className":"MultiLineLabel","variables":{"measured":1},"constants":{"false":1},"javaDoc":"","comments":"Tell our superclass about the new font Note that we need to remeasure lines Request a redraw ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void setForeground(Color c) {\n    // Tell our superclass about the new color.\n    super.setForeground(c);\n    // Request a redraw (size is unchanged).\n    repaint();\n}\n","name":"setForeground","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"","comments":"Tell our superclass about the new color Request a redraw (size is unchanged) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setAlignment(int a) {\n    alignment = a;\n    repaint();\n}\n","name":"setAlignment","className":"MultiLineLabel","variables":{"a":1,"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginWidth(int mw) {\n    margin_width = mw;\n    repaint();\n}\n","name":"setMarginWidth","className":"MultiLineLabel","variables":{"mw":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginHeight(int mh) {\n    margin_height = mh;\n    repaint();\n}\n","name":"setMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1,"mh":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getLabel() {\n    return label;\n}\n","name":"getLabel","className":"MultiLineLabel","variables":{"label":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getAlignment() {\n    return alignment;\n}\n","name":"getAlignment","className":"MultiLineLabel","variables":{"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginWidth() {\n    return margin_width;\n}\n","name":"getMarginWidth","className":"MultiLineLabel","variables":{"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginHeight() {\n    return margin_height;\n}\n","name":"getMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":8,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n   * This method is called by a layout manager when it wants to\n   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n   * the preferred version of this method.  We use this deprecated version\n   * so that this component can interoperate with 1.0 components.\n   */\npublic Dimension preferredSize() {\n    if (!measured)\n        measure();\n    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);\n}\n","name":"preferredSize","className":"MultiLineLabel","variables":{"max_width":1,"margin_height":1,"measured":1,"line_height":1,"margin_width":1,"num_lines":1},"constants":{"2":2},"javaDoc":"This method is called by a layout manager when it wants to know how big we'd like to be In Java 1 1 getPreferredSize() is the preferred version of this method We use this deprecated version so that this component can interoperate with 1 0 components","comments":"\n   * This method is called by a layout manager when it wants to\n   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n   * the preferred version of this method.  We use this deprecated version\n   * so that this component can interoperate with 1.0 components.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"preferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n   * This method is called when the layout manager wants to know\n   * the bare minimum amount of space we need to get by.\n   * For Java 1.1, we'd use getMinimumSize().\n   */\npublic Dimension minimumSize() {\n    return preferredSize();\n}\n","name":"minimumSize","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"This method is called when the layout manager wants to know the bare minimum amount of space we need to get by For Java 1 1 we'd use getMinimumSize()","comments":"\n   * This method is called when the layout manager wants to know\n   * the bare minimum amount of space we need to get by.\n   * For Java 1.1, we'd use getMinimumSize().\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"measure":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":9,"NameExpr":43,"FieldAccessExpr":3,"EnclosedExpr":2,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":5},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":4,"ForStmt":1,"ExpressionStmt":8},"text":"/**\n   * This method draws the label (same method that applets use).\n   * Note that it handles the margins and the alignment, but that\n   * it doesn't have to worry about the color or font--the superclass\n   * takes care of setting those in the Graphics object we're passed.\n   */\npublic void paint(Graphics g) {\n    int x, y;\n    // use getSize() in Java 1.1\n    Dimension size = this.size();\n    if (!measured)\n        measure();\n    y = line_ascent + (size.height - num_lines * line_height) / 2;\n    for (int i = 0; i < num_lines; i++, y += line_height) {\n        switch(alignment) {\n            default:\n            case LEFT:\n                x = margin_width;\n                break;\n            case CENTER:\n                x = (size.width - line_widths[i]) / 2;\n                break;\n            case RIGHT:\n                x = size.width - margin_width - line_widths[i];\n                break;\n        }\n        g.drawString(lines[i], x, y);\n    }\n}\n","name":"paint","className":"MultiLineLabel","variables":{"measured":1,"LEFT":1,"g":1,"line_widths":2,"i":6,"CENTER":1,"line_height":2,"size":1,"line_ascent":1,"x":4,"y":3,"RIGHT":1,"alignment":1,"lines":1,"num_lines":2,"margin_width":2},"constants":{"0":1,"2":2},"javaDoc":"This method draws the label (same method that applets use) Note that it handles the margins and the alignment but that it doesn't have to worry about the color or font--the superclass takes care of setting those in the Graphics object we're passed","comments":"use getSize() in Java 1 1 \n   * This method draws the label (same method that applets use).\n   * Note that it handles the margins and the alignment, but that\n   * it doesn't have to worry about the color or font--the superclass\n   * takes care of setting those in the Graphics object we're passed.\n   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"countTokens":1,"nextToken":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"StringTokenizer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":1,"ArrayCreationExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":5},"text":"/** This internal method breaks a specified label up into an array of lines.\n   *  It uses the StringTokenizer utility class. */\nprotected synchronized void newLabel() {\n    StringTokenizer t = new StringTokenizer(label, \"\\n\");\n    num_lines = t.countTokens();\n    lines = new String[num_lines];\n    line_widths = new int[num_lines];\n    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();\n}\n","name":"newLabel","className":"MultiLineLabel","variables":{"t":3,"line_widths":1,"i":4,"label":1,"lines":2,"num_lines":4},"constants":{"0":1,"\"\\n\"":1},"javaDoc":"This internal method breaks a specified label up into an array of lines It uses the StringTokenizer utility class","comments":" This internal method breaks a specified label up into an array of lines.\n   *  It uses the StringTokenizer utility class. ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":[],"returnType":"void","methodCalls":{"getFontMetrics":1,"getAscent":1,"stringWidth":1,"getHeight":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"FontMetrics":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":6,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"/** This internal method figures out how the font is, and how wide each\n   *  line of the label is, and how wide the widest line is. */\nprotected synchronized void measure() {\n    FontMetrics fm = this.getToolkit().getFontMetrics(this.getFont());\n    line_height = fm.getHeight();\n    line_ascent = fm.getAscent();\n    max_width = 0;\n    for (int i = 0; i < num_lines; i++) {\n        line_widths[i] = fm.stringWidth(lines[i]);\n        if (line_widths[i] > max_width)\n            max_width = line_widths[i];\n    }\n    measured = true;\n}\n","name":"measure","className":"MultiLineLabel","variables":{"max_width":3,"measured":1,"line_height":1,"fm":4,"line_ascent":1,"line_widths":3,"i":7,"lines":1,"num_lines":1},"constants":{"0":2,"true":1},"javaDoc":"This internal method figures out how the font is and how wide each line of the label is and how wide the widest line is","comments":" This internal method figures out how the font is, and how wide each\n   *  line of the label is, and how wide the widest line is. ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"CastExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setValue(Object o) {\n    value = (String) o;\n}\n","name":"setValue","className":"YesNoDialogMessageEditor","variables":{"value":1,"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Object getValue() {\n    return value;\n}\n","name":"getValue","className":"YesNoDialogMessageEditor","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAsText(String s) {\n    value = s;\n}\n","name":"setAsText","className":"YesNoDialogMessageEditor","variables":{"s":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getAsText() {\n    return value;\n}\n","name":"getAsText","className":"YesNoDialogMessageEditor","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// not enumerated; no tags\npublic String[] getTags() {\n    return null;\n}\n","name":"getTags","className":"YesNoDialogMessageEditor","variables":{},"constants":{"null":1},"javaDoc":"","comments":" not enumerated; no tags","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Say that we allow custom editing.\npublic boolean supportsCustomEditor() {\n    return true;\n}\n","name":"supportsCustomEditor","className":"YesNoDialogMessageEditor","variables":{},"constants":{"true":1},"javaDoc":"","comments":" Say that we allow custom editing.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TextEvent"],"returnType":"void","methodCalls":{"firePropertyChange":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void textValueChanged(TextEvent e) {\n    value = t.getText();\n    listeners.firePropertyChange(null, null, null);\n}\n","name":"textValueChanged","className":"","variables":{"t":1,"listeners":1,"value":1},"constants":{"null":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Component","methodCalls":{"setSize":1,"firePropertyChange":1,"getText":1,"addTextListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"TextArea":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":17,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// Return the custom editor.  This just creates and returns a TextArea\n// to edit the multi-line text.  But it also registers a listener on the\n// text area to update the value as the user types and to fire the\n// property change events that property editors are required to fire.\npublic Component getCustomEditor() {\n    final TextArea t = new TextArea(value);\n    // TextArea doesn't have a preferred size, so set one\n    t.setSize(300, 150);\n    t.addTextListener(new TextListener() {\n\n        public void textValueChanged(TextEvent e) {\n            value = t.getText();\n            listeners.firePropertyChange(null, null, null);\n        }\n    });\n    return t;\n}\n","name":"getCustomEditor","className":"YesNoDialogMessageEditor","variables":{"textValueChanged":1,"t":5,"listeners":1,"e":1,"value":2},"constants":{"300":1,"null":3,"150":1},"javaDoc":"","comments":"TextArea doesn't have a preferred size so set one  property change events that property editors are required to fire.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Visual display of the value, for use with the custom editor.\n// Just print some instructions and hope they fit in the in the box.\n// This could be more sophisticated.\npublic boolean isPaintable() {\n    return true;\n}\n","name":"isPaintable","className":"YesNoDialogMessageEditor","variables":{},"constants":{"true":1},"javaDoc":"","comments":" This could be more sophisticated.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Rectangle"],"returnType":"void","methodCalls":{"setClip":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void paintValue(Graphics g, Rectangle r) {\n    g.setClip(r);\n    g.drawString(\"Click to edit...\", r.x + 5, r.y + 15);\n}\n","name":"paintValue","className":"YesNoDialogMessageEditor","variables":{"g":2},"constants":{"15":1,"\"Click to edit...\"":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Important method for code generators.  Note that it\n// ought to add any necessary escape sequences.\npublic String getJavaInitializationString() {\n    return \"\\\"\" + value + \"\\\"\";\n}\n","name":"getJavaInitializationString","className":"YesNoDialogMessageEditor","variables":{"value":1},"constants":{"\"\\\"\"":2},"javaDoc":"","comments":" ought to add any necessary escape sequences.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"addPropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addPropertyChangeListener(PropertyChangeListener l) {\n    listeners.addPropertyChangeListener(l);\n}\n","name":"addPropertyChangeListener","className":"YesNoDialogMessageEditor","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"removePropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void removePropertyChangeListener(PropertyChangeListener l) {\n    listeners.removePropertyChangeListener(l);\n}\n","name":"removePropertyChangeListener","className":"YesNoDialogMessageEditor","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"GZIPOutputStream":1,"FileInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":18,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"ExpressionStmt":7},"text":"/** Gzip the contents of the from file and save in the to file. */\npublic static void gzipFile(String from, String to) throws IOException {\n    // Create stream to read from the from file\n    FileInputStream in = new FileInputStream(from);\n    // Create stream to compress data and write it to the to file.\n    GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(to));\n    // Copy bytes from one stream to the other\n    byte[] buffer = new byte[4096];\n    int bytes_read;\n    while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n    // And close the streams\n    in.close();\n    out.close();\n}\n","name":"gzipFile","className":"Compress","variables":{"in":3,"from":1,"bytes_read":2,"to":1,"buffer":1,"out":3},"constants":{"0":1,"4096":1,"1":1},"javaDoc":"Gzip the contents of the from file and save in the to file","comments":"Create stream to read from the from file Create stream to compress data and write it to the to file Copy bytes from one stream to the other And close the streams  Gzip the contents of the from file and save in the to file. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"putNextEntry":1,"read":1,"getPath":1,"list":1,"write":1,"close":2,"isDirectory":2},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":[],"types":{"byte[]":1,"ZipOutputStream":1,"ZipEntry":1,"String[]":1,"File":2,"int":2,"FileInputStream":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":1,"UnaryExpr":3,"AssignExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":12},"text":"/** Zip the contents of the directory, and save it in the zipfile */\npublic static void zipDirectory(String dir, String zipfile) throws IOException, IllegalArgumentException {\n    // Check that the directory is a directory, and get its contents\n    File d = new File(dir);\n    if (!d.isDirectory())\n        throw new IllegalArgumentException(\"Compress: not a directory:  \" + dir);\n    String[] entries = d.list();\n    // Create a buffer for copying \n    byte[] buffer = new byte[4096];\n    int bytes_read;\n    // Create a stream to compress data and write it to the zipfile\n    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile));\n    // Loop through all entries in the directory\n    for (int i = 0; i < entries.length; i++) {\n        File f = new File(d, entries[i]);\n        // Don't zip sub-directories\n        if (f.isDirectory())\n            continue;\n        // Stream to read file\n        FileInputStream in = new FileInputStream(f);\n        // Make a ZipEntry\n        ZipEntry entry = new ZipEntry(f.getPath());\n        // Store entry in zipfile\n        out.putNextEntry(entry);\n        while (// Copy bytes to zipfile\n        (bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n        // Close input stream\n        in.close();\n    }\n    // When we're done with the whole loop, close the output stream\n    out.close();\n}\n","name":"zipDirectory","className":"Compress","variables":{"entry":1,"entries":2,"zipfile":1,"d":4,"in":3,"f":4,"i":4,"bytes_read":2,"buffer":1,"dir":2,"out":4},"constants":{"0":2,"4096":1,"1":1,"\"Compress: not a directory:  \"":1},"javaDoc":"Zip the contents of the directory and save it in the zipfile","comments":"Check that the directory is a directory and get its contents Create a buffer for copying Create a stream to compress data and write it to the zipfile Loop through all entries in the directory Don't zip sub-directories Stream to read file Make a ZipEntry Store entry in zipfile Copy bytes to zipfile Close input stream When we're done with the whole loop close the output stream  Zip the contents of the directory, and save it in the zipfile ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"zipDirectory":1,"System.err.println":2,"isDirectory":1,"gzipFile":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"boolean":1,"String":1,"File":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":52,"StringLiteralExpr":4,"FieldAccessExpr":5,"EnclosedExpr":3,"MethodCallExpr":8,"AssignExpr":3},"statements":{"IfStmt":5,"BlockStmt":3,"ExpressionStmt":12},"text":"/**\n     * Compress a specified file or directory.  If no destination name is\n     * specified, append .gz to a file name or .zip to a directory name\n     **/\npublic static void main(String args[]) throws IOException {\n    if ((args.length != 1) && (args.length != 2)) {\n        // check arguments\n        System.err.println(\"Usage: java Compress$Test <from> [<to>]\");\n        System.exit(0);\n    }\n    String from = args[0], to;\n    File f = new File(from);\n    // Is it a file or directory?\n    boolean directory = f.isDirectory();\n    if (args.length == 2)\n        to = args[1];\n    else {\n        // If destination not specified\n        if (//   use a .zip suffix\n        directory)\n            //   use a .zip suffix\n            to = from + \".zip\";\n        else\n            //   or a .gz suffix\n            to = from + \".gz\";\n    }\n    if ((new File(to)).exists()) {\n        // Make sure not to overwrite anything\n        System.err.println(\"Compress: won't overwrite existing file: \" + to);\n        System.exit(0);\n    }\n    // Finally, call one of the methods defined above to do the work.\n    if (directory)\n        Compress.zipDirectory(from, to);\n    else\n        Compress.gzipFile(from, to);\n}\n","name":"main","className":"Test","variables":{"args":2,"Compress":2,"f":2,"from":4,"to":6,"directory":3,"System":2},"constants":{"0":3,"1":2,"2":2,"\"Usage: java Compress$Test <from> [<to>]\"":1,"\"Compress: won't overwrite existing file: \"":1,"\".gz\"":1,"\".zip\"":1},"javaDoc":"Compress a specified file or directory If no destination name is specified append gz to a file name or zip to a directory name","comments":"check arguments Is it a file or directory? If destination not specified use a zip suffix use a zip suffix or a gz suffix Make sure not to overwrite anything Finally call one of the methods defined above to do the work \n     * Compress a specified file or directory.  If no destination name is\n     * specified, append .gz to a file name or .zip to a directory name\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Button":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":6,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"public void init() {\n    // Get rid of the default layout manager.\n    // We'll arrange the components ourself.\n    this.setLayout(null);\n    for (int i = 1; i <= 9; i++) {\n        Button b = new Button(\"Button #\" + i);\n        // use reshape() in Java 1.0\n        b.setBounds(i * 26, i * 18, 100, 25);\n        this.add(b);\n    }\n}\n","name":"init","className":"NullLayoutExample","variables":{"b":2,"i":6},"constants":{"1":1,"100":1,"25":1,"null":1,"26":1,"18":1,"9":1,"\"Button #\"":1},"javaDoc":"","comments":"Get rid of the default layout manager We'll arrange the components ourself use reshape() in Java 1 0 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"public Dimension getPreferredSize() {\n    return new Dimension(350, 225);\n}\n","name":"getPreferredSize","className":"NullLayoutExample","variables":{},"constants":{"225":1,"350":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":3,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Initialize some variables\n    int current, prev = 1, prevprev = 0;\n    for (int i = 0; i < 20; i++) {\n        // Loop exactly 20 times\n        // Next number is sum of previous two\n        current = prev + prevprev;\n        // Print it out\n        System.out.print(current + \" \");\n        // First previous becomes 2nd previous\n        prevprev = prev;\n        // And current number becomes previous\n        prev = current;\n    }\n    // Terminate the line, and flush output\n    System.out.println();\n}\n","name":"main","className":"Fibonacci","variables":{"prevprev":3,"current":4,"prev":4,"i":3},"constants":{"0":2,"1":1,"\" \"":1,"20":1},"javaDoc":"","comments":"Initialize some variables Loop exactly 20 times Next number is sum of previous two Print it out First previous becomes 2nd previous And current number becomes previous Terminate the line and flush output ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"sqrt":1,"ceil":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"boolean[]":1,"int":6},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":7,"ArrayAccessExpr":7,"BinaryExpr":9,"NameExpr":45,"StringLiteralExpr":2,"UnaryExpr":4,"AssignExpr":7,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"EmptyStmt":1,"ForStmt":4,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // We will compute all primes less than the supplied command line argument\n    // Or, if no argument, all primes less than 100\n    // Assign a default value\n    int max = 100;\n    try // Try to parse user-supplied arg\n    {\n        max = Integer.parseInt(args[0]);\n    }// Silently ignore exceptions.\n     catch (Exception e) {\n    }\n    // Create an array that specifies whether each number is prime or not.\n    boolean[] isprime = new boolean[max + 1];\n    // Assume that all numbers are primes, until proven otherwise.\n    for (int i = 0; i <= max; i++) isprime[i] = true;\n    // However, we know that 0 and 1 are not primes.  Make a note of it.\n    isprime[0] = isprime[1] = false;\n    // To compute all primes less than max, we need to rule out\n    // multiples of all integers less than the square root of max.\n    // See java.lang.Math class\n    int n = (int) Math.ceil(Math.sqrt(max));\n    //   ruled out by one of the prime factors of i, so we can skip this case.\n    for (int i = 0; i <= n; i++) {\n        if (// If i is a prime, \n        isprime[i])\n            for (// loop through its multiples\n            int j = 2 * i; // loop through its multiples\n            j <= max; // loop through its multiples\n            j = j + i) // noting they are not prime.\n            isprime[j] = false;\n    }\n    // Now go look for the largest prime:\n    int largest;\n    // empty loop body\n     // Now, for each integer i from 0 to n:\n\n     //   If i is a prime, then none of its multiples are primes, so\n\n     //   indicate this in the array.  \n\n     //   If i is not a prime, then its multiples have already been\n\n    for (largest = max; !isprime[largest]; largest--) ;\n    // Output the result\n    System.out.println(\"The largest prime less than or equal to \" + max + \" is \" + largest);\n}\n","name":"main","className":"Sieve","variables":{"Integer":1,"args":1,"largest":5,"max":7,"e":1,"i":10,"j":5,"Math":2,"isprime":7,"n":2},"constants":{"0":4,"100":1,"1":2,"2":1,"\"The largest prime less than or equal to \"":1,"\" is \"":1,"true":1,"false":2},"javaDoc":"","comments":"We will compute all primes less than the supplied command line argument Or if no argument all primes less than 100 To compute all primes less than max we need to rule out multiples of all integers less than the square root of max Now for each integer i from 0 to n: If i is a prime then none of its multiples are primes so indicate this in the array If i is not a prime then its multiples have already been Assign a default value Try to parse user-supplied arg Silently ignore exceptions Create an array that specifies whether each number is prime or not Assume that all numbers are primes until proven otherwise However we know that 0 and 1 are not primes Make a note of it See java lang Math class ruled out by one of the prime factors of i so we can skip this case If i is a prime loop through its multiples loop through its multiples loop through its multiples noting they are not prime Now go look for the largest prime: empty loop body Output the result ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"exit":1,"forName":1,"addService":2,"newInstance":1,"System.err.println":2},"annotations":[],"exceptions":["IllegalArgumentException","// Display a message if anything goes wrong\nException"],"concepts":["Casting","ExceptionHandling"],"types":{"Server":1,"Service":1,"Class":1,"String":2,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":5,"BinaryExpr":4,"NameExpr":61,"StringLiteralExpr":5,"CastExpr":1,"FieldAccessExpr":5,"UnaryExpr":5,"MethodCallExpr":10},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":5,"ThrowStmt":1,"ExpressionStmt":14},"text":"/**\n   * A main() method for running the server as a standalone program.\n   * The command-line arguments to the program should be pairs of servicenames\n   * and port numbers.  For each pair, the program will dynamically load the \n   * named Service class, instantiate it, and tell the server to provide that\n   * Service on the specified port.  The special -control argument should be\n   * followed by a password and port, and will start special server control\n   * service running on the specified port, protected by the specified \n   * password.\n   **/\npublic static void main(String[] args) {\n    try {\n        if (// Check number of arguments\n        args.length < 2)\n            throw new IllegalArgumentException(\"Must start at least one service\");\n        // Create a Server object that uses standard out as its log and\n        // has a limit of ten concurrent connections at once.\n        Server s = new Server(System.out, 10);\n        // Parse the argument list\n        int i = 0;\n        while (i < args.length) {\n            if (args[i].equals(\"-control\")) {\n                // Handle the -control argument\n                i++;\n                String password = args[i++];\n                int port = Integer.parseInt(args[i++]);\n                // add control service\n                s.addService(new Control(s, password), port);\n            } else {\n                // Otherwise start a named service on the specified port.\n                // Dynamically load and instantiate a class that implements Service.\n                String serviceName = args[i++];\n                // dynamic load\n                Class serviceClass = Class.forName(serviceName);\n                // instantiate\n                Service service = (Service) serviceClass.newInstance();\n                int port = Integer.parseInt(args[i++]);\n                s.addService(service, port);\n            }\n        }\n    } catch (// Display a message if anything goes wrong\n    Exception // Display a message if anything goes wrong\n    e) {\n        System.err.println(\"Server: \" + e);\n        System.err.println(\"Usage: java Server [-control <password> <port>] \" + \"[<servicename> <port> ... ]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"Server","variables":{"args":5,"Integer":2,"password":2,"s":4,"serviceClass":2,"port":2,"e":2,"service":1,"i":8,"Class":1,"serviceName":1,"System":1},"constants":{"0":1,"1":1,"2":1,"\"[<servicename> <port> ... ]\"":1,"\"Must start at least one service\"":1,"\"Usage: java Server [-control <password> <port>] \"":1,"\"Server: \"":1,"\"-control\"":1,"10":1},"javaDoc":"A main() method for running the server as a standalone program The command-line arguments to the program should be pairs of servicenames and port numbers For each pair the program will dynamically load the named Service class instantiate it and tell the server to provide that Service on the specified port The special -control argument should be followed by a password and port and will start special server control service running on the specified port protected by the specified password","comments":"Create a Server object that uses standard out as its log and Check number of arguments has a limit of ten concurrent connections at once Parse the argument list Handle the -control argument add control service Otherwise start a named service on the specified port Dynamically load and instantiate a class that implements Service dynamic load instantiate Display a message if anything goes wrong Display a message if anything goes wrong \n   * A main() method for running the server as a standalone program.\n   * The command-line arguments to the program should be pairs of servicenames\n   * and port numbers.  For each pair, the program will dynamically load the \n   * named Service class, instantiate it, and tell the server to provide that\n   * Service on the specified port.  The special -control argument should be\n   * followed by a password and port, and will start special server control\n   * service running on the specified port, protected by the specified \n   * password.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["OutputStream","int"],"returnType":"Server","methodCalls":{"log":1,"start":1,"setLogStream":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":13,"StringLiteralExpr":2,"MethodCallExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":6},"text":"/**\n   * This is the Server() constructor.  It must be passed a stream \n   * to send log output to (may be null), and the limit on the number of\n   * concurrent connections.  It creates and starts a ConnectionManager \n   * thread which enforces this limit on connections.\n   **/\npublic Server(OutputStream logStream, int maxConnections) {\n    setLogStream(logStream);\n    log(\"Starting server\");\n    threadGroup = new ThreadGroup(\"Server\");\n    connectionManager = new ConnectionManager(threadGroup, maxConnections);\n    connectionManager.start();\n    services = new Hashtable();\n}\n","name":"Server","className":"Server","variables":{"threadGroup":2,"connectionManager":2,"services":1,"maxConnections":1},"constants":{"\"Starting server\"":1,"\"Server\"":1},"javaDoc":"This is the Server() constructor It must be passed a stream to send log output to (may be null) and the limit on the number of concurrent connections It creates and starts a ConnectionManager thread which enforces this limit on connections","comments":"\n   * This is the Server() constructor.  It must be passed a stream \n   * to send log output to (may be null), and the limit on the number of\n   * concurrent connections.  It creates and starts a ConnectionManager \n   * thread which enforces this limit on connections.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["OutputStream"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":2,"BinaryExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** \n   * A public method to set the current logging stream.  Pass null\n   * to turn logging off\n   **/\npublic void setLogStream(OutputStream out) {\n    if (out != null)\n        logStream = new PrintWriter(new OutputStreamWriter(out));\n    else\n        logStream = null;\n}\n","name":"setLogStream","className":"Server","variables":{"logStream":2,"out":2},"constants":{"null":2},"javaDoc":"A public method to set the current logging stream Pass null to turn logging off","comments":" \n   * A public method to set the current logging stream.  Pass null\n   * to turn logging off\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"flush":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** Write the specified string to the log */\nprotected synchronized void log(String s) {\n    if (logStream != null) {\n        logStream.println(\"[\" + new Date() + \"] \" + s);\n        logStream.flush();\n    }\n}\n","name":"log","className":"Server","variables":{"s":1,"logStream":3},"constants":{"null":1,"\"[\"":1,"\"] \"":1},"javaDoc":"Write the specified string to the log","comments":" Write the specified string to the log ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"log":1,"toString":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Write the specified object to the log */\nprotected void log(Object o) {\n    log(o.toString());\n}\n","name":"log","className":"Server","variables":{"o":1},"constants":{},"javaDoc":"Write the specified object to the log","comments":" Write the specified object to the log ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Service","int"],"returnType":"void","methodCalls":{"getClass":1,"getName":1,"log":1,"get":1,"start":1,"put":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":[],"types":{"Integer":1,"Listener":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":25,"StringLiteralExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n   * This method makes the server start providing a new service.\n   * It runs the specified Service object on the specified port.\n   **/\npublic void addService(Service service, int port) throws IOException {\n    // the hashtable key\n    Integer key = new Integer(port);\n    // Check whether a service is already on that port\n    if (services.get(key) != null)\n        throw new IllegalArgumentException(\"Port \" + port + \" already in use.\");\n    // Create a Listener object to listen for connections on the port\n    Listener listener = new Listener(threadGroup, port, service);\n    // Store it in the hashtable\n    services.put(key, listener);\n    // Log it\n    log(\"Starting service \" + service.getClass().getName() + \" on port \" + port);\n    // Start the listener running.\n    listener.start();\n}\n","name":"addService","className":"Server","variables":{"threadGroup":1,"port":4,"service":2,"listener":2,"services":2,"key":1},"constants":{"null":1,"\" on port \"":1,"\"Starting service \"":1,"\"Port \"":1,"\" already in use.\"":1},"javaDoc":"This method makes the server start providing a new service It runs the specified Service object on the specified port","comments":"the hashtable key Check whether a service is already on that port Create a Listener object to listen for connections on the port Store it in the hashtable Log it Start the listener running \n   * This method makes the server start providing a new service.\n   * It runs the specified Service object on the specified port.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getName":1,"log":1,"listener.service.getClass":1,"get":1,"pleaseStop":1,"remove":1},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables"],"types":{"Integer":1,"Listener":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":23,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n   * This method makes the server stop providing a service on a port.\n   * It does not terminate any pending connections to that service, merely\n   * causes the server to stop accepting new connections\n   **/\npublic void removeService(int port) {\n    // hashtable key\n    Integer key = new Integer(port);\n    // Look up the Listener object for the port in the hashtable of services\n    final Listener listener = (Listener) services.get(key);\n    if (listener == null)\n        return;\n    // Ask the listener to stop\n    listener.pleaseStop();\n    // Remove it from the hashtable\n    services.remove(key);\n    // And log it.\n    log(\"Stopping service \" + listener.service.getClass().getName() + \" on port \" + port);\n}\n","name":"removeService","className":"Server","variables":{"port":2,"listener":3,"services":2,"key":1},"constants":{"\"Stopping service \"":1,"null":1,"\" on port \"":1},"javaDoc":"This method makes the server stop providing a service on a port It does not terminate any pending connections to that service merely causes the server to stop accepting new connections","comments":"hashtable key Look up the Listener object for the port in the hashtable of services Ask the listener to stop Remove it from the hashtable And log it \n   * This method makes the server stop providing a service on a port.\n   * It does not terminate any pending connections to that service, merely\n   * causes the server to stop accepting new connections\n   *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ThreadGroup","int","Service"],"returnType":"Listener","methodCalls":{"setSoTimeout":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":4},"text":"/**\n     * The Listener constructor creates a thread for itself in the specified\n     * threadgroup.  It creates a ServerSocket to listen for connections\n     * on the specified port.  It arranges for the ServerSocket to be\n     * interruptible, so that services can be removed from the server.\n     **/\npublic Listener(ThreadGroup group, int port, Service service) throws IOException {\n    super(group, \"Listener:\" + port);\n    listen_socket = new ServerSocket(port);\n    // give the socket a non-zero timeout so accept() can be interrupted\n    listen_socket.setSoTimeout(600000);\n    this.port = port;\n    this.service = service;\n}\n","name":"Listener","className":"Listener","variables":{"port":3,"service":1,"listen_socket":2,"group":1},"constants":{"600000":1,"\"Listener:\"":1},"javaDoc":"The Listener constructor creates a thread for itself in the specified threadgroup It creates a ServerSocket to listen for connections on the specified port It arranges for the ServerSocket to be interruptible so that services can be removed from the server","comments":"give the socket a non-zero timeout so accept() can be interrupted \n     * The Listener constructor creates a thread for itself in the specified\n     * threadgroup.  It creates a ServerSocket to listen for connections\n     * on the specified port.  It arranges for the ServerSocket to be\n     * interruptible, so that services can be removed from the server.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** This is the nice way to get a Listener to stop accepting connections */\npublic void pleaseStop() {\n    // set the stop flag\n    this.stop = true;\n    // and make the accept() call stop blocking\n    this.interrupt();\n}\n","name":"pleaseStop","className":"Listener","variables":{},"constants":{"true":1},"javaDoc":"This is the nice way to get a Listener to stop accepting connections","comments":"set the stop flag and make the accept() call stop blocking  This is the nice way to get a Listener to stop accepting connections ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":1,"addConnection":1,"accept":1},"annotations":[],"exceptions":["InterruptedIOException","IOException"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":3},"text":"/**\n     * A Listener is a Thread, and this is its body.\n     * Wait for connection requests, accept them, and pass the socket on\n     * to the ConnectionManager object of this server\n     **/\npublic void run() {\n    while (!stop) {\n        // loop until we're asked to stop.\n        try {\n            Socket client = listen_socket.accept();\n            connectionManager.addConnection(client, service);\n        } catch (InterruptedIOException e) {\n        } catch (IOException e) {\n            log(e);\n        }\n    }\n}\n","name":"run","className":"Listener","variables":{"stop":1,"e":2,"connectionManager":1,"client":1,"listen_socket":1},"constants":{},"javaDoc":"A Listener is a Thread and this is its body Wait for connection requests accept them and pass the socket on to the ConnectionManager object of this server","comments":"loop until we're asked to stop \n     * A Listener is a Thread, and this is its body.\n     * Wait for connection requests, accept them, and pass the socket on\n     * to the ConnectionManager object of this server\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ThreadGroup","int"],"returnType":"ConnectionManager","methodCalls":{"log":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":4},"text":"/** \n     * Create a ConnectionManager in the specified thread group to enforce\n     * the specified maximum connection limit.  Make it a daemon thread so\n     * the interpreter won't wait around for it to exit.\n     **/\npublic ConnectionManager(ThreadGroup group, int maxConnections) {\n    super(group, \"ConnectionManager\");\n    this.setDaemon(true);\n    this.maxConnections = maxConnections;\n    connections = new Vector(maxConnections);\n    log(\"Starting connection manager.  Max connections: \" + maxConnections);\n}\n","name":"ConnectionManager","className":"ConnectionManager","variables":{"connections":1,"group":1,"maxConnections":3},"constants":{"\"ConnectionManager\"":1,"\"Starting connection manager.  Max connections: \"":1,"true":1},"javaDoc":"Create a ConnectionManager in the specified thread group to enforce the specified maximum connection limit Make it a daemon thread so the interpreter won't wait around for it to exit","comments":" \n     * Create a ConnectionManager in the specified thread group to enforce\n     * the specified maximum connection limit.  Make it a daemon thread so\n     * the interpreter won't wait around for it to exit.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket","Service"],"returnType":"void","methodCalls":{"getInetAddress":2,"getClass":1,"getLocalPort":1,"getName":1,"log":3,"start":1,"println":1,"getPort":2,"size":1,"flush":1,"getOutputStream":1,"getHostAddress":2,"addElement":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Connection":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":13,"NameExpr":56,"StringLiteralExpr":9,"MethodCallExpr":19},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":10},"text":"/**\n     * This is the method that Listener objects call when they accept a\n     * connection from a client.  It either creates a Connection object \n     * for the connection and adds it to the list of current connections,\n     * or, if the limit on connections has been reached, it closes the \n     * connection. \n     **/\nsynchronized void addConnection(Socket s, Service service) {\n    // If the connection limit has been reached\n    if (connections.size() >= maxConnections) {\n        try {\n            PrintWriter out = new PrintWriter(s.getOutputStream());\n            // Then tell the client it is being rejected.\n            out.println(\"Connection refused; \" + \"server has reached maximum number of clients.\");\n            out.flush();\n            // And close the connection to the rejected client.\n            s.close();\n            // And log it, of course\n            log(\"Connection refused to \" + s.getInetAddress().getHostAddress() + \":\" + s.getPort() + \": max connections reached.\");\n        } catch (IOException e) {\n            log(e);\n        }\n    } else {\n        // Otherwise, if the limit has not been reached\n        // Create a Connection thread to handle this connection\n        Connection c = new Connection(s, service);\n        // Add it to the list of current connections\n        connections.addElement(c);\n        // Log this new connection\n        log(\"Connected to \" + s.getInetAddress().getHostAddress() + \":\" + s.getPort() + \" on port \" + s.getLocalPort() + \" for service \" + service.getClass().getName());\n        // And start the Connection thread running to provide the service\n        c.start();\n    }\n}\n","name":"addConnection","className":"ConnectionManager","variables":{"s":8,"c":2,"e":1,"service":2,"connections":2,"maxConnections":1,"out":3},"constants":{"\"Connected to \"":1,"\"Connection refused; \"":1,"\" on port \"":1,"\"Connection refused to \"":1,"\" for service \"":1,"\":\"":2,"\"server has reached maximum number of clients.\"":1,"\": max connections reached.\"":1},"javaDoc":"This is the method that Listener objects call when they accept a connection from a client It either creates a Connection object for the connection and adds it to the list of current connections or if the limit on connections has been reached it closes the connection","comments":"If the connection limit has been reached Then tell the client it is being rejected And close the connection to the rejected client And log it of course Otherwise if the limit has not been reached Create a Connection thread to handle this connection Add it to the list of current connections Log this new connection And start the Connection thread running to provide the service \n     * This is the method that Listener objects call when they accept a\n     * connection from a client.  It either creates a Connection object \n     * for the connection and adds it to the list of current connections,\n     * or, if the limit on connections has been reached, it closes the \n     * connection. \n     *","isEmpty":false,"hasInnerClass":false,"modifier":32}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":2,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * A Connection object calls this method just before it exits.\n     * This method uses notify() to tell the ConnectionManager thread\n     * to wake up and delete the thread that has exited.\n     **/\npublic synchronized void endConnection() {\n    this.notify();\n}\n","name":"endConnection","className":"ConnectionManager","variables":{},"constants":{},"javaDoc":"A Connection object calls this method just before it exits This method uses notify() to tell the ConnectionManager thread to wake up and delete the thread that has exited","comments":"\n     * A Connection object calls this method just before it exits.\n     * This method uses notify() to tell the ConnectionManager thread\n     * to wake up and delete the thread that has exited.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Change the current connection limit */\npublic synchronized void setMaxConnections(int max) {\n    maxConnections = max;\n}\n","name":"setMaxConnections","className":"ConnectionManager","variables":{"max":1,"maxConnections":1},"constants":{},"javaDoc":"Change the current connection limit","comments":" Change the current connection limit ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"c.service.getClass":1,"println":1,"c.client.getInetAddress":1,"getName":1,"size":1,"c.client.getLocalPort":1,"elementAt":1,"getHostAddress":1,"c.client.getPort":1},"annotations":[],"exceptions":[],"concepts":["Casting","Synchronization"],"types":{"Connection":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":8,"NameExpr":36,"CastExpr":1,"StringLiteralExpr":4,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** \n     * Output the current list of connections to the specified stream.\n     * This method is used by the Control service defined below.\n     **/\npublic synchronized void printConnections(PrintWriter out) {\n    for (int i = 0; i < connections.size(); i++) {\n        Connection c = (Connection) connections.elementAt(i);\n        out.println(\"CONNECTED TO \" + c.client.getInetAddress().getHostAddress() + \":\" + c.client.getPort() + \" ON PORT \" + c.client.getLocalPort() + \" FOR SERVICE \" + c.service.getClass().getName());\n    }\n}\n","name":"printConnections","className":"ConnectionManager","variables":{"c":1,"i":3,"connections":2,"out":1},"constants":{"0":1,"\"CONNECTED TO \"":1,"\" ON PORT \"":1,"\" FOR SERVICE \"":1,"\":\"":1},"javaDoc":"Output the current list of connections to the specified stream This method is used by the Control service defined below","comments":" \n     * Output the current list of connections to the specified stream.\n     * This method is used by the Control service defined below.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"void","methodCalls":{"isAlive":1,"c.client.getInetAddress":1,"size":1,"log":1,"elementAt":1,"removeElementAt":1,"getHostAddress":1,"c.client.getPort":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"Connection":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":5,"NameExpr":32,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":2,"UnaryExpr":2,"ThisExpr":2,"MethodCallExpr":9},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":6,"TryStmt":1,"SynchronizedStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * The ConnectionManager is a thread, and this is the body of that\n     * thread.  While the ConnectionManager methods above are called by other\n     * threads, this method is run in its own thread.  The job of this thread\n     * is to keep the list of connections up to date by removing connections\n     * that are no longer alive.  It uses wait() to block until notify()'d by\n     * the endConnection() method.\n     **/\npublic void run() {\n    while (true) {\n        // Check through the list of connections, removing dead ones\n        for (int i = 0; i < connections.size(); i++) {\n            Connection c = (Connection) connections.elementAt(i);\n            if (!c.isAlive()) {\n                connections.removeElementAt(i);\n                log(\"Connection to \" + c.client.getInetAddress().getHostAddress() + \":\" + c.client.getPort() + \" closed.\");\n            }\n        }\n        // When we wake up we'll check the list of connections again.\n        try {\n            synchronized (this) {\n                this.wait();\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}\n                      // infinite loop\n\n         // Now wait to be notify()'d that a connection has exited\n\n","name":"run","className":"ConnectionManager","variables":{"c":2,"e":1,"i":3,"connections":3},"constants":{"0":1,"\"Connection to \"":1,"true":1,"\":\"":1,"\" closed.\"":1},"javaDoc":"The ConnectionManager is a thread and this is the body of that thread While the ConnectionManager methods above are called by other threads this method is run in its own thread The job of this thread is to keep the list of connections up to date by removing connections that are no longer alive It uses wait() to block until notify()'d by the endConnection() method","comments":"infinite loop Now wait to be notify()'d that a connection has exited Check through the list of connections removing dead ones When we wake up we'll check the list of connections again \n     * The ConnectionManager is a thread, and this is the body of that\n     * thread.  While the ConnectionManager methods above are called by other\n     * threads, this method is run in its own thread.  The job of this thread\n     * is to keep the list of connections up to date by removing connections\n     * that are no longer alive.  It uses wait() to block until notify()'d by\n     * the endConnection() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket","Service"],"returnType":"Connection","methodCalls":{"getInetAddress":1,"getPort":1,"getHostAddress":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":14,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":3,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"/**\n     * This constructor just saves some state and calls the superclass\n     * constructor to create a thread to handle the connection.  Connection\n     * objects are created by Listener threads.  These threads are part of\n     * the server's ThreadGroup, so all Connection threads are part of that\n     * group, too.\n     **/\npublic Connection(Socket client, Service service) {\n    super(\"Server.Connection:\" + client.getInetAddress().getHostAddress() + \":\" + client.getPort());\n    this.client = client;\n    this.service = service;\n}\n","name":"Connection","className":"Connection","variables":{"service":1,"client":3},"constants":{"\"Server.Connection:\"":1,"\":\"":1},"javaDoc":"This constructor just saves some state and calls the superclass constructor to create a thread to handle the connection Connection objects are created by Listener threads These threads are part of the server's ThreadGroup so all Connection threads are part of that group too","comments":"\n     * This constructor just saves some state and calls the superclass\n     * constructor to create a thread to handle the connection.  Connection\n     * objects are created by Listener threads.  These threads are part of\n     * the server's ThreadGroup, so all Connection threads are part of that\n     * group, too.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":1,"getOutputStream":1,"serve":1,"endConnection":1,"getInputStream":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"OutputStream":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":17,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"/**\n     * This is the body of each and every Connection thread.\n     * All it does is pass the client input and output streams to the \n     * serve() method of the specified Service object.  That method\n     * is responsible for reading from and writing to those streams to\n     * provide the actual service.  Recall that the Service object has been\n     * passed from the Server.addService() method to a Listener object\n     * to the ConnectionManager.addConnection() to this Connection object,\n     * and is now finally getting used to provide the service.\n     * Note that just before this thread exits it calls the \n     * ConnectionManager.endConnection() method to wake up the \n     * ConnectionManager thread so that it can remove this Connection\n     * from its list of active connections.\n     **/\npublic void run() {\n    try {\n        InputStream in = client.getInputStream();\n        OutputStream out = client.getOutputStream();\n        service.serve(in, out);\n    } catch (IOException e) {\n        log(e);\n    } finally {\n        connectionManager.endConnection();\n    }\n}\n","name":"run","className":"Connection","variables":{"in":1,"e":1,"service":1,"connectionManager":1,"client":2,"out":1},"constants":{},"javaDoc":"This is the body of each and every Connection thread All it does is pass the client input and output streams to the serve() method of the specified Service object That method is responsible for reading from and writing to those streams to provide the actual service Recall that the Service object has been passed from the Server addService() method to a Listener object to the ConnectionManager addConnection() to this Connection object and is now finally getting used to provide the service Note that just before this thread exits it calls the ConnectionManager endConnection() method to wake up the ConnectionManager thread so that it can remove this Connection from its list of active connections","comments":"\n     * This is the body of each and every Connection thread.\n     * All it does is pass the client input and output streams to the \n     * serve() method of the specified Service object.  That method\n     * is responsible for reading from and writing to those streams to\n     * provide the actual service.  Recall that the Service object has been\n     * passed from the Server.addService() method to a Listener object\n     * to the ConnectionManager.addConnection() to this Connection object,\n     * and is now finally getting used to provide the service.\n     * Note that just before this thread exits it calls the \n     * ConnectionManager.endConnection() method to wake up the \n     * ConnectionManager thread so that it can remove this Connection\n     * from its list of active connections.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void serve(InputStream in, OutputStream out) throws IOException;\n","name":"serve","className":"Service","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"println":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));\n    out.println(new Date());\n    out.close();\n    i.close();\n}\n","name":"serve","className":"Time","variables":{"i":1,"out":3,"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"println":3,"print":2,"flush":1,"equals":1,"length":1,"readLine":1,"close":2,"charAt":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1,"int":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":42,"StringLiteralExpr":4,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":2,"ExpressionStmt":11},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o)));\n    out.println(\"Welcome to the line reversal server.\");\n    out.println(\"Enter lines.  End with a '.' on a line by itself\");\n    for (; ; ) {\n        out.print(\"> \");\n        out.flush();\n        String line = in.readLine();\n        if ((line == null) || line.equals(\".\"))\n            break;\n        for (int j = line.length() - 1; j >= 0; j--) out.print(line.charAt(j));\n        out.println();\n    }\n    out.close();\n    in.close();\n}\n","name":"serve","className":"Reverse","variables":{"in":3,"line":5,"i":1,"j":3,"out":8,"o":1},"constants":{"0":1,"1":1,"null":1,"\".\"":1,"\"Welcome to the line reversal server.\"":1,"\"Enter lines.  End with a '.' on a line by itself\"":1,"\"> \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"println":4,"length":1,"readLine":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":2,"EnclosedExpr":1,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));\n    out.println(\"HTTP/1.0 200 \");\n    out.println(\"Content-Type: text/plain\");\n    out.println();\n    String line;\n    while ((line = in.readLine()) != null) {\n        if (line.length() == 0)\n            break;\n        out.println(line);\n    }\n    out.close();\n    in.close();\n}\n","name":"serve","className":"HTTPMirror","variables":{"in":3,"line":3,"i":1,"out":6,"o":1},"constants":{"0":1,"null":1,"\"Content-Type: text/plain\"":1,"\"HTTP/1.0 200 \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"public synchronized int nextId() {\n    return id++;\n}\n","name":"nextId","className":"UniqueID","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"println":1,"nextId":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));\n    out.println(\"You are client #: \" + nextId());\n    out.close();\n    i.close();\n}\n","name":"serve","className":"UniqueID","variables":{"i":1,"out":3,"o":1},"constants":{"\"You are client #: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Server","String"],"returnType":"Control","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Create a new Control service.  It will control the specified Server\n     * object, and will require the specified password for authorization\n     * Note that this Service does not have a no argument constructor, which\n     * means that it cannot be dynamically instantiated and added as the other,\n     * generic services above can be.\n     **/\npublic Control(Server server, String password) {\n    this.server = server;\n    this.password = password;\n}\n","name":"Control","className":"Control","variables":{"server":1,"password":1},"constants":{},"javaDoc":"Create a new Control service It will control the specified Server object and will require the specified password for authorization Note that this Service does not have a no argument constructor which means that it cannot be dynamically instantiated and added as the other generic services above can be","comments":"\n     * Create a new Control service.  It will control the specified Server\n     * object, and will require the specified password for authorization\n     * Note that this Service does not have a no argument constructor, which\n     * means that it cannot be dynamically instantiated and added as the other,\n     * generic services above can be.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"server.connectionManager.setMaxConnections":1,"hasMoreTokens":1,"getName":1,"forName":1,"listener.service.getClass":1,"toLowerCase":1,"newInstance":1,"readLine":1,"parseInt":3,"server.connectionManager.printConnections":1,"println":16,"print":1,"flush":1,"removeService":1,"addService":1,"nextToken":6,"hasMoreElements":1,"equals":8,"server.services.keys":1,"server.services.get":1,"close":3,"nextElement":1},"annotations":[],"exceptions":["IOException","NoSuchMethodError","IllegalArgumentException","Exception"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"Integer":1,"StringTokenizer":1,"boolean":1,"Enumeration":1,"Listener":1,"BufferedReader":1,"Service":1,"Class":1,"String":4,"int":4,"PrintWriter":1},"expressions":{"ObjectCreationExpr":6,"VariableDeclarationExpr":17,"BinaryExpr":13,"NameExpr":197,"StringLiteralExpr":33,"UnaryExpr":5,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":4,"CastExpr":3,"FieldAccessExpr":8,"ThisExpr":2,"MethodCallExpr":53},"statements":{"ContinueStmt":1,"IfStmt":15,"WhileStmt":1,"BreakStmt":2,"BlockStmt":19,"TryStmt":2,"SynchronizedStmt":1,"ReturnStmt":1,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":47},"text":"/**\n     * This is the serve method that provides the service.  It reads a line \n     * the client, and uses java.util.StringTokenizer to parse it into\n     * commands and arguments.  It does various things depending on the \n     * command.\n     **/\npublic void serve(InputStream i, OutputStream o) throws IOException {\n    // Setup the streams\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));\n    String line;\n    // Has the user has given the password yet?\n    boolean authorized = false;\n    int num;\n    // synchronized block to prevent a race condition.\n    synchronized (this) {\n        if (connected) {\n            out.println(\"ONLY ONE CONTROL CONNECTION ALLOWED AT A TIME.\");\n            out.close();\n            return;\n        } else\n            connected = true;\n    }\n    for (; ; ) {\n        // infinite loop\n        // Display a prompt\n        out.print(\"> \");\n        // Make it appear right away\n        out.flush();\n        // Get the user's input\n        line = in.readLine();\n        // Quit if we get EOF.\n        if (line == null)\n            break;\n        try {\n            // Use a StringTokenizer to parse the user's command\n            StringTokenizer t = new StringTokenizer(line);\n            // if input was blank line\n            if (!t.hasMoreTokens())\n                continue;\n            // Get the first word of the input and convert to lower case\n            String command = t.nextToken().toLowerCase();\n            // appropriate thing for each command\n            if (command.equals(\"password\")) {\n                // Password command\n                // Get the next word of input\n                String p = t.nextToken();\n                if (p.equals(this.password)) {\n                    // Does it equal the password\n                    // Say so\n                    out.println(\"OK\");\n                    // Grant authorization\n                    authorized = true;\n                } else\n                    // Otherwise fail\n                    out.println(\"INVALID PASSWORD\");\n            } else if (command.equals(\"add\")) {\n                // Check whether password has been given\n                if (!authorized)\n                    out.println(\"PASSWORD REQUIRED\");\n                else {\n                    // Get the name of the service and try to dynamically load\n                    // and instantiate it.  Exceptions will be handled below\n                    String serviceName = t.nextToken();\n                    Class serviceClass = Class.forName(serviceName);\n                    Service service;\n                    try {\n                        service = (Service) serviceClass.newInstance();\n                    } catch (NoSuchMethodError e) {\n                        throw new IllegalArgumentException(\"Service must have a \" + \"no-argument constructor\");\n                    }\n                    int port = Integer.parseInt(t.nextToken());\n                    // If no exceptions occurred, add the service\n                    server.addService(service, port);\n                    // acknowledge\n                    out.println(\"SERVICE ADDED\");\n                }\n            } else if (command.equals(\"remove\")) {\n                // Remove service command\n                if (!authorized)\n                    out.println(\"PASSWORD REQUIRED\");\n                else {\n                    // get port\n                    int port = Integer.parseInt(t.nextToken());\n                    // remove the service on it\n                    server.removeService(port);\n                    // acknowledge\n                    out.println(\"SERVICE REMOVED\");\n                }\n            } else if (command.equals(\"max\")) {\n                // Set max connection limit\n                if (!authorized)\n                    out.println(\"PASSWORD REQUIRED\");\n                else {\n                    // get limit\n                    int max = Integer.parseInt(t.nextToken());\n                    // set limit\n                    server.connectionManager.setMaxConnections(max);\n                    // acknowledge\n                    out.println(\"MAX CONNECTIONS CHANGED\");\n                }\n            } else if (command.equals(\"status\")) {\n                // Status Display command\n                if (!authorized)\n                    out.println(\"PASSWORD REQUIRED\");\n                else {\n                    // Display a list of all services currently running\n                    Enumeration keys = server.services.keys();\n                    while (keys.hasMoreElements()) {\n                        Integer port = (Integer) keys.nextElement();\n                        Listener listener = (Listener) server.services.get(port);\n                        out.println(\"SERVICE \" + listener.service.getClass().getName() + \" ON PORT \" + port);\n                    }\n                    // Display a list of all current connections\n                    server.connectionManager.printConnections(out);\n                    // Display the current connection limit\n                    out.println(\"MAX CONNECTIONS: \" + server.connectionManager.maxConnections);\n                }\n            } else if (command.equals(\"help\")) {\n                // Help command\n                // Display command syntax.  Password not required\n                out.println(\"COMMANDS:\\n\" + \"\\tpassword <password>\\n\" + \"\\tadd <service> <port>\\n\" + \"\\tremove <port>\\n\" + \"\\tmax <max-connections>\\n\" + \"\\tstatus\\n\" + \"\\thelp\\n\" + \"\\tquit\");\n            } else if (// Quit command.  Exit.\n            command.equals(\"quit\"))\n                // Quit command.  Exit.\n                break;\n            else\n                // Unknown command error\n                out.println(\"UNRECOGNIZED COMMAND\");\n        } catch (Exception e) {\n            out.println(\"EXCEPTION WHILE PARSING OR EXECUTING COMMAND:\");\n            out.println(e);\n        }\n    }\n    // Finally, when the loop command loop ends, close the streams\n    // and set our connected flag to false so that other clients can\n    // now connect.\n    out.close();\n    in.close();\n    connected = false;\n}\n       // If there is already a client connected to this service, display a\n\n       // message to this client and close the connection.  We use a \n\n           // Now compare it to each of the possible commands, doing the\n\n                                                   // Add Service command\n\n           // If an exception occurred during the command, print an error\n\n           // message, then output details of the exception.\n\n","name":"serve","className":"Control","variables":{"server":2,"serviceClass":2,"in":3,"e":2,"max":1,"line":4,"keys":3,"num":1,"listener":1,"i":1,"serviceName":1,"command":8,"out":21,"o":1,"connected":3,"p":2,"Integer":3,"t":8,"port":4,"service":2,"authorized":6,"Class":1},"constants":{"\"remove\"":1,"\"> \"":1,"\"\\tstatus\\n\"":1,"\"add\"":1,"\"\\tmax <max-connections>\\n\"":1,"\"SERVICE REMOVED\"":1,"\"PASSWORD REQUIRED\"":4,"\"MAX CONNECTIONS: \"":1,"\"status\"":1,"\"Service must have a \"":1,"\"\\thelp\\n\"":1,"\"quit\"":1,"\"\\tadd <service> <port>\\n\"":1,"\"EXCEPTION WHILE PARSING OR EXECUTING COMMAND:\"":1,"\"\\tpassword <password>\\n\"":1,"false":2,"\"no-argument constructor\"":1,"\"password\"":1,"\"MAX CONNECTIONS CHANGED\"":1,"\"\\tremove <port>\\n\"":1,"\"COMMANDS:\\n\"":1,"\"UNRECOGNIZED COMMAND\"":1,"\"ONLY ONE CONTROL CONNECTION ALLOWED AT A TIME.\"":1,"\"max\"":1,"\"help\"":1,"\"SERVICE \"":1,"null":1,"\"OK\"":1,"\" ON PORT \"":1,"\"INVALID PASSWORD\"":1,"true":2,"\"SERVICE ADDED\"":1,"\"\\tquit\"":1},"javaDoc":"This is the serve method that provides the service It reads a line the client and uses java util StringTokenizer to parse it into commands and arguments It does various things depending on the command","comments":"If there is already a client connected to this service display a message to this client and close the connection We use a Finally when the loop command loop ends close the streams and set our connected flag to false so that other clients can Setup the streams Has the user has given the password yet? synchronized block to prevent a race condition infinite loop Display a prompt Make it appear right away Get the user's input Quit if we get EOF Now compare it to each of the possible commands doing the Use a StringTokenizer to parse the user's command if input was blank line Get the first word of the input and convert to lower case appropriate thing for each command Password command Get the next word of input Does it equal the password Say so Grant authorization Otherwise fail Add Service command Check whether password has been given Get the name of the service and try to dynamically load and instantiate it Exceptions will be handled below If no exceptions occurred add the service acknowledge Remove service command get port remove the service on it acknowledge Set max connection limit get limit set limit acknowledge Status Display command Display a list of all services currently running Display a list of all current connections Display the current connection limit Help command Display command syntax Password not required Quit command Exit Quit command Exit Unknown command error If an exception occurred during the command print an error message then output details of the exception now connect \n     * This is the serve method that provides the service.  It reads a line \n     * the client, and uses java.util.StringTokenizer to parse it into\n     * commands and arguments.  It does various things depending on the \n     * command.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// Called when the user clicks.\npublic boolean mouseDown(Event e, int x, int y) {\n    // Remember the location of the click.\n    last_x = x;\n    // Remember the location of the click.\n    last_y = y;\n    return true;\n}\n","name":"mouseDown","className":"Scribble","variables":{"last_x":1,"x":1,"last_y":1,"y":1},"constants":{"true":1},"javaDoc":"","comments":"Remember the location of the click Remember the location of the click  Called when the user clicks.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":13,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"// Called when the mouse moves with the button down\npublic boolean mouseDrag(Event e, int x, int y) {\n    // Get a Graphics to draw with.\n    Graphics g = getGraphics();\n    // Draw a line from last point to this.\n    g.drawLine(last_x, last_y, x, y);\n    // And update the saved location.\n    last_x = x;\n    // And update the saved location.\n    last_y = y;\n    return true;\n}\n","name":"mouseDrag","className":"Scribble","variables":{"g":2,"last_x":1,"x":1,"last_y":1,"y":1},"constants":{"true":1},"javaDoc":"","comments":"Get a Graphics to draw with Draw a line from last point to this And update the saved location And update the saved location  Called when the mouse moves with the button down","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":5,"MethodCallExpr":5,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"// Initialize the applet\npublic void init() {\n    this.setBackground(Color.lightGray);\n    image = this.getImage(this.getDocumentBase(), \"tiger.gif\");\n    background = this.getImage(this.getDocumentBase(), \"background.gif\");\n}\n","name":"init","className":"GraphicsSampler","variables":{"image":1,"background":1},"constants":{"\"tiger.gif\"":1,"\"background.gif\"":1},"javaDoc":"","comments":" Initialize the applet","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"centerText":8,"drawOval":1,"fillArc":1,"fillRoundRect":1,"cos":1,"drawLine":1,"drawArc":1,"getWidth":1,"fillRect":1,"clearRect":1,"drawImage":1,"getHeight":1,"setColor":12,"draw3DRect":3,"fillPolygon":1,"drawRoundRect":1,"tile":1,"sin":1,"setFont":1,"fillOval":1,"drawRect":1,"drawPolygon":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Color":3,"int[]":2,"Font":1,"int":4},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":114,"VariableDeclarationExpr":11,"ArrayAccessExpr":6,"BinaryExpr":17,"NameExpr":188,"StringLiteralExpr":15,"UnaryExpr":1,"AssignExpr":4,"NullLiteralExpr":2,"BooleanLiteralExpr":3,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":4,"ArrayCreationExpr":2,"ThisExpr":4,"MethodCallExpr":42},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":52},"text":"// Draw the applet whenever necessary\npublic void paint(Graphics g) {\n    Color fill = new Color(200, 200, 200);\n    Color outline = Color.blue;\n    Color textcolor = Color.red;\n    Font font = new Font(\"sansserif\", Font.BOLD, 14);\n    g.setFont(font);\n    // get a background image and tile it\n    tile(g, this, background);\n    // Draw a line\n    g.setColor(outline);\n    g.drawLine(25, 10, 150, 80);\n    centerText(\"drawLine()\", null, g, textcolor, 25, 10, 150, 80);\n    // Draw an arc\n    g.setColor(fill);\n    g.fillArc(225, 10, 150, 80, 90, 135);\n    g.setColor(outline);\n    g.drawArc(225, 10, 150, 80, 90, 135);\n    centerText(\"fillArc()\", \"drawArc()\", g, textcolor, 225, 10, 150, 80);\n    // Draw a rectangle\n    g.setColor(fill);\n    g.fillRect(25, 110, 150, 80);\n    g.setColor(outline);\n    g.drawRect(25, 110, 150, 80);\n    centerText(\"fillRect()\", \"drawRect()\", g, textcolor, 25, 110, 150, 80);\n    // Draw a rounded rectangle\n    g.setColor(fill);\n    g.fillRoundRect(225, 110, 150, 80, 20, 20);\n    g.setColor(outline);\n    g.drawRoundRect(225, 110, 150, 80, 20, 20);\n    centerText(\"fillRoundRect()\", \"drawRoundRect()\", g, textcolor, 225, 110, 150, 80);\n    // Draw a 3D rectangle (clear an area for it first)\n    g.setColor(fill);\n    g.clearRect(20, 205, 160, 90);\n    g.draw3DRect(25, 210, 150, 80, true);\n    g.draw3DRect(26, 211, 148, 78, true);\n    g.draw3DRect(27, 212, 146, 76, true);\n    centerText(\"draw3DRect()\", \"x 3\", g, textcolor, 25, 210, 150, 80);\n    // Draw an oval\n    g.setColor(fill);\n    g.fillOval(225, 210, 150, 80);\n    g.setColor(outline);\n    g.drawOval(225, 210, 150, 80);\n    centerText(\"fillOval()\", \"drawOval()\", g, textcolor, 225, 210, 150, 80);\n    // Draw a polygon\n    int numpoints = 9;\n    int[] xpoints = new int[numpoints + 1];\n    int[] ypoints = new int[numpoints + 1];\n    for (int i = 0; i < numpoints; i++) {\n        double angle = 2 * Math.PI * i / numpoints;\n        xpoints[i] = (int) (100 + 75 * Math.cos(angle));\n        ypoints[i] = (int) (350 - 40 * Math.sin(angle));\n    }\n    g.setColor(fill);\n    g.fillPolygon(xpoints, ypoints, numpoints);\n    g.setColor(outline);\n    xpoints[numpoints] = xpoints[0];\n    ypoints[numpoints] = ypoints[0];\n    g.drawPolygon(xpoints, ypoints, numpoints + 1);\n    centerText(\"fillPolygon()\", \"drawPolygon()\", g, textcolor, 25, 310, 150, 80);\n    // Center and draw an image\n    int w = image.getWidth(this);\n    int h = image.getHeight(this);\n    g.drawImage(image, 225 + (150 - w) / 2, 310 + (80 - h) / 2, this);\n    centerText(\"drawImage()\", null, g, textcolor, 225, 310, 150, 80);\n}\n","name":"paint","className":"GraphicsSampler","variables":{"image":2,"ypoints":4,"xpoints":4,"g":29,"textcolor":1,"h":2,"i":6,"fill":1,"Math":2,"numpoints":8,"outline":1,"w":2,"angle":1,"font":1},"constants":{"\"sansserif\"":1,"25":8,"26":1,"\"drawRoundRect()\"":1,"27":1,"\"drawOval()\"":1,"\"fillArc()\"":1,"\"drawArc()\"":1,"150":19,"\"fillRect()\"":1,"\"drawPolygon()\"":1,"350":1,"\"x 3\"":1,"110":6,"210":5,"211":1,"310":3,"135":2,"212":1,"90":3,"75":1,"10":5,"76":1,"78":1,"14":1,"\"fillPolygon()\"":1,"\"drawRect()\"":1,"160":1,"\"fillOval()\"":1,"\"drawImage()\"":1,"0":3,"1":3,"100":1,"200":3,"2":3,"146":1,"null":2,"225":11,"148":1,"\"fillRoundRect()\"":1,"205":1,"80":19,"\"drawLine()\"":1,"true":3,"9":1,"\"draw3DRect()\"":1,"40":1,"20":5},"javaDoc":"","comments":"get a background image and tile it Draw a line Draw an arc Draw a rectangle Draw a rounded rectangle Draw a 3D rectangle (clear an area for it first) Draw an oval Draw a polygon Center and draw an image  Draw the applet whenever necessary","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Component","Image"],"returnType":"void","methodCalls":{"drawImage":1,"getHeight":1,"getWidth":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1,"int":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":32,"FieldAccessExpr":2,"EnclosedExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":4},"text":"// Utility method to tile an image on the background\nprotected void tile(Graphics g, Component c, Image i) {\n    // use c.bounds() in Java 1.0.x\n    Rectangle r = c.getBounds();\n    int iw = i.getWidth(c);\n    int ih = i.getHeight(c);\n    if ((iw <= 0) || (ih <= 0))\n        return;\n    for (int x = 0; x < r.width; x += iw) for (int y = 0; y < r.height; y += ih) g.drawImage(i, x, y, c);\n}\n","name":"tile","className":"GraphicsSampler","variables":{"r":1,"c":1,"g":1,"x":3,"i":2,"y":3,"iw":3,"ih":3},"constants":{"0":4},"javaDoc":"","comments":"use c bounds() in Java 1 0 x  Utility method to tile an image on the background","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String","Graphics","Color","int","int","int","int"],"returnType":"void","methodCalls":{"getFontMetrics":1,"getAscent":1,"stringWidth":2,"getHeight":1,"setColor":1,"getDefaultToolkit":1,"getFont":1,"drawString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"FontMetrics":1,"Font":1,"int":3},"expressions":{"IntegerLiteralExpr":10,"NullLiteralExpr":3,"VariableDeclarationExpr":5,"DoubleLiteralExpr":2,"BinaryExpr":20,"NameExpr":65,"CastExpr":2,"EnclosedExpr":6,"MethodCallExpr":10,"AssignExpr":7},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":15},"text":"// Utility method to center text in a rectangle\nprotected void centerText(String s1, String s2, Graphics g, Color c, int x, int y, int w, int h) {\n    Font f = g.getFont();\n    FontMetrics fm = Toolkit.getDefaultToolkit().getFontMetrics(f);\n    int ascent = fm.getAscent();\n    int height = fm.getHeight();\n    int width1 = 0, width2 = 0, x0 = 0, x1 = 0, y0 = 0, y1 = 0;\n    width1 = fm.stringWidth(s1);\n    if (s2 != null)\n        width2 = fm.stringWidth(s2);\n    x0 = x + (w - width1) / 2;\n    x1 = x + (w - width2) / 2;\n    if (s2 == null)\n        y0 = y + (h - height) / 2 + ascent;\n    else {\n        y0 = y + (h - (int) (height * 2.2)) / 2 + ascent;\n        y1 = y0 + (int) (height * 1.2);\n    }\n    g.setColor(c);\n    g.drawString(s1, x0, y0);\n    if (s2 != null)\n        g.drawString(s2, x1, y1);\n}\n","name":"centerText","className":"GraphicsSampler","variables":{"f":1,"g":4,"fm":5,"h":2,"width2":3,"width1":3,"ascent":3,"y0":4,"w":2,"x0":2,"y1":2,"x":2,"x1":2,"y":2,"Toolkit":1,"height":4,"s2":3},"constants":{"0":6,"2":4,"null":3,"1.2":1,"2.2":1},"javaDoc":"","comments":" Utility method to center text in a rectangle","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"System.out.flush":1,"getWarnings":1,"length":1,"getMoreResults":1,"getMessage":2,"getUpdateCount":2,"getSQLState":2,"readLine":1,"execute":1,"createStatement":1,"getConnection":1,"getResultSet":1,"equals":1,"printResultsTable":1,"System.err.println":5,"getNextWarning":1,"close":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"SQLWarning":1,"boolean":1,"Statement":1,"Connection":1,"BufferedReader":1,"ResultSet":1,"String":2,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":4,"VariableDeclarationExpr":10,"ArrayAccessExpr":7,"BinaryExpr":20,"StringLiteralExpr":18,"NameExpr":153,"UnaryExpr":5,"InstanceOfExpr":1,"AssignExpr":7,"NullLiteralExpr":8,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":11,"EnclosedExpr":2,"MethodCallExpr":31},"statements":{"ContinueStmt":1,"IfStmt":10,"WhileStmt":1,"BreakStmt":1,"TryStmt":3,"BlockStmt":13,"ForStmt":2,"ThrowStmt":2,"ExpressionStmt":25,"DoStmt":1},"text":"public static void main(String[] args) {\n    // Our JDBC connection to the database server\n    Connection conn = null;\n    try {\n        String driver = null, url = null, user = \"\", password = \"\";\n        // Parse all the command-line arguments\n        for (int n = 0; n < args.length; n++) {\n            if (args[n].equals(\"-d\"))\n                driver = args[++n];\n            else if (args[n].equals(\"-u\"))\n                user = args[++n];\n            else if (args[n].equals(\"-p\"))\n                password = args[++n];\n            else if (url == null)\n                url = args[n];\n            else\n                throw new IllegalArgumentException(\"Unknown argument.\");\n        }\n        // The only required argument is the database URL.\n        if (url == null)\n            throw new IllegalArgumentException(\"No database specified\");\n        // to register itself with the DriverManager.\n        if (driver != null)\n            Class.forName(driver);\n        // Now open a connection the specified database, using the user-specified\n        // username and password, if any.  The driver manager will try all of\n        // the DB drivers it knows about to try to parse the URL and connect to\n        // the DB server.\n        conn = DriverManager.getConnection(url, user, password);\n        // Now create the statement object we'll use to talk to the DB\n        Statement s = conn.createStatement();\n        // Get a stream to read from the console\n       // If the user specified the classname for the DB driver, load\n\n       // that class dynamically.  This gives the driver the opportunity\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        // Loop forever, reading the user's queries and executing them\n        while (true) {\n            // prompt the user\n            System.out.print(\"sql> \");\n            // make the prompt appear immediately\n            System.out.flush();\n            // get a line of input from the user\n            String sql = in.readLine();\n            // Quit when the user types \"quit\".\n            if ((sql == null) || sql.equals(\"quit\"))\n                break;\n            // Ignore blank lines\n            if (sql.length() == 0)\n                continue;\n            // Now, attempt to execute the user's line of SQL and display results.\n            try {\n                // We don't know if this is a query or some kind of update, so we\n                // use execute() instead of executeQuery() or executeUpdate()\n                // If the return value is true, it was a query, else an update\n                boolean status = s.execute(sql);\n                // Loop until there are no more results to return\n                do {\n                    if (status) {\n                        // statement was a query that returns a ResultSet\n                        // Get the set of results and display them\n                        ResultSet rs = s.getResultSet();\n                        printResultsTable(rs, System.out);\n                    } else {\n                        // If the SQL command that was executed was some kind of update\n                        // rather than a query, then it doesn't return a ResultSet.\n                        // Instead, we just print the number of rows that were affected.\n                        int numUpdates = s.getUpdateCount();\n                        System.out.println(\"Ok. \" + numUpdates + \" rows affected.\");\n                    }\n                    // Now go see if there are even more results, and\n                    // continue the results display loop if there are.\n                    status = s.getMoreResults();\n                // With some buggy JDBC drivers, this condition causes an infinite\n                // loop with SQL updates. If that happens, change to: while(status); \n                } while (status || s.getUpdateCount() != -1);\n            }// returned by getSQLState()\n             catch (SQLException e) {\n                System.err.println(\"SQLException: \" + e.getMessage() + \":\" + e.getSQLState());\n            } finally // Each time through this loop, check to see if any warnings were\n            // issued.  Note that there can be a whole chain of warnings.\n            {\n                // print out any warnings that occurred\n                for (SQLWarning w = conn.getWarnings(); w != null; w = w.getNextWarning()) System.err.println(\"WARNING: \" + w.getMessage() + \":\" + w.getSQLState());\n            }\n        }\n    }// connection setup, etc.  For SQLExceptions, print the details.\n     catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQL State: \" + ((SQLException) e).getSQLState());\n         // If a SQLException is thrown, display an error message.  Note that\n\n         // SQLExceptions can have a general message and a DB-specific message\n\n        System.err.println(\"Usage: java ExecuteSQL [-d <driver>] [-u <user>] \" + \"[-p <password>] <database URL>\");\n    } finally // Be sure to always close the database connection when we exit, whether\n    // we exit because the user types 'quit' or because of an exception thrown\n    // while setting things up.  Closing this connection also implicitly\n    // closes any open statements and result sets associated with it.\n    {\n        try {\n            conn.close();\n        } catch (Exception e) {\n        }\n    }\n}\n     // Handle exceptions that occur during argument parsing, database\n\n","name":"main","className":"ExecuteSQL","variables":{"rs":1,"conn":5,"in":2,"e":7,"url":4,"n":10,"sql":4,"args":7,"numUpdates":2,"password":2,"s":6,"driver":3,"w":6,"Class":1,"user":2,"DriverManager":1,"status":4},"constants":{"\"\"":2,"\"quit\"":1,"\"Unknown argument.\"":1,"\"-u\"":1,"\":\"":2,"\" rows affected.\"":1,"\"-p\"":1,"\"sql> \"":1,"0":2,"1":1,"null":8,"\"[-p <password>] <database URL>\"":1,"\"No database specified\"":1,"true":1,"\"-d\"":1,"\"SQLException: \"":1,"\"WARNING: \"":1,"\"SQL State: \"":1,"\"Ok. \"":1,"\"Usage: java ExecuteSQL [-d <driver>] [-u <user>] \"":1},"javaDoc":"","comments":"Our JDBC connection to the database server Handle exceptions that occur during argument parsing database Be sure to always close the database connection when we exit whether we exit because the user types 'quit' or because of an exception thrown while setting things up Closing this connection also implicitly If the user specified the classname for the DB driver load that class dynamically This gives the driver the opportunity Now open a connection the specified database using the user-specified username and password if any The driver manager will try all of the DB drivers it knows about to try to parse the URL and connect to Parse all the command-line arguments The only required argument is the database URL to register itself with the DriverManager the DB server Now create the statement object we'll use to talk to the DB Get a stream to read from the console Loop forever reading the user's queries and executing them prompt the user make the prompt appear immediately get a line of input from the user Quit when the user types \"quit\" Ignore blank lines Now attempt to execute the user's line of SQL and display results If a SQLException is thrown display an error message Note that SQLExceptions can have a general message and a DB-specific message Each time through this loop check to see if any warnings were We don't know if this is a query or some kind of update so we use execute() instead of executeQuery() or executeUpdate() If the return value is true it was a query else an update Loop until there are no more results to return Now go see if there are even more results and With some buggy JDBC drivers this condition causes an infinite loop with SQL updates If that happens change to: while(status); statement was a query that returns a ResultSet Get the set of results and display them If the SQL command that was executed was some kind of update rather than a query then it doesn't return a ResultSet Instead we just print the number of rows that were affected continue the results display loop if there are returned by getSQLState() issued Note that there can be a whole chain of warnings print out any warnings that occurred connection setup etc For SQLExceptions print the details closes any open statements and result sets associated with it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResultSet","OutputStream"],"returnType":"void","methodCalls":{"next":1,"getObject":1,"getColumnLabel":1,"setCharAt":4,"insert":2,"getColumnCount":1,"println":5,"trim":1,"flush":1,"toString":3,"getMetaData":1,"overwrite":4,"getColumnDisplaySize":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"StringBuffer":3,"int[]":2,"Object":1,"String[]":1,"int":10,"PrintWriter":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":20,"VariableDeclarationExpr":19,"ArrayAccessExpr":15,"BinaryExpr":21,"NameExpr":155,"StringLiteralExpr":3,"CharLiteralExpr":5,"UnaryExpr":6,"AssignExpr":8,"EnclosedExpr":1,"ArrayCreationExpr":3,"MethodCallExpr":28},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":5,"ForStmt":5,"ExpressionStmt":38},"text":"/**\n   * This method attempts to output the contents of a ResultSet in a \n   * textual table.  It relies on the ResultSetMetaData class, but a fair\n   * bit of the code is simple string manipulation.\n   **/\nstatic void printResultsTable(ResultSet rs, OutputStream output) throws SQLException {\n    // Set up the output stream\n    PrintWriter out = new PrintWriter(new OutputStreamWriter(output));\n    // Get some \"meta data\" (column names, etc.) about the results\n    ResultSetMetaData metadata = rs.getMetaData();\n    // Variables to hold important data about the table to be displayed\n    // how many columns\n    int numcols = metadata.getColumnCount();\n    // the column labels\n    String[] labels = new String[numcols];\n    // the width of each\n    int[] colwidths = new int[numcols];\n    // start position of each\n    int[] colpos = new int[numcols];\n    // total width of table\n    int linewidth;\n    // Figure out how wide the columns are, where each one begins, \n    // how wide each row of the table will be, etc.\n    // for the initial '|'.\n    linewidth = 1;\n    for (int i = 0; i < numcols; i++) {\n        // for each column\n        // save its position\n        colpos[i] = linewidth;\n        // get its label \n        labels[i] = metadata.getColumnLabel(i + 1);\n        // Get the column width.  If the db doesn't report one, guess\n        // 30 characters.  Then check the length of the label, and use\n        // it if it is larger than the column width\n        int size = metadata.getColumnDisplaySize(i + 1);\n        // some drivers return -1...\n        if (size == -1)\n            size = 30;\n        int labelsize = labels[i].length();\n        if (labelsize > size)\n            size = labelsize;\n        // save the column the size  \n        colwidths[i] = size + 1;\n        // increment total size\n        linewidth += colwidths[i] + 2;\n    }\n    // Create a horizontal divider line we use in the table.\n    // Also create a blank line that is the initial value of each \n    // line of the table\n    StringBuffer divider = new StringBuffer(linewidth);\n    StringBuffer blankline = new StringBuffer(linewidth);\n    for (int i = 0; i < linewidth; i++) {\n        divider.insert(i, '-');\n        blankline.insert(i, \" \");\n    }\n    // Put special marks in the divider line at the column positions\n    for (int i = 0; i < numcols; i++) divider.setCharAt(colpos[i] - 1, '+');\n    divider.setCharAt(linewidth - 1, '+');\n    // Begin the table output with a divider line\n    out.println(divider);\n    // The next line of the table contains the column labels.\n    // Begin with a blank line, and put the column names and column\n    // divider characters \"|\" into it.  overwrite() is defined below.\n    StringBuffer line = new StringBuffer(blankline.toString());\n    line.setCharAt(0, '|');\n    for (int i = 0; i < numcols; i++) {\n        int pos = colpos[i] + 1 + (colwidths[i] - labels[i].length()) / 2;\n        overwrite(line, pos, labels[i]);\n        overwrite(line, colpos[i] + colwidths[i], \" |\");\n    }\n    // Then output the line of column labels and another divider\n    out.println(line);\n    out.println(divider);\n    // we did for the column labels above.\n    while (rs.next()) {\n        line = new StringBuffer(blankline.toString());\n        line.setCharAt(0, '|');\n        for (int i = 0; i < numcols; i++) {\n            Object value = rs.getObject(i + 1);\n            overwrite(line, colpos[i] + 1, value.toString().trim());\n            overwrite(line, colpos[i] + colwidths[i], \" |\");\n        }\n        out.println(line);\n    }\n    // Finally, end the table with one last divider line.\n    out.println(divider);\n    out.flush();\n}\n     // Now, output the table data.  Loop through the ResultSet, using\n\n     // the next() method to get the rows one at a time. Obtain the \n\n     // value of each column with getObject(), and output it, much as \n\n","name":"printResultsTable","className":"ExecuteSQL","variables":{"rs":3,"labelsize":3,"metadata":4,"line":4,"i":33,"colpos":7,"colwidths":6,"linewidth":8,"out":7,"labels":5,"output":1,"blankline":4,"size":6,"divider":4,"pos":1,"numcols":8,"value":2},"constants":{"0":7,"1":10,"'-'":1,"2":2,"'|'":2,"'+'":2,"\" \"":1,"\" |\"":2,"30":1},"javaDoc":"This method attempts to output the contents of a ResultSet in a textual table It relies on the ResultSetMetaData class but a fair bit of the code is simple string manipulation","comments":"Variables to hold important data about the table to be displayed Figure out how wide the columns are where each one begins how wide each row of the table will be etc Create a horizontal divider line we use in the table Also create a blank line that is the initial value of each The next line of the table contains the column labels Begin with a blank line and put the column names and column Now output the table data Loop through the ResultSet using the next() method to get the rows one at a time Obtain the value of each column with getObject() and output it much as Set up the output stream Get some \"meta data\" (column names etc ) about the results how many columns the column labels the width of each start position of each total width of table for the initial '|' for each column Get the column width If the db doesn't report one guess 30 characters Then check the length of the label and use save its position get its label it if it is larger than the column width some drivers return -1 save the column the size increment total size line of the table Put special marks in the divider line at the column positions Begin the table output with a divider line divider characters \"|\" into it overwrite() is defined below Then output the line of column labels and another divider we did for the column labels above Finally end the table with one last divider line \n   * This method attempts to output the contents of a ResultSet in a \n   * textual table.  It relies on the ResultSetMetaData class, but a fair\n   * bit of the code is simple string manipulation.\n   *","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["StringBuffer","int","String"],"returnType":"void","methodCalls":{"length":1,"setCharAt":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":15,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"/** This utility method is used when printing the table of results */\nstatic void overwrite(StringBuffer b, int pos, String s) {\n    int len = s.length();\n    for (int i = 0; i < len; i++) b.setCharAt(pos + i, s.charAt(i));\n}\n","name":"overwrite","className":"ExecuteSQL","variables":{"b":1,"s":2,"len":2,"pos":1,"i":4},"constants":{"0":1},"javaDoc":"This utility method is used when printing the table of results","comments":" This utility method is used when printing the table of results ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["double","double","double","double","double","double"],"returnType":"Spiral","methodCalls":{"max":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":7,"EnclosedExpr":2,"UnaryExpr":1,"ThisExpr":7,"AssignExpr":9,"MethodCallExpr":1},"statements":{"IfStmt":2,"ThrowStmt":1,"ExpressionStmt":9},"text":"/**\n     * The constructor.  It takes arguments for the center of the shape, the\n     * start point, and the end point.  The start and end points are specified\n     * in terms of angle and radius.  The spiral curve is formed by varying\n     * the angle and radius smoothly between the two end points.\n     **/\npublic Spiral(double centerX, double centerY, double startRadius, double startAngle, double endRadius, double endAngle) {\n    // Save the parameters that describe the spiral\n    this.centerX = centerX;\n    this.centerY = centerY;\n    this.startRadius = startRadius;\n    this.startAngle = startAngle;\n    this.endRadius = endRadius;\n    this.endAngle = endAngle;\n    // figure out the maximum radius, and the spiral direction\n    this.outerRadius = Math.max(startRadius, endRadius);\n    if (startAngle < endAngle)\n        angleDirection = 1;\n    else\n        angleDirection = -1;\n    if ((startRadius < 0) || (endRadius < 0))\n        throw new IllegalArgumentException(\"Spiral radii must be >= 0\");\n}\n","name":"Spiral","className":"Spiral","variables":{"centerY":1,"startAngle":2,"centerX":1,"endAngle":2,"startRadius":2,"angleDirection":2,"Math":1,"endRadius":2},"constants":{"0":2,"\"Spiral radii must be >= 0\"":1,"1":2},"javaDoc":"The constructor It takes arguments for the center of the shape the start point and the end point The start and end points are specified in terms of angle and radius The spiral curve is formed by varying the angle and radius smoothly between the two end points","comments":"Save the parameters that describe the spiral figure out the maximum radius and the spiral direction \n     * The constructor.  It takes arguments for the center of the shape, the\n     * start point, and the end point.  The start and end points are specified\n     * in terms of angle and radius.  The spiral curve is formed by varying\n     * the angle and radius smoothly between the two end points.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":4,"CastExpr":4,"NameExpr":6,"EnclosedExpr":4},"statements":{"ReturnStmt":1},"text":"/** \n     * The bounding box of a Spiral is the same as the bounding box of a\n     * circle with the same center and the maximum radius\n     **/\npublic Rectangle getBounds() {\n    return new Rectangle((int) (centerX - outerRadius), (int) (centerY - outerRadius), (int) (outerRadius * 2), (int) (outerRadius * 2));\n}\n","name":"getBounds","className":"Spiral","variables":{"outerRadius":4,"centerY":1,"centerX":1},"constants":{"2":2},"javaDoc":"The bounding box of a Spiral is the same as the bounding box of a circle with the same center and the maximum radius","comments":" \n     * The bounding box of a Spiral is the same as the bounding box of a\n     * circle with the same center and the maximum radius\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle2D","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":6},"statements":{"ReturnStmt":1},"text":"/** Same as getBounds(), but with floating-point coordinates */\npublic Rectangle2D getBounds2D() {\n    return new Rectangle2D.Double(centerX - outerRadius, centerY - outerRadius, outerRadius * 2, outerRadius * 2);\n}\n","name":"getBounds2D","className":"Spiral","variables":{"outerRadius":4,"centerY":1,"centerX":1},"constants":{"2":2},"javaDoc":"Same as getBounds() but with floating-point coordinates","comments":" Same as getBounds(), but with floating-point coordinates ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n     * A spiral is an open curve, not a not a closed area; it does not have an\n     * inside and an outsize, so the contains() methods always return false.\n     **/\npublic boolean contains(double x, double y) {\n    return false;\n}\n","name":"contains","className":"Spiral","variables":{},"constants":{"false":1},"javaDoc":"A spiral is an open curve not a not a closed area; it does not have an inside and an outsize so the contains() methods always return false","comments":" \n     * A spiral is an open curve, not a not a closed area; it does not have an\n     * inside and an outsize, so the contains() methods always return false.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point2D"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(Point2D p) {\n    return false;\n}\n","name":"contains","className":"Spiral","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rectangle2D"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(Rectangle2D r) {\n    return false;\n}\n","name":"contains","className":"Spiral","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double","double","double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(double x, double y, double w, double h) {\n    return false;\n}\n","name":"contains","className":"Spiral","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double","double","double"],"returnType":"boolean","methodCalls":{"intersects":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Shape":1,"Double":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":13,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This method is allowed to approximate if it would be too computationally\n     * intensive to determine an exact answer.  Therefore, we check whether\n     * the rectangle intersects a circle of the outer radius.  This is a good\n     * guess for a tight spiral, but less good for a \"loose\" spiral. \n     **/\npublic boolean intersects(double x, double y, double w, double h) {\n    Shape approx = new Ellipse2D.Double(centerX - outerRadius, centerY - outerRadius, outerRadius * 2, outerRadius * 2);\n    return approx.intersects(x, y, w, h);\n}\n","name":"intersects","className":"Spiral","variables":{"outerRadius":4,"centerY":1,"centerX":1,"approx":2},"constants":{"2":2},"javaDoc":"This method is allowed to approximate if it would be too computationally intensive to determine an exact answer Therefore we check whether the rectangle intersects a circle of the outer radius This is a good guess for a tight spiral but less good for a \"loose\" spiral","comments":"\n     * This method is allowed to approximate if it would be too computationally\n     * intensive to determine an exact answer.  Therefore, we check whether\n     * the rectangle intersects a circle of the outer radius.  This is a good\n     * guess for a tight spiral, but less good for a \"loose\" spiral. \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rectangle2D"],"returnType":"boolean","methodCalls":{"getX":1,"getHeight":1,"getY":1,"intersects":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":14,"MethodCallExpr":5},"statements":{"ReturnStmt":1},"text":"/** This version of intersects() just calls the one above */\npublic boolean intersects(Rectangle2D r) {\n    return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n}\n","name":"intersects","className":"Spiral","variables":{"r":4},"constants":{},"javaDoc":"This version of intersects() just calls the one above","comments":" This version of intersects() just calls the one above ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform"],"returnType":"PathIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"DoubleLiteralExpr":1,"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * This method is the heart of all Shape implementations.  It returns a\n     * PathIterator that describes the shape in terms of the line and curve\n     * segments that comprise it.  Our iterator implementation approximates\n     * the shape of the spiral using line segments only.  We pass in a\n     * \"flatness\" argument that tells it how good the approximation must be.\n     * (smaller numbers mean a better approximation).\n     */\npublic PathIterator getPathIterator(AffineTransform at) {\n    return new SpiralIterator(at, outerRadius / 500.0);\n}\n","name":"getPathIterator","className":"Spiral","variables":{"outerRadius":1,"at":1},"constants":{"500.0":1},"javaDoc":"This method is the heart of all Shape implementations It returns a PathIterator that describes the shape in terms of the line and curve segments that comprise it Our iterator implementation approximates the shape of the spiral using line segments only We pass in a \"flatness\" argument that tells it how good the approximation must be (smaller numbers mean a better approximation)","comments":"\n     * This method is the heart of all Shape implementations.  It returns a\n     * PathIterator that describes the shape in terms of the line and curve\n     * segments that comprise it.  Our iterator implementation approximates\n     * the shape of the spiral using line segments only.  We pass in a\n     * \"flatness\" argument that tells it how good the approximation must be.\n     * (smaller numbers mean a better approximation).\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform","double"],"returnType":"PathIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * Return a PathIterator that describes the shape in terms of line\n     * segments only, with an approximation quality specified by flatness.\n     **/\npublic PathIterator getPathIterator(AffineTransform at, double flatness) {\n    return new SpiralIterator(at, flatness);\n}\n","name":"getPathIterator","className":"Spiral","variables":{"at":1,"flatness":1},"constants":{},"javaDoc":"Return a PathIterator that describes the shape in terms of line segments only with an approximation quality specified by flatness","comments":"\n     * Return a PathIterator that describes the shape in terms of line\n     * segments only, with an approximation quality specified by flatness.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform","double"],"returnType":"SpiralIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** A simple constructor.  Just store the parameters into fields */\npublic SpiralIterator(AffineTransform transform, double flatness) {\n    this.transform = transform;\n    this.flatness = flatness;\n}\n","name":"SpiralIterator","className":"SpiralIterator","variables":{"transform":1,"flatness":1},"constants":{},"javaDoc":"A simple constructor Just store the parameters into fields","comments":" A simple constructor.  Just store the parameters into fields ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n\t * All PathIterators have a \"winding rule\" that helps to specify what\n\t * is the inside of a area and what is the outside.  If you fill a\n\t * spiral (which you're not supposed to do) the winding rule returned\n\t * here yields better results than the alternative, WIND_EVEN_ODD\n\t **/\npublic int getWindingRule() {\n    return WIND_NON_ZERO;\n}\n","name":"getWindingRule","className":"SpiralIterator","variables":{"WIND_NON_ZERO":1},"constants":{},"javaDoc":"All PathIterators have a \"winding rule\" that helps to specify what is the inside of a area and what is the outside If you fill a spiral (which you're not supposed to do) the winding rule returned here yields better results than the alternative WIND_EVEN_ODD","comments":" \n\t * All PathIterators have a \"winding rule\" that helps to specify what\n\t * is the inside of a area and what is the outside.  If you fill a\n\t * spiral (which you're not supposed to do) the winding rule returned\n\t * here yields better results than the alternative, WIND_EVEN_ODD\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Returns true if the entire path has been iterated */\npublic boolean isDone() {\n    return done;\n}\n","name":"isDone","className":"SpiralIterator","variables":{"done":1},"constants":{},"javaDoc":"Returns true if the entire path has been iterated","comments":" Returns true if the entire path has been iterated ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float[]"],"returnType":"int","methodCalls":{"transform":1,"cos":1,"sin":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"NullLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":7,"BooleanLiteralExpr":1,"NameExpr":27,"CastExpr":2,"EnclosedExpr":2,"AssignExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":3,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n\t * Store the coordinates of the current segment of the path into the\n\t * specified array, and return the type of the segment.  Use\n\t * trigonometry to compute the coordinates based on the current angle\n\t * and radius.  If this was the first point, return a MOVETO segment,\n\t * otherwise return a LINETO segment. Also, check to see if we're done.\n\t **/\npublic int currentSegment(float[] coords) {\n    // given the radius and the angle, compute the point coords\n    coords[0] = (float) (centerX + radius * Math.cos(angle));\n    coords[1] = (float) (centerY - radius * Math.sin(angle));\n    // If a transform was specified, use it on the coordinates\n    if (transform != null)\n        transform.transform(coords, 0, coords, 0, 1);\n    // If we've reached the end of the spiral remember that fact\n    if (angle == endAngle)\n        done = true;\n    // If this is the first point in the spiral then move to it\n    if (angle == startAngle)\n        return SEG_MOVETO;\n    // Otherwise draw a line from the previous point to this one\n    return SEG_LINETO;\n}\n","name":"currentSegment","className":"SpiralIterator","variables":{"centerY":1,"transform":2,"startAngle":1,"centerX":1,"SEG_LINETO":1,"endAngle":1,"angle":2,"radius":2,"Math":2,"done":1,"SEG_MOVETO":1,"coords":2},"constants":{"0":3,"1":2,"null":1,"true":1},"javaDoc":"Store the coordinates of the current segment of the path into the specified array and return the type of the segment Use trigonometry to compute the coordinates based on the current angle and radius If this was the first point return a MOVETO segment otherwise return a LINETO segment Also check to see if we're done","comments":"given the radius and the angle compute the point coords If a transform was specified use it on the coordinates If we've reached the end of the spiral remember that fact If this is the first point in the spiral then move to it Otherwise draw a line from the previous point to this one \n\t * Store the coordinates of the current segment of the path into the\n\t * specified array, and return the type of the segment.  Use\n\t * trigonometry to compute the coordinates based on the current angle\n\t * and radius.  If this was the first point, return a MOVETO segment,\n\t * otherwise return a LINETO segment. Also, check to see if we're done.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double[]"],"returnType":"int","methodCalls":{"transform":1,"cos":1,"sin":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"NullLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":7,"BooleanLiteralExpr":1,"NameExpr":27,"AssignExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":3,"ReturnStmt":2,"ExpressionStmt":4},"text":"/** This method is the same as above, except using double values */\npublic int currentSegment(double[] coords) {\n    coords[0] = centerX + radius * Math.cos(angle);\n    coords[1] = centerY - radius * Math.sin(angle);\n    if (transform != null)\n        transform.transform(coords, 0, coords, 0, 1);\n    if (angle == endAngle)\n        done = true;\n    if (angle == startAngle)\n        return SEG_MOVETO;\n    else\n        return SEG_LINETO;\n}\n","name":"currentSegment","className":"SpiralIterator","variables":{"centerY":1,"transform":2,"startAngle":1,"centerX":1,"SEG_LINETO":1,"endAngle":1,"angle":2,"radius":2,"Math":2,"done":1,"SEG_MOVETO":1,"coords":2},"constants":{"0":3,"1":2,"null":1,"true":1},"javaDoc":"This method is the same as above except using double values","comments":" This method is the same as above, except using double values ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"acos":1,"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":3},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"DoubleLiteralExpr":1,"BinaryExpr":20,"NameExpr":36,"FieldAccessExpr":1,"EnclosedExpr":5,"MethodCallExpr":2,"AssignExpr":4},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"/** \n\t * Move on to the next segment of the path.  Compute the angle and\n\t * radius values for the next point in the spiral.\n\t **/\npublic void next() {\n    if (done)\n        return;\n    // First, figure out how much to increment the angle.  This\n    // depends on the required flatness, and also upon the current\n    // radius.  When drawing a circle (which we'll use as our\n    // approximation) of radius r, we can maintain a flatness f by\n    // using angular increments given by this formula:\n    //      a = acos(2*(f/r)*(f/r) - 4*(f/r) + 1)\n    // Use this formula to figure out how much we can increment the\n    // angle for the next segment.  Note that the formula does not\n    // work well for very small radii, so we special case those.\n    double x = flatness / radius;\n    if (Double.isNaN(x) || (x > .1))\n        angle += Math.PI / 4 * angleDirection;\n    else {\n        double y = 2 * x * x - 4 * x + 1;\n        angle += Math.acos(y) * angleDirection;\n    }\n    // Check whether we've gone past the end of the spiral\n    if ((angle - endAngle) * angleDirection > 0)\n        angle = endAngle;\n    // Now that we know the new angle, we can use interpolation to\n    // figure out what the corresponding radius is.\n    double fractionComplete = (angle - startAngle) / (endAngle - startAngle);\n    radius = startRadius + (endRadius - startRadius) * fractionComplete;\n}\n","name":"next","className":"SpiralIterator","variables":{"startAngle":2,"flatness":1,"endAngle":3,"startRadius":2,"Math":1,"done":1,"Double":1,"endRadius":1,"fractionComplete":2,"x":5,"angle":5,"y":1,"angleDirection":3,"radius":2},"constants":{"0":1,"1":1,"2":1,".1":1,"4":2},"javaDoc":"Move on to the next segment of the path Compute the angle and radius values for the next point in the spiral","comments":"First figure out how much to increment the angle This depends on the required flatness and also upon the current radius When drawing a circle (which we'll use as our approximation) of radius r we can maintain a flatness f by using angular increments given by this formula: a = acos(2 (f/r) (f/r) - 4 (f/r) + 1) Use this formula to figure out how much we can increment the angle for the next segment Note that the formula does not Now that we know the new angle we can use interpolation to work well for very small radii so we special case those Check whether we've gone past the end of the spiral figure out what the corresponding radius is  \n\t * Move on to the next segment of the path.  Compute the angle and\n\t * radius values for the next point in the spiral.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ColorModel","Rectangle","Rectangle2D","AffineTransform","RenderingHints"],"returnType":"PaintContext","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is the main Paint method;  all it does is return a PaintContext */\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    return new RandomPaintContext();\n}\n","name":"createContext","className":"RandomPaint","variables":{},"constants":{},"javaDoc":"This is the main Paint method; all it does is return a PaintContext","comments":" This is the main Paint method;  all it does is return a PaintContext ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This Paint object only uses opaque colors */\npublic int getTransparency() {\n    return OPAQUE;\n}\n","name":"getTransparency","className":"RandomPaint","variables":{"OPAQUE":1},"constants":{},"javaDoc":"This Paint object only uses opaque colors","comments":" This Paint object only uses opaque colors ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ColorModel","methodCalls":{"getColorModel":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the color model used by this Paint implementation */\npublic ColorModel getColorModel() {\n    return image.getColorModel();\n}\n","name":"getColorModel","className":"RandomPaintContext","variables":{"image":1},"constants":{},"javaDoc":"Return the color model used by this Paint implementation","comments":" Return the color model used by this Paint implementation ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int"],"returnType":"Raster","methodCalls":{"getHeight":1,"setColor":1,"createGraphics":1,"getWidth":1,"nextInt":3,"fillRect":1,"getData":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":7,"BinaryExpr":5,"NameExpr":54,"FieldAccessExpr":5,"EnclosedExpr":3,"MethodCallExpr":9,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"/**\n\t * This is the main method of PaintContext.  It must return a Raster\n\t * that contains fill data for the specified rectangle.  For this \n\t * implementation, we just fill with a random solid color each time.\n\t * Instead of setting pixels at the Raster level, we instead \n\t * manipulate a BufferedImage using the Graphics.fillRect() method.\n\t * Note that we never create an image larger than we need.\n\t **/\npublic Raster getRaster(int x, int y, int w, int h) {\n    // Create an initial image or a larger image as needed\n    if ((image == null) || (image.getWidth() < w) || (image.getHeight() < h)) {\n        image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n        imageGraphics = image.createGraphics();\n    }\n    // Choose and use a random color\n    imageGraphics.setColor(new Color(randomizer.nextInt(256), randomizer.nextInt(256), randomizer.nextInt(256)));\n    // Fill a rectangle of the specified size with that color\n    imageGraphics.fillRect(0, 0, w, h);\n    // Then extract the corresponding Raster from the image and return\n    rect.x = 0;\n    rect.y = 0;\n    rect.width = w;\n    rect.height = h;\n    return image.getData(rect);\n}\n","name":"getRaster","className":"RandomPaintContext","variables":{"image":6,"imageGraphics":3,"w":3,"h":3,"randomizer":3},"constants":{"0":4,"256":3,"null":1},"javaDoc":"This is the main method of PaintContext It must return a Raster that contains fill data for the specified rectangle For this implementation we just fill with a random solid color each time Instead of setting pixels at the Raster level we instead manipulate a BufferedImage using the Graphics fillRect() method Note that we never create an image larger than we need","comments":"Create an initial image or a larger image as needed Choose and use a random color Fill a rectangle of the specified size with that color Then extract the corresponding Raster from the image and return \n\t * This is the main method of PaintContext.  It must return a Raster\n\t * that contains fill data for the specified rectangle.  For this \n\t * implementation, we just fill with a random solid color each time.\n\t * Instead of setting pixels at the Raster level, we instead \n\t * manipulate a BufferedImage using the Graphics.fillRect() method.\n\t * Note that we never create an image larger than we need.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/** Called when the PaintContext is no longer needed. */\npublic void dispose() {\n    imageGraphics.dispose();\n    image = null;\n    imageGraphics = null;\n}\n","name":"dispose","className":"RandomPaintContext","variables":{"image":1,"imageGraphics":2},"constants":{"null":2},"javaDoc":"Called when the PaintContext is no longer needed","comments":" Called when the PaintContext is no longer needed. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setFont":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2,"Font":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":4,"BinaryExpr":8,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":4},"text":"// Draw the applet.  \npublic void paint(Graphics g) {\n    for (int f = 0; f < families.length; f++) {\n        // for each family\n        for (int s = 0; s < styles.length; s++) {\n            // for each style\n            // create font\n            Font font = new Font(families[f], styles[s], 18);\n            // set font\n            g.setFont(font);\n            // create name\n            String name = families[f] + \" \" + stylenames[s];\n            // display name\n            g.drawString(name, 20, (f * 4 + s + 1) * 20);\n        }\n    }\n}\n","name":"paint","className":"FontList","variables":{"s":6,"stylenames":1,"f":6,"g":2,"name":1,"styles":1,"families":2,"font":1},"constants":{"0":2,"1":1,"\" \"":1,"4":1,"18":1,"20":2},"javaDoc":"","comments":"for each family for each style create font set font create name display name  Draw the applet.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ColorModel","Rectangle","Rectangle2D","AffineTransform","RenderingHints"],"returnType":"PaintContext","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is the main Paint method;  all it does is return a PaintContext */\npublic PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {\n    return new GenericPaintContext(xform);\n}\n","name":"createContext","className":"GenericPaint","variables":{"xform":1},"constants":{},"javaDoc":"This is the main Paint method; all it does is return a PaintContext","comments":" This is the main Paint method;  all it does is return a PaintContext ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This paint class allows translucent painting */\npublic int getTransparency() {\n    return TRANSLUCENT;\n}\n","name":"getTransparency","className":"GenericPaint","variables":{"TRANSLUCENT":1},"constants":{},"javaDoc":"This paint class allows translucent painting","comments":" This paint class allows translucent painting ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/**\n     * These three methods return the red, green, blue, and alpha values of\n     * the pixel at appear at the specified user-space coordinates.  The return\n     * value of each method should be between 0 and 255.\n     **/\npublic abstract int computeRed(double x, double y);\n","name":"computeRed","className":"GenericPaint","variables":{},"constants":{},"javaDoc":"These three methods return the red green blue and alpha values of the pixel at appear at the specified user-space coordinates The return value of each method should be between 0 and 255","comments":"\n     * These three methods return the red, green, blue, and alpha values of\n     * the pixel at appear at the specified user-space coordinates.  The return\n     * value of each method should be between 0 and 255.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"public abstract int computeGreen(double x, double y);\n","name":"computeGreen","className":"GenericPaint","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"public abstract int computeBlue(double x, double y);\n","name":"computeBlue","className":"GenericPaint","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"public abstract int computeAlpha(double x, double y);\n","name":"computeAlpha","className":"GenericPaint","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["AffineTransform"],"returnType":"GenericPaintContext","methodCalls":{"transform":1,"createInverse":1,"deltaTransform":2},"annotations":[],"exceptions":["NoninvertibleTransformException"],"concepts":["ExceptionHandling"],"types":{"AffineTransform":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":17,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":19,"AssignExpr":7,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"public GenericPaintContext(AffineTransform userToDevice) {\n    // Our color model packs ARGB values into a single int\n    model = new DirectColorModel(32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);\n    // can compute the user space coordinates of each device pixel\n    try {\n        AffineTransform deviceToUser = userToDevice.createInverse();\n        origin = deviceToUser.transform(new Point(0, 0), null);\n        unitVectorX = deviceToUser.deltaTransform(new Point(1, 0), null);\n        unitVectorY = deviceToUser.deltaTransform(new Point(0, 1), null);\n    } catch (NoninvertibleTransformException e) {\n        origin = new Point(0, 0);\n        unitVectorX = new Point(1, 0);\n        unitVectorY = new Point(0, 1);\n    }\n}\n         // The specified transform converts user to device pixels\n\n         // We need to figure out the reverse transformation, so we\n\n         // If we can't invert the transform, just use device space\n\n","name":"GenericPaintContext","className":"GenericPaintContext","variables":{"e":1,"origin":2,"unitVectorX":2,"model":1,"userToDevice":1,"unitVectorY":2,"deviceToUser":4},"constants":{"0":8,"0x0000ff00":1,"1":4,"null":3,"0x00ff0000":1,"0x000000ff":1,"0xff000000":1,"32":1},"javaDoc":"","comments":"The specified transform converts user to device pixels We need to figure out the reverse transformation so we Our color model packs ARGB values into a single int can compute the user space coordinates of each device pixel If we can't invert the transform just use device space ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ColorModel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the color model used by this Paint implementation */\npublic ColorModel getColorModel() {\n    return model;\n}\n","name":"getColorModel","className":"GenericPaintContext","variables":{"model":1},"constants":{},"javaDoc":"Return the color model used by this Paint implementation","comments":" Return the color model used by this Paint implementation ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int"],"returnType":"Raster","methodCalls":{"getX":3,"getY":3,"setPixel":1,"computeGreen":1,"computeAlpha":1,"computeBlue":1,"createCompatibleWritableRaster":1,"computeRed":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WritableRaster":1,"double":2,"int[]":1,"int":4},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":12,"NameExpr":64,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":12,"AssignExpr":4},"statements":{"BlockStmt":2,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":11},"text":"/**\n\t * This is the main method of PaintContext.  It must return a Raster\n\t * that contains fill data for the specified rectangle.  It creates a\n\t * raster of the specified size, and loops through the device pixels.\n\t * For each one, it converts the coordinates to user space, then calls\n\t * the computeRed(), computeGreen() and computeBlue() methods to\n\t * obtain the appropriate color for the device pixel.\n\t **/\npublic Raster getRaster(int x, int y, int w, int h) {\n    WritableRaster raster = model.createCompatibleWritableRaster(w, h);\n    int[] colorComponents = new int[4];\n    for (int j = 0; j < h; j++) {\n        // Loop through rows of raster\n        int deviceY = y + j;\n        for (int i = 0; i < w; i++) {\n            // Loop through columns\n            int deviceX = x + i;\n            // Convert device coordinate to user-space coordinate\n            double userX = origin.getX() + deviceX * unitVectorX.getX() + deviceY * unitVectorY.getX();\n            double userY = origin.getY() + deviceX * unitVectorX.getY() + deviceY * unitVectorY.getY();\n            // Compute the color components of the pixel\n            colorComponents[0] = computeRed(userX, userY);\n            colorComponents[1] = computeGreen(userX, userY);\n            colorComponents[2] = computeBlue(userX, userY);\n            colorComponents[3] = computeAlpha(userX, userY);\n            // Set the color of the pixel\n            raster.setPixel(i, j, colorComponents);\n        }\n    }\n    return raster;\n}\n","name":"getRaster","className":"GenericPaintContext","variables":{"origin":2,"raster":3,"h":1,"userY":1,"i":4,"j":4,"userX":1,"colorComponents":5,"w":1,"x":1,"unitVectorX":2,"y":1,"model":1,"deviceX":3,"deviceY":3,"unitVectorY":2},"constants":{"0":3,"1":1,"2":1,"3":1,"4":1},"javaDoc":"This is the main method of PaintContext It must return a Raster that contains fill data for the specified rectangle It creates a raster of the specified size and loops through the device pixels For each one it converts the coordinates to user space then calls the computeRed() computeGreen() and computeBlue() methods to obtain the appropriate color for the device pixel","comments":"Loop through rows of raster Loop through columns Convert device coordinate to user-space coordinate Compute the color components of the pixel Set the color of the pixel \n\t * This is the main method of PaintContext.  It must return a Raster\n\t * that contains fill data for the specified rectangle.  It creates a\n\t * raster of the specified size, and loops through the device pixels.\n\t * For each one, it converts the coordinates to user space, then calls\n\t * the computeRed(), computeGreen() and computeBlue() methods to\n\t * obtain the appropriate color for the device pixel.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Called when the PaintContext is no longer needed. */\npublic void dispose() {\n}\n","name":"dispose","className":"GenericPaintContext","variables":{},"constants":{},"javaDoc":"Called when the PaintContext is no longer needed","comments":" Called when the PaintContext is no longer needed. ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Stroking\";\n}\n","name":"getName","className":"Stroking","variables":{},"constants":{"\"Stroking\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"Stroking","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"Stroking","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setColor":1,"createStrokedShape":1,"createRegularPolygon":1,"setStroke":1,"setFont":1,"draw":2,"fill":2,"translate":4,"drawString":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"BasicStroke":1,"Shape":2},"expressions":{"IntegerLiteralExpr":23,"ObjectCreationExpr":3,"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"NameExpr":67,"StringLiteralExpr":7,"FieldAccessExpr":2,"UnaryExpr":6,"MethodCallExpr":19},"statements":{"ExpressionStmt":20},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // Create the shape we'll work with.  See convenience method below.\n    Shape pentagon = createRegularPolygon(5, 75);\n    // Set up basic drawing attributes\n    // Draw in black\n    g.setColor(Color.black);\n    // Use thin lines\n    g.setStroke(new BasicStroke(1.0f));\n    // Basic small font\n    g.setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n    // Move to position\n    g.translate(100, 100);\n    // Outline the shape\n    g.draw(pentagon);\n    // Draw the caption\n    g.drawString(\"The shape\", -30, 90);\n    // Move over\n    g.translate(175, 0);\n    // Fill the shape\n    g.fill(pentagon);\n    // Another caption\n    g.drawString(\"The filled shape\", -50, 90);\n    // Now use a Stroke object to create a \"stroked shape\" for our shape\n    BasicStroke wideline = new BasicStroke(10.0f);\n    Shape outline = wideline.createStrokedShape(pentagon);\n    // Move over\n    g.translate(175, 0);\n    // Draw the stroked shape\n    g.draw(outline);\n    // Draw the caption\n    g.drawString(\"A Stroke creates\", -50, 90);\n    g.drawString(\"a new shape\", -35, 105);\n    // Move over\n    g.translate(175, 0);\n    // Fill the stroked shape\n    g.fill(outline);\n    // Draw the caption\n    g.drawString(\"Filling the new shape\", -65, 90);\n    g.drawString(\"outlines the old one\", -65, 105);\n}\n","name":"draw","className":"Stroking","variables":{"outline":1,"g":17,"wideline":2,"pentagon":1},"constants":{"12":1,"35":1,"1.0f":1,"\"SansSerif\"":1,"10.0f":1,"\"A Stroke creates\"":1,"175":3,"0":3,"100":2,"\"a new shape\"":1,"5":1,"105":2,"90":4,"\"outlines the old one\"":1,"\"The shape\"":1,"\"Filling the new shape\"":1,"50":2,"30":1,"\"The filled shape\"":1,"75":1,"65":2},"javaDoc":"Draw the example","comments":"Set up basic drawing attributes Create the shape we'll work with See convenience method below Draw in black Use thin lines Basic small font Move to position Outline the shape Draw the caption Move over Fill the shape Another caption Now use a Stroke object to create a \"stroked shape\" for our shape Move over Draw the stroked shape Draw the caption Move over Fill the stroked shape Draw the caption  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Shape","methodCalls":{"cos":1,"sin":1,"addPoint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"Polygon":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":23,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":2,"UnaryExpr":2,"MethodCallExpr":3},"statements":{"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// A convenience method to define a regular polygon.\n// Returns a shape that represents a regular polygon with the specified\n// radius and number of sides, and centered at the origin.\npublic Shape createRegularPolygon(int numsides, int radius) {\n    Polygon p = new Polygon();\n    // Angle between vertices\n    double angle = 2 * Math.PI / numsides;\n    for (// Compute location of each vertex\n    int i = 0; // Compute location of each vertex\n    i < numsides; // Compute location of each vertex\n    i++) p.addPoint((int) (radius * Math.sin(angle * i)), (int) (radius * -Math.cos(angle * i)));\n    return p;\n}\n","name":"createRegularPolygon","className":"Stroking","variables":{"p":3,"numsides":2,"angle":3,"i":5,"radius":2,"Math":2},"constants":{"0":1,"2":1},"javaDoc":"","comments":"Angle between vertices Compute location of each vertex Compute location of each vertex Compute location of each vertex  radius and number of sides, and centered at the origin.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Shapes\";\n}\n","name":"getName","className":"Shapes","variables":{},"constants":{"\"Shapes\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"Shapes","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"Shapes","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setRenderingHint":1,"setColor":2,"setFont":1,"setStroke":1,"draw":1,"fill":1,"translate":3,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":13,"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":60,"StringLiteralExpr":1,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // Set basic drawing attributes\n    // select font\n    g.setFont(new Font(\"SansSerif\", Font.PLAIN, 10));\n    // 2 pixel lines\n    g.setStroke(new BasicStroke(2.0f));\n    // antialiasing\n    g.setRenderingHint(// antialiasing\n    RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    // margins\n    g.translate(10, 10);\n    // Loop through each shape\n    for (int i = 0; i < shapes.length; i++) {\n        // Set a color\n        g.setColor(Color.yellow);\n        // Fill the shape with it\n        g.fill(shapes[i]);\n        // Switch to black\n        g.setColor(Color.black);\n        // Outline the shape with it\n        g.draw(shapes[i]);\n        // Label the shape\n        g.drawString(labels[i], 0, 110);\n        // Move over for next shape\n        g.translate(120, 0);\n        // Move down after 6\n        if (i % 6 == 5)\n            g.translate(-6 * 120, 120);\n    }\n}\n","name":"draw","className":"Shapes","variables":{"shapes":2,"g":11,"i":7,"labels":1},"constants":{"0":3,"110":1,"2.0f":1,"5":1,"6":2,"\"SansSerif\"":1,"10":3,"120":3},"javaDoc":"Draw the example","comments":"Set basic drawing attributes select font 2 pixel lines antialiasing antialiasing antialiasing margins Loop through each shape Set a color Fill the shape with it Switch to black Outline the shape with it Label the shape Move over for next shape Move down after 6  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Custom Strokes\";\n}\n","name":"getName","className":"CustomStrokes","variables":{},"constants":{"\"Custom Strokes\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"CustomStrokes","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"CustomStrokes","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setRenderingHint":1,"getOutline":1,"createGlyphVector":1,"setColor":1,"getFontRenderContext":1,"setStroke":1,"draw":1,"translate":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"GlyphVector":1,"Shape":1,"Font":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":6,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":47,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // Get a shape to work with.  Here we'll use the letter B\n    Font f = new Font(\"Serif\", Font.BOLD, 200);\n    GlyphVector gv = f.createGlyphVector(g.getFontRenderContext(), \"B\");\n    Shape shape = gv.getOutline();\n    // Set drawing attributes and starting position\n    g.setColor(Color.black);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g.translate(10, 175);\n    // Draw the shape once with each stroke\n    for (int i = 0; i < strokes.length; i++) {\n        // set the stroke\n        g.setStroke(strokes[i]);\n        // draw the shape\n        g.draw(shape);\n        // move to the right\n        g.translate(140, 0);\n    }\n}\n","name":"draw","className":"CustomStrokes","variables":{"strokes":1,"shape":1,"f":2,"g":7,"i":4,"gv":2},"constants":{"0":2,"200":1,"\"B\"":1,"\"Serif\"":1,"140":1,"10":1,"175":1},"javaDoc":"Draw the example","comments":"Get a shape to work with Here we'll use the letter B Set drawing attributes and starting position Draw the shape once with each stroke set the stroke draw the shape move to the right  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Shape"],"returnType":"Shape","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Shape createStrokedShape(Shape s) {\n    return s;\n}\n","name":"createStrokedShape","className":"NullStroke","variables":{"s":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float","float"],"returnType":"DoubleStroke","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public DoubleStroke(float width1, float width2) {\n    // Constructor arguments specify\n    stroke1 = new BasicStroke(width1);\n    // the line widths for the strokes\n    stroke2 = new BasicStroke(width2);\n}\n","name":"DoubleStroke","className":"DoubleStroke","variables":{"stroke1":1,"stroke2":1,"width2":1,"width1":1},"constants":{},"javaDoc":"","comments":"Constructor arguments specify the line widths for the strokes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Shape"],"returnType":"Shape","methodCalls":{"createStrokedShape":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Shape":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Shape createStrokedShape(Shape s) {\n    // Use the first stroke to create an outline of the shape\n    Shape outline = stroke1.createStrokedShape(s);\n    // It is this outline of the outline that will be filled in\n    return stroke2.createStrokedShape(outline);\n}\n     // Use the second stroke to create an outline of that outline.\n\n","name":"createStrokedShape","className":"DoubleStroke","variables":{"stroke1":1,"outline":1,"stroke2":1},"constants":{},"javaDoc":"","comments":"Use the second stroke to create an outline of that outline Use the first stroke to create an outline of the shape It is this outline of the outline that will be filled in ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float"],"returnType":"ControlPointsStroke","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public ControlPointsStroke(float radius) {\n    this.radius = radius;\n}\n","name":"ControlPointsStroke","className":"ControlPointsStroke","variables":{"radius":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Shape"],"returnType":"Shape","methodCalls":{"next":1,"getPathIterator":1,"currentSegment":1,"isDone":1,"markPoint":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Shape":1,"GeneralPath":1,"PathIterator":1,"int":1,"float[]":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":7,"NullLiteralExpr":4,"VariableDeclarationExpr":5,"DoubleLiteralExpr":1,"ArrayAccessExpr":6,"NameExpr":48,"FieldAccessExpr":5,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"SwitchStmt":1,"BreakStmt":1,"BlockStmt":1,"SwitchEntryStmt":5,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":7},"text":"public Shape createStrokedShape(Shape shape) {\n    // Start off by stroking the shape with a thin line.  Store the\n    // resulting shape in a GeneralPath object so we can add to it.\n    GeneralPath strokedShape = new GeneralPath(new BasicStroke(1.0f).createStrokedShape(shape));\n    // Use a PathIterator object to iterate through each of the line and\n    // curve segments of the shape.  For each one, mark the endpoint and\n    // control points (if any) by adding a rectangle to the GeneralPath\n    float[] coords = new float[6];\n    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {\n        int type = i.currentSegment(coords);\n        Shape s = null, s2 = null, s3 = null;\n        switch(type) {\n            case PathIterator.SEG_CUBICTO:\n                // falls through\n                markPoint(strokedShape, coords[4], coords[5]);\n            case PathIterator.SEG_QUADTO:\n                // falls through\n                markPoint(strokedShape, coords[2], coords[3]);\n            case PathIterator.SEG_MOVETO:\n            case PathIterator.SEG_LINETO:\n                // falls through\n                markPoint(strokedShape, coords[0], coords[1]);\n            case PathIterator.SEG_CLOSE:\n                break;\n        }\n    }\n    return strokedShape;\n}\n","name":"createStrokedShape","className":"ControlPointsStroke","variables":{"s3":1,"s":1,"shape":1,"i":4,"type":2,"strokedShape":2,"coords":7,"s2":1},"constants":{"0":1,"1":1,"2":1,"3":1,"null":4,"4":1,"1.0f":1,"5":1,"6":1},"javaDoc":"","comments":"Start off by stroking the shape with a thin line Store the Use a PathIterator object to iterate through each of the line and curve segments of the shape For each one mark the endpoint and resulting shape in a GeneralPath object so we can add to it control points (if any) by adding a rectangle to the GeneralPath falls through falls through falls through ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GeneralPath","float","float"],"returnType":"void","methodCalls":{"closePath":1,"lineTo":3,"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"NameExpr":31,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/** Add a small square centered at (x,y) to the specified path */\nvoid markPoint(GeneralPath path, float x, float y) {\n    // Begin a new sub-path\n    path.moveTo(x - radius, y - radius);\n    // Add a line segment to it\n    path.lineTo(x + radius, y - radius);\n    // Add a second line segment\n    path.lineTo(x + radius, y + radius);\n    // And a third\n    path.lineTo(x - radius, y + radius);\n    // Go back to last moveTo position\n    path.closePath();\n}\n","name":"markPoint","className":"ControlPointsStroke","variables":{"path":5,"x":4,"y":4,"radius":8},"constants":{},"javaDoc":"Add a small square centered at (x y) to the specified path","comments":"Begin a new sub-path Add a line segment to it Add a second line segment And a third Go back to last moveTo position  Add a small square centered at (x,y) to the specified path ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["float","float"],"returnType":"SloppyStroke","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public SloppyStroke(float width, float sloppiness) {\n    // Used to stroke modified shape\n    this.stroke = new BasicStroke(width);\n    // How sloppy should we be?\n    this.sloppiness = sloppiness;\n}\n","name":"SloppyStroke","className":"SloppyStroke","variables":{"width":1,"sloppiness":1},"constants":{},"javaDoc":"","comments":"Used to stroke modified shape How sloppy should we be? ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Shape"],"returnType":"Shape","methodCalls":{"next":1,"quadTo":1,"getPathIterator":1,"createStrokedShape":1,"closePath":1,"curveTo":1,"lineTo":1,"currentSegment":1,"isDone":1,"perturb":4,"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GeneralPath":1,"PathIterator":1,"int":1,"float[]":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":19,"NullLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":14,"NameExpr":74,"FieldAccessExpr":5,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"SwitchStmt":1,"BreakStmt":5,"BlockStmt":1,"SwitchEntryStmt":5,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":12},"text":"public Shape createStrokedShape(Shape shape) {\n    // Start with an empty shape\n    GeneralPath newshape = new GeneralPath();\n    // Iterate through the specified shape, perturb its coordinates, and\n    // use them to build up the new shape.\n    float[] coords = new float[6];\n    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {\n        int type = i.currentSegment(coords);\n        switch(type) {\n            case PathIterator.SEG_MOVETO:\n                perturb(coords, 2);\n                newshape.moveTo(coords[0], coords[1]);\n                break;\n            case PathIterator.SEG_LINETO:\n                perturb(coords, 2);\n                newshape.lineTo(coords[0], coords[1]);\n                break;\n            case PathIterator.SEG_QUADTO:\n                perturb(coords, 4);\n                newshape.quadTo(coords[0], coords[1], coords[2], coords[3]);\n                break;\n            case PathIterator.SEG_CUBICTO:\n                perturb(coords, 6);\n                newshape.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);\n                break;\n            case PathIterator.SEG_CLOSE:\n                newshape.closePath();\n                break;\n        }\n    }\n    // Finally, stroke the perturbed shape and return the result\n    return stroke.createStrokedShape(newshape);\n}\n","name":"createStrokedShape","className":"SloppyStroke","variables":{"shape":1,"i":4,"type":2,"newshape":6,"stroke":1,"coords":15},"constants":{"0":4,"1":4,"2":4,"3":2,"null":1,"4":2,"5":1,"6":2},"javaDoc":"","comments":"Iterate through the specified shape perturb its coordinates and Start with an empty shape use them to build up the new shape Finally stroke the perturbed shape and return the result ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float[]","int"],"returnType":"void","methodCalls":{"random":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"DoubleLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":9,"CastExpr":1,"EnclosedExpr":2,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"// Randomly modify the specified number of coordinates, by an amount\n// specified by the sloppiness field.\nvoid perturb(float[] coords, int numCoords) {\n    for (int i = 0; i < numCoords; i++) coords[i] += (float) ((Math.random() * 2 - 1.0) * sloppiness);\n}\n","name":"perturb","className":"SloppyStroke","variables":{"sloppiness":1,"i":4,"numCoords":1,"Math":1,"coords":1},"constants":{"0":1,"2":1,"1.0":1},"javaDoc":"","comments":" specified by the sloppiness field.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"AntiAliasing\";\n}\n","name":"getName","className":"AntiAlias","variables":{},"constants":{"\"AntiAliasing\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"AntiAlias","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"AntiAlias","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setRenderingHint":1,"drawImage":2,"drawOval":1,"setColor":2,"createGraphics":1,"setStroke":1,"setFont":1,"getScaleInstance":1,"fillRect":1,"drawString":1,"setPaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BufferedImage":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":21,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"NameExpr":67,"StringLiteralExpr":2,"FieldAccessExpr":8,"MethodCallExpr":13},"statements":{"ExpressionStmt":13},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    BufferedImage // Create an off-screen image\n    image = new BufferedImage(65, 35, BufferedImage.TYPE_INT_RGB);\n    // Get its Graphics for drawing\n    Graphics2D ig = image.createGraphics();\n    // Set the background to a gradient fill.  The varying color of\n    // the background helps to demonstrate the anti-aliasing effect\n    ig.setPaint(new GradientPaint(0, 0, Color.black, 65, 35, Color.white));\n    ig.fillRect(0, 0, 65, 35);\n    // Set drawing attributes for the foreground.\n    // Most importantly, turn on anti-aliasing.\n    // 2-pixel lines\n    ig.setStroke(new BasicStroke(2.0f));\n    // 18-point font\n    ig.setFont(new Font(\"Serif\", Font.BOLD, 18));\n    // Anti-alias!\n    ig.setRenderingHint(// Anti-alias!\n    RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    // Now draw pure blue text and a pure red oval\n    ig.setColor(Color.blue);\n    ig.drawString(\"Java\", 9, 22);\n    ig.setColor(Color.red);\n    ig.drawOval(1, 1, 62, 32);\n    // Finally, scale the image by a factor of 10 and display it\n    // in the window.  This will allow us to see the anti-aliased pixels\n    g.drawImage(image, AffineTransform.getScaleInstance(10, 10), c);\n    // Draw the image one more time at its original size, for comparison\n    g.drawImage(image, 0, 0, c);\n}\n","name":"draw","className":"AntiAlias","variables":{"image":2,"g":2,"AffineTransform":1,"ig":10},"constants":{"22":1,"35":3,"2.0f":1,"18":1,"0":6,"1":2,"9":1,"\"Java\"":1,"62":1,"\"Serif\"":1,"65":3,"32":1,"10":2},"javaDoc":"Draw the example","comments":"Set the background to a gradient fill The varying color of Set drawing attributes for the foreground Most importantly turn on anti-aliasing Finally scale the image by a factor of 10 and display it Create an off-screen image Get its Graphics for drawing the background helps to demonstrate the anti-aliasing effect 2-pixel lines 18-point font Anti-alias! Anti-alias! Anti-alias! Now draw pure blue text and a pure red oval in the window This will allow us to see the anti-aliased pixels Draw the image one more time at its original size for comparison  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"print":1,"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    // Get the currently displayed example, and call \n    // the print method (defined below)\n    print(examples[tpane.getSelectedIndex()]);\n}\n","name":"actionPerformed","className":"","variables":{"examples":1,"tpane":1},"constants":{},"javaDoc":"","comments":"Get the currently displayed example and call the print method (defined below) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    System.exit(0);\n}\n","name":"actionPerformed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GraphicsExample[]"],"returnType":"GraphicsExampleFrame","methodCalls":{"add":4,"exit":2,"addTab":1,"print":1,"getName":1,"addActionListener":2,"getContentPane":1,"getSelectedIndex":1,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"GraphicsExample":1,"Container":1,"JTabbedPane":1,"JMenuItem":2,"JMenuBar":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":1,"StringLiteralExpr":4,"NameExpr":67,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":16},"statements":{"BlockStmt":4,"ExplicitConstructorInvocationStmt":1,"ForStmt":1,"ExpressionStmt":20},"text":"public GraphicsExampleFrame(final GraphicsExample[] examples) {\n    super(\"GraphicsExampleFrame\");\n    // Set up the frame \n    Container cpane = getContentPane();\n    cpane.setLayout(new BorderLayout());\n    // And the tabbed pane \n    final JTabbedPane tpane = new JTabbedPane();\n    cpane.add(tpane, BorderLayout.CENTER);\n    // Add a menubar\n    // Create the menubar\n    JMenuBar menubar = new JMenuBar();\n    // Add it to the frame\n    this.setJMenuBar(menubar);\n    // Create a File menu\n    JMenu filemenu = new JMenu(\"File\");\n    // Add to the menubar\n    menubar.add(filemenu);\n    // Create a Print item\n    JMenuItem print = new JMenuItem(\"Print\");\n    // Add it to the menu\n    filemenu.add(print);\n    // Create a Quit item\n    JMenuItem quit = new JMenuItem(\"Quit\");\n    // Add it to the menu\n    filemenu.add(quit);\n    // Tell the Print menu item what to do when selected\n    print.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // Get the currently displayed example, and call \n            // the print method (defined below)\n            print(examples[tpane.getSelectedIndex()]);\n        }\n    });\n    // Tell the Quit menu item what to do when selected\n    quit.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n        }\n    });\n    // In addition to the Quit menu item, also handle window close events\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Insert each of the example objects into the tabbed pane\n    for (int i = 0; i < examples.length; i++) {\n        GraphicsExample e = examples[i];\n        tpane.addTab(e.getName(), new GraphicsExamplePane(e));\n    }\n}\n","name":"GraphicsExampleFrame","className":"GraphicsExampleFrame","variables":{"menubar":2,"actionPerformed":2,"print":2,"examples":2,"e":6,"windowClosing":1,"filemenu":3,"i":4,"quit":2,"tpane":3,"cpane":3,"System":2},"constants":{"0":3,"\"GraphicsExampleFrame\"":1,"\"Quit\"":1,"\"File\"":1,"\"Print\"":1},"javaDoc":"","comments":"Add a menubar Set up the frame And the tabbed pane Create the menubar Add it to the frame Create a File menu Add to the menubar Create a Print item Add it to the menu Create a Quit item Add it to the menu Tell the Print menu item what to do when selected Get the currently displayed example and call the print method (defined below) Tell the Quit menu item what to do when selected In addition to the Quit menu item also handle window close events Insert each of the example objects into the tabbed pane ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GraphicsExample"],"returnType":"GraphicsExamplePane","methodCalls":{"getHeight":1,"getWidth":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":10,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public GraphicsExamplePane(GraphicsExample example) {\n    this.example = example;\n    size = new Dimension(example.getWidth(), example.getHeight());\n}\n","name":"GraphicsExamplePane","className":"GraphicsExamplePane","variables":{"size":1,"example":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"draw":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":25,"CastExpr":1,"FieldAccessExpr":4,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Draw the component and the example it contains */\npublic void paintComponent(Graphics g) {\n    // set the background\n    g.setColor(Color.white);\n    // to white\n    g.fillRect(0, 0, size.width, size.height);\n    // set a default drawing color\n    g.setColor(Color.black);\n    // ask example to draw itself\n    example.draw((Graphics2D) g, this);\n}\n","name":"paintComponent","className":"GraphicsExamplePane","variables":{"g":4,"example":1},"constants":{"0":2},"javaDoc":"Draw the component and the example it contains","comments":"set the background to white set a default drawing color ask example to draw itself  Draw the component and the example it contains ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These methods specify how big the component must be\npublic Dimension getPreferredSize() {\n    return size;\n}\n","name":"getPreferredSize","className":"GraphicsExamplePane","variables":{"size":1},"constants":{},"javaDoc":"","comments":" These methods specify how big the component must be","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Dimension getMinimumSize() {\n    return size;\n}\n","name":"getMinimumSize","className":"GraphicsExamplePane","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GraphicsExample"],"returnType":"void","methodCalls":{"printDialog":1,"print":1,"getPrinterJob":1,"getMessage":1,"setPrintable":1,"System.out.println":1},"annotations":[],"exceptions":["PrinterException"],"concepts":["ExceptionHandling"],"types":{"PrinterJob":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/** This method is invoked by the Print menu item */\npublic void print(final GraphicsExample example) {\n    // Start off by getting a printer job to do the printing\n    PrinterJob job = PrinterJob.getPrinterJob();\n    // Wrap the example in a Printable object (defined below)\n    // and tell the PrinterJob that we want to print it\n    job.setPrintable(new PrintableExample(example));\n    // Display the print dialog to the user\n    if (job.printDialog()) {\n        // If they didn't cancel it, then tell the job to start printing\n        try {\n            job.print();\n        } catch (PrinterException e) {\n            System.out.println(\"Couldn't print: \" + e.getMessage());\n        }\n    }\n}\n","name":"print","className":"GraphicsExampleFrame","variables":{"e":2,"job":4,"PrinterJob":1,"example":1},"constants":{"\"Couldn't print: \"":1},"javaDoc":"This method is invoked by the Print menu item","comments":"Wrap the example in a Printable object (defined below) Start off by getting a printer job to do the printing and tell the PrinterJob that we want to print it Display the print dialog to the user If they didn't cancel it then tell the job to start printing  This method is invoked by the Print menu item ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GraphicsExample"],"returnType":"PrintableExample","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// The constructor.  Just remember the example\npublic PrintableExample(GraphicsExample example) {\n    this.example = example;\n}\n","name":"PrintableExample","className":"PrintableExample","variables":{"example":1},"constants":{},"javaDoc":"","comments":" The constructor.  Just remember the example","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","PageFormat","int"],"returnType":"int","methodCalls":{"getHeight":1,"min":1,"getImageableHeight":1,"scale":1,"getImageableWidth":1,"getWidth":1,"draw":1,"getImageableX":1,"translate":1,"getImageableY":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":6,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":7,"DoubleLiteralExpr":2,"BinaryExpr":6,"NameExpr":51,"CastExpr":1,"ThisExpr":1,"MethodCallExpr":10,"AssignExpr":2},"statements":{"IfStmt":4,"ReturnStmt":2,"ExpressionStmt":12},"text":"/**\n\t * This method is called by the PrinterJob to print the example\n\t **/\npublic int print(Graphics g, PageFormat pf, int pageIndex) {\n    // Tell the PrinterJob that there is only one page\n    if (pageIndex != 0)\n        return NO_SUCH_PAGE;\n    // The PrinterJob supplies us a Graphics object to draw with.\n    // Anything drawn with this object will be sent to the printer.\n    // The Graphics object can safely be cast to a Graphics2D object.\n    Graphics2D g2 = (Graphics2D) g;\n    // Translate to skip the left and top margins.\n    g2.translate(pf.getImageableX(), pf.getImageableY());\n    // Figure out how big the printable area is, and how big\n    // the example is.\n    double pageWidth = pf.getImageableWidth();\n    double pageHeight = pf.getImageableHeight();\n    double exampleWidth = example.getWidth();\n    double exampleHeight = example.getHeight();\n    // Scale the example if needed\n    double scalex = 1.0, scaley = 1.0;\n    if (exampleWidth > pageWidth)\n        scalex = pageWidth / exampleWidth;\n    if (exampleHeight > pageHeight)\n        scaley = pageHeight / exampleHeight;\n    double scalefactor = Math.min(scalex, scaley);\n    if (scalefactor != 1)\n        g2.scale(scalefactor, scalefactor);\n    // Finally, call the draw() method of the example, passing in\n    // the Graphics2D object for the printer\n    example.draw(g2, GraphicsExampleFrame.this);\n    // Tell the PrinterJob that we successfully printed the page\n    return PAGE_EXISTS;\n}\n","name":"print","className":"PrintableExample","variables":{"scalefactor":2,"exampleWidth":3,"g":1,"g2":3,"Math":1,"pageHeight":3,"pageWidth":3,"NO_SUCH_PAGE":1,"example":3,"scalex":2,"scaley":2,"pageIndex":1,"pf":4,"exampleHeight":3,"GraphicsExampleFrame":1,"PAGE_EXISTS":1},"constants":{"0":1,"1":1,"1.0":2},"javaDoc":"This method is called by the PrinterJob to print the example","comments":"The PrinterJob supplies us a Graphics object to draw with Anything drawn with this object will be sent to the printer Figure out how big the printable area is and how big Finally call the draw() method of the example passing in Tell the PrinterJob that there is only one page The Graphics object can safely be cast to a Graphics2D object Translate to skip the left and top margins the example is Scale the example if needed the Graphics2D object for the printer Tell the PrinterJob that we successfully printed the page \n\t * This method is called by the PrinterJob to print the example\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"exit":3,"forName":1,"newInstance":1,"System.err.println":3,"indexOf":1,"pack":1},"annotations":[],"exceptions":["// class doesn't have a public constructor\nException","// wrong type of class\nClassCastException","// unknown class\nClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"GraphicsExample[]":1,"Class":1,"String":1,"GraphicsExampleFrame":1,"int":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":59,"StringLiteralExpr":5,"CharLiteralExpr":1,"UnaryExpr":2,"AssignExpr":2,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":5,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ExpressionStmt":14},"text":"/** \n     * The main program.  Use Java reflection to load and instantiate\n     * the specified GraphicsExample classes, then create a\n     * GraphicsExampleFrame to display them.\n     **/\npublic static void main(String[] args) {\n    GraphicsExample[] examples = new GraphicsExample[args.length];\n    // Loop through the command line arguments\n    for (int i = 0; i < args.length; i++) {\n        // The class name of the requested example\n        String classname = args[i];\n        // If no package is specified, assume it is in this package\n        if (classname.indexOf('.') == -1)\n            classname = \"com.davidflanagan.examples.graphics.\" + args[i];\n        // Try to instantiate the named GraphicsExample class\n        try {\n            Class exampleClass = Class.forName(classname);\n            examples[i] = (GraphicsExample) exampleClass.newInstance();\n        } catch (// unknown class\n        ClassNotFoundException // unknown class\n        e) {\n            System.err.println(\"Couldn't find example: \" + classname);\n            System.exit(1);\n        } catch (// wrong type of class\n        ClassCastException // wrong type of class\n        e) {\n            System.err.println(\"Class \" + classname + \" is not a GraphicsExample\");\n            System.exit(1);\n        } catch (// class doesn't have a public constructor\n        Exception // class doesn't have a public constructor\n        e) {\n            System.err.println(\"Couldn't instantiate example: \" + classname);\n            System.exit(1);\n        }\n    }\n    // Now create a window to display the examples in, and make it visible\n    GraphicsExampleFrame f = new GraphicsExampleFrame(examples);\n    f.pack();\n    f.setVisible(true);\n}\n         // catch InstantiationException, IllegalAccessException\n\n","name":"main","className":"GraphicsExampleFrame","variables":{"args":2,"examples":3,"classname":6,"e":3,"f":3,"i":6,"Class":1,"System":3,"exampleClass":2},"constants":{"0":1,"'.'":1,"1":4,"\"Couldn't find example: \"":1,"true":1,"\"Class \"":1,"\"Couldn't instantiate example: \"":1,"\" is not a GraphicsExample\"":1,"\"com.davidflanagan.examples.graphics.\"":1},"javaDoc":"The main program Use Java reflection to load and instantiate the specified GraphicsExample classes then create a GraphicsExampleFrame to display them","comments":"Loop through the command line arguments The class name of the requested example If no package is specified assume it is in this package Try to instantiate the named GraphicsExample class unknown class unknown class wrong type of class wrong type of class catch InstantiationException IllegalAccessException class doesn't have a public constructor class doesn't have a public constructor Now create a window to display the examples in and make it visible  \n     * The main program.  Use Java reflection to load and instantiate\n     * the specified GraphicsExample classes, then create a\n     * GraphicsExampleFrame to display them.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double","double","double","double","double","float","int","double","double","double"],"returnType":"Hypnosis","methodCalls":{"setRenderingHint":1,"createGraphics":1,"setStroke":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":63,"CastExpr":2,"FieldAccessExpr":15,"EnclosedExpr":2,"ThisExpr":11,"AssignExpr":13,"MethodCallExpr":3},"statements":{"ExpressionStmt":15},"text":"public Hypnosis(double x, double y, double r1, double r2, double a1, double a2, float linewidth, int delay, double deltaA, double deltaX, double deltaY) {\n    this.x = x;\n    this.y = y;\n    this.r1 = r1;\n    this.r2 = r2;\n    this.a1 = a1;\n    this.a2 = a2;\n    this.linewidth = linewidth;\n    this.deltaA = deltaA;\n    this.deltaX = deltaX;\n    this.deltaY = deltaY;\n    // Set up a timer to call actionPerformed() every delay milliseconds\n    timer = new Timer(delay, this);\n    // Create a buffer for double-buffering\n    buffer = new BufferedImage((int) (2 * r2 + linewidth), (int) (2 * r2 + linewidth), BufferedImage.TYPE_INT_RGB);\n    // Create a Graphics object for the buffer, and set the linewidth\n    // and request antialiasing when drawing with it\n    osg = buffer.createGraphics();\n    osg.setStroke(new BasicStroke(linewidth, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));\n    osg.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n}\n","name":"Hypnosis","className":"Hypnosis","variables":{"r2":3,"osg":3,"deltaX":1,"deltaY":1,"linewidth":4,"deltaA":1,"a1":1,"a2":1,"timer":1,"delay":1,"x":1,"y":1,"buffer":2,"r1":1},"constants":{"2":2},"javaDoc":"","comments":"Create a Graphics object for the buffer and set the linewidth Set up a timer to call actionPerformed() every delay milliseconds Create a buffer for double-buffering and request antialiasing when drawing with it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// Start and stop the animation by starting and stopping the timer\npublic void start() {\n    timer.start();\n}\n","name":"start","className":"Hypnosis","variables":{"timer":1},"constants":{},"javaDoc":"","comments":" Start and stop the animation by starting and stopping the timer","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"stop":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void stop() {\n    timer.stop();\n}\n","name":"stop","className":"Hypnosis","variables":{"timer":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1,"getHeight":1,"setColor":2,"getWidth":1,"draw":1,"getBackground":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":39,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":2,"ThisExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":5},"text":"/** \n     * Swing calls this method to ask the component to redraw itself.\n     * This method uses double-buffering to make the animation smoother.\n     * Swing does double-buffering automatically, so this may not actually\n     * make much difference, but it is important to understand the technique.\n     **/\npublic void paintComponent(Graphics g) {\n    // Clear the background of the off-screen image\n    osg.setColor(getBackground());\n    osg.fillRect(0, 0, buffer.getWidth(), buffer.getHeight());\n    // Now draw a black spiral into the off-screen image\n    osg.setColor(Color.black);\n    osg.draw(new Spiral(r2 + linewidth / 2, r2 + linewidth / 2, r1, a1, r2, a2));\n    // Now copy that off-screen image onto the screen\n    g.drawImage(buffer, (int) (x - r2), (int) (y - r2), this);\n}\n","name":"paintComponent","className":"Hypnosis","variables":{"r2":5,"a1":1,"a2":1,"osg":4,"g":1,"x":1,"y":1,"buffer":2,"linewidth":2,"r1":1},"constants":{"0":2,"2":2},"javaDoc":"Swing calls this method to ask the component to redraw itself This method uses double-buffering to make the animation smoother Swing does double-buffering automatically so this may not actually make much difference but it is important to understand the technique","comments":"Clear the background of the off-screen image Now draw a black spiral into the off-screen image Now copy that off-screen image onto the screen  \n     * Swing calls this method to ask the component to redraw itself.\n     * This method uses double-buffering to make the animation smoother.\n     * Swing does double-buffering automatically, so this may not actually\n     * make much difference, but it is important to understand the technique.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"repaint":2,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":1,"BinaryExpr":34,"NameExpr":68,"CastExpr":8,"FieldAccessExpr":5,"EnclosedExpr":16,"UnaryExpr":2,"MethodCallExpr":3,"AssignExpr":8},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":11},"text":"/** \n     * This method implements the ActionListener interface.  Our Timer object\n     * calls this method periodically.  It updates the position and angles\n     * of the spiral and requests a redraw.  Instead of redrawing the entire\n     * component, however, this method requests a redraw only for the \n     * area that has changed.\n     **/\npublic void actionPerformed(ActionEvent e) {\n    // Ask to have the old bounding box of the spiral redrawn.\n    // Nothing else has anything drawn in it, so it doesn't need a redraw\n    repaint((int) (x - r2 - linewidth), (int) (y - r2 - linewidth), (int) (2 * (r2 + linewidth)), (int) (2 * (r2 + linewidth)));\n    // Now animate: update the position and angles of the spiral\n    // Bounce if we've hit an edge\n    Rectangle bounds = getBounds();\n    if ((x - r2 + deltaX < 0) || (x + r2 + deltaX > bounds.width))\n        deltaX = -deltaX;\n    if ((y - r2 + deltaY < 0) || (y + r2 + deltaY > bounds.height))\n        deltaY = -deltaY;\n    // Move the center of the spiral\n    x += deltaX;\n    y += deltaY;\n    // Increment the start and end angles;\n    a1 += deltaA;\n    a2 += deltaA;\n    if (a1 > 2 * Math.PI) {\n        // Don't let them get too big\n        a1 -= 2 * Math.PI;\n        a2 -= 2 * Math.PI;\n    }\n    // Now ask to have the new bounding box of the spiral redrawn.  This\n    // rectangle will be intersected with the redraw rectangle requested\n    // above, and only the combined region will be redrawn\n    repaint((int) (x - r2 - linewidth), (int) (y - r2 - linewidth), (int) (2 * (r2 + linewidth)), (int) (2 * (r2 + linewidth)));\n}\n","name":"actionPerformed","className":"Hypnosis","variables":{"r2":12,"a1":3,"a2":2,"deltaX":5,"deltaY":5,"x":5,"bounds":1,"y":5,"linewidth":8,"deltaA":2},"constants":{"0":2,"2":7},"javaDoc":"This method implements the ActionListener interface Our Timer object calls this method periodically It updates the position and angles of the spiral and requests a redraw Instead of redrawing the entire component however this method requests a redraw only for the area that has changed","comments":"Ask to have the old bounding box of the spiral redrawn Now animate: update the position and angles of the spiral Now ask to have the new bounding box of the spiral redrawn This rectangle will be intersected with the redraw rectangle requested Nothing else has anything drawn in it so it doesn't need a redraw Bounce if we've hit an edge Move the center of the spiral Increment the start and end angles; Don't let them get too big above and only the combined region will be redrawn  \n     * This method implements the ActionListener interface.  Our Timer object\n     * calls this method periodically.  It updates the position and angles\n     * of the spiral and requests a redraw.  Instead of redrawing the entire\n     * component, however, this method requests a redraw only for the \n     * area that has changed.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Tell Swing not to double-buffer for us, since we do our own */\npublic boolean isDoubleBuffered() {\n    return false;\n}\n","name":"isDoubleBuffered","className":"Hypnosis","variables":{},"constants":{"false":1},"javaDoc":"Tell Swing not to double-buffer for us since we do our own","comments":" Tell Swing not to double-buffer for us, since we do our own ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setSize":1,"show":1,"start":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"Hypnosis":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":14,"VariableDeclarationExpr":2,"BinaryExpr":3,"StringLiteralExpr":1,"NameExpr":24,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/** This is a main() method for testing the component */\npublic static void main(String[] args) {\n    JFrame f = new JFrame(\"Hypnosis\");\n    Hypnosis h = new Hypnosis(200, 200, 10, 100, 0, 11 * Math.PI, 7, 100, 2 * Math.PI / 30, 3, 5);\n    f.getContentPane().add(h, BorderLayout.CENTER);\n    f.setSize(400, 400);\n    f.show();\n    h.start();\n}\n","name":"main","className":"Hypnosis","variables":{"f":4,"h":2},"constants":{"0":1,"11":1,"100":2,"200":2,"2":1,"3":1,"400":2,"5":1,"7":1,"\"Hypnosis\"":1,"30":1,"10":1},"javaDoc":"This is a main() method for testing the component","comments":" This is a main() method for testing the component ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"LineStyles\";\n}\n","name":"getName","className":"LineStyles","variables":{},"constants":{"\"LineStyles\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return 450;\n}\n","name":"getWidth","className":"LineStyles","variables":{},"constants":{"450":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return 180;\n}\n","name":"getHeight","className":"LineStyles","variables":{},"constants":{"180":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setRenderingHint":1,"setColor":2,"lineTo":2,"setStroke":2,"draw":2,"fillRect":1,"translate":2,"drawString":2,"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GeneralPath":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":20,"VariableDeclarationExpr":3,"ArrayAccessExpr":11,"BinaryExpr":4,"NameExpr":86,"FieldAccessExpr":6,"UnaryExpr":2,"MethodCallExpr":15},"statements":{"BlockStmt":1,"ForStmt":2,"ExpressionStmt":16},"text":"/** This method draws the example figure */\npublic void draw(Graphics2D g, Component c) {\n    // Use anti-aliasing to avoid \"jaggies\" in the lines\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    // Define the shape to draw\n    GeneralPath shape = new GeneralPath();\n    // start at point 0\n    shape.moveTo(xpoints[0], ypoints[0]);\n    // draw a line to point 1\n    shape.lineTo(xpoints[1], ypoints[1]);\n    // and then on to point 2\n    shape.lineTo(xpoints[2], ypoints[2]);\n    // Move the origin to the right and down, creating a margin\n    g.translate(20, 40);\n    // Now loop, drawing our shape with the three different line styles\n    for (int i = 0; i < linestyles.length; i++) {\n        // Draw a gray line\n        g.setColor(Color.gray);\n        // Select the line style to use\n        g.setStroke(linestyles[i]);\n        // Draw the shape\n        g.draw(shape);\n        // Now use black\n        g.setColor(Color.black);\n        // And the thin dashed line\n        g.setStroke(thindashed);\n        // And draw the shape again.\n        g.draw(shape);\n        // This accentuates the cap and join styles we're demonstrating\n        for (int j = 0; j < xpoints.length; j++) g.fillRect(xpoints[j] - 2, ypoints[j] - 2, 5, 5);\n        // Label the cap style\n        g.drawString(capNames[i], 5, 105);\n        // Label the join style\n        g.drawString(joinNames[i], 5, 120);\n        // Move over to the right before looping again\n        g.translate(150, 0);\n    }\n}\n         // Highlight the location of the vertexes of the shape\n\n","name":"draw","className":"LineStyles","variables":{"ypoints":4,"xpoints":4,"shape":4,"g":12,"i":6,"linestyles":1,"j":5,"joinNames":1,"capNames":1},"constants":{"0":5,"1":2,"2":4,"5":4,"105":1,"40":1,"150":1,"20":1,"120":1},"javaDoc":"This method draws the example figure","comments":"Use anti-aliasing to avoid \"jaggies\" in the lines Define the shape to draw start at point 0 draw a line to point 1 and then on to point 2 Move the origin to the right and down creating a margin Now loop drawing our shape with the three different line styles Highlight the location of the vertexes of the shape Draw a gray line Select the line style to use Draw the shape Now use black And the thin dashed line And draw the shape again This accentuates the cap and join styles we're demonstrating Label the cap style Label the join style Move over to the right before looping again  This method draws the example figure ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":1,"fillOval":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** This method simply draws the circle at its current position */\npublic void paint(Graphics g) {\n    g.setColor(Color.red);\n    g.fillOval(x - r, y - r, r * 2, r * 2);\n}\n","name":"paint","className":"BouncingCircle","variables":{"r":4,"g":2,"x":1,"y":1},"constants":{"2":2},"javaDoc":"This method simply draws the circle at its current position","comments":" This method simply draws the circle at its current position ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"repaint":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":14,"NameExpr":30,"FieldAccessExpr":2,"EnclosedExpr":4,"UnaryExpr":2,"MethodCallExpr":2,"AssignExpr":4},"statements":{"IfStmt":2,"ExpressionStmt":6},"text":"/**\n     * This method moves (and bounces) the circle and then requests a redraw.\n     * The animator thread calls this method periodically.\n     **/\npublic void animate() {\n    // Bounce if we've hit an edge.\n    Rectangle bounds = getBounds();\n    if ((x - r + dx < 0) || (x + r + dx > bounds.width))\n        dx = -dx;\n    if ((y - r + dy < 0) || (y + r + dy > bounds.height))\n        dy = -dy;\n    // Move the circle.\n    x += dx;\n    y += dy;\n    // Ask the browser to call our paint() method to draw the circle\n    // at its new position.\n    repaint();\n}\n","name":"animate","className":"BouncingCircle","variables":{"r":4,"dx":5,"dy":5,"bounds":1,"x":3,"y":3},"constants":{"0":2},"javaDoc":"This method moves (and bounces) the circle and then requests a redraw The animator thread calls this method periodically","comments":"Ask the browser to call our paint() method to draw the circle Bounce if we've hit an edge Move the circle at its new position \n     * This method moves (and bounces) the circle and then requests a redraw.\n     * The animator thread calls this method periodically.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"animate":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":2},"text":"/**\n     * This method is from the Runnable interface.  It is the body of the \n     * thread that performs the animation.  The thread itself is created \n     * and started in the start() method.\n     **/\npublic void run() {\n    while (!pleaseStop) {\n        // Loop until we're asked to stop\n        // Update and request redraw\n        animate();\n        try // Wait 100 milliseconds\n        {\n            Thread.sleep(100);\n        }// Ignore interruptions\n         catch (InterruptedException e) {\n        }\n    }\n}\n","name":"run","className":"BouncingCircle","variables":{"e":1,"pleaseStop":1,"Thread":1},"constants":{"100":1},"javaDoc":"This method is from the Runnable interface It is the body of the thread that performs the animation The thread itself is created and started in the start() method","comments":"Loop until we're asked to stop Update and request redraw Wait 100 milliseconds Ignore interruptions \n     * This method is from the Runnable interface.  It is the body of the \n     * thread that performs the animation.  The thread itself is created \n     * and started in the start() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":5,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Start animating when the browser starts the applet */\npublic void start() {\n    // Create a thread\n    animator = new Thread(this);\n    // Don't ask it to stop now\n    pleaseStop = false;\n    // Start the thread.\n    animator.start();\n// The thread that called start now returns to its caller.\n// Meanwhile, the new animator thread has called the run() method\n}\n","name":"start","className":"BouncingCircle","variables":{"pleaseStop":1,"animator":2},"constants":{"false":1},"javaDoc":"Start animating when the browser starts the applet","comments":"The thread that called start now returns to its caller Meanwhile the new animator thread has called the run() method Create a thread Don't ask it to stop now Start the thread  Start animating when the browser starts the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Stop animating when the browser stops the applet */\npublic void stop() {\n    // Set the flag that causes the run() method to end\n    pleaseStop = true;\n}\n","name":"stop","className":"BouncingCircle","variables":{"pleaseStop":1},"constants":{"true":1},"javaDoc":"Stop animating when the browser stops the applet","comments":"Set the flag that causes the run() method to end  Stop animating when the browser stops the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Transforms\";\n}\n","name":"getName","className":"Transforms","variables":{},"constants":{"\"Transforms\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return 750;\n}\n","name":"getWidth","className":"Transforms","variables":{},"constants":{"750":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return 250;\n}\n","name":"getHeight","className":"Transforms","variables":{},"constants":{"250":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Transforms","methodCalls":{"getScaleInstance":2,"getRotateInstance":2,"append":3,"getShearInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"GeneralPath":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":19,"VariableDeclarationExpr":1,"ArrayAccessExpr":8,"BinaryExpr":3,"NameExpr":51,"StringLiteralExpr":6,"UnaryExpr":3,"AssignExpr":9,"DoubleLiteralExpr":20,"ArrayInitializerExpr":3,"BooleanLiteralExpr":3,"FieldAccessExpr":5,"ArrayCreationExpr":4,"ThisExpr":2,"MethodCallExpr":10},"statements":{"ExpressionStmt":15},"text":"/** \n     * This constructor sets up the Shape and AffineTransform objects we need\n     **/\npublic Transforms() {\n    // Create a shape to draw\n    GeneralPath path = new GeneralPath();\n    path.append(new Line2D.Float(0.0f, 0.0f, 0.0f, 100.0f), false);\n    path.append(new Line2D.Float(-10.0f, 50.0f, 10.0f, 50.0f), false);\n    path.append(new Polygon(new int[] { -5, 0, 5 }, new int[] { 5, 0, 5 }, 3), false);\n    // Remember this shape\n    this.shape = path;\n    // Set up some transforms to alter the shape\n    this.transforms = new AffineTransform[6];\n    // 1) the identity transform\n    transforms[0] = new AffineTransform();\n    // 2) A scale tranform: 3/4 size\n    transforms[1] = AffineTransform.getScaleInstance(0.75, 0.75);\n    // 3) A shearing transform\n    transforms[2] = AffineTransform.getShearInstance(-0.4, 0.0);\n    // 4) A 30 degree clockwise rotation about the origin of the shape\n    transforms[3] = AffineTransform.getRotateInstance(Math.PI * 2 / 12);\n    // 5) A 180 degree rotation about the midpoint of the shape\n    transforms[4] = AffineTransform.getRotateInstance(Math.PI, 0.0, 50.0);\n    // 6) A combination transform\n    transforms[5] = AffineTransform.getScaleInstance(0.5, 1.5);\n    transforms[5].shear(0.0, 0.4);\n    // 90 degrees\n    transforms[5].rotate(Math.PI / 2, 0.0, 50.0);\n    // Define names for the transforms\n    transformLabels = new String[] { \"identity\", \"scale\", \"shear\", \"rotate\", \"rotate\", \"combo\" };\n}\n","name":"Transforms","className":"Transforms","variables":{"path":5,"transformLabels":1,"transforms":8,"AffineTransform":5},"constants":{"12":1,"0.0f":3,"\"identity\"":1,"\"combo\"":1,"50.0":2,"false":3,"50.0f":2,"0.75":2,"100.0f":1,"\"scale\"":1,"10.0f":2,"\"rotate\"":2,"0":3,"1":1,"2":3,"0.0":4,"3":2,"4":1,"5":7,"6":1,"0.4":2,"0.5":1,"1.5":1,"\"shear\"":1},"javaDoc":"This constructor sets up the Shape and AffineTransform objects we need","comments":"Create a shape to draw Remember this shape Set up some transforms to alter the shape 1) the identity transform 2) A scale tranform: 3/4 size 3) A shearing transform 4) A 30 degree clockwise rotation about the origin of the shape 5) A 180 degree rotation about the midpoint of the shape 6) A combination transform 90 degrees Define names for the transforms  \n     * This constructor sets up the Shape and AffineTransform objects we need\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"setRenderingHint":1,"transform":1,"setColor":1,"setTransform":1,"setStroke":1,"draw":1,"getTransform":1,"drawRect":1,"translate":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"AffineTransform":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":10,"VariableDeclarationExpr":2,"DoubleLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":57,"FieldAccessExpr":6,"UnaryExpr":4,"MethodCallExpr":10},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"/** Draw the defined shape and label, using each transform */\npublic void draw(Graphics2D g, Component c) {\n    // Define basic drawing attributes\n    // black\n    g.setColor(Color.black);\n    g.setStroke(new // 2-pixel\n    BasicStroke(// 2-pixel\n    2.0f, // 2-pixel\n    BasicStroke.CAP_SQUARE, BasicStroke.JOIN_BEVEL));\n    // antialias\n    g.setRenderingHint(// antialias\n    RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    // Now draw the shape once using each of the transforms we've defined\n    for (int i = 0; i < transforms.length; i++) {\n        // save current state\n        AffineTransform save = g.getTransform();\n        // move origin\n        g.translate(i * 125 + 50, 50);\n        // apply transform\n        g.transform(transforms[i]);\n        // draw shape\n        g.draw(shape);\n        // draw label\n        g.drawString(transformLabels[i], -25, 125);\n        // draw box\n        g.drawRect(-40, -10, 80, 150);\n        // restore transform\n        g.setTransform(save);\n    }\n}\n","name":"draw","className":"Transforms","variables":{"transformLabels":1,"g":10,"save":1,"transforms":1,"i":6},"constants":{"0":1,"25":1,"125":2,"80":1,"50":2,"40":1,"150":1,"10":1},"javaDoc":"Draw the defined shape and label using each transform","comments":"Define basic drawing attributes black 2-pixel 2-pixel 2-pixel antialias antialias antialias Now draw the shape once using each of the transforms we've defined save current state move origin apply transform draw shape draw label draw box restore transform  Draw the defined shape and label, using each transform ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"decode":2,"getParameter":2},"annotations":[],"exceptions":["NumberFormatException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":21,"StringLiteralExpr":3,"FieldAccessExpr":2,"AssignExpr":5,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** \n     * Get the gradient start and end colors as applet parameter values, and\n     * parse them using Color.decode().  If they are malformed, use white.\n     **/\npublic void init() {\n    try {\n        startColor = Color.decode(getParameter(\"startColor\"));\n        endColor = Color.decode(getParameter(\"endColor\"));\n    } catch (NumberFormatException e) {\n        startColor = endColor = Color.white;\n    }\n    bigFont = new Font(\"Helvetica\", Font.BOLD, 72);\n}\n","name":"init","className":"ColorGradient","variables":{"bigFont":1,"endColor":2,"e":1,"Color":2,"startColor":2},"constants":{"\"Helvetica\"":1,"\"startColor\"":1,"72":1,"\"endColor\"":1},"javaDoc":"Get the gradient start and end colors as applet parameter values and parse them using Color decode() If they are malformed use white","comments":" \n     * Get the gradient start and end colors as applet parameter values, and\n     * parse them using Color.decode().  If they are malformed, use white.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"fillGradient":1,"setColor":1,"setFont":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"NameExpr":15,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Draw the applet.  The interesting code is in fillGradient() below */\npublic void paint(Graphics g) {\n    // display the gradient\n    fillGradient(this, g, startColor, endColor);\n    // set a font\n    g.setFont(bigFont);\n    // light blue\n    g.setColor(new Color(100, 100, 200));\n    // draw something interesting\n    g.drawString(\"Colors!\", 100, 100);\n}\n","name":"paint","className":"ColorGradient","variables":{"g":3},"constants":{"100":4,"200":1,"\"Colors!\"":1},"javaDoc":"Draw the applet The interesting code is in fillGradient() below","comments":"display the gradient set a font light blue draw something interesting  Draw the applet.  The interesting code is in fillGradient() below ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Graphics","Color","Color"],"returnType":"void","methodCalls":{"getRed":2,"getGreen":2,"setColor":1,"drawLine":1,"getBlue":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1,"float":9,"int":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":11,"DoubleLiteralExpr":6,"BinaryExpr":14,"NameExpr":60,"FieldAccessExpr":5,"EnclosedExpr":3,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":9,"AssignExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":15},"text":"/**\n     * Draw a color gradient from the top of the specified component to the\n     * bottom.  Start with the start color and change smoothly to the end \n     **/\npublic void fillGradient(Component c, Graphics g, Color start, Color end) {\n    // How big is the component?\n    Rectangle bounds = this.getBounds();\n    // Get the red, green, and blue components of the start and end\n    // colors as floats between 0.0 and 1.0.  Note that the Color class\n    // also works with int values between 0 and 255\n    float r1 = start.getRed() / 255.0f;\n    float g1 = start.getGreen() / 255.0f;\n    float b1 = start.getBlue() / 255.0f;\n    float r2 = end.getRed() / 255.0f;\n    float g2 = end.getGreen() / 255.0f;\n    float b2 = end.getBlue() / 255.0f;\n    // Figure out how much each component should change at each y value\n    float dr = (r2 - r1) / bounds.height;\n    float dg = (g2 - g1) / bounds.height;\n    float db = (b2 - b1) / bounds.height;\n    // Now loop once for each row of pixels in the component\n    for (int y = 0; y < bounds.height; y++) {\n        // Set the color of the row\n        g.setColor(new Color(r1, g1, b1));\n        // Draw the row\n        g.drawLine(0, y, bounds.width - 1, y);\n        // Increment color components\n        r1 += dr;\n        // Increment color components\n        g1 += dg;\n        // Increment color components\n        b1 += db;\n    }\n}\n","name":"fillGradient","className":"ColorGradient","variables":{"r2":2,"dg":2,"g":2,"start":3,"g1":4,"g2":2,"dr":2,"b1":4,"b2":2,"bounds":1,"y":3,"end":3,"db":2,"r1":4},"constants":{"0":2,"1":1,"255.0f":6},"javaDoc":"Draw a color gradient from the top of the specified component to the bottom Start with the start color and change smoothly to the end","comments":"Get the red green and blue components of the start and end colors as floats between 0 0 and 1 0 Note that the Color class How big is the component? also works with int values between 0 and 255 Figure out how much each component should change at each y value Now loop once for each row of pixels in the component Set the color of the row Draw the row Increment color components Increment color components Increment color components \n     * Draw a color gradient from the top of the specified component to the\n     * bottom.  Start with the start color and change smoothly to the end \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"CompositeEffects","methodCalls":{"getResource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.net.URL":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** This constructor loads the cover image */\npublic CompositeEffects() {\n    java.net.URL imageurl = this.getClass().getResource(\"cover.gif\");\n    cover = new javax.swing.ImageIcon(imageurl).getImage();\n}\n","name":"CompositeEffects","className":"CompositeEffects","variables":{"cover":1,"imageurl":2},"constants":{"\"cover.gif\"":1},"javaDoc":"This constructor loads the cover image","comments":" This constructor loads the cover image ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// These are basic GraphicsExample methods\npublic String getName() {\n    return \"Composite Effects\";\n}\n","name":"getName","className":"CompositeEffects","variables":{},"constants":{"\"Composite Effects\"":1},"javaDoc":"","comments":" These are basic GraphicsExample methods","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getWidth() {\n    return 6 * COVERWIDTH + 70;\n}\n","name":"getWidth","className":"CompositeEffects","variables":{"COVERWIDTH":1},"constants":{"6":1,"70":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getHeight() {\n    return COVERHEIGHT + 35;\n}\n","name":"getHeight","className":"CompositeEffects","variables":{"COVERHEIGHT":1},"constants":{"35":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"intersect":1,"subtract":1,"getWidth":1,"fillRect":4,"translate":6,"drawString":6,"drawImage":9,"getHeight":1,"setColor":1,"setComposite":7,"getClip":1,"createGraphics":1,"setClip":1,"setFont":1,"getInstance":1,"clip":1,"setPaint":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"Area":1,"Shape":1,"BufferedImage":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":15,"IntegerLiteralExpr":84,"VariableDeclarationExpr":4,"DoubleLiteralExpr":1,"BinaryExpr":16,"NameExpr":228,"StringLiteralExpr":7,"FieldAccessExpr":13,"MethodCallExpr":47},"statements":{"ExpressionStmt":46},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // fill the background \n    g.setPaint(new Color(175, 175, 175));\n    g.fillRect(0, 0, getWidth(), getHeight());\n    // Set text attributes\n    g.setColor(Color.black);\n    g.setFont(new Font(\"SansSerif\", Font.BOLD, 12));\n    // Draw the unmodified image\n    g.translate(10, 10);\n    g.drawImage(cover, 0, 0, c);\n    g.drawString(\"SRC_OVER\", 0, COVERHEIGHT + 15);\n    // Draw the cover again, using AlphaComposite to make the opaque\n    // colors of the image 50% translucent\n    g.translate(COVERWIDTH + 10, 0);\n    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));\n    g.drawImage(cover, 0, 0, c);\n    // Restore the pre-defined default Composite for the screen, so\n    // opaque colors stay opaque.\n    g.setComposite(AlphaComposite.SrcOver);\n    // Label the effect\n    g.drawString(\"SRC_OVER, 50%\", 0, COVERHEIGHT + 15);\n    // Now get an offscreen image to work with.  In order to achieve\n    // certain compositing effects, the drawing surface must support\n    // transparency. Onscreen drawing surfaces cannot, so we have to do the\n    // compositing in an offscreen image that is specially created to have\n    // an \"alpha channel\", then copy the final result to the screen.\n    BufferedImage offscreen = new BufferedImage(COVERWIDTH, COVERHEIGHT, BufferedImage.TYPE_INT_ARGB);\n    // First, fill the image with a color gradient background that varies\n    // left-to-right from opaque to transparent yellow\n    Graphics2D osg = offscreen.createGraphics();\n    osg.setPaint(new GradientPaint(0, 0, Color.yellow, COVERWIDTH, 0, new Color(255, 255, 0, 0)));\n    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);\n    // Now copy the cover image on top of this, but use the DstOver rule\n    // which draws it \"underneath\" the existing pixels, and allows the\n    // image to show depending on the transparency of those pixels.\n    osg.setComposite(AlphaComposite.DstOver);\n    osg.drawImage(cover, 0, 0, c);\n    // And display this composited image on the screen.  Note that the\n    // image is opaque and that none of the screen background shows through\n    g.translate(COVERWIDTH + 10, 0);\n    g.drawImage(offscreen, 0, 0, c);\n    g.drawString(\"DST_OVER\", 0, COVERHEIGHT + 15);\n    // Now start over and do a new effect with the off-screen image.\n    // First, fill the offscreen image with a new color gradient.  We\n    // don't care about the colors themselves; we just want the\n    // translucency of the background to vary.  We use opaque black to\n    // transparent black. Note that since we've already used this offscreen\n    // image, we set the composite to Src, we can fill the image and\n    // ignore anything that is already there.\n    osg.setComposite(AlphaComposite.Src);\n    osg.setPaint(new GradientPaint(0, 0, Color.black, COVERWIDTH, COVERHEIGHT, new Color(0, 0, 0, 0)));\n    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);\n    // Now set the compositing type to SrcIn, so colors come from the \n    // source, but translucency comes from the destination\n    osg.setComposite(AlphaComposite.SrcIn);\n    // Draw our loaded image into the off-screen image, compositing it.\n    osg.drawImage(cover, 0, 0, c);\n    // And then copy our off-screen image to the screen.  Note that the\n    // image is translucent and some of the image shows through.\n    g.translate(COVERWIDTH + 10, 0);\n    g.drawImage(offscreen, 0, 0, c);\n    g.drawString(\"SRC_IN\", 0, COVERHEIGHT + 15);\n    // If we do the same thing but use SrcOut, then the resulting image \n    // will have the inverted translucency values of the destination\n    osg.setComposite(AlphaComposite.Src);\n    osg.setPaint(new GradientPaint(0, 0, Color.black, COVERWIDTH, COVERHEIGHT, new Color(0, 0, 0, 0)));\n    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);\n    osg.setComposite(AlphaComposite.SrcOut);\n    osg.drawImage(cover, 0, 0, c);\n    g.translate(COVERWIDTH + 10, 0);\n    g.drawImage(offscreen, 0, 0, c);\n    g.drawString(\"SRC_OUT\", 0, COVERHEIGHT + 15);\n    // Here's a cool effect; it has nothing to do with compositing, but\n    // uses an arbitrary shape to clip the image.  It uses Area to combine\n    // shapes into more complicated ones.\n    g.translate(COVERWIDTH + 10, 0);\n    // Save current clipping region\n    Shape savedClip = g.getClip();\n    // Create a shape to use as the new clipping region.  \n    // Begin with an ellipse\n    Area clip = new Area(new Ellipse2D.Float(0, 0, COVERWIDTH, COVERHEIGHT));\n    // Intersect with a rectangle, truncating the ellipse.\n    clip.intersect(new Area(new Rectangle(5, 5, COVERWIDTH - 10, COVERHEIGHT - 10)));\n    // Then subtract an ellipse from the bottom of the truncated ellipse.\n    clip.subtract(new Area(new Ellipse2D.Float(COVERWIDTH / 2 - 40, COVERHEIGHT - 20, 80, 40)));\n    // Use the resulting shape as the new clipping region\n    g.clip(clip);\n    // Then draw the image through this clipping region\n    g.drawImage(cover, 0, 0, c);\n    // Restore the old clipping region so we can label the effect\n    g.setClip(savedClip);\n    g.drawString(\"Clipping\", 0, COVERHEIGHT + 15);\n}\n","name":"draw","className":"CompositeEffects","variables":{"osg":15,"COVERHEIGHT":12,"AlphaComposite":1,"g":27,"COVERWIDTH":12,"offscreen":2,"savedClip":1,"clip":3},"constants":{"12":1,"\"SRC_OVER\"":1,"15":6,"\"SansSerif\"":1,"\"DST_OVER\"":1,"175":3,"\"Clipping\"":1,"0":56,"255":2,"2":1,"\"SRC_OVER, 50%\"":1,"5":2,"\"SRC_IN\"":1,"80":1,"0.5f":1,"\"SRC_OUT\"":1,"40":2,"20":1,"10":9},"javaDoc":"Draw the example","comments":"Draw the cover again using AlphaComposite to make the opaque Restore the pre-defined default Composite for the screen so Now get an offscreen image to work with In order to achieve certain compositing effects the drawing surface must support transparency Onscreen drawing surfaces cannot so we have to do the compositing in an offscreen image that is specially created to have First fill the image with a color gradient background that varies Now copy the cover image on top of this but use the DstOver rule which draws it \"underneath\" the existing pixels and allows the And display this composited image on the screen Note that the Now start over and do a new effect with the off-screen image First fill the offscreen image with a new color gradient We don't care about the colors themselves; we just want the translucency of the background to vary We use opaque black to transparent black Note that since we've already used this offscreen image we set the composite to Src we can fill the image and Now set the compositing type to SrcIn so colors come from the And then copy our off-screen image to the screen Note that the If we do the same thing but use SrcOut then the resulting image Here's a cool effect; it has nothing to do with compositing but uses an arbitrary shape to clip the image It uses Area to combine Create a shape to use as the new clipping region fill the background Set text attributes Draw the unmodified image colors of the image 50% translucent opaque colors stay opaque Label the effect an \"alpha channel\" then copy the final result to the screen left-to-right from opaque to transparent yellow image to show depending on the transparency of those pixels image is opaque and that none of the screen background shows through ignore anything that is already there source but translucency comes from the destination Draw our loaded image into the off-screen image compositing it image is translucent and some of the image shows through will have the inverted translucency values of the destination shapes into more complicated ones Save current clipping region Begin with an ellipse Intersect with a rectangle truncating the ellipse Then subtract an ellipse from the bottom of the truncated ellipse Use the resulting shape as the new clipping region Then draw the image through this clipping region Restore the old clipping region so we can label the effect  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Paints\";\n}\n","name":"getName","className":"Paints","variables":{},"constants":{"\"Paints\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"Paints","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"Paints","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int computeRed(double x, double y) {\n    return 128;\n}\n","name":"computeRed","className":"","variables":{},"constants":{"128":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{"cos":1,"sin":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"BinaryExpr":6,"CastExpr":1,"NameExpr":8,"EnclosedExpr":2,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"public int computeGreen(double x, double y) {\n    return (int) ((Math.sin(x / 7) + Math.cos(y / 5) + 2) / 4 * 255);\n}\n","name":"computeGreen","className":"","variables":{"x":1,"y":1,"Math":2},"constants":{"2":1,"255":1,"4":1,"5":1,"7":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":2,"EnclosedExpr":2},"statements":{"ReturnStmt":1},"text":"public int computeBlue(double x, double y) {\n    return ((int) (x * y)) % 256;\n}\n","name":"computeBlue","className":"","variables":{"x":1,"y":1},"constants":{"256":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"BinaryExpr":7,"CastExpr":2,"NameExpr":2,"EnclosedExpr":2},"statements":{"ReturnStmt":1},"text":"public int computeAlpha(double x, double y) {\n    return ((int) x % 25 * 8 + 50) + ((int) y % 25 * 8 + 50);\n}\n","name":"computeAlpha","className":"","variables":{"x":1,"y":1},"constants":{"25":2,"8":2,"50":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"deriveFont":1,"cos":1,"scale":1,"getScaleInstance":1,"draw":4,"fill":8,"createTransformedShape":4,"fillRect":2,"translate":6,"createGlyphVector":1,"setColor":1,"getFontRenderContext":1,"sin":1,"createGraphics":1,"setStroke":2,"fillOval":1,"drawRect":1,"getGlyphOutline":3,"setPaint":15,"getShearInstance":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"GlyphVector":1,"Shape":3,"Color":1,"AffineTransform":1,"Paint":1,"Font":2,"BufferedImage":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":16,"IntegerLiteralExpr":81,"VariableDeclarationExpr":10,"BinaryExpr":17,"NameExpr":235,"StringLiteralExpr":2,"UnaryExpr":3,"DoubleLiteralExpr":7,"BooleanLiteralExpr":1,"CastExpr":4,"FieldAccessExpr":10,"EnclosedExpr":6,"MethodCallExpr":56},"statements":{"BlockStmt":4,"ReturnStmt":4,"ExpressionStmt":51},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // Paint the entire background using a GradientPaint.\n    // The background color varies diagonally from deep red to pale blue\n    g.setPaint(new GradientPaint(0, 0, new Color(150, 0, 0), WIDTH, HEIGHT, new Color(200, 200, 255)));\n    // fill the background\n    g.fillRect(0, 0, WIDTH, HEIGHT);\n    // Use a different GradientPaint to draw a box.\n    // This one alternates between deep opaque green and transparent green.\n    // Note: the 4th arg to Color() constructor specifies color opacity\n    g.setPaint(new GradientPaint(0, 0, new Color(0, 150, 0), 20, 20, new Color(0, 150, 0, 0), true));\n    // use wide lines\n    g.setStroke(new BasicStroke(15));\n    // draw the box\n    g.drawRect(25, 25, WIDTH - 50, HEIGHT - 50);\n    // The glyphs of fonts can be used as Shape objects, which enables\n    // us to use Java2D techniques with letters Just as we would with\n    // any other shape.  Here we get some letter shapes to draw.\n    // a basic font\n    Font font = new Font(\"Serif\", Font.BOLD, 10);\n    Font // a scaled up version\n    bigfont = font.deriveFont(AffineTransform.getScaleInstance(30.0, 30.0));\n    GlyphVector gv = bigfont.createGlyphVector(g.getFontRenderContext(), \"JAV\");\n    // Shape of letter J\n    Shape jshape = gv.getGlyphOutline(0);\n    // Shape of letter A\n    Shape ashape = gv.getGlyphOutline(1);\n    // Shape of letter V\n    Shape vshape = gv.getGlyphOutline(2);\n    // We're going to outline the letters with a 5-pixel wide line\n    g.setStroke(new BasicStroke(5.0f));\n    // We're going to fake shadows for the letters using the\n    // following Paint and AffineTransform objects\n    // Translucent black\n    Paint shadowPaint = new Color(0, 0, 0, 100);\n    AffineTransform shadowTransform = // Shear to the right\n    AffineTransform.getShearInstance(-1.0, 0.0);\n    // Scale height by 1/2\n    shadowTransform.scale(1.0, 0.5);\n    // Move to the baseline of our first letter\n    g.translate(65, 270);\n    // Draw the shadow of the J shape\n    g.setPaint(shadowPaint);\n    // Compensate for the descender of the J\n    g.translate(15, 20);\n    // transform the J into the shape of its shadow, and fill it\n    g.fill(shadowTransform.createTransformedShape(jshape));\n    // Undo the translation above\n    g.translate(-15, -20);\n    // Now fill the J shape with a solid (and opaque) color\n    // Fill with solid, opaque blue\n    g.setPaint(Color.blue);\n    // Fill the shape\n    g.fill(jshape);\n    // Switch to solid black\n    g.setPaint(Color.black);\n    // And draw the outline of the J\n    g.draw(jshape);\n    // Now draw the A shadow\n    // Move to the right\n    g.translate(75, 0);\n    // Set shadow color\n    g.setPaint(shadowPaint);\n    // draw shadow\n    g.fill(shadowTransform.createTransformedShape(ashape));\n    // Draw the A shape using a solid transparent color\n    // Transparent green as paint\n    g.setPaint(new Color(0, 255, 0, 125));\n    // Fill the shape\n    g.fill(ashape);\n    // Switch to solid back\n    g.setPaint(Color.black);\n    // Draw the outline\n    g.draw(ashape);\n    // Move to the right and draw the shadow of the letter V\n    g.translate(175, 0);\n    g.setPaint(shadowPaint);\n    g.fill(shadowTransform.createTransformedShape(vshape));\n    // We're going to fill the next letter using a TexturePaint, which\n    // repeatedly tiles an image. The first step is to obtain the image.\n    // We could load it from an image file, but here we create it \n    // ourselves by drawing a into an off-screen image.  Note that we use\n    // a GradientPaint to fill the off-screen image, so the fill pattern\n    // combines features of both Paint classes.\n    BufferedImage // Create an image\n    tile = new BufferedImage(50, 50, BufferedImage.TYPE_INT_RGB);\n    // Get its Graphics for drawing\n    Graphics2D tg = tile.createGraphics();\n    tg.setColor(Color.pink);\n    // Fill tile background with pink\n    tg.fillRect(0, 0, 50, 50);\n    tg.setPaint(new // diagonal gradient\n    GradientPaint(// diagonal gradient\n    40, // diagonal gradient\n    0, // diagonal gradient\n    Color.green, 0, 40, // green to gray\n    Color.gray));\n    // Draw a circle with this gradient\n    tg.fillOval(5, 5, 40, 40);\n    // Use this new tile to create a TexturePaint and fill the letter V\n    g.setPaint(new TexturePaint(tile, new Rectangle(0, 0, 50, 50)));\n    // Fill letter shape\n    g.fill(vshape);\n    // Switch to solid black\n    g.setPaint(Color.black);\n    // Draw outline of letter\n    g.draw(vshape);\n    // Move to the right and draw the shadow of the final A\n    g.translate(160, 0);\n    g.setPaint(shadowPaint);\n    g.fill(shadowTransform.createTransformedShape(ashape));\n    // For the last letter, use a custom Paint class to fill with a \n    // complex mathematically defined pattern.  The GenericPaint\n    // class is defined later in the chapter.\n    g.setPaint(new GenericPaint() {\n\n        public int computeRed(double x, double y) {\n            return 128;\n        }\n\n        public int computeGreen(double x, double y) {\n            return (int) ((Math.sin(x / 7) + Math.cos(y / 5) + 2) / 4 * 255);\n        }\n\n        public int computeBlue(double x, double y) {\n            return ((int) (x * y)) % 256;\n        }\n\n        public int computeAlpha(double x, double y) {\n            return ((int) x % 25 * 8 + 50) + ((int) y % 25 * 8 + 50);\n        }\n    });\n    // Fill letter A\n    g.fill(ashape);\n    // Revert to solid black\n    g.setPaint(Color.black);\n    // Draw the outline of the A\n    g.draw(ashape);\n}\n","name":"draw","className":"Paints","variables":{"bigfont":2,"g":37,"computeGreen":1,"computeAlpha":1,"WIDTH":2,"vshape":1,"ashape":1,"HEIGHT":2,"Math":2,"gv":4,"jshape":1,"shadowPaint":1,"tg":5,"tile":3,"x":7,"AffineTransform":2,"y":7,"computeBlue":1,"shadowTransform":6,"font":2,"computeRed":1},"constants":{"25":4,"30.0":2,"270":1,"150":3,"175":1,"255":3,"256":1,"5.0f":1,"50":10,"75":1,"10":1,"15":3,"\"JAV\"":1,"160":1,"0":27,"1":1,"100":1,"200":2,"2":2,"0.0":1,"1.0":2,"125":1,"4":1,"5":3,"0.5":1,"128":1,"7":1,"true":1,"8":2,"40":3,"\"Serif\"":1,"20":4,"65":1},"javaDoc":"Draw the example","comments":"Paint the entire background using a GradientPaint Use a different GradientPaint to draw a box This one alternates between deep opaque green and transparent green The glyphs of fonts can be used as Shape objects which enables us to use Java2D techniques with letters Just as we would with any other shape Here we get some letter shapes to draw We're going to fake shadows for the letters using the following Paint and AffineTransform objects Now fill the J shape with a solid (and opaque) color Now draw the A shadow Draw the A shape using a solid transparent color We're going to fill the next letter using a TexturePaint which repeatedly tiles an image The first step is to obtain the image We could load it from an image file but here we create it ourselves by drawing a into an off-screen image Note that we use a GradientPaint to fill the off-screen image so the fill pattern For the last letter use a custom Paint class to fill with a complex mathematically defined pattern The GenericPaint The background color varies diagonally from deep red to pale blue fill the background Note: the 4th arg to Color() constructor specifies color opacity use wide lines draw the box a basic font a scaled up version Shape of letter J Shape of letter A Shape of letter V We're going to outline the letters with a 5-pixel wide line Translucent black Shear to the right Scale height by 1/2 Move to the baseline of our first letter Draw the shadow of the J shape Compensate for the descender of the J transform the J into the shape of its shadow and fill it Undo the translation above Fill with solid opaque blue Fill the shape Switch to solid black And draw the outline of the J Move to the right Set shadow color draw shadow Transparent green as paint Fill the shape Switch to solid back Draw the outline Move to the right and draw the shadow of the letter V combines features of both Paint classes Create an image Get its Graphics for drawing Fill tile background with pink diagonal gradient diagonal gradient diagonal gradient diagonal gradient green to gray Draw a circle with this gradient Use this new tile to create a TexturePaint and fill the letter V Fill letter shape Switch to solid black Draw outline of letter Move to the right and draw the shadow of the final A class is defined later in the chapter Fill letter A Revert to solid black Draw the outline of the A  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"NameExpr":32,"StringLiteralExpr":3,"FieldAccessExpr":4,"ThisExpr":6,"AssignExpr":7,"MethodCallExpr":6},"statements":{"ExpressionStmt":8},"text":"// This method is called when the applet is first created.\n// It performs initialization, such as creating the resources\n// (graphics attribute values) used by the paint() method.\npublic void init() {\n    // Initialize color resources.  Note the use of the Color() constructor\n    // and the use of pre-defined color constants.\n    // Equal red, green, and blue == gray\n    fill = new Color(200, 200, 200);\n    // Same as new Color(0, 0, 255)\n    outline = Color.blue;\n    // Same as new Color(255, 0, 0)\n    textcolor = Color.red;\n    // Create a font for use in the paint() method.  Get its metrics, too.\n    font = new Font(\"sansserif\", Font.BOLD, 14);\n    metrics = this.getFontMetrics(font);\n    // Load some Image objects for use in the paint() method.\n    image = this.getImage(this.getDocumentBase(), \"tiger.gif\");\n    background = this.getImage(this.getDocumentBase(), \"background.gif\");\n    // Set a property that tells the applet its background color\n    this.setBackground(Color.lightGray);\n}\n","name":"init","className":"GraphicsSampler","variables":{"image":1,"outline":1,"background":1,"textcolor":1,"metrics":1,"fill":1,"font":1},"constants":{"\"sansserif\"":1,"200":3,"14":1,"\"tiger.gif\"":1,"\"background.gif\"":1},"javaDoc":"","comments":"Initialize color resources Note the use of the Color() constructor and the use of pre-defined color constants Equal red green and blue == gray Same as new Color(0 0 255) Same as new Color(255 0 0) Create a font for use in the paint() method Get its metrics too Load some Image objects for use in the paint() method Set a property that tells the applet its background color  (graphics attribute values) used by the paint() method.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"centerText":8,"drawOval":1,"fillArc":1,"fillRoundRect":1,"cos":1,"drawLine":1,"drawArc":1,"getWidth":1,"fillRect":2,"drawImage":1,"getHeight":1,"setColor":12,"fillPolygon":1,"draw3DRect":3,"drawRoundRect":1,"tile":1,"sin":1,"setFont":1,"fillOval":1,"drawRect":1,"drawPolygon":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int[]":2,"int":4},"expressions":{"IntegerLiteralExpr":107,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":16,"NameExpr":173,"StringLiteralExpr":14,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":2,"BooleanLiteralExpr":3,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":4,"ArrayCreationExpr":2,"ThisExpr":4,"MethodCallExpr":42},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":46},"text":"// This method is called whenever the applet needs to be drawn or redrawn\npublic void paint(Graphics g) {\n    // Specify the font we'll be using throughout\n    g.setFont(font);\n    // Draw a background by tiling an image tile() is defined below\n    tile(g, this, background);\n    // Draw a line\n    // Specify the drawing color\n    g.setColor(outline);\n    // Draw a line from (25,10) to (150,80)\n    g.drawLine(25, 10, 150, 80);\n    // Draw some text.  See the centerText() method below.\n    centerText(\"drawLine()\", null, g, textcolor, 25, 10, 150, 80);\n    // Draw and fill an arc\n    g.setColor(fill);\n    g.fillArc(225, 10, 150, 80, 90, 135);\n    g.setColor(outline);\n    g.drawArc(225, 10, 150, 80, 90, 135);\n    centerText(\"fillArc()\", \"drawArc()\", g, textcolor, 225, 10, 150, 80);\n    // Draw and fill a rectangle\n    g.setColor(fill);\n    g.fillRect(25, 110, 150, 80);\n    g.setColor(outline);\n    g.drawRect(25, 110, 150, 80);\n    centerText(\"fillRect()\", \"drawRect()\", g, textcolor, 25, 110, 150, 80);\n    // Draw and fill a rounded rectangle\n    g.setColor(fill);\n    g.fillRoundRect(225, 110, 150, 80, 20, 20);\n    g.setColor(outline);\n    g.drawRoundRect(225, 110, 150, 80, 20, 20);\n    centerText(\"fillRoundRect()\", \"drawRoundRect()\", g, textcolor, 225, 110, 150, 80);\n    // Draw and fill an oval\n    g.setColor(fill);\n    g.fillOval(25, 210, 150, 80);\n    g.setColor(outline);\n    g.drawOval(25, 210, 150, 80);\n    centerText(\"fillOval()\", \"drawOval()\", g, textcolor, 25, 210, 150, 80);\n    // Define an octagon using arrays of X and Y coordinates\n    int numpoints = 8;\n    int[] xpoints = new int[numpoints + 1];\n    int[] ypoints = new int[numpoints + 1];\n    for (int i = 0; i < numpoints; i++) {\n        double angle = 2 * Math.PI * i / numpoints;\n        xpoints[i] = (int) (300 + 75 * Math.cos(angle));\n        ypoints[i] = (int) (250 - 40 * Math.sin(angle));\n    }\n    // Draw and fill the polygon\n    g.setColor(fill);\n    g.fillPolygon(xpoints, ypoints, numpoints);\n    g.setColor(outline);\n    g.drawPolygon(xpoints, ypoints, numpoints);\n    centerText(\"fillPolygon()\", \"drawPolygon()\", g, textcolor, 225, 210, 150, 80);\n    // Draw a 3D rectangle (clear an area for it first)\n    g.setColor(fill);\n    g.fillRect(20, 305, 160, 90);\n    g.draw3DRect(25, 310, 150, 80, true);\n    g.draw3DRect(26, 311, 148, 78, true);\n    g.draw3DRect(27, 312, 146, 76, true);\n    centerText(\"draw3DRect()\", \"x 3\", g, textcolor, 25, 310, 150, 80);\n    // Draw an image (centered within an area)\n    int w = image.getWidth(this);\n    int h = image.getHeight(this);\n    g.drawImage(image, 225 + (150 - w) / 2, 310 + (80 - h) / 2, this);\n    centerText(\"drawImage()\", null, g, textcolor, 225, 310, 150, 80);\n}\n","name":"paint","className":"GraphicsSampler","variables":{"image":2,"ypoints":2,"xpoints":2,"g":29,"w":2,"h":2,"i":6,"angle":1,"Math":2,"numpoints":5},"constants":{"25":10,"26":1,"\"drawRoundRect()\"":1,"\"drawOval()\"":1,"27":1,"\"fillArc()\"":1,"\"drawArc()\"":1,"150":19,"\"fillRect()\"":1,"250":1,"\"drawPolygon()\"":1,"\"x 3\"":1,"110":6,"210":4,"310":4,"135":2,"311":1,"312":1,"90":3,"75":1,"10":5,"76":1,"78":1,"\"fillPolygon()\"":1,"\"drawRect()\"":1,"160":1,"\"fillOval()\"":1,"\"drawImage()\"":1,"0":1,"1":2,"2":3,"300":1,"146":1,"null":2,"225":9,"148":1,"\"fillRoundRect()\"":1,"80":19,"\"drawLine()\"":1,"8":1,"305":1,"true":3,"\"draw3DRect()\"":1,"40":1,"20":5},"javaDoc":"","comments":"Draw a line Specify the font we'll be using throughout Draw a background by tiling an image tile() is defined below Specify the drawing color Draw a line from (25 10) to (150 80) Draw some text See the centerText() method below Draw and fill an arc Draw and fill a rectangle Draw and fill a rounded rectangle Draw and fill an oval Define an octagon using arrays of X and Y coordinates Draw and fill the polygon Draw a 3D rectangle (clear an area for it first) Draw an image (centered within an area)  This method is called whenever the applet needs to be drawn or redrawn","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Component","Image"],"returnType":"void","methodCalls":{"drawImage":1,"getHeight":1,"getWidth":1,"getBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rectangle":1,"int":4},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":5,"BinaryExpr":5,"NameExpr":32,"FieldAccessExpr":2,"EnclosedExpr":2,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":4},"text":"// Utility method to tile an image on the background of the component \nprotected void tile(Graphics g, Component c, Image i) {\n    // Use bounds() instead of getBounds() if you want\n    // compatibility with Java 1.0 and old browsers like Netscape 3\n    // How big is the component?\n    Rectangle r = c.getBounds();\n    // How big is the image?\n    int iw = i.getWidth(c);\n    int ih = i.getHeight(c);\n    if ((iw <= 0) || (ih <= 0))\n        return;\n    for (// Loop horizontally\n    int x = 0; // Loop horizontally\n    x < r.width; // Loop horizontally\n    x += iw) for (// Loop vertically\n    int y = 0; // Loop vertically\n    y < r.height; // Loop vertically\n    y += ih) // Draw the image\n    g.drawImage(i, x, y, c);\n}\n","name":"tile","className":"GraphicsSampler","variables":{"r":1,"c":1,"g":1,"x":3,"i":2,"y":3,"iw":3,"ih":3},"constants":{"0":4},"javaDoc":"","comments":"Use bounds() instead of getBounds() if you want compatibility with Java 1 0 and old browsers like Netscape 3 How big is the component? How big is the image? Loop horizontally Loop horizontally Loop horizontally Loop vertically Loop vertically Loop vertically Draw the image  Utility method to tile an image on the background of the component ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","String","Graphics","Color","int","int","int","int"],"returnType":"void","methodCalls":{"getAscent":1,"stringWidth":2,"getHeight":1,"setColor":1,"drawString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":10,"NullLiteralExpr":3,"VariableDeclarationExpr":3,"DoubleLiteralExpr":2,"BinaryExpr":20,"NameExpr":56,"CastExpr":2,"EnclosedExpr":6,"MethodCallExpr":7,"AssignExpr":7},"statements":{"IfStmt":3,"BlockStmt":1,"ExpressionStmt":13},"text":"// Utility method to center two lines of text in a rectangle.\n// Relies on the FontMetrics obtained in the init() method.\nprotected void centerText(String s1, String s2, Graphics g, Color c, int x, int y, int w, int h) {\n    // How tall is the font?\n    int height = metrics.getHeight();\n    // Where is the font baseline?\n    int ascent = metrics.getAscent();\n    int width1 = 0, width2 = 0, x0 = 0, x1 = 0, y0 = 0, y1 = 0;\n    // How wide are the strings?\n    width1 = metrics.stringWidth(s1);\n    if (s2 != null)\n        width2 = metrics.stringWidth(s2);\n    // Center the strings horizontally\n    x0 = x + (w - width1) / 2;\n    x1 = x + (w - width2) / 2;\n    if (// Center one string vertically\n    s2 == null)\n        y0 = y + (h - height) / 2 + ascent;\n    else {\n        // Center two strings vertically\n        y0 = y + (h - (int) (height * 2.2)) / 2 + ascent;\n        y1 = y0 + (int) (height * 1.2);\n    }\n    // Set the color\n    g.setColor(c);\n    // Draw the strings\n    g.drawString(s1, x0, y0);\n    if (s2 != null)\n        g.drawString(s2, x1, y1);\n}\n","name":"centerText","className":"GraphicsSampler","variables":{"g":3,"h":2,"width2":3,"width1":3,"ascent":3,"y0":4,"w":2,"x0":2,"y1":2,"x":2,"x1":2,"y":2,"metrics":4,"height":4,"s2":3},"constants":{"0":6,"2":4,"null":3,"1.2":1,"2.2":1},"javaDoc":"","comments":"How tall is the font? Where is the font baseline? How wide are the strings? Center the strings horizontally Center one string vertically Center two strings vertically Set the color Draw the strings  Relies on the FontMetrics obtained in the init() method.","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic String getName() {\n    return \"Image Processing\";\n}\n","name":"getName","className":"ImageOps","variables":{},"constants":{"\"Image Processing\"":1},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getWidth() {\n    return WIDTH;\n}\n","name":"getWidth","className":"ImageOps","variables":{"WIDTH":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// From GraphicsExample\npublic int getHeight() {\n    return HEIGHT;\n}\n","name":"getHeight","className":"ImageOps","variables":{"HEIGHT":1},"constants":{},"javaDoc":"","comments":" From GraphicsExample","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ImageOps","methodCalls":{"getResource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.net.URL":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** This constructor loads the image we will manipulate */\npublic ImageOps() {\n    java.net.URL imageurl = this.getClass().getResource(\"cover.gif\");\n    image = new javax.swing.ImageIcon(imageurl).getImage();\n}\n","name":"ImageOps","className":"ImageOps","variables":{"image":1,"imageurl":2},"constants":{"\"cover.gif\"":1},"javaDoc":"This constructor loads the image we will manipulate","comments":" This constructor loads the image we will manipulate ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{"drawImage":3,"getHeight":1,"setColor":1,"createGraphics":1,"getWidth":1,"setFont":1,"translate":3,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"BufferedImage":1,"int":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":19,"NullLiteralExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":5,"NameExpr":67,"StringLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":13},"statements":{"IfStmt":2,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"/** Draw the example */\npublic void draw(Graphics2D g, Component c) {\n    // Create a BufferedImage big enough to hold the Image loaded\n    // in the constructor.  Then copy that image into the new\n    // BufferedImage object so that we can process it.\n    BufferedImage bimage = new BufferedImage(image.getWidth(c), image.getHeight(c), BufferedImage.TYPE_INT_RGB);\n    Graphics2D ig = bimage.createGraphics();\n    // copy the image\n    ig.drawImage(image, 0, 0, c);\n    // Set some default graphics attributes\n    // 12pt bold text\n    g.setFont(new Font(\"SansSerif\", Font.BOLD, 12));\n    // Draw in green\n    g.setColor(Color.green);\n    // Set some margins\n    g.translate(10, 10);\n    // Loop through the filters\n    for (int i = 0; i < filters.length; i++) {\n        // draw the image as processed by the filter\n        if (filters[i] == null)\n            g.drawImage(bimage, 0, 0, c);\n        else\n            g.drawImage(filters[i].filter(bimage, null), 0, 0, c);\n        // Label the image\n        g.drawString(filterNames[i], 0, 205);\n        // Move over\n        g.translate(137, 0);\n        // Move down after 4\n        if (i % 4 == 3)\n            g.translate(-137 * 4, 215);\n    }\n}\n         // If the filter is null, draw the original image, otherwise,\n\n","name":"draw","className":"ImageOps","variables":{"image":2,"g":8,"i":7,"filters":2,"bimage":2,"filterNames":1,"ig":2},"constants":{"0":9,"12":1,"3":1,"null":2,"4":2,"137":2,"215":1,"205":1,"\"SansSerif\"":1,"10":2},"javaDoc":"Draw the example","comments":"Create a BufferedImage big enough to hold the Image loaded in the constructor Then copy that image into the new Set some default graphics attributes BufferedImage object so that we can process it copy the image 12pt bold text Draw in green Set some margins Loop through the filters If the filter is null draw the original image otherwise draw the image as processed by the filter Label the image Move over Move down after 4  Draw the example ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Return the example name\npublic String getName();\n","name":"getName","className":"GraphicsExample","variables":{},"constants":{},"javaDoc":"","comments":" Return the example name","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Return its width\npublic int getWidth();\n","name":"getWidth","className":"GraphicsExample","variables":{},"constants":{},"javaDoc":"","comments":" Return its width","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Return its height\npublic int getHeight();\n","name":"getHeight","className":"GraphicsExample","variables":{},"constants":{},"javaDoc":"","comments":" Return its height","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics2D","Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Draw the example\npublic void draw(Graphics2D g, Component c);\n","name":"draw","className":"GraphicsExample","variables":{},"constants":{},"javaDoc":"","comments":" Draw the example","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int","int","int"],"returnType":"DrawableRect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** The DrawableRect constructor just invokes the Rect() constructor */\npublic DrawableRect(int x1, int y1, int x2, int y2) {\n    super(x1, y1, x2, y2);\n}\n","name":"DrawableRect","className":"DrawableRect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"The DrawableRect constructor just invokes the Rect() constructor","comments":" The DrawableRect constructor just invokes the Rect() constructor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["java.awt.Graphics"],"returnType":"void","methodCalls":{"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"NameExpr":9,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This is the new method defined by DrawableRect */\npublic void draw(java.awt.Graphics g) {\n    g.drawRect(x1, y1, (x2 - x1), (y2 - y1));\n}\n","name":"draw","className":"DrawableRect","variables":{"g":1,"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"This is the new method defined by DrawableRect","comments":" This is the new method defined by DrawableRect ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"intersection":1,"union":1,"isInside":1,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rect":4},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"BinaryExpr":12,"NameExpr":44,"StringLiteralExpr":7,"FieldAccessExpr":7,"MethodCallExpr":6},"statements":{"IfStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // Create Rect objects\n    Rect r1 = new Rect(1, 1, 4, 4);\n    Rect r2 = new Rect(2, 3, 5, 6);\n    // Invoke Rect methods\n    Rect u = r1.union(r2);\n    Rect i = r2.intersection(r1);\n    if (// Use Rect fields and invoke a method\n    u.isInside(r2.x1, r2.y1))\n        System.out.println(\"(\" + r2.x1 + \",\" + r2.y1 + \") is inside the union\");\n    // These lines implicitly call the Rect.toString() method\n    System.out.println(r1 + \" union \" + r2 + \" = \" + u);\n    System.out.println(r1 + \" intersect \" + r2 + \" = \" + i);\n}\n","name":"main","className":"RectTest","variables":{"r2":4,"u":3,"i":2,"r1":4},"constants":{"1":2,"\" intersect \"":1,"2":1,"3":1,"4":2,"5":1,"\") is inside the union\"":1,"\" union \"":1,"6":1,"\",\"":1,"\"(\"":1,"\" = \"":2},"javaDoc":"","comments":"Create Rect objects Invoke Rect methods Use Rect fields and invoke a method These lines implicitly call the Rect toString() method ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** This is the constructor.  It initializes the x and y variables */\npublic ComplexNumber(double real, double imaginary) {\n    this.x = real;\n    this.y = imaginary;\n}\n","name":"ComplexNumber","className":"ComplexNumber","variables":{"imaginary":1,"real":1},"constants":{},"javaDoc":"This is the constructor It initializes the x and y variables","comments":" This is the constructor.  It initializes the x and y variables ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** \n     * An accessor method.  Returns the real part of the complex number.\n     * Note that there is no setReal() method to set the real part.  This means\n     * that the ComplexNumber class is \"immutable\".\n     **/\npublic double real() {\n    return x;\n}\n","name":"real","className":"ComplexNumber","variables":{"x":1},"constants":{},"javaDoc":"An accessor method Returns the real part of the complex number Note that there is no setReal() method to set the real part This means that the ComplexNumber class is \"immutable\"","comments":" \n     * An accessor method.  Returns the real part of the complex number.\n     * Note that there is no setReal() method to set the real part.  This means\n     * that the ComplexNumber class is \"immutable\".\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** An accessor method. Returns the imaginary part of the complex number */\npublic double imaginary() {\n    return y;\n}\n","name":"imaginary","className":"ComplexNumber","variables":{"y":1},"constants":{},"javaDoc":"An accessor method Returns the imaginary part of the complex number","comments":" An accessor method. Returns the imaginary part of the complex number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":7,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Compute the magnitude of a complex number */\npublic double magnitude() {\n    return Math.sqrt(x * x + y * y);\n}\n","name":"magnitude","className":"ComplexNumber","variables":{"x":2,"y":2,"Math":1},"constants":{},"javaDoc":"Compute the magnitude of a complex number","comments":" Compute the magnitude of a complex number ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"StringLiteralExpr":3,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n     * This method converts a ComplexNumber to a string.  This is a method of\n     * Object that we override so that complex numbers can be meaningfully\n     * converted to strings, and so they can conveniently be printed out with\n     * System.out.println() and related methods\n     **/\npublic String toString() {\n    return \"{\" + x + \",\" + y + \"}\";\n}\n","name":"toString","className":"ComplexNumber","variables":{"x":1,"y":1},"constants":{"\"}\"":1,"\",\"":1,"\"{\"":1},"javaDoc":"This method converts a ComplexNumber to a string This is a method of Object that we override so that complex numbers can be meaningfully converted to strings and so they can conveniently be printed out with System out println() and related methods","comments":" \n     * This method converts a ComplexNumber to a string.  This is a method of\n     * Object that we override so that complex numbers can be meaningfully\n     * converted to strings, and so they can conveniently be printed out with\n     * System.out.println() and related methods\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComplexNumber","ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** \n     * This is a static class method.  It takes two complex numbers, adds\n     * them, and returns the result as a third number.  Because it is static,\n     * there is no \"current instance\" or \"this\" object.  Use it like this:\n     * ComplexNumber c = ComplexNumber.add(a, b);\n     **/\npublic static ComplexNumber add(ComplexNumber a, ComplexNumber b) {\n    return new ComplexNumber(a.x + b.x, a.y + b.y);\n}\n","name":"add","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"This is a static class method It takes two complex numbers adds them and returns the result as a third number Because it is static there is no \"current instance\" or \"this\" object Use it like this: ComplexNumber c = ComplexNumber add(a b);","comments":" \n     * This is a static class method.  It takes two complex numbers, adds\n     * them, and returns the result as a third number.  Because it is static,\n     * there is no \"current instance\" or \"this\" object.  Use it like this:\n     * ComplexNumber c = ComplexNumber.add(a, b);\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":10,"FieldAccessExpr":4,"ThisExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * This is a non-static instance method by the same name.  It adds the\n     * specified complex number to the current complex number.  Use it like\n     * this:\n     * ComplexNumber c = a.add(b);\n     **/\npublic ComplexNumber add(ComplexNumber a) {\n    return new ComplexNumber(this.x + a.x, this.y + a.y);\n}\n","name":"add","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"This is a non-static instance method by the same name It adds the specified complex number to the current complex number Use it like this: ComplexNumber c = a add(b);","comments":"\n     * This is a non-static instance method by the same name.  It adds the\n     * specified complex number to the current complex number.  Use it like\n     * this:\n     * ComplexNumber c = a.add(b);\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComplexNumber","ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":24,"FieldAccessExpr":8},"statements":{"ReturnStmt":1},"text":"/** A static class method to multiply complex numbers */\npublic static ComplexNumber multiply(ComplexNumber a, ComplexNumber b) {\n    return new ComplexNumber(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n","name":"multiply","className":"ComplexNumber","variables":{},"constants":{},"javaDoc":"A static class method to multiply complex numbers","comments":" A static class method to multiply complex numbers ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ComplexNumber"],"returnType":"ComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":6,"NameExpr":16,"FieldAccessExpr":4},"statements":{"ReturnStmt":1},"text":"/** An instance method to multiply complex numbers */\npublic ComplexNumber multiply(ComplexNumber a) {\n    return new ComplexNumber(x * a.x - y * a.y, x * a.y + y * a.x);\n}\n","name":"multiply","className":"ComplexNumber","variables":{"x":2,"y":2},"constants":{},"javaDoc":"An instance method to multiply complex numbers","comments":" An instance method to multiply complex numbers ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Randomizer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n     * The constructor for the Randomizer() class.  It must be passed some\n     * arbitrary initial value or \"seed\" for its pseudo-randomness.\n     **/\npublic Randomizer(int seed) {\n    this.seed = seed;\n}\n","name":"Randomizer","className":"Randomizer","variables":{"seed":1},"constants":{},"javaDoc":"The constructor for the Randomizer() class It must be passed some arbitrary initial value or \"seed\" for its pseudo-randomness","comments":" \n     * The constructor for the Randomizer() class.  It must be passed some\n     * arbitrary initial value or \"seed\" for its pseudo-randomness.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"float","methodCalls":{"abs":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":10,"CastExpr":3,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This method computes a pseudo-random number between 0 and 1 using a very\n     * simple algorithm.  Math.random() and java.util.Random are actually a lot\n     * better at computing randomness.\n     **/\npublic float randomFloat() {\n    seed = (seed * a + c) % m;\n    return (float) Math.abs((float) seed / (float) m);\n}\n","name":"randomFloat","className":"Randomizer","variables":{"a":1,"c":1,"seed":3,"Math":1,"m":2},"constants":{},"javaDoc":"This method computes a pseudo-random number between 0 and 1 using a very simple algorithm Math random() and java util Random are actually a lot better at computing randomness","comments":"\n     * This method computes a pseudo-random number between 0 and 1 using a very\n     * simple algorithm.  Math.random() and java.util.Random are actually a lot\n     * better at computing randomness.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"randomFloat":1,"round":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** \n     * This method computes a pseudo-random integer between 0 and specified\n     * maximum.  It uses randomFloat() above.\n     **/\npublic int randomInt(int max) {\n    return Math.round(max * randomFloat());\n}\n","name":"randomInt","className":"Randomizer","variables":{"max":1,"Math":1},"constants":{},"javaDoc":"This method computes a pseudo-random integer between 0 and specified maximum It uses randomFloat() above","comments":" \n     * This method computes a pseudo-random integer between 0 and specified\n     * maximum.  It uses randomFloat() above.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"randomInt":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Randomizer":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"CastExpr":1,"NameExpr":12,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public static void main(String[] args) {\n    Randomizer r = new Randomizer((int) new java.util.Date().getTime());\n    for (int i = 0; i < 10; i++) System.out.println(r.randomInt(100));\n}\n","name":"main","className":"Test","variables":{"r":2,"i":3},"constants":{"0":1,"100":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int","int"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n     * The is the main constructor for the class.  It simply uses its arguments\n     * to initialize each of the fields of the new object.  Note that it has\n     * the same name as the class, and that it has no return value declared in\n     * its signature.\n     **/\npublic Rect(int x1, int y1, int x2, int y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Rect","className":"Rect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"The is the main constructor for the class It simply uses its arguments to initialize each of the fields of the new object Note that it has the same name as the class and that it has no return value declared in its signature","comments":"\n     * The is the main constructor for the class.  It simply uses its arguments\n     * to initialize each of the fields of the new object.  Note that it has\n     * the same name as the class, and that it has no return value declared in\n     * its signature.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * This is another constructor.  It defines itself in terms of the above\n     **/\npublic Rect(int width, int height) {\n    this(0, 0, width, height);\n}\n","name":"Rect","className":"Rect","variables":{"width":1,"height":1},"constants":{"0":2},"javaDoc":"This is another constructor It defines itself in terms of the above","comments":"\n     * This is another constructor.  It defines itself in terms of the above\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** This is yet another constructor. */\npublic Rect() {\n    this(0, 0, 0, 0);\n}\n","name":"Rect","className":"Rect","variables":{},"constants":{"0":4},"javaDoc":"This is yet another constructor","comments":" This is yet another constructor. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Move the rectangle by the specified amounts */\npublic void move(int deltax, int deltay) {\n    x1 += deltax;\n    x2 += deltax;\n    y1 += deltay;\n    y2 += deltay;\n}\n","name":"move","className":"Rect","variables":{"deltax":2,"deltay":2,"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"Move the rectangle by the specified amounts","comments":" Move the rectangle by the specified amounts ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":7,"NameExpr":8,"EnclosedExpr":5},"statements":{"ReturnStmt":1},"text":"/** Test whether the specified point is inside the rectangle */\npublic boolean isInside(int x, int y) {\n    return ((x >= x1) && (x <= x2) && (y >= y1) && (y <= y2));\n}\n","name":"isInside","className":"Rect","variables":{"x":2,"y1":1,"x1":1,"y":2,"y2":1,"x2":1},"constants":{},"javaDoc":"Test whether the specified point is inside the rectangle","comments":" Test whether the specified point is inside the rectangle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rect"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":40,"FieldAccessExpr":16,"ConditionalExpr":4,"EnclosedExpr":4,"ThisExpr":8},"statements":{"ReturnStmt":1},"text":"/** \n     * Return the union of this rectangle with another.  I.e. return the \n     * smallest rectangle that includes them both.\n     **/\npublic Rect union(Rect r) {\n    return new Rect((this.x1 < r.x1) ? this.x1 : r.x1, (this.y1 < r.y1) ? this.y1 : r.y1, (this.x2 > r.x2) ? this.x2 : r.x2, (this.y2 > r.y2) ? this.y2 : r.y2);\n}\n","name":"union","className":"Rect","variables":{},"constants":{},"javaDoc":"Return the union of this rectangle with another I e return the smallest rectangle that includes them both","comments":" \n     * Return the union of this rectangle with another.  I.e. return the \n     * smallest rectangle that includes them both.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rect"],"returnType":"Rect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"Rect":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":6,"NameExpr":65,"FieldAccessExpr":24,"ConditionalExpr":4,"EnclosedExpr":4,"ThisExpr":8,"AssignExpr":4},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** \n     * Return the intersection of this rectangle with another. \n     * I.e. return their overlap.\n     **/\npublic Rect intersection(Rect r) {\n    Rect result = new Rect((this.x1 > r.x1) ? this.x1 : r.x1, (this.y1 > r.y1) ? this.y1 : r.y1, (this.x2 < r.x2) ? this.x2 : r.x2, (this.y2 < r.y2) ? this.y2 : r.y2);\n    if (result.x1 > result.x2) {\n        result.x1 = result.x2 = 0;\n    }\n    if (result.y1 > result.y2) {\n        result.y1 = result.y2 = 0;\n    }\n    return result;\n}\n","name":"intersection","className":"Rect","variables":{"result":2},"constants":{"0":2},"javaDoc":"Return the intersection of this rectangle with another I e return their overlap","comments":" \n     * Return the intersection of this rectangle with another. \n     * I.e. return their overlap.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":8,"StringLiteralExpr":5,"NameExpr":4},"statements":{"ReturnStmt":1},"text":"/**\n      * This is a method of our superclass, Object.  We override it so that\n      * Rect objects can be meaningfully converted to strings, can be \n      * concatenated to strings with the + operator, and can be passed to \n      * methods like System.out.println()\n      **/\npublic String toString() {\n    return \"[\" + x1 + \",\" + y1 + \"; \" + x2 + \",\" + y2 + \"]\";\n}\n","name":"toString","className":"Rect","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{"\"]\"":1,"\",\"":2,"\"[\"":1,"\"; \"":1},"javaDoc":"This is a method of our superclass Object We override it so that Rect objects can be meaningfully converted to strings can be concatenated to strings with the + operator and can be passed to methods like System out println()","comments":"\n      * This is a method of our superclass, Object.  We override it so that\n      * Rect objects can be meaningfully converted to strings, can be \n      * concatenated to strings with the + operator, and can be passed to \n      * methods like System.out.println()\n      *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Compare objects, return a value that indicates their relative order:\n\t * if (a > b) return > 0; \n\t * if (a == b) return 0;\n\t * if (a < b) return < 0. \n\t **/\npublic int compare(Object a, Object b);\n","name":"compare","className":"Comparer","variables":{},"constants":{},"javaDoc":"Compare objects return a value that indicates their relative order: if (a > b) return > 0; if (a == b) return 0; if (a < b) return < 0","comments":"\n\t * Compare objects, return a value that indicates their relative order:\n\t * if (a > b) return > 0; \n\t * if (a == b) return 0;\n\t * if (a < b) return < 0. \n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Compare objects, return a value that indicates their relative order:\n\t * if (this > other) return > 0\n\t * if (this == other) return 0\n\t * if (this < other) return < 0\n\t **/\npublic int compareTo(Object other);\n","name":"compareTo","className":"Comparable","variables":{},"constants":{},"javaDoc":"Compare objects return a value that indicates their relative order: if (this > other) return > 0 if (this == other) return 0 if (this < other) return < 0","comments":" \n\t * Compare objects, return a value that indicates their relative order:\n\t * if (this > other) return > 0\n\t * if (this == other) return 0\n\t * if (this < other) return < 0\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((String) a).compareTo((String) b);\n}\n","name":"compare","className":"","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((Comparable) a).compareTo(b);\n}\n","name":"compare","className":"","variables":{"a":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of ASCII strings into ascending order */\npublic static void sortAscii(String[] a) {\n    // Note use of the ascii_comparer object\n    sort(a, null, 0, a.length - 1, true, ascii_comparer);\n}\n","name":"sortAscii","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of ASCII strings into ascending order","comments":"Note use of the ascii_comparer object  Sort an array of ASCII strings into ascending order ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n     * Sort a portion of an array of ASCII strings into ascending or descending\n     * order, depending on the argument up\n     **/\npublic static void sortAscii(String[] a, int from, int to, boolean up) {\n    // Note use of the ascii_comparer object\n    sort(a, null, from, to, up, ascii_comparer);\n}\n","name":"sortAscii","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of ASCII strings into ascending or descending order depending on the argument up","comments":"Note use of the ascii_comparer object  \n     * Sort a portion of an array of ASCII strings into ascending or descending\n     * order, depending on the argument up\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sortAsciiIgnoreCase":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of ASCII strings into ascending order, ignoring case */\npublic static void sortAsciiIgnoreCase(String[] a) {\n    sortAsciiIgnoreCase(a, 0, a.length - 1, true);\n}\n","name":"sortAsciiIgnoreCase","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"true":1},"javaDoc":"Sort an array of ASCII strings into ascending order ignoring case","comments":" Sort an array of ASCII strings into ascending order, ignoring case ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":26,"FieldAccessExpr":3,"EnclosedExpr":2,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/**\n     * Sort an portion of an array of ASCII strings, ignoring case.  Sort into\n     * ascending order if up is true, otherwise sort into descending order.\n     **/\npublic static void sortAsciiIgnoreCase(String[] a, int from, int to, boolean up) {\n    if ((a == null) || (a.length < 2))\n        return;\n    // Create a secondary array of strings that contains lowercase versions\n    // of all the specified strings. \n    String b[] = new String[a.length];\n    for (int i = 0; i < a.length; i++) b[i] = a[i].toLowerCase();\n    // Sort that secondary array, and rearrange the original array \n    // in exactly the same way, resulting in a case-insensitive sort.\n    // Note the use of the ascii_comparer object\n    sort(b, a, from, to, up, ascii_comparer);\n}\n","name":"sortAsciiIgnoreCase","className":"Sorter","variables":{"a":2,"b":2,"i":5},"constants":{"0":1,"2":1,"null":1},"javaDoc":"Sort an portion of an array of ASCII strings ignoring case Sort into ascending order if up is true otherwise sort into descending order","comments":"Create a secondary array of strings that contains lowercase versions Sort that secondary array and rearrange the original array in exactly the same way resulting in a case-insensitive sort of all the specified strings Note the use of the ascii_comparer object \n     * Sort an portion of an array of ASCII strings, ignoring case.  Sort into\n     * ascending order if up is true, otherwise sort into descending order.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":2,"NullLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n     * Sort an array of strings into ascending order, using the correct\n     * collation order for the default locale\n     **/\npublic static void sort(String[] a) {\n    sort(a, 0, a.length - 1, true, false, null);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1,"false":1},"javaDoc":"Sort an array of strings into ascending order using the correct collation order for the default locale","comments":" \n     * Sort an array of strings into ascending order, using the correct\n     * collation order for the default locale\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]","int","int","boolean","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Sort a portion of an array of strings, using the collation order of\n     * the default locale.   If up is true, sort ascending, otherwise, sort\n     * descending.  If ignorecase is true, ignore the capitalization of letters\n     **/\npublic static void sort(String[] a, int from, int to, boolean up, boolean ignorecase) {\n    sort(a, from, to, up, ignorecase, null);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of strings using the collation order of the default locale If up is true sort ascending otherwise sort descending If ignorecase is true ignore the capitalization of letters","comments":"\n     * Sort a portion of an array of strings, using the collation order of\n     * the default locale.   If up is true, sort ascending, otherwise, sort\n     * descending.  If ignorecase is true, ignore the capitalization of letters\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":2,"NameExpr":4,"EnclosedExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public int compare(Object a, Object b) {\n    return ((CollationKey) a).compareTo((CollationKey) b);\n}\n","name":"compare","className":"","variables":{"a":1,"b":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]","int","int","boolean","boolean","Locale"],"returnType":"void","methodCalls":{"setStrength":1,"getCollationKey":1,"getInstance":2,"sort":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","Recursion"],"types":{"Comparer":1,"CollationKey[]":1,"int":1,"Collator":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":50,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":2,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":8},"text":"/**\n     * Sort a portion of an array of strings, using the collation order of\n     * the specified locale.   If up is true, sort ascending, otherwise, sort\n     * descending.  If ignorecase is true, ignore the capitalization of letters\n     **/\npublic static void sort(String[] a, int from, int to, boolean up, boolean ignorecase, Locale locale) {\n    // Don't sort if we don't have to\n    if ((a == null) || (a.length < 2))\n        return;\n    // The java.text.Collator object does internationalized string compares\n    // Create one for the specified, or the default locale.\n    Collator c;\n    if (locale == null)\n        c = Collator.getInstance();\n    else\n        c = Collator.getInstance(locale);\n    // using the default American English locale.\n    if (ignorecase)\n        c.setStrength(Collator.SECONDARY);\n    // Use the Collator object to create an array of CollationKey objects \n    // that correspond to each of the strings.  \n    // Comparing CollationKeys is much quicker than comparing Strings\n    CollationKey[] b = new CollationKey[a.length];\n    for (int i = 0; i < a.length; i++) b[i] = c.getCollationKey(a[i]);\n    // Now define a Comparer object to compare collation keys, using an\n    // anonymous class.\n    Comparer comp = new Comparer() {\n\n        public int compare(Object a, Object b) {\n            return ((CollationKey) a).compareTo((CollationKey) b);\n        }\n    };\n    // Finally, sort the array of CollationKey objects, rearranging the \n    // original array of strings in exactly the same way.\n    sort(b, a, from, to, up, comp);\n}\n         // Specify whether or not case should be considered in the sort.\n\n         // Note: this option does not seem to work correctly in JDK 1.1.1\n\n","name":"sort","className":"Sorter","variables":{"a":4,"ignorecase":1,"comp":1,"b":4,"compare":1,"c":5,"i":5,"locale":1,"Collator":2},"constants":{"0":1,"2":1,"null":2},"javaDoc":"Sort a portion of an array of strings using the collation order of the specified locale If up is true sort ascending otherwise sort descending If ignorecase is true ignore the capitalization of letters","comments":"The java text Collator object does internationalized string compares Specify whether or not case should be considered in the sort Note: this option does not seem to work correctly in JDK 1 1 1 Use the Collator object to create an array of CollationKey objects that correspond to each of the strings Now define a Comparer object to compare collation keys using an Finally sort the array of CollationKey objects rearranging the Don't sort if we don't have to Create one for the specified or the default locale using the default American English locale Comparing CollationKeys is much quicker than comparing Strings anonymous class original array of strings in exactly the same way \n     * Sort a portion of an array of strings, using the collation order of\n     * the specified locale.   If up is true, sort ascending, otherwise, sort\n     * descending.  If ignorecase is true, ignore the capitalization of letters\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Sort an array of Comparable objects into ascending order */\npublic static void sort(Comparable[] a) {\n    sort(a, null, 0, a.length - 1, true);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of Comparable objects into ascending order","comments":" Sort an array of Comparable objects into ascending order ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Sort a portion of an array of Comparable objects.  If up is true,\n     * sort into ascending order, otherwise sort into descending order.\n     **/\npublic static void sort(Comparable[] a, int from, int to, boolean up) {\n    sort(a, null, from, to, up, comparable_comparer);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of Comparable objects If up is true sort into ascending order otherwise sort into descending order","comments":"\n     * Sort a portion of an array of Comparable objects.  If up is true,\n     * sort into ascending order, otherwise sort into descending order.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Comparable[]","Object[]","int","int","boolean"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Sort a portion of array a of Comparable objects.  If up is true,\n     * sort into ascending order, otherwise sort into descending order.\n     * Re-arrange the array b in exactly the same way as a.\n     **/\npublic static void sort(Comparable[] a, Object[] b, int from, int to, boolean up) {\n    sort(a, b, from, to, up, comparable_comparer);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{},"javaDoc":"Sort a portion of array a of Comparable objects If up is true sort into ascending order otherwise sort into descending order Re-arrange the array b in exactly the same way as a","comments":"\n     * Sort a portion of array a of Comparable objects.  If up is true,\n     * sort into ascending order, otherwise sort into descending order.\n     * Re-arrange the array b in exactly the same way as a.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","Comparer"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Sort an array of arbitrary objects into ascending order, using the \n     * comparison defined by the Comparer object c\n     **/\npublic static void sort(Object[] a, Comparer c) {\n    sort(a, null, 0, a.length - 1, true, c);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"0":1,"1":1,"null":1,"true":1},"javaDoc":"Sort an array of arbitrary objects into ascending order using the comparison defined by the Comparer object c","comments":"\n     * Sort an array of arbitrary objects into ascending order, using the \n     * comparison defined by the Comparer object c\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","int","int","boolean","Comparer"],"returnType":"void","methodCalls":{"sort":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":7,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Sort a portion of an array of objects, using the comparison defined by\n     * the Comparer object c.  If up is true, sort into ascending order, \n     * otherwise sort into descending order.\n     **/\npublic static void sort(Object[] a, int from, int to, boolean up, Comparer c) {\n    sort(a, null, from, to, up, c);\n}\n","name":"sort","className":"Sorter","variables":{},"constants":{"null":1},"javaDoc":"Sort a portion of an array of objects using the comparison defined by the Comparer object c If up is true sort into ascending order otherwise sort into descending order","comments":"\n     * Sort a portion of an array of objects, using the comparison defined by\n     * the Comparer object c.  If up is true, sort into ascending order, \n     * otherwise sort into descending order.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object[]","Object[]","int","int","boolean","Comparer"],"returnType":"void","methodCalls":{"compare":4,"sort":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Object":2,"int":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":3,"ArrayAccessExpr":13,"BinaryExpr":23,"NameExpr":94,"FieldAccessExpr":1,"EnclosedExpr":11,"UnaryExpr":6,"MethodCallExpr":6,"AssignExpr":5},"statements":{"IfStmt":7,"WhileStmt":4,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":16,"DoStmt":1},"text":"/**\n     * This is the main sort() routine. It performs a quicksort on the elements\n     * of array a between the element from and the element to.  The up argument\n     * specifies whether the elements should be sorted into ascending (true) or\n     * descending (false) order.  The Comparer argument c is used to perform\n     * comparisons between elements of the array.  The elements of the array b\n     * are reordered in exactly the same way as the elements of array a are.\n     **/\npublic static void sort(Object[] a, Object[] b, int from, int to, boolean up, Comparer c) {\n    // If there is nothing to sort, return\n    if ((a == null) || (a.length < 2))\n        return;\n    // This is the basic quicksort algorithm, stripped of frills that can\n    // make it faster but even more confusing than it already is.  You\n    // should understand what the code does, but don't have to understand\n    // just why it is guaranteed to sort the array...\n    // Note the use of the compare() method of the Comparer object.\n    int i = from, j = to;\n    Object center = a[(from + to) / 2];\n    do {\n        if (up) {\n            // an ascending sort\n            while ((i < to) && (c.compare(center, a[i]) > 0)) i++;\n            while ((j > from) && (c.compare(center, a[j]) < 0)) j--;\n        } else {\n            // a descending sort\n            while ((i < to) && (c.compare(center, a[i]) < 0)) i++;\n            while ((j > from) && (c.compare(center, a[j]) > 0)) j--;\n        }\n        if (i < j) {\n            // swap elements\n            Object tmp = a[i];\n            // swap elements\n            a[i] = a[j];\n            // swap elements\n            a[j] = tmp;\n            // swap\n            if (b != null) {\n                tmp = b[i];\n                b[i] = b[j];\n                b[j] = tmp;\n            }\n        }\n        if (i <= j) {\n            i++;\n            j--;\n        }\n    } while (i <= j);\n    // recursively sort the rest\n    if (from < j)\n        sort(a, b, from, j, up, c);\n    if (i < to)\n        sort(a, b, i, to, up, c);\n}\n","name":"sort","className":"Sorter","variables":{"a":10,"b":5,"c":4,"tmp":4,"center":1,"i":16,"from":5,"j":16,"to":5,"up":1},"constants":{"0":4,"2":2,"null":2},"javaDoc":"This is the main sort() routine It performs a quicksort on the elements of array a between the element from and the element to The up argument specifies whether the elements should be sorted into ascending (true) or descending (false) order The Comparer argument c is used to perform comparisons between elements of the array The elements of the array b are reordered in exactly the same way as the elements of array a are","comments":"This is the basic quicksort algorithm stripped of frills that can make it faster but even more confusing than it already is You should understand what the code does but don't have to understand just why it is guaranteed to sort the array If there is nothing to sort return Note the use of the compare() method of the Comparer object an ascending sort a descending sort swap elements swap elements swap elements swap recursively sort the rest \n     * This is the main sort() routine. It performs a quicksort on the elements\n     * of array a between the element from and the element to.  The up argument\n     * specifies whether the elements should be sorted into ascending (true) or\n     * descending (false) order.  The Comparer argument c is used to perform\n     * comparisons between elements of the array.  The elements of the array b\n     * are reordered in exactly the same way as the elements of array a are.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"SortableComplexNumber","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SortableComplexNumber(double x, double y) {\n    super(x, y);\n}\n","name":"SortableComplexNumber","className":"SortableComplexNumber","variables":{"x":1,"y":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"sign":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1},"text":"public int compareTo(Object other) {\n    return sign(this.magnitude() - ((ComplexNumber) other).magnitude());\n}\n","name":"compareTo","className":"SortableComplexNumber","variables":{"other":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"imaginary":2,"sign":1,"real":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"ComplexNumber":2},"expressions":{"VariableDeclarationExpr":2,"BinaryExpr":3,"CastExpr":2,"NameExpr":16,"EnclosedExpr":2,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public int compare(Object a, Object b) {\n    ComplexNumber i = (ComplexNumber) a;\n    ComplexNumber j = (ComplexNumber) b;\n    return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));\n}\n","name":"compare","className":"","variables":{"a":1,"b":1,"i":3,"j":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"imaginary":2,"sign":1,"real":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":1,"ComplexNumber":2},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"CastExpr":2,"NameExpr":19,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public int compare(Object a, Object b) {\n    ComplexNumber i = (ComplexNumber) a;\n    ComplexNumber j = (ComplexNumber) b;\n    double result = i.real() - j.real();\n    if (result == 0)\n        result = i.imaginary() - j.imaginary();\n    return sign(result);\n}\n","name":"compare","className":"","variables":{"result":3,"a":1,"b":1,"i":3,"j":3},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":2,"imaginary":4,"sign":2,"sort":3,"real":4,"System.out.println":6},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"double":1,"ComplexNumber":4,"int":4,"SortableComplexNumber[]":1},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":3,"VariableDeclarationExpr":10,"ArrayAccessExpr":4,"BinaryExpr":13,"NameExpr":118,"StringLiteralExpr":3,"UnaryExpr":4,"AssignExpr":2,"BooleanLiteralExpr":1,"CastExpr":4,"FieldAccessExpr":11,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":21},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":4,"ReturnStmt":2,"ExpressionStmt":17},"text":"/** A a test program that sorts complex numbers in various ways. */\npublic static void main(String[] args) {\n    // Define an array of SortableComplexNumber objects.  Initialize it\n    // to contain random complex numbers.\n    SortableComplexNumber[] a = new SortableComplexNumber[5];\n    for (int i = 0; i < a.length; i++) a[i] = new SortableComplexNumber(Math.random() * 10, Math.random() * 10);\n    // Now sort it using the SortableComplexNumber compareTo() method, \n    // which sorts by magnitude, and print the results out.\n    System.out.println(\"Sorted by magnitude:\");\n    Sorter.sort(a);\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n    // Sort the complex numbers again, using a Comparer object that\n    // compares them based on the sum of their real and imaginary parts\n    System.out.println(\"Sorted by sum of real and imaginary parts:\");\n    Sorter.sort(a, new Sorter.Comparer() {\n\n        public int compare(Object a, Object b) {\n            ComplexNumber i = (ComplexNumber) a;\n            ComplexNumber j = (ComplexNumber) b;\n            return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));\n        }\n    });\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n    // Sort them again using a Comparer object that compares their real\n    // parts, and then their imaginary parts\n    System.out.println(\"Sorted descending by real, then imaginary:\");\n    Sorter.sort(a, 0, a.length - 1, false, new Sorter.Comparer() {\n\n        public int compare(Object a, Object b) {\n            ComplexNumber i = (ComplexNumber) a;\n            ComplexNumber j = (ComplexNumber) b;\n            double result = i.real() - j.real();\n            if (result == 0)\n                result = i.imaginary() - j.imaginary();\n            return sign(result);\n        }\n    });\n    for (int i = 0; i < a.length; i++) System.out.println(a[i]);\n}\n","name":"main","className":"Test","variables":{"result":3,"a":9,"b":4,"compare":2,"Sorter":3,"i":22,"j":6,"Math":2},"constants":{"0":6,"1":1,"\"Sorted by magnitude:\"":1,"\"Sorted by sum of real and imaginary parts:\"":1,"5":1,"false":1,"\"Sorted descending by real, then imaginary:\"":1,"10":2},"javaDoc":"A a test program that sorts complex numbers in various ways","comments":"Define an array of SortableComplexNumber objects Initialize it Now sort it using the SortableComplexNumber compareTo() method Sort the complex numbers again using a Comparer object that Sort them again using a Comparer object that compares their real to contain random complex numbers which sorts by magnitude and print the results out compares them based on the sum of their real and imaginary parts parts and then their imaginary parts  A a test program that sorts complex numbers in various ways. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":5,"BinaryExpr":2,"NameExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3},"text":"/** This is a convenience routine used by comparison routines */\npublic static int sign(double x) {\n    if (x > 0)\n        return 1;\n    else if (x < 0)\n        return -1;\n    else\n        return 0;\n}\n","name":"sign","className":"Test","variables":{"x":2},"constants":{"0":3,"1":2},"javaDoc":"This is a convenience routine used by comparison routines","comments":" This is a convenience routine used by comparison routines ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"UnaryExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/** \n     * This method adds a new datum into the average.\n     **/\npublic void addDatum(double x) {\n    n++;\n    sum += x;\n    sumOfSquares += x * x;\n}\n","name":"addDatum","className":"Averager","variables":{"sumOfSquares":1,"x":3,"sum":1,"n":1},"constants":{},"javaDoc":"This method adds a new datum into the average","comments":" \n     * This method adds a new datum into the average.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** This method returns the average of all numbers passed to addDatum() */\npublic double getAverage() {\n    return sum / n;\n}\n","name":"getAverage","className":"Averager","variables":{"sum":1,"n":1},"constants":{},"javaDoc":"This method returns the average of all numbers passed to addDatum()","comments":" This method returns the average of all numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{"sqrt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":8,"EnclosedExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the standard deviation of the data */\npublic double getStandardDeviation() {\n    return Math.sqrt(((sumOfSquares - sum * sum / n) / n));\n}\n","name":"getStandardDeviation","className":"Averager","variables":{"sumOfSquares":1,"sum":2,"Math":1,"n":2},"constants":{},"javaDoc":"This method returns the standard deviation of the data","comments":" This method returns the standard deviation of the data ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the number of numbers passed to addDatum() */\npublic double getNum() {\n    return n;\n}\n","name":"getNum","className":"Averager","variables":{"n":1},"constants":{},"javaDoc":"This method returns the number of numbers passed to addDatum()","comments":" This method returns the number of numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the sum of all numbers passed to addDatum() */\npublic double getSum() {\n    return sum;\n}\n","name":"getSum","className":"Averager","variables":{"sum":1},"constants":{},"javaDoc":"This method returns the sum of all numbers passed to addDatum()","comments":" This method returns the sum of all numbers passed to addDatum() ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"double","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method returns the sum of the squares of all numbers. */\npublic double getSumOfSquares() {\n    return sumOfSquares;\n}\n","name":"getSumOfSquares","className":"Averager","variables":{"sumOfSquares":1},"constants":{},"javaDoc":"This method returns the sum of the squares of all numbers","comments":" This method returns the sum of the squares of all numbers. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"DoubleLiteralExpr":2,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/** This method resets the Averager object to begin from scratch */\npublic void reset() {\n    n = 0;\n    sum = 0.0;\n    sumOfSquares = 0.0;\n}\n","name":"reset","className":"Averager","variables":{"sumOfSquares":1,"sum":1,"n":1},"constants":{"0":1,"0.0":2},"javaDoc":"This method resets the Averager object to begin from scratch","comments":" This method resets the Averager object to begin from scratch ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getStandardDeviation":1,"getSumOfSquares":1,"getNum":1,"getAverage":1,"getSum":1,"addDatum":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"Averager":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":46,"StringLiteralExpr":5,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":11},"statements":{"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String args[]) {\n    Averager a = new Averager();\n    for (int i = 1; i <= 100; i++) a.addDatum(i);\n    System.out.println(\"Average: \" + a.getAverage());\n    System.out.println(\"Standard Deviation: \" + a.getStandardDeviation());\n    System.out.println(\"N: \" + a.getNum());\n    System.out.println(\"Sum: \" + a.getSum());\n    System.out.println(\"Sum of squares: \" + a.getSumOfSquares());\n}\n","name":"main","className":"Test","variables":{"a":7,"i":3},"constants":{"100":1,"1":1,"\"Standard Deviation: \"":1,"\"N: \"":1,"\"Sum: \"":1,"\"Sum of squares: \"":1,"\"Average: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Returns the next element in the list\npublic Linkable getNext();\n","name":"getNext","className":"Linkable","variables":{},"constants":{},"javaDoc":"","comments":" Returns the next element in the list","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Sets the next element in the list\npublic void setNext(Linkable node);\n","name":"setNext","className":"Linkable","variables":{},"constants":{},"javaDoc":"","comments":" Sets the next element in the list","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the first node in the list */\npublic synchronized Linkable getHead() {\n    return head;\n}\n","name":"getHead","className":"LinkedList","variables":{"head":1},"constants":{},"javaDoc":"Return the first node in the list","comments":" Return the first node in the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"setNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Insert a node at the beginning of the list */\npublic synchronized void insertAtHead(Linkable node) {\n    node.setNext(head);\n    head = node;\n}\n","name":"insertAtHead","className":"LinkedList","variables":{"head":1,"node":2},"constants":{},"javaDoc":"Insert a node at the beginning of the list","comments":" Insert a node at the beginning of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"setNext":1,"getNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":15,"EnclosedExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"EmptyStmt":1,"ForStmt":1,"ExpressionStmt":3},"text":"/** Insert a node at the end of the list */\npublic synchronized void insertAtTail(Linkable node) {\n    if (head == null)\n        head = node;\n    else {\n        Linkable p, q;\n        for (p = head; (q = p.getNext()) != null; p = q) ;\n        /* no body */\n        p.setNext(node);\n    }\n}\n","name":"insertAtTail","className":"LinkedList","variables":{"head":3,"p":5,"node":1,"q":3},"constants":{"null":2},"javaDoc":"Insert a node at the end of the list","comments":"no body  Insert a node at the end of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{"setNext":1,"getNext":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"AssignExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Remove and return the node at the head of the list */\npublic synchronized Linkable removeFromHead() {\n    Linkable node = head;\n    if (node != null) {\n        head = node.getNext();\n        node.setNext(null);\n    }\n    return node;\n}\n","name":"removeFromHead","className":"LinkedList","variables":{"head":2,"node":5},"constants":{"null":2},"javaDoc":"Remove and return the node at the head of the list","comments":" Remove and return the node at the head of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{"setNext":1,"getNext":2},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":7,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"EnclosedExpr":1,"MethodCallExpr":3,"AssignExpr":4},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":2,"ReturnStmt":3,"ExpressionStmt":5},"text":"/** Remove and return the node at the end of the list */\npublic synchronized Linkable removeFromTail() {\n    if (head == null)\n        return null;\n    Linkable p = head, q = null, next = head.getNext();\n    if (next == null) {\n        head = null;\n        return p;\n    }\n    while ((next = p.getNext()) != null) {\n        q = p;\n        p = next;\n    }\n    q.setNext(null);\n    return p;\n}\n","name":"removeFromTail","className":"LinkedList","variables":{"head":4,"p":6,"next":4,"q":3},"constants":{"null":7},"javaDoc":"Remove and return the node at the end of the list","comments":" Remove and return the node at the end of the list ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{"equals":2,"setNext":1,"getNext":3},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"Linkable":1},"expressions":{"NullLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":26,"EnclosedExpr":1,"MethodCallExpr":6,"AssignExpr":3},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":4},"text":"/** \n     * Remove a node matching the specified node from the list.  \n     * Use equals() instead of == to test for a matched node.\n     **/\npublic synchronized void remove(Linkable node) {\n    if (head == null)\n        return;\n    if (node.equals(head)) {\n        head = head.getNext();\n        return;\n    }\n    Linkable p = head, q = null;\n    while ((q = p.getNext()) != null) {\n        if (node.equals(q)) {\n            p.setNext(q.getNext());\n            return;\n        }\n        p = q;\n    }\n}\n","name":"remove","className":"LinkedList","variables":{"head":4,"p":4,"node":2,"q":4},"constants":{"null":3},"javaDoc":"Remove a node matching the specified node from the list Use equals() instead of == to test for a matched node","comments":" \n     * Remove a node matching the specified node from the list.  \n     * Use equals() instead of == to test for a matched node.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["int"],"returnType":"LinkableInteger","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Constructor\npublic LinkableInteger(int i) {\n    this.i = i;\n}\n","name":"LinkableInteger","className":"LinkableInteger","variables":{"i":1},"constants":{},"javaDoc":"","comments":" Constructor","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Linkable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Part of Linkable\npublic Linkable getNext() {\n    return next;\n}\n","name":"getNext","className":"LinkableInteger","variables":{"next":1},"constants":{},"javaDoc":"","comments":" Part of Linkable","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Linkable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Linkable\npublic void setNext(Linkable node) {\n    next = node;\n}\n","name":"setNext","className":"LinkableInteger","variables":{"next":1,"node":1},"constants":{},"javaDoc":"","comments":" Linkable","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":1,"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// For easy printing\npublic String toString() {\n    return i + \"\";\n}\n","name":"toString","className":"LinkableInteger","variables":{"i":1},"constants":{"\"\"":1},"javaDoc":"","comments":" For easy printing","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"BooleanLiteralExpr":4,"NameExpr":7,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":2,"UnaryExpr":1,"InstanceOfExpr":1,"ThisExpr":2},"statements":{"IfStmt":3,"ReturnStmt":4},"text":"public boolean equals(Object o) {\n    // For comparison\n    if (this == o)\n        return true;\n    if (!(o instanceof LinkableInteger))\n        return false;\n    if (((LinkableInteger) o).i == this.i)\n        return true;\n    return false;\n}\n","name":"equals","className":"LinkableInteger","variables":{"o":3},"constants":{"true":2,"false":2},"javaDoc":"","comments":"For comparison ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"insertAtTail":2,"getHead":1,"removeFromTail":1,"insertAtHead":4,"getNext":1,"remove":1,"System.out.println":3,"removeFromHead":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Linkable":1,"LinkedList":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":7,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":51,"FieldAccessExpr":3,"MethodCallExpr":14,"AssignExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":11},"text":"/**\n\t * The test program.  Insert some nodes, remove some nodes, then\n\t * print out all elements in the list.  It should print out the\n\t * numbers 4, 6, 3, 1, and 5\n\t **/\npublic static void main(String[] args) {\n    // Create a list\n    LinkedList ll = new LinkedList();\n    // Insert some stuff\n    ll.insertAtHead(new LinkableInteger(1));\n    ll.insertAtHead(new LinkableInteger(2));\n    ll.insertAtHead(new LinkableInteger(3));\n    ll.insertAtHead(new LinkableInteger(4));\n    ll.insertAtTail(new LinkableInteger(5));\n    ll.insertAtTail(new LinkableInteger(6));\n    // Remove and print a node\n    System.out.println(ll.removeFromHead());\n    // Remove and print again\n    System.out.println(ll.removeFromTail());\n    // Remove another one\n    ll.remove(new LinkableInteger(2));\n    // Now print out the contents of the list.\n    for (Linkable l = ll.getHead(); l != null; l = l.getNext()) System.out.println(l);\n}\n","name":"main","className":"Test","variables":{"ll":11,"l":4},"constants":{"1":1,"2":2,"3":1,"4":1,"null":1,"5":1,"6":1},"javaDoc":"The test program Insert some nodes remove some nodes then print out all elements in the list It should print out the numbers 4 6 3 1 and 5","comments":"Create a list Insert some stuff Remove and print a node Remove and print again Remove another one Now print out the contents of the list \n\t * The test program.  Insert some nodes, remove some nodes, then\n\t * print out all elements in the list.  It should print out the\n\t * numbers 4, 6, 3, 1, and 5\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int","int","int","int","Color","Color"],"returnType":"ColoredRect","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"/**\n     * This constructor uses super() to invoke the superclass constructor, and\n     * also does some initialization of its own.\n     **/\npublic ColoredRect(int x1, int y1, int x2, int y2, Color border, Color fill) {\n    super(x1, y1, x2, y2);\n    this.border = border;\n    this.fill = fill;\n}\n","name":"ColoredRect","className":"ColoredRect","variables":{"border":1,"y1":1,"x1":1,"y2":1,"x2":1,"fill":1},"constants":{},"javaDoc":"This constructor uses super() to invoke the superclass constructor and also does some initialization of its own","comments":"\n     * This constructor uses super() to invoke the superclass constructor, and\n     * also does some initialization of its own.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setColor":2,"fillRect":1,"drawRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":26,"EnclosedExpr":4,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/**\n     * This method overrides the draw() method of our superclass so that it\n     * can make use of the colors that have been specified.\n     **/\npublic void draw(Graphics g) {\n    g.setColor(fill);\n    g.fillRect(x1, y1, (x2 - x1), (y2 - y1));\n    g.setColor(border);\n    g.drawRect(x1, y1, (x2 - x1), (y2 - y1));\n}\n","name":"draw","className":"ColoredRect","variables":{"g":4,"y1":2,"x1":2,"y2":2,"x2":2},"constants":{},"javaDoc":"This method overrides the draw() method of our superclass so that it can make use of the colors that have been specified","comments":"\n     * This method overrides the draw() method of our superclass so that it\n     * can make use of the colors that have been specified.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":2,"getY":2,"getSource":1,"show":1,"isPopupTrigger":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":24,"CastExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    if (e.isPopupTrigger())\n        popup.show((Component) e.getSource(), e.getX(), e.getY());\n    else\n        // start new line\n        scribble.moveto(e.getX(), e.getY());\n}\n","name":"mousePressed","className":"","variables":{"popup":1,"e":6,"scribble":1},"constants":{},"javaDoc":"","comments":"start new line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"lineto":1,"getModifiers":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":17,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public void mouseDragged(MouseEvent e) {\n    // If this isn't mouse button 1, ignore it\n    if ((e.getModifiers() & InputEvent.BUTTON1_MASK) == 0)\n        return;\n    // Add a line \n    scribble.lineto(e.getX(), e.getY());\n    repaint();\n}\n","name":"mouseDragged","className":"","variables":{"e":3,"scribble":1},"constants":{"0":1},"javaDoc":"","comments":"If this isn't mouse button 1 ignore it Add a line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribbleCutAndPaste","methodCalls":{"add":1,"addActionListener":1,"show":1,"addMouseMotionListener":1,"setActionCommand":1,"lineto":1,"isPopupTrigger":1,"getX":3,"getY":3,"getSource":1,"setLabel":1,"getModifiers":1,"repaint":1,"addMouseListener":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"String[]":2,"JMenuItem":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":3,"StringLiteralExpr":9,"NameExpr":75,"UnaryExpr":1,"AssignExpr":1,"ArrayInitializerExpr":2,"CastExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":2,"ThisExpr":2,"MethodCallExpr":20},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"public ScribbleCutAndPaste() {\n    // Create the popup menu.\n    String[] labels = new String[] { \"Clear\", \"Cut\", \"Copy\", \"Paste\" };\n    String[] commands = new String[] { \"clear\", \"cut\", \"copy\", \"paste\" };\n    // Create the menu\n    popup = new JPopupMenu();\n    popup.setLabel(\"Edit\");\n    for (int i = 0; i < labels.length; i++) {\n        // Create a menu item \n        JMenuItem mi = new JMenuItem(labels[i]);\n        // Set its action command\n        mi.setActionCommand(commands[i]);\n        // And its action listener\n        mi.addActionListener(this);\n        // Add item to the menu\n        popup.add(mi);\n    }\n    // Finally, register the popup menu with the component it appears over\n    this.add(popup);\n    // Add event listeners to do the drawing and handle the popup\n    addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            if (e.isPopupTrigger())\n                popup.show((Component) e.getSource(), e.getX(), e.getY());\n            else\n                // start new line\n                scribble.moveto(e.getX(), e.getY());\n        }\n    });\n    addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            // If this isn't mouse button 1, ignore it\n            if ((e.getModifiers() & InputEvent.BUTTON1_MASK) == 0)\n                return;\n            // Add a line \n            scribble.lineto(e.getX(), e.getY());\n            repaint();\n        }\n    });\n}\n","name":"ScribbleCutAndPaste","className":"ScribbleCutAndPaste","variables":{"popup":4,"mouseDragged":1,"e":11,"i":5,"mi":3,"commands":2,"scribble":2,"labels":2,"mousePressed":1},"constants":{"0":2,"\"Copy\"":1,"\"clear\"":1,"\"Paste\"":1,"\"Edit\"":1,"\"copy\"":1,"\"Cut\"":1,"\"Clear\"":1,"\"paste\"":1,"\"cut\"":1},"javaDoc":"","comments":"Create the popup menu Create the menu Create a menu item Set its action command And its action listener Add item to the menu Finally register the popup menu with the component it appears over Add event listeners to do the drawing and handle the popup start new line If this isn't mouse button 1 ignore it Add a line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setStroke":1,"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"NameExpr":12,"CastExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/** \n     * Draw the component.\n     * This method relies on Scribble which implements Shape.\n     **/\npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2 = (Graphics2D) g;\n    // Specify wide lines\n    g2.setStroke(linestyle);\n    // Draw the scribble\n    g2.draw(scribble);\n}\n","name":"paintComponent","className":"ScribbleCutAndPaste","variables":{"g":1,"g2":3},"constants":{},"javaDoc":"Draw the component This method relies on Scribble which implements Shape","comments":"Specify wide lines Draw the scribble  \n     * Draw the component.\n     * This method relies on Scribble which implements Shape.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"cut":1,"equals":4,"clear":1,"getActionCommand":1,"copy":1,"paste":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":23,"StringLiteralExpr":4,"MethodCallExpr":9},"statements":{"IfStmt":4,"ExpressionStmt":5},"text":"/** This is the ActionListener method invoked by the popup menu items */\npublic void actionPerformed(ActionEvent event) {\n    String command = event.getActionCommand();\n    if (command.equals(\"clear\"))\n        clear();\n    else if (command.equals(\"cut\"))\n        cut();\n    else if (command.equals(\"copy\"))\n        copy();\n    else if (command.equals(\"paste\"))\n        paste();\n}\n","name":"actionPerformed","className":"ScribbleCutAndPaste","variables":{"event":1,"command":5},"constants":{"\"clear\"":1,"\"copy\"":1,"\"paste\"":1,"\"cut\"":1},"javaDoc":"This is the ActionListener method invoked by the popup menu items","comments":" This is the ActionListener method invoked by the popup menu items ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Clear the scribble.  Invoked by popup menu */\nvoid clear() {\n    // Get a new, empty scribble\n    scribble = new Scribble();\n    // And redraw everything.\n    repaint();\n}\n","name":"clear","className":"ScribbleCutAndPaste","variables":{"scribble":1},"constants":{},"javaDoc":"Clear the scribble Invoked by popup menu","comments":"Get a new empty scribble And redraw everything  Clear the scribble.  Invoked by popup menu ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"clone":1,"setContents":1,"getSystemClipboard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Clipboard":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":12,"CastExpr":1,"ThisExpr":2,"MethodCallExpr":4,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/** \n     * Make a copy of the current Scribble and put it on the clipboard\n     * We can do this because Scribble implements Transferable\n     * The user invokes this method through the popup menu\n     **/\npublic void copy() {\n    // Get system clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Make a copy of the Scribble object to put on the clipboard\n    selection = (Scribble) scribble.clone();\n    // Put the copy on the clipboard\n    // What to put on the clipboard\n    c.setContents(// What to put on the clipboard\n    selection, // Who to notify when it is no longer there\n    this);\n}\n","name":"copy","className":"ScribbleCutAndPaste","variables":{"c":2,"selection":1,"scribble":1},"constants":{},"javaDoc":"Make a copy of the current Scribble and put it on the clipboard We can do this because Scribble implements Transferable The user invokes this method through the popup menu","comments":"Get system clipboard Make a copy of the Scribble object to put on the clipboard Put the copy on the clipboard What to put on the clipboard What to put on the clipboard What to put on the clipboard Who to notify when it is no longer there  \n     * Make a copy of the current Scribble and put it on the clipboard\n     * We can do this because Scribble implements Transferable\n     * The user invokes this method through the popup menu\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"clear":1,"copy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n     * The cut action is just like the copy action, except that we erase the\n     * current scribble after copying it to the clipboard\n     **/\npublic void cut() {\n    copy();\n    clear();\n}\n","name":"cut","className":"ScribbleCutAndPaste","variables":{},"constants":{},"javaDoc":"The cut action is just like the copy action except that we erase the current scribble after copying it to the clipboard","comments":" \n     * The cut action is just like the copy action, except that we erase the\n     * current scribble after copying it to the clipboard\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"beep":1,"getContents":1,"parse":1,"getTransferData":2,"repaint":1,"getSystemClipboard":1,"append":1},"annotations":[],"exceptions":["// UnsupportedFlavor, NullPointer, etc.\nException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Transferable":1,"Scribble":1,"Clipboard":1,"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":4,"NameExpr":35,"CastExpr":2,"FieldAccessExpr":2,"ThisExpr":3,"MethodCallExpr":10,"AssignExpr":2},"statements":{"TryStmt":2,"BlockStmt":4,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** \n     * The user invokes this method through the popup menu.\n     * First, ask for the Transferable contents of the system clipboard.\n     * Then ask that Transferable object for the scribble data it represents.\n     * Try using both data flavors supported by the Scribble class.\n     * If it doesn't work, beep to tell the user it failed.\n     **/\npublic void paste() {\n    // Get clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Get its contents\n    Transferable t = c.getContents(this);\n    // Now try to get a Scribble object from the transferrable\n    Scribble pastedScribble = null;\n    try {\n        pastedScribble = (Scribble) t.getTransferData(Scribble.scribbleDataFlavor);\n    } catch (// UnsupportedFlavor, NullPointer, etc.\n    Exception // UnsupportedFlavor, NullPointer, etc.\n    e) {\n        try {\n            String s = (String) t.getTransferData(DataFlavor.stringFlavor);\n            pastedScribble = Scribble.parse(s);\n        } catch (Exception e2) {\n            this.getToolkit().beep();\n            return;\n        }\n    }\n    // If we get here, we've retrieved a Scribble object from the clipboard\n    // Add it to the current scribble, and ask to be redrawn\n    scribble.append(pastedScribble);\n    repaint();\n}\n         // If that didn't work, try asking for a string instead.\n\n         // We got a string, so try converting it to a Scribble\n\n                                // UnsupportedFlavor, NumberFormat, etc.\n\n         // If we couldn't get and parse a string, give up\n\n                                     // Tell the user the paste failed\n\n","name":"paste","className":"ScribbleCutAndPaste","variables":{"c":2,"s":1,"t":3,"e":1,"pastedScribble":3,"Scribble":1,"e2":1,"scribble":1},"constants":{"null":1},"javaDoc":"The user invokes this method through the popup menu First ask for the Transferable contents of the system clipboard Then ask that Transferable object for the scribble data it represents Try using both data flavors supported by the Scribble class If it doesn't work beep to tell the user it failed","comments":"If we get here we've retrieved a Scribble object from the clipboard Get clipboard Get its contents Now try to get a Scribble object from the transferrable If that didn't work try asking for a string instead We got a string so try converting it to a Scribble UnsupportedFlavor NumberFormat etc If we couldn't get and parse a string give up Tell the user the paste failed UnsupportedFlavor NullPointer etc UnsupportedFlavor NullPointer etc Add it to the current scribble and ask to be redrawn  \n     * The user invokes this method through the popup menu.\n     * First, ask for the Transferable contents of the system clipboard.\n     * Then ask that Transferable object for the scribble data it represents.\n     * Try using both data flavors supported by the Scribble class.\n     * If it doesn't work, beep to tell the user it failed.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Clipboard","Transferable"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n     * This method implements the ClipboardOwner interface.  We specify a\n     * ClipboardOwner when we copy a Scribble to the clipboard.  This method\n     * will be invoked when something else is copied to the clipboard, and\n     * bumps our data off the clipboard.  When this method is invoked we no\n     * longer have to maintain our copied Scribble object, since it is no\n     * longer available to be pasted.  Often, a component will highlight a\n     * selected object while it is on the clipboard, and will use this method\n     * to un-highlight the object when it is no longer on the clipboard.\n     **/\npublic void lostOwnership(Clipboard c, Transferable t) {\n    selection = null;\n}\n","name":"lostOwnership","className":"ScribbleCutAndPaste","variables":{"selection":1},"constants":{"null":1},"javaDoc":"This method implements the ClipboardOwner interface We specify a ClipboardOwner when we copy a Scribble to the clipboard This method will be invoked when something else is copied to the clipboard and bumps our data off the clipboard When this method is invoked we no longer have to maintain our copied Scribble object since it is no longer available to be pasted Often a component will highlight a selected object while it is on the clipboard and will use this method to un-highlight the object when it is no longer on the clipboard","comments":" \n     * This method implements the ClipboardOwner interface.  We specify a\n     * ClipboardOwner when we copy a Scribble to the clipboard.  This method\n     * will be invoked when something else is copied to the clipboard, and\n     * bumps our data off the clipboard.  When this method is invoked we no\n     * longer have to maintain our copied Scribble object, since it is no\n     * longer available to be pasted.  Often, a component will highlight a\n     * selected object while it is on the clipboard, and will use this method\n     * to un-highlight the object when it is no longer on the clipboard.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"ScribbleCutAndPaste":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/** A simple main method to test the class. */\npublic static void main(String[] args) {\n    JFrame frame = new JFrame(\"ScribbleCutAndPaste\");\n    ScribbleCutAndPaste s = new ScribbleCutAndPaste();\n    frame.getContentPane().add(s, BorderLayout.CENTER);\n    frame.setSize(400, 400);\n    frame.setVisible(true);\n}\n","name":"main","className":"ScribbleCutAndPaste","variables":{"s":1,"frame":4},"constants":{"\"ScribbleCutAndPaste\"":1,"400":2,"true":1},"javaDoc":"A simple main method to test the class","comments":" A simple main method to test the class. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"addWindowListener":1,"exit":1,"pack":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"Frame":1,"SimpleCutAndPaste":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":14,"MethodCallExpr":4},"statements":{"BlockStmt":1,"ExpressionStmt":5},"text":"/** The main method creates a frame and pops it up. */\npublic static void main(String[] args) {\n    Frame f = new SimpleCutAndPaste();\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    f.pack();\n    f.setVisible(true);\n}\n","name":"main","className":"SimpleCutAndPaste","variables":{"e":1,"windowClosing":1,"f":4,"System":1},"constants":{"0":1,"true":1},"javaDoc":"The main method creates a frame and pops it up","comments":" The main method creates a frame and pops it up. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"copy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    copy();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"paste":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    paste();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SimpleCutAndPaste","methodCalls":{"addActionListener":2,"copy":1,"paste":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Button":2},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"StringLiteralExpr":7,"NameExpr":29,"FieldAccessExpr":1,"ThisExpr":4,"MethodCallExpr":8,"AssignExpr":1},"statements":{"BlockStmt":2,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":11},"text":"/**\n     * The constructor builds a very simple test GUI, and registers this object\n     * as the ActionListener for the buttons \n     **/\npublic SimpleCutAndPaste() {\n    // Window title\n    super(\"SimpleCutAndPaste\");\n    // Use a big font\n    this.setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n    // Set up the Cut button\n    Button copy = new Button(\"Copy\");\n    copy.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            copy();\n        }\n    });\n    this.add(copy, \"West\");\n    // Set up the Paste button\n    Button paste = new Button(\"Paste\");\n    paste.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            paste();\n        }\n    });\n    this.add(paste, \"East\");\n    // Set up the text field that they both operate on\n    field = new TextField();\n    this.add(field, \"North\");\n}\n","name":"SimpleCutAndPaste","className":"SimpleCutAndPaste","variables":{"actionPerformed":2,"field":1,"e":2,"copy":2,"paste":2},"constants":{"\"North\"":1,"\"Copy\"":1,"\"Paste\"":1,"18":1,"\"SansSerif\"":1,"\"SimpleCutAndPaste\"":1,"\"East\"":1,"\"West\"":1},"javaDoc":"The constructor builds a very simple test GUI and registers this object as the ActionListener for the buttons","comments":"Window title Use a big font Set up the Cut button Set up the Paste button Set up the text field that they both operate on \n     * The constructor builds a very simple test GUI, and registers this object\n     * as the ActionListener for the buttons \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"selectAll":1,"getText":1,"setContents":1,"getSystemClipboard":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"StringSelection":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":14,"ThisExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":4},"text":"/**\n     * This method takes the current contents of the text field, creates a\n     * StringSelection object to represent that string, and puts the \n     * StringSelection onto the clipboard\n     **/\npublic void copy() {\n    // Get the currently displayed value\n    String s = field.getText();\n    // Create a StringSelection object to represent the text.\n    // StringSelection is a pre-defined class that implements\n    // Transferable and ClipboardOwner for us. \n    StringSelection ss = new StringSelection(s);\n    // Now set the StringSelection object as the contents of the clipboard\n    // Also specify that we're the clipboard owner\n    this.getToolkit().getSystemClipboard().setContents(ss, this);\n    // Highlight the text to indicate it is on the clipboard.\n    field.selectAll();\n}\n","name":"copy","className":"SimpleCutAndPaste","variables":{"ss":1,"s":2,"field":2},"constants":{},"javaDoc":"This method takes the current contents of the text field creates a StringSelection object to represent that string and puts the StringSelection onto the clipboard","comments":"Create a StringSelection object to represent the text StringSelection is a pre-defined class that implements Now set the StringSelection object as the contents of the clipboard Get the currently displayed value Transferable and ClipboardOwner for us Also specify that we're the clipboard owner Highlight the text to indicate it is on the clipboard \n     * This method takes the current contents of the text field, creates a\n     * StringSelection object to represent that string, and puts the \n     * StringSelection onto the clipboard\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"beep":1,"isDataFlavorSupported":2,"getName":1,"get":1,"getContents":1,"getTransferData":2,"getSystemClipboard":1,"setText":2},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"java.util.List":1,"Transferable":1,"Clipboard":1,"String":1,"java.io.File":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":48,"CastExpr":3,"FieldAccessExpr":4,"ThisExpr":3,"MethodCallExpr":13},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":8},"text":"/**\n     * Get the contents of the clipboard, and, if we understand the type,\n     * display the contents.  This method understands strings and file lists.\n     **/\npublic void paste() {\n    // Get the clipboard\n    Clipboard c = this.getToolkit().getSystemClipboard();\n    // Get the contents of the clipboard, as a Transferable object\n    Transferable t = c.getContents(this);\n    // Find out what kind of data is on the clipboard\n    try {\n        if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n            // If it is a string, then get and display the string\n            String s = (String) t.getTransferData(DataFlavor.stringFlavor);\n            field.setText(s);\n        } else if (t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\n            // If it is a list of File objects, get the list and display\n            // the name of the first file on the list\n            java.util.List files = (java.util.List) t.getTransferData(DataFlavor.javaFileListFlavor);\n            java.io.File file = (java.io.File) files.get(0);\n            field.setText(file.getName());\n        }\n    }// If anything goes wrong with the transfer, just beep and do nothing.\n     catch (Exception e) {\n        this.getToolkit().beep();\n    }\n}\n","name":"paste","className":"SimpleCutAndPaste","variables":{"c":2,"s":1,"file":2,"t":5,"field":2,"e":1,"files":2},"constants":{"0":1},"javaDoc":"Get the contents of the clipboard and if we understand the type display the contents This method understands strings and file lists","comments":"Get the clipboard Get the contents of the clipboard as a Transferable object Find out what kind of data is on the clipboard If it is a string then get and display the string If it is a list of File objects get the list and display the name of the first file on the list If anything goes wrong with the transfer just beep and do nothing \n     * Get the contents of the clipboard, and, if we understand the type,\n     * display the contents.  This method understands strings and file lists.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Clipboard","Transferable"],"returnType":"void","methodCalls":{"select":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * This method implements the ClipboardOwner interface.  It is called when\n     * something else is placed on the clipboard.\n     **/\npublic void lostOwnership(Clipboard c, Transferable t) {\n    // Un-highlight the text field, since we don't \"own\" the clipboard\n    // anymore, and the text is no longer available to be pasted.\n    field.select(0, 0);\n}\n","name":"lostOwnership","className":"SimpleCutAndPaste","variables":{"field":1},"constants":{"0":2},"javaDoc":"This method implements the ClipboardOwner interface It is called when something else is placed on the clipboard","comments":"Un-highlight the text field since we don't \"own\" the clipboard anymore and the text is no longer available to be pasted \n     * This method implements the ClipboardOwner interface.  It is called when\n     * something else is placed on the clipboard.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribbleDragAndDrop","methodCalls":{"getDefaultDragSource":1,"createDefaultDragGestureRecognizer":1,"setBorder":1,"addMouseMotionListener":1,"addMouseListener":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"DropTarget":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":20,"FieldAccessExpr":1,"ThisExpr":7,"MethodCallExpr":6,"AssignExpr":1},"statements":{"ExpressionStmt":7},"text":"/** The constructor: set up drag-and-drop stuff */\npublic ScribbleDragAndDrop() {\n    // Give ourselves a nice default border.\n    // We'll change this border during drag-and-drop.\n    setBorder(normalBorder);\n    // Register listeners to handle drawing\n    addMouseListener(this);\n    addMouseMotionListener(this);\n    // Create a DragSource and DragGestureRecognizer to listen for drags\n    // The DragGestureRecognizer will notify the DragGestureListener\n    // when the user tries to drag an object\n    dragSource = DragSource.getDefaultDragSource();\n    // What component\n    dragSource.createDefaultDragGestureRecognizer(// What component\n    this, // What drag types?\n    DnDConstants.ACTION_COPY_OR_MOVE, // the listener\n    this);\n    // Create and set up a DropTarget that will listen for drags and\n    // drops over this component, and will notify the DropTargetListener\n    DropTarget dropTarget = new // component to monitor\n    DropTarget(// component to monitor\n    this, // listener to notify\n    this);\n    // Tell the component about it.\n    this.setDropTarget(dropTarget);\n}\n","name":"ScribbleDragAndDrop","className":"ScribbleDragAndDrop","variables":{"dropTarget":1,"DragSource":1,"dragSource":2},"constants":{},"javaDoc":"The constructor: set up drag-and-drop stuff","comments":"Give ourselves a nice default border Create a DragSource and DragGestureRecognizer to listen for drags The DragGestureRecognizer will notify the DragGestureListener Create and set up a DropTarget that will listen for drags and We'll change this border during drag-and-drop Register listeners to handle drawing when the user tries to drag an object What component What component What component What drag types? the listener drops over this component and will notify the DropTargetListener component to monitor component to monitor listener to notify Tell the component about it  The constructor: set up drag-and-drop stuff ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"get":1,"setStroke":1,"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Scribble":1,"int":2,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"SuperExpr":1,"BinaryExpr":1,"NameExpr":22,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n     * The component draws itself by drawing each of the Scribble objects.\n     **/\npublic void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    Graphics2D g2 = (Graphics2D) g;\n    // Specify wide lines\n    g2.setStroke(linestyle);\n    int numScribbles = scribbles.size();\n    for (int i = 0; i < numScribbles; i++) {\n        Scribble s = (Scribble) scribbles.get(i);\n        // Draw the scribble\n        g2.draw(s);\n    }\n}\n","name":"paintComponent","className":"ScribbleDragAndDrop","variables":{"s":1,"g":1,"numScribbles":2,"i":3,"g2":3,"scribbles":2},"constants":{"0":1},"javaDoc":"The component draws itself by drawing each of the Scribble objects","comments":"Specify wide lines Draw the scribble \n     * The component draws itself by drawing each of the Scribble objects.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setDragMode(boolean dragMode) {\n    this.dragMode = dragMode;\n}\n","name":"setDragMode","className":"ScribbleDragAndDrop","variables":{"dragMode":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean getDragMode() {\n    return dragMode;\n}\n","name":"getDragMode","className":"ScribbleDragAndDrop","variables":{"dragMode":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"add":1,"getX":1,"getY":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":15,"AssignExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/**\n     * This method, and the following four methods are from the MouseListener\n     * interface.  If we're in drawing mode, this method handles mouse down\n     * events and starts a new scribble.\n     **/\npublic void mousePressed(MouseEvent e) {\n    if (dragMode)\n        return;\n    currentScribble = new Scribble();\n    scribbles.add(currentScribble);\n    currentScribble.moveto(e.getX(), e.getY());\n}\n","name":"mousePressed","className":"ScribbleDragAndDrop","variables":{"dragMode":1,"e":2,"currentScribble":2,"scribbles":1},"constants":{},"javaDoc":"This method and the following four methods are from the MouseListener interface If we're in drawing mode this method handles mouse down events and starts a new scribble","comments":"\n     * This method, and the following four methods are from the MouseListener\n     * interface.  If we're in drawing mode, this method handles mouse down\n     * events and starts a new scribble.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseReleased(MouseEvent e) {\n}\n","name":"mouseReleased","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent e) {\n}\n","name":"mouseClicked","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent e) {\n}\n","name":"mouseEntered","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent e) {\n}\n","name":"mouseExited","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"lineto":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n     * This method and mouseMoved() below are from the MouseMotionListener\n     * interface.  If we're in drawing mode, this method adds a new point\n     * to the current scribble and requests a redraw\n     **/\npublic void mouseDragged(MouseEvent e) {\n    if (dragMode)\n        return;\n    currentScribble.lineto(e.getX(), e.getY());\n    repaint();\n}\n","name":"mouseDragged","className":"ScribbleDragAndDrop","variables":{"dragMode":1,"e":2,"currentScribble":1},"constants":{},"javaDoc":"This method and mouseMoved() below are from the MouseMotionListener interface If we're in drawing mode this method adds a new point to the current scribble and requests a redraw","comments":"\n     * This method and mouseMoved() below are from the MouseMotionListener\n     * interface.  If we're in drawing mode, this method adds a new point\n     * to the current scribble and requests a redraw\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseMoved(MouseEvent e) {\n}\n","name":"mouseMoved","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragGestureEvent"],"returnType":"void","methodCalls":{"intersects":1,"isDragImageSupported":1,"draw":1,"fillRect":1,"translate":2,"getBounds":1,"getX":1,"getDragAction":1,"getTriggerEvent":1,"getY":1,"setColor":2,"size":1,"get":1,"clone":1,"startDrag":2,"getGraphics":1,"setStroke":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"MouseEvent":1,"Rectangle":2,"Scribble":2,"Point":1,"Cursor":1,"Image":1,"int":4,"Graphics2D":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":9,"VariableDeclarationExpr":13,"BinaryExpr":5,"NameExpr":127,"CastExpr":4,"FieldAccessExpr":13,"UnaryExpr":8,"ThisExpr":3,"MethodCallExpr":21,"AssignExpr":3},"statements":{"SwitchStmt":1,"IfStmt":3,"BreakStmt":2,"BlockStmt":4,"SwitchEntryStmt":3,"ReturnStmt":3,"ForStmt":1,"ExpressionStmt":24},"text":"/**\n     * This method implements the DragGestureListener interface.  It will be\n     * invoked when the DragGestureRecognizer thinks that the user has \n     * initiated a drag.  If we're not in drawing mode, then this method will\n     * try to figure out which Scribble object is being dragged, and will\n     * initiate a drag on that object.\n     **/\npublic void dragGestureRecognized(DragGestureEvent e) {\n    // Don't drag if we're not in drag mode\n    if (!dragMode)\n        return;\n    // Figure out where the drag started\n    MouseEvent inputEvent = (MouseEvent) e.getTriggerEvent();\n    int x = inputEvent.getX();\n    int y = inputEvent.getY();\n    // Figure out which scribble was clicked on, if any by creating a \n    // small rectangle around the point and testing for intersection.\n    Rectangle r = new Rectangle(x - LINEWIDTH, y - LINEWIDTH, LINEWIDTH * 2, LINEWIDTH * 2);\n    int numScribbles = scribbles.size();\n    for (int i = 0; i < numScribbles; i++) {\n        // Loop through the scribbles\n        Scribble s = (Scribble) scribbles.get(i);\n        if (s.intersects(r)) {\n            // The user started the drag on top of this scribble, so \n            // start to drag it.\n            // First, remember which scribble is being dragged, so we can \n            // delete it later (if this is a move rather than a copy)\n            beingDragged = s;\n            // Next, create a copy that will be the one dragged\n            Scribble dragScribble = (Scribble) s.clone();\n            // Adjust the origin to the point the user clicked on.\n            dragScribble.translate(-x, -y);\n            // Choose a cursor based on the type of drag the user initiated\n            Cursor cursor;\n            switch(e.getDragAction()) {\n                case DnDConstants.ACTION_COPY:\n                    cursor = DragSource.DefaultCopyDrop;\n                    break;\n                case DnDConstants.ACTION_MOVE:\n                    cursor = DragSource.DefaultMoveDrop;\n                    break;\n                default:\n                    // We only support move and copys\n                    return;\n            }\n            // cursor.  If so, create an image of the scribble to drag\n            if (dragSource.isDragImageSupported()) {\n                Rectangle scribbleBox = dragScribble.getBounds();\n                Image dragImage = this.createImage(scribbleBox.width, scribbleBox.height);\n                Graphics2D g = (Graphics2D) dragImage.getGraphics();\n                // transparent background\n                g.setColor(new Color(0, 0, 0, 0));\n                g.fillRect(0, 0, scribbleBox.width, scribbleBox.height);\n                g.setColor(Color.black);\n                g.setStroke(linestyle);\n                g.translate(-scribbleBox.x, -scribbleBox.y);\n                g.draw(dragScribble);\n                Point hotspot = new Point(-scribbleBox.x, -scribbleBox.y);\n                // Now start dragging, using the image.\n                e.startDrag(cursor, dragImage, hotspot, dragScribble, this);\n            } else {\n                // Or start the drag without an image\n                e.startDrag(cursor, dragScribble, this);\n            }\n            // After we've started dragging one scribble, stop looking\n            return;\n        }\n    }\n}\n         // Some systems allow us to drag an image along with the \n\n","name":"dragGestureRecognized","className":"ScribbleDragAndDrop","variables":{"beingDragged":1,"cursor":3,"dragMode":1,"e":4,"LINEWIDTH":4,"hotspot":1,"numScribbles":2,"g":7,"inputEvent":3,"i":3,"scribbles":2,"r":1,"s":4,"dragScribble":3,"x":3,"y":3,"dragSource":1,"scribbleBox":1,"dragImage":2},"constants":{"0":7,"2":2},"javaDoc":"This method implements the DragGestureListener interface It will be invoked when the DragGestureRecognizer thinks that the user has initiated a drag If we're not in drawing mode then this method will try to figure out which Scribble object is being dragged and will initiate a drag on that object","comments":"Figure out which scribble was clicked on if any by creating a Don't drag if we're not in drag mode Figure out where the drag started small rectangle around the point and testing for intersection Loop through the scribbles The user started the drag on top of this scribble so start to drag it First remember which scribble is being dragged so we can Some systems allow us to drag an image along with the delete it later (if this is a move rather than a copy) Next create a copy that will be the one dragged Adjust the origin to the point the user clicked on Choose a cursor based on the type of drag the user initiated We only support move and copys cursor If so create an image of the scribble to drag transparent background Now start dragging using the image Or start the drag without an image After we've started dragging one scribble stop looking \n     * This method implements the DragGestureListener interface.  It will be\n     * invoked when the DragGestureRecognizer thinks that the user has \n     * initiated a drag.  If we're not in drawing mode, then this method will\n     * try to figure out which Scribble object is being dragged, and will\n     * initiate a drag on that object.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragSourceDropEvent"],"returnType":"void","methodCalls":{"getDropSuccess":1,"getDropAction":1,"repaint":1,"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * This method, and the four unused methods that follow it implement the\n     * DragSourceListener interface.  dragDropEnd() is invoked when the user\n     * drops the scribble she was dragging.  If the drop was successful, and\n     * if the user did a \"move\" rather than a \"copy\", then we delete the\n     * dragged scribble from the list of scribbles to draw.\n     **/\npublic void dragDropEnd(DragSourceDropEvent e) {\n    if (!e.getDropSuccess())\n        return;\n    int action = e.getDropAction();\n    if (action == DnDConstants.ACTION_MOVE) {\n        scribbles.remove(beingDragged);\n        beingDragged = null;\n        repaint();\n    }\n}\n","name":"dragDropEnd","className":"ScribbleDragAndDrop","variables":{"beingDragged":1,"e":2,"action":2,"scribbles":1},"constants":{"null":1},"javaDoc":"This method and the four unused methods that follow it implement the DragSourceListener interface dragDropEnd() is invoked when the user drops the scribble she was dragging If the drop was successful and if the user did a \"move\" rather than a \"copy\" then we delete the dragged scribble from the list of scribbles to draw","comments":"\n     * This method, and the four unused methods that follow it implement the\n     * DragSourceListener interface.  dragDropEnd() is invoked when the user\n     * drops the scribble she was dragging.  If the drop was successful, and\n     * if the user did a \"move\" rather than a \"copy\", then we delete the\n     * dragged scribble from the list of scribbles to draw.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragSourceDragEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// These methods are also part of DragSourceListener.\n// They are invoked at interesting points during the drag, and can be\n// used to perform \"drag over\" effects, such as changing the drag cursor\n// or drag image.\npublic void dragEnter(DragSourceDragEvent e) {\n}\n","name":"dragEnter","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","comments":" or drag image.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragSourceEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void dragExit(DragSourceEvent e) {\n}\n","name":"dragExit","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragSourceDragEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void dropActionChanged(DragSourceDragEvent e) {\n}\n","name":"dropActionChanged","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DragSourceDragEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void dragOver(DragSourceDragEvent e) {\n}\n","name":"dragOver","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DropTargetDragEvent"],"returnType":"void","methodCalls":{"isDataFlavorSupported":2,"acceptDrag":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":21,"FieldAccessExpr":3,"ThisExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/**\n     * This method is invoked when the user first drags something over us.\n     * If we understand the data type being dragged, then call acceptDrag()\n     * to tell the system that we're receptive.  Also, we change our border\n     * as a \"drag under\" effect to signal that we can accept the drop.\n     **/\npublic void dragEnter(DropTargetDragEvent e) {\n    if (e.isDataFlavorSupported(Scribble.scribbleDataFlavor) || e.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n        e.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);\n        this.setBorder(dropBorder);\n    }\n}\n","name":"dragEnter","className":"ScribbleDragAndDrop","variables":{"e":3},"constants":{},"javaDoc":"This method is invoked when the user first drags something over us If we understand the data type being dragged then call acceptDrag() to tell the system that we're receptive Also we change our border as a \"drag under\" effect to signal that we can accept the drop","comments":"\n     * This method is invoked when the user first drags something over us.\n     * If we understand the data type being dragged, then call acceptDrag()\n     * to tell the system that we're receptive.  Also, we change our border\n     * as a \"drag under\" effect to signal that we can accept the drop.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DropTargetEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The user is no longer dragging over us, so restore the border */\npublic void dragExit(DropTargetEvent e) {\n    this.setBorder(normalBorder);\n}\n","name":"dragExit","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"The user is no longer dragging over us so restore the border","comments":" The user is no longer dragging over us, so restore the border ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DropTargetDropEvent"],"returnType":"void","methodCalls":{"add":1,"acceptDrop":1,"getLocation":1,"parse":1,"getTransferData":2,"dropComplete":2,"translate":1,"getTransferable":1,"getX":1,"isDataFlavorSupported":2,"getY":1,"rejectDrop":1,"repaint":1},"annotations":[],"exceptions":["// unsupported flavor, IO exception, etc.\nException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Transferable":1,"Scribble":1,"String":1,"Point":1},"expressions":{"VariableDeclarationExpr":4,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":69,"CastExpr":2,"FieldAccessExpr":5,"ThisExpr":1,"MethodCallExpr":17,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":2,"ExpressionStmt":14},"text":"/** \n     * This is the key method of DropTargetListener.  It is invoked when the\n     * user drops something on us.\n     **/\npublic void drop(DropTargetDropEvent e) {\n    // Restore the default border\n    this.setBorder(normalBorder);\n    // If we supports our data flavors, accept the drop, otherwise reject.\n    if (e.isDataFlavorSupported(Scribble.scribbleDataFlavor) || e.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n        e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);\n    } else {\n        e.rejectDrop();\n        return;\n    }\n    // We've accepted the drop, so now we attempt to get the dropped data\n    // from the Transferable object.\n    // Holds the dropped data\n    Transferable t = e.getTransferable();\n    // This will hold the Scribble object\n    Scribble droppedScribble;\n    // First, try to get the data directly as a scribble object\n    try {\n        droppedScribble = (Scribble) t.getTransferData(Scribble.scribbleDataFlavor);\n    } catch (// unsupported flavor, IO exception, etc.\n    Exception // unsupported flavor, IO exception, etc.\n    ex) {\n        try {\n            String s = (String) t.getTransferData(DataFlavor.stringFlavor);\n            droppedScribble = Scribble.parse(s);\n        } catch (Exception ex2) {\n            e.dropComplete(false);\n            return;\n        }\n    }\n    // If we get here, we've got the Scribble object\n    // Where did the drop happen?\n    Point p = e.getLocation();\n    // Move it there\n    droppedScribble.translate(p.getX(), p.getY());\n    // add to display list\n    scribbles.add(droppedScribble);\n    // ask for redraw\n    repaint();\n    // signal success!\n    e.dropComplete(true);\n}\n     // First, check whether we understand the data that was dropped.\n\n         // If that doesn't work, try to get it as a String and parse it\n\n         // If we still couldn't get the data, tell the system we failed\n\n","name":"drop","className":"ScribbleDragAndDrop","variables":{"p":3,"ex":1,"s":1,"t":3,"e":8,"Scribble":1,"scribbles":1,"droppedScribble":4,"ex2":1},"constants":{"false":1,"true":1},"javaDoc":"This is the key method of DropTargetListener It is invoked when the user drops something on us","comments":"First check whether we understand the data that was dropped We've accepted the drop so now we attempt to get the dropped data from the Transferable object If we get here we've got the Scribble object Restore the default border If we supports our data flavors accept the drop otherwise reject Holds the dropped data This will hold the Scribble object First try to get the data directly as a scribble object If that doesn't work try to get it as a String and parse it If we still couldn't get the data tell the system we failed unsupported flavor IO exception etc unsupported flavor IO exception etc Where did the drop happen? Move it there add to display list ask for redraw signal success!  \n     * This is the key method of DropTargetListener.  It is invoked when the\n     * user drops something on us.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DropTargetDragEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// These are unused DropTargetListener methods\npublic void dragOver(DropTargetDragEvent e) {\n}\n","name":"dragOver","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","comments":" These are unused DropTargetListener methods","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DropTargetDragEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void dropActionChanged(DropTargetDragEvent e) {\n}\n","name":"dropActionChanged","className":"ScribbleDragAndDrop","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setDragMode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    scribblePane.setDragMode(false);\n}\n","name":"actionPerformed","className":"","variables":{"scribblePane":1},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setDragMode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    scribblePane.setDragMode(true);\n}\n","name":"actionPerformed","className":"","variables":{"scribblePane":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"setVisible":1,"setSize":1,"setSelected":1,"addActionListener":2,"getContentPane":2,"setDragMode":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JToggleButton":2,"JFrame":1,"ButtonGroup":1,"ScribbleDragAndDrop":1,"JToolBar":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"BooleanLiteralExpr":5,"StringLiteralExpr":3,"NameExpr":62,"FieldAccessExpr":2,"MethodCallExpr":16},"statements":{"BlockStmt":2,"ExpressionStmt":20},"text":"/**\n     * The main method.  Creates a simple application using this class.  Note\n     * the buttons for switching between draw mode and drag mode.\n     **/\npublic static void main(String[] args) {\n    // Create a frame and put a scribble pane in it\n    JFrame frame = new JFrame(\"ScribbleDragAndDrop\");\n    final ScribbleDragAndDrop scribblePane = new ScribbleDragAndDrop();\n    frame.getContentPane().add(scribblePane, BorderLayout.CENTER);\n    // Create two buttons for switching modes\n    JToolBar toolbar = new JToolBar();\n    ButtonGroup group = new ButtonGroup();\n    JToggleButton draw = new JToggleButton(\"Draw\");\n    JToggleButton drag = new JToggleButton(\"Drag\");\n    draw.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            scribblePane.setDragMode(false);\n        }\n    });\n    drag.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            scribblePane.setDragMode(true);\n        }\n    });\n    group.add(draw);\n    group.add(drag);\n    toolbar.add(draw);\n    toolbar.add(drag);\n    frame.getContentPane().add(toolbar, BorderLayout.NORTH);\n    // Start off in drawing mode\n    draw.setSelected(true);\n    scribblePane.setDragMode(false);\n    // Pop up the window\n    frame.setSize(400, 400);\n    frame.setVisible(true);\n}\n","name":"main","className":"ScribbleDragAndDrop","variables":{"toolbar":3,"actionPerformed":2,"scribblePane":4,"e":2,"draw":3,"drag":2,"frame":5,"group":3},"constants":{"\"Draw\"":1,"\"Drag\"":1,"400":2,"false":2,"true":3,"\"ScribbleDragAndDrop\"":1},"javaDoc":"The main method Creates a simple application using this class Note the buttons for switching between draw mode and drag mode","comments":"Create a frame and put a scribble pane in it Create two buttons for switching modes Start off in drawing mode Pop up the window \n     * The main method.  Creates a simple application using this class.  Note\n     * the buttons for switching between draw mode and drag mode.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"lineto":1,"reallocate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":15,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** \n     * Begin a new polyline at (x,y).  Note the use of Double.NaN in the\n     * points array to mark the beginning of a new polyline\n     **/\npublic void moveto(double x, double y) {\n    if (numPoints + 3 > points.length)\n        reallocate();\n    // Mark this as the beginning of a new line\n    points[numPoints++] = Double.NaN;\n    // The rest of this method is just like lineto();\n    lineto(x, y);\n}\n","name":"moveto","className":"Scribble","variables":{"numPoints":2,"points":1},"constants":{"3":1},"javaDoc":"Begin a new polyline at (x y) Note the use of Double NaN in the points array to mark the beginning of a new polyline","comments":"Mark this as the beginning of a new line The rest of this method is just like lineto();  \n     * Begin a new polyline at (x,y).  Note the use of Double.NaN in the\n     * points array to mark the beginning of a new polyline\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"reallocate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":28,"FieldAccessExpr":1,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":6},"statements":{"IfStmt":5,"ExpressionStmt":7},"text":"/**\n     * Add the point (x,y) to the end of the current polyline \n     **/\npublic void lineto(double x, double y) {\n    if (numPoints + 2 > points.length)\n        reallocate();\n    points[numPoints++] = x;\n    points[numPoints++] = y;\n    // See if the point enlarges our bounding box\n    if (x > maxX)\n        maxX = x;\n    if (x < minX)\n        minX = x;\n    if (y > maxY)\n        maxY = y;\n    if (y < minY)\n        minY = y;\n}\n","name":"lineto","className":"Scribble","variables":{"numPoints":3,"minY":2,"minX":2,"maxY":2,"maxX":2,"x":5,"y":5,"points":2},"constants":{"2":1},"javaDoc":"Add the point (x y) to the end of the current polyline","comments":"See if the point enlarges our bounding box \n     * Add the point (x,y) to the end of the current polyline \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Scribble"],"returnType":"void","methodCalls":{"min":2,"max":2,"arraycopy":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":58,"FieldAccessExpr":7,"ArrayCreationExpr":1,"MethodCallExpr":6,"AssignExpr":6},"statements":{"ExpressionStmt":10},"text":"/**\n     * Append the Scribble s to this Scribble\n     **/\npublic void append(Scribble s) {\n    int n = numPoints + s.numPoints;\n    double[] newpoints = new double[n];\n    System.arraycopy(points, 0, newpoints, 0, numPoints);\n    System.arraycopy(s.points, 0, newpoints, numPoints, s.numPoints);\n    points = newpoints;\n    numPoints = n;\n    minX = Math.min(minX, s.minX);\n    maxX = Math.max(maxX, s.maxX);\n    minY = Math.min(minY, s.minY);\n    maxY = Math.max(maxY, s.maxY);\n}\n","name":"append","className":"Scribble","variables":{"numPoints":2,"newpoints":2,"minY":1,"minX":1,"maxY":1,"maxX":1,"Math":4,"n":3,"System":2,"points":1},"constants":{"0":3},"javaDoc":"Append the Scribble s to this Scribble","comments":"\n     * Append the Scribble s to this Scribble\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"void","methodCalls":{"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":1,"NameExpr":22,"UnaryExpr":2,"MethodCallExpr":1,"AssignExpr":6},"statements":{"ContinueStmt":1,"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"/**\n     * Translate the coordinates of all points in the Scribble by x,y\n     **/\npublic void translate(double x, double y) {\n    for (int i = 0; i < numPoints; i++) {\n        if (Double.isNaN(points[i]))\n            continue;\n        points[i++] += x;\n        points[i] += y;\n    }\n    minX += x;\n    maxX += x;\n    minY += y;\n    maxY += y;\n}\n","name":"translate","className":"Scribble","variables":{"numPoints":1,"minY":1,"minX":1,"maxY":1,"maxX":1,"x":3,"i":6,"y":3,"Double":1,"points":3},"constants":{"0":1},"javaDoc":"Translate the coordinates of all points in the Scribble by x y","comments":"\n     * Translate the coordinates of all points in the Scribble by x,y\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/** An internal method to make more room in the data array */\nprotected void reallocate() {\n    double[] newpoints = new double[points.length * 2];\n    System.arraycopy(points, 0, newpoints, 0, numPoints);\n    points = newpoints;\n}\n","name":"reallocate","className":"Scribble","variables":{"newpoints":2,"System":1,"points":1},"constants":{"0":2,"2":1},"javaDoc":"An internal method to make more room in the data array","comments":" An internal method to make more room in the data array ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"Object","methodCalls":{"clone":1},"annotations":[],"exceptions":["// This should never happen\nCloneNotSupportedException"],"concepts":["Casting","ExceptionHandling"],"types":{"Scribble":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"CastExpr":2,"NameExpr":9,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** Clone a Scribble object and its internal array of data */\npublic Object clone() {\n    try {\n        // make a copy of all fields\n        Scribble s = (Scribble) super.clone();\n        // copy the entire array\n        s.points = (double[]) points.clone();\n        return s;\n    } catch (// This should never happen\n    CloneNotSupportedException // This should never happen\n    e) {\n        return this;\n    }\n}\n","name":"clone","className":"Scribble","variables":{"s":2,"e":1,"points":1},"constants":{},"javaDoc":"Clone a Scribble object and its internal array of data","comments":"make a copy of all fields copy the entire array This should never happen This should never happen  Clone a Scribble object and its internal array of data ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1,"isNaN":1,"append":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":1,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Convert the scribble data to a textual format */\npublic String toString() {\n    StringBuffer b = new StringBuffer();\n    for (int i = 0; i < numPoints; i++) {\n        if (Double.isNaN(points[i])) {\n            b.append(\"m \");\n        } else {\n            b.append(points[i]);\n            b.append(' ');\n        }\n    }\n    return b.toString();\n}\n","name":"toString","className":"Scribble","variables":{"numPoints":1,"b":5,"i":5,"Double":1,"points":2},"constants":{"0":1,"\"m \"":1,"' '":1},"javaDoc":"Convert the scribble data to a textual format","comments":" Convert the scribble data to a textual format ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Scribble","methodCalls":{"parseDouble":4,"hasMoreTokens":1,"nextToken":4,"lineto":1,"charAt":1,"moveto":1},"annotations":[],"exceptions":["NumberFormatException"],"concepts":[],"types":{"StringTokenizer":1,"Scribble":1,"String":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":39,"CharLiteralExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n     * Create a new Scribble object and initialize it by parsing a string of\n     * coordinate data in the format produced by toString()\n     **/\npublic static Scribble parse(String s) throws NumberFormatException {\n    StringTokenizer st = new StringTokenizer(s);\n    Scribble scribble = new Scribble();\n    while (st.hasMoreTokens()) {\n        String t = st.nextToken();\n        if (t.charAt(0) == 'm') {\n            scribble.moveto(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()));\n        } else {\n            scribble.lineto(Double.parseDouble(t), Double.parseDouble(st.nextToken()));\n        }\n    }\n    return scribble;\n}\n","name":"parse","className":"Scribble","variables":{"st":6,"s":1,"t":2,"Double":4,"scribble":4},"constants":{"0":1,"'m'":1},"javaDoc":"Create a new Scribble object and initialize it by parsing a string of coordinate data in the format produced by toString()","comments":" \n     * Create a new Scribble object and initialize it by parsing a string of\n     * coordinate data in the format produced by toString()\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Rectangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"DoubleLiteralExpr":4,"BinaryExpr":6,"CastExpr":4,"NameExpr":6,"EnclosedExpr":4},"statements":{"ReturnStmt":1},"text":"/** Return the bounding box of the Shape */\npublic Rectangle getBounds() {\n    return new Rectangle((int) (minX - 0.5f), (int) (minY - 0.5f), (int) (maxX - minX + 0.5f), (int) (maxY - minY + 0.5f));\n}\n","name":"getBounds","className":"Scribble","variables":{"minY":2,"minX":2,"maxY":1,"maxX":1},"constants":{"0.5f":4},"javaDoc":"Return the bounding box of the Shape","comments":" Return the bounding box of the Shape ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Rectangle2D","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":6},"statements":{"ReturnStmt":1},"text":"/** Return the bounding box of the Shape */\npublic Rectangle2D getBounds2D() {\n    return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);\n}\n","name":"getBounds2D","className":"Scribble","variables":{"minY":2,"minX":2,"maxY":1,"maxX":1},"constants":{},"javaDoc":"Return the bounding box of the Shape","comments":" Return the bounding box of the Shape ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Point2D"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** Our shape is an open curve, so it never contains anything */\npublic boolean contains(Point2D p) {\n    return false;\n}\n","name":"contains","className":"Scribble","variables":{},"constants":{"false":1},"javaDoc":"Our shape is an open curve so it never contains anything","comments":" Our shape is an open curve, so it never contains anything ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rectangle2D"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(Rectangle2D r) {\n    return false;\n}\n","name":"contains","className":"Scribble","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(double x, double y) {\n    return false;\n}\n","name":"contains","className":"Scribble","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double","double","double"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean contains(double x, double y, double w, double h) {\n    return false;\n}\n","name":"contains","className":"Scribble","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Rectangle2D"],"returnType":"boolean","methodCalls":{"intersectsLine":1,"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"DoubleLiteralExpr":2,"ArrayAccessExpr":5,"BinaryExpr":2,"BooleanLiteralExpr":3,"NameExpr":32,"UnaryExpr":5,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":3,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":3,"ExpressionStmt":9},"text":"/**\n     * Determine if the scribble intersects the specified rectangle by testing\n     * each line segment individually \n     **/\npublic boolean intersects(Rectangle2D r) {\n    if (numPoints < 4)\n        return false;\n    int i = 0;\n    double x1, y1, x2 = 0.0, y2 = 0.0;\n    while (i < numPoints) {\n        if (Double.isNaN(points[i])) {\n            // If we're beginning a new line\n            // Skip the NaN\n            i++;\n            x2 = points[i++];\n            y2 = points[i++];\n        } else {\n            x1 = x2;\n            y1 = y2;\n            x2 = points[i++];\n            y2 = points[i++];\n            if (r.intersectsLine(x1, y1, x2, y2))\n                return true;\n        }\n    }\n    return false;\n}\n","name":"intersects","className":"Scribble","variables":{"numPoints":2,"r":1,"y1":2,"i":8,"x1":2,"y2":4,"x2":4,"Double":1,"points":5},"constants":{"0":1,"0.0":2,"4":1,"false":2,"true":1},"javaDoc":"Determine if the scribble intersects the specified rectangle by testing each line segment individually","comments":"If we're beginning a new line Skip the NaN \n     * Determine if the scribble intersects the specified rectangle by testing\n     * each line segment individually \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double","double","double","double"],"returnType":"boolean","methodCalls":{"intersects":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Test for intersection by invoking the method above */\npublic boolean intersects(double x, double y, double w, double h) {\n    return intersects(new Rectangle2D.Double(x, y, w, h));\n}\n","name":"intersects","className":"Scribble","variables":{"w":1,"x":1,"h":1,"y":1},"constants":{},"javaDoc":"Test for intersection by invoking the method above","comments":" Test for intersection by invoking the method above ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform"],"returnType":"PathIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Return a PathIterator object that tells Java2D how to draw this scribble\n     **/\npublic PathIterator getPathIterator(AffineTransform at) {\n    return new ScribbleIterator(at);\n}\n","name":"getPathIterator","className":"Scribble","variables":{"at":1},"constants":{},"javaDoc":"Return a PathIterator object that tells Java2D how to draw this scribble","comments":"\n     * Return a PathIterator object that tells Java2D how to draw this scribble\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform","double"],"returnType":"PathIterator","methodCalls":{"getPathIterator":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Return a PathIterator that doesn't include curves.  Ours never does.\n     **/\npublic PathIterator getPathIterator(AffineTransform at, double flatness) {\n    return getPathIterator(at);\n}\n","name":"getPathIterator","className":"Scribble","variables":{},"constants":{},"javaDoc":"Return a PathIterator that doesn't include curves Ours never does","comments":"\n     * Return a PathIterator that doesn't include curves.  Ours never does.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AffineTransform"],"returnType":"ScribbleIterator","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public ScribbleIterator(AffineTransform transform) {\n    this.transform = transform;\n}\n","name":"ScribbleIterator","className":"ScribbleIterator","variables":{"transform":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"/** How to determine insideness and outsideness for this shape */\npublic int getWindingRule() {\n    return PathIterator.WIND_NON_ZERO;\n}\n","name":"getWindingRule","className":"ScribbleIterator","variables":{},"constants":{},"javaDoc":"How to determine insideness and outsideness for this shape","comments":" How to determine insideness and outsideness for this shape ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** Have we reached the end of the scribble path yet? */\npublic boolean isDone() {\n    return i >= numPoints;\n}\n","name":"isDone","className":"ScribbleIterator","variables":{"numPoints":1,"i":1},"constants":{},"javaDoc":"Have we reached the end of the scribble path yet?","comments":" Have we reached the end of the scribble path yet? ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"ArrayAccessExpr":1,"NameExpr":7,"MethodCallExpr":1,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Move on to the next segment of the path */\npublic void next() {\n    if (Double.isNaN(points[i]))\n        i += 3;\n    else\n        i += 2;\n}\n","name":"next","className":"ScribbleIterator","variables":{"i":3,"Double":1,"points":1},"constants":{"2":1,"3":1},"javaDoc":"Move on to the next segment of the path","comments":" Move on to the next segment of the path ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float[]"],"returnType":"int","methodCalls":{"transform":1,"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":10,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":9,"BinaryExpr":4,"NameExpr":28,"CastExpr":4,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"/** \n\t * Get the coordinates of the current moveto or lineto as floats\n\t **/\npublic int currentSegment(float[] coords) {\n    int retval;\n    if (Double.isNaN(points[i])) {\n        // If its a moveto\n        coords[0] = (float) points[i + 1];\n        coords[1] = (float) points[i + 2];\n        retval = SEG_MOVETO;\n    } else {\n        coords[0] = (float) points[i];\n        coords[1] = (float) points[i + 1];\n        retval = SEG_LINETO;\n    }\n    // If a transform was specified, use it on the coordinates\n    if (transform != null)\n        transform.transform(coords, 0, coords, 0, 1);\n    return retval;\n}\n","name":"currentSegment","className":"ScribbleIterator","variables":{"transform":2,"SEG_LINETO":1,"i":5,"Double":1,"SEG_MOVETO":1,"retval":4,"coords":4,"points":5},"constants":{"0":4,"1":5,"2":1,"null":1},"javaDoc":"Get the coordinates of the current moveto or lineto as floats","comments":"If its a moveto If a transform was specified use it on the coordinates  \n\t * Get the coordinates of the current moveto or lineto as floats\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["double[]"],"returnType":"int","methodCalls":{"transform":1,"isNaN":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":10,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":9,"BinaryExpr":4,"NameExpr":28,"MethodCallExpr":2,"AssignExpr":6},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":8},"text":"/** \n\t * Get the coordinates of the current moveto or lineto as doubles\n\t **/\npublic int currentSegment(double[] coords) {\n    int retval;\n    if (Double.isNaN(points[i])) {\n        coords[0] = points[i + 1];\n        coords[1] = points[i + 2];\n        retval = SEG_MOVETO;\n    } else {\n        coords[0] = points[i];\n        coords[1] = points[i + 1];\n        retval = SEG_LINETO;\n    }\n    if (transform != null)\n        transform.transform(coords, 0, coords, 0, 1);\n    return retval;\n}\n","name":"currentSegment","className":"ScribbleIterator","variables":{"transform":2,"SEG_LINETO":1,"i":5,"Double":1,"SEG_MOVETO":1,"retval":4,"coords":4,"points":5},"constants":{"0":4,"1":5,"2":1,"null":1},"javaDoc":"Get the coordinates of the current moveto or lineto as doubles","comments":" \n\t * Get the coordinates of the current moveto or lineto as doubles\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"DataFlavor[]","methodCalls":{"clone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the data formats or \"flavors\" we know how to transfer */\npublic DataFlavor[] getTransferDataFlavors() {\n    return (DataFlavor[]) supportedFlavors.clone();\n}\n","name":"getTransferDataFlavors","className":"Scribble","variables":{"supportedFlavors":1},"constants":{},"javaDoc":"Return the data formats or \"flavors\" we know how to transfer","comments":" Return the data formats or \"flavors\" we know how to transfer ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DataFlavor"],"returnType":"boolean","methodCalls":{"equals":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":10,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Check whether we support a given flavor */\npublic boolean isDataFlavorSupported(DataFlavor flavor) {\n    return (flavor.equals(scribbleDataFlavor) || flavor.equals(DataFlavor.stringFlavor));\n}\n","name":"isDataFlavorSupported","className":"Scribble","variables":{"flavor":2},"constants":{},"javaDoc":"Check whether we support a given flavor","comments":" Check whether we support a given flavor ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["DataFlavor"],"returnType":"Object","methodCalls":{"equals":2,"toString":1},"annotations":[],"exceptions":["UnsupportedFlavorException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":13,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":2,"ThrowStmt":1},"text":"/**\n     * Return the scribble data in the requested format, or throw an exception\n     * if we don't support the requested format\n     **/\npublic Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {\n    if (flavor.equals(scribbleDataFlavor)) {\n        return this;\n    } else if (flavor.equals(DataFlavor.stringFlavor)) {\n        return toString();\n    } else\n        throw new UnsupportedFlavorException(flavor);\n}\n","name":"getTransferData","className":"Scribble","variables":{"flavor":3},"constants":{},"javaDoc":"Return the scribble data in the requested format or throw an exception if we don't support the requested format","comments":"\n     * Return the scribble data in the requested format, or throw an exception\n     * if we don't support the requested format\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getServletConfig":1,"getConnection":1,"getInitParameter":4,"forName":1,"log":1,"getMessage":1},"annotations":[],"exceptions":["ServletException","Exception"],"concepts":["ExceptionHandling"],"types":{"ServletConfig":1,"String":4},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":1,"NameExpr":32,"StringLiteralExpr":6,"MethodCallExpr":9,"AssignExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":8},"text":"public void init() throws ServletException {\n    // Read initialization parameters from the web.xml file\n    ServletConfig config = getServletConfig();\n    String driverClassName = config.getInitParameter(\"driverClassName\");\n    String url = config.getInitParameter(\"url\");\n    String username = config.getInitParameter(\"username\");\n    String password = config.getInitParameter(\"password\");\n    // If anything goes wrong, log it, wrap the exception and re-throw it\n    try {\n        Class.forName(driverClassName);\n        db = DriverManager.getConnection(url, username, password);\n    } catch (Exception e) {\n        log(\"Can't create DB connection\", e);\n        throw new ServletException(\"Query: can't initialize: \" + e.getMessage(), e);\n    }\n}\n     // Use those init params to establish a connection to the database\n\n","name":"init","className":"Query","variables":{"password":1,"e":3,"driverClassName":1,"Class":1,"config":5,"DriverManager":1,"url":1,"db":1,"username":1},"constants":{"\"username\"":1,"\"url\"":1,"\"Query: can't initialize: \"":1,"\"password\"":1,"\"Can't create DB connection\"":1,"\"driverClassName\"":1},"javaDoc":"","comments":"Use those init params to establish a connection to the database Read initialization parameters from the web xml file If anything goes wrong log it wrap the exception and re-throw it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["SQLException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"/** Close the database connection when the servlet is unloaded  */\npublic void destroy() {\n    try // Try to close the connection\n    {\n        db.close();\n    }// Ignore errors; at least we tried!\n     catch (SQLException e) {\n    }\n}\n","name":"destroy","className":"Query","variables":{"e":1,"db":1},"constants":{},"javaDoc":"Close the database connection when the servlet is unloaded","comments":"Try to close the connection Ignore errors; at least we tried!  Close the database connection when the servlet is unloaded  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"next":1,"include":1,"getObject":1,"getColumnLabel":1,"getRequestDispatcher":1,"getMessage":1,"getColumnCount":1,"executeQuery":1,"createStatement":1,"println":9,"print":3,"setAttribute":1,"getWriter":1,"setContentType":1,"getMetaData":1,"close":1,"getParameter":1},"annotations":[],"exceptions":["ServletException","SQLException","IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"ResultSetMetaData":1,"Statement":1,"ResultSet":1,"String":1,"int":3,"RequestDispatcher":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"BinaryExpr":16,"NameExpr":101,"StringLiteralExpr":21,"FieldAccessExpr":1,"ClassExpr":1,"UnaryExpr":2,"MethodCallExpr":28,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":8,"TryStmt":2,"ForStmt":2,"ExpressionStmt":24},"text":"public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n    // We're outputting HTML\n    response.setContentType(\"text/html\");\n    // Where to output it to\n    PrintWriter out = response.getWriter();\n    // Output document header and a form for entering SQL queries\n    // When the form is submitted, this servlet is reloaded\n    out.println(\"<head><title>DB Query</title></head>\\n\" + \"<body bgcolor=white><h1>DB Query</h1>\\n\" + \"<form><b>Query: </b><input name='q'>\" + \"<input type=submit></form>\");\n    // See if a query was specified in this request.\n    String query = request.getParameter(\"q\");\n    if (query != null) {\n        // display the query text as a page heading\n        out.println(\"<h1>\" + query + \"</h1>\");\n        // Now try to execute the query and display the results in a table\n        // An object to execute the query\n        Statement statement = null;\n        try {\n            // Create a statement to use\n            statement = db.createStatement();\n            // Use it to execute the specified query, and get result set\n            ResultSet results = statement.executeQuery(query);\n            // Ask for extra information about the results\n            ResultSetMetaData metadata = results.getMetaData();\n            // How many columns are there in the results?\n            int numcols = metadata.getColumnCount();\n            // Begin a table, and output a header row of column names\n            out.println(\"<table border=2><tr>\");\n            for (int i = 0; i < numcols; i++) out.print(\"<th>\" + metadata.getColumnLabel(i + 1) + \"</th>\");\n            out.println(\"</tr>\");\n            // Now loop through the \"rows\" of the result set\n            while (results.next()) {\n                // For each row, display the the values for each column\n                out.print(\"<tr>\");\n                for (int i = 0; i < numcols; i++) out.print(\"<td>\" + results.getObject(i + 1) + \"</td>\");\n                out.println(\"</tr>\");\n            }\n            // end the table\n            out.println(\"</table>\");\n        } catch (SQLException e) {\n            out.println(\"SQL Error: \" + e.getMessage());\n        } finally {\n            // Whatever happens, always close the Statement object\n            try {\n                statement.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n    // Now, display the number of hits on this page by invoking the\n    // Counter servlet and including its output in this page.\n    // This is done with a RequestDispatcher object.\n    RequestDispatcher dispatcher = request.getRequestDispatcher(\"/servlet/counter\");\n    if (dispatcher != null) {\n        out.println(\"<br>Page hits:\");\n        // Add a request attribute that tells the servlet what to count.\n        // Use the attribute name defined by the Counter servlet, and\n        // use the name of this class as a unique counter name.\n        request.setAttribute(Counter.ATTRIBUTE_NAME, Query.class.getName());\n        // Tell the dispatcher to invoke its servlet and include the output\n        dispatcher.include(request, response);\n    }\n    // Finally, end the HTML output\n    out.println(\"</body>\");\n}\n         // If anything goes wrong (usually a SQL error) display the\n\n         // error to the user so they can correct it.\n\n","name":"doGet","className":"Query","variables":{"request":3,"metadata":3,"e":3,"response":2,"query":3,"statement":4,"i":8,"numcols":3,"results":4,"dispatcher":3,"db":1,"out":13},"constants":{"\"SQL Error: \"":1,"\"<form><b>Query: </b><input name='q'>\"":1,"\"<h1>\"":1,"\"<body bgcolor=white><h1>DB Query</h1>\\n\"":1,"\"<td>\"":1,"\"<table border=2><tr>\"":1,"\"</td>\"":1,"\"</th>\"":1,"\"</table>\"":1,"\"<head><title>DB Query</title></head>\\n\"":1,"0":2,"1":2,"\"q\"":1,"\"</body>\"":1,"null":3,"\"</tr>\"":2,"\"<tr>\"":1,"\"<input type=submit></form>\"":1,"\"<th>\"":1,"\"/servlet/counter\"":1,"\"text/html\"":1,"\"</h1>\"":1,"\"<br>Page hits:\"":1},"javaDoc":"","comments":"Output document header and a form for entering SQL queries Now display the number of hits on this page by invoking the Counter servlet and including its output in this page We're outputting HTML Where to output it to When the form is submitted this servlet is reloaded See if a query was specified in this request Now try to execute the query and display the results in a table display the query text as a page heading An object to execute the query Create a statement to use Use it to execute the specified query and get result set Ask for extra information about the results How many columns are there in the results? Begin a table and output a header row of column names Now loop through the \"rows\" of the result set For each row display the the values for each column end the table If anything goes wrong (usually a SQL error) display the error to the user so they can correct it Whatever happens always close the Statement object This is done with a RequestDispatcher object Add a request attribute that tells the servlet what to count Use the attribute name defined by the Counter servlet and use the name of this class as a unique counter name Tell the dispatcher to invoke its servlet and include the output Finally end the HTML output ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"invalidate":1,"getSession":1,"sendRedirect":1,"getParameter":1},"annotations":[],"exceptions":["java.io.IOException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":12,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"public void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n    // Destroy the user's session\n    request.getSession().invalidate();\n    // Figure out what to display next\n    String nextpage = request.getParameter(\"page\");\n    // And redirect the user's browser to that page\n    response.sendRedirect(nextpage);\n}\n","name":"doGet","className":"Logout","variables":{"request":2,"nextpage":1,"response":1},"constants":{"\"page\"":1},"javaDoc":"","comments":"Destroy the user's session Figure out what to display next And redirect the user's browser to that page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"doGet":1},"annotations":[],"exceptions":["java.io.IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// doPost just invokes doGet\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n    doGet(request, response);\n}\n","name":"doPost","className":"Logout","variables":{},"constants":{},"javaDoc":"","comments":" doPost just invokes doGet","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"println":1,"getAttribute":1,"getWriter":1,"setContentType":1,"getSession":1,"getParameter":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":22,"StringLiteralExpr":6,"CastExpr":1,"MethodCallExpr":6,"AssignExpr":2},"statements":{"IfStmt":2,"ExpressionStmt":6},"text":"// This method is invoked when the servlet is the subject of an HTTP GET\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // See if the username is specified in the request\n    String name = request.getParameter(\"username\");\n    // and associates a HttpSession object with each session.\n    if (name == null)\n        name = (String) request.getSession().getAttribute(\"username\");\n    // If the username is not found in either place, use a default name.\n    if (name == null)\n        name = \"World\";\n    // Specify the type of output we produce.  If this servlet is\n    // included from within another servlet or JSP page, this setting\n    // will be ignored.\n    response.setContentType(\"text/html\");\n    // Get an stream that we can write the output to\n    PrintWriter out = response.getWriter();\n    // And, finally, do our output.\n    out.println(\"Hello \" + name + \"!\");\n}\n     // If not, look in the session object.  The web server or servlet\n\n     // container performs session tracking automatically for the servlet,\n\n","name":"doGet","className":"Hello","variables":{"request":2,"response":2,"name":6,"out":2},"constants":{"\"username\"":2,"\"!\"":1,"null":2,"\"Hello \"":1,"\"World\"":1,"\"text/html\"":1},"javaDoc":"","comments":"If not look in the session object The web server or servlet container performs session tracking automatically for the servlet Specify the type of output we produce If this servlet is included from within another servlet or JSP page this setting See if the username is specified in the request and associates a HttpSession object with each session If the username is not found in either place use a default name will be ignored Get an stream that we can write the output to And finally do our output  This method is invoked when the servlet is the subject of an HTTP GET","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"doGet":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method is invoked when the servlet is the subject of an HTTP POST.\n// It calls the doGet() method so that this servlet works correctly\n// with either type of request.\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    doGet(request, response);\n}\n","name":"doPost","className":"Hello","variables":{},"constants":{},"javaDoc":"","comments":" with either type of request.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"parseInt":1,"getServletConfig":1,"loadState":1,"getInitParameter":2,"currentTimeMillis":1,"getMessage":1},"annotations":[],"exceptions":["ServletException","Exception"],"concepts":["ExceptionHandling"],"types":{"ServletConfig":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":3,"MethodCallExpr":7,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":5},"text":"// This method is called when the web server first instantiates this\n// servlet.  It reads initialization parameters (which are configured\n// at deployment time in the web.xml file), and loads the initial state\n// of the counter variables from a file.\npublic void init() throws ServletException {\n    ServletConfig config = getServletConfig();\n    try {\n        // Get the save file.\n        countfile = new File(config.getInitParameter(\"countfile\"));\n        // How often should we save our state while running?\n        saveInterval = Integer.parseInt(config.getInitParameter(\"saveInterval\"));\n        // The state couldn't have changed before now.\n        lastSaveTime = System.currentTimeMillis();\n        // Now read in the count data\n        loadState();\n    } catch (Exception e) {\n        throw new ServletException(\"Can't init Counter servlet: \" + e.getMessage(), e);\n    }\n}\n         // If something goes wrong, wrap the exception and rethrow it\n\n","name":"init","className":"Counter","variables":{"Integer":1,"countfile":1,"e":3,"lastSaveTime":1,"saveInterval":1,"config":3,"System":1},"constants":{"\"countfile\"":1,"\"Can't init Counter servlet: \"":1,"\"saveInterval\"":1},"javaDoc":"","comments":"Get the save file How often should we save our state while running? The state couldn't have changed before now Now read in the count data If something goes wrong wrap the exception and rethrow it  of the counter variables from a file.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"saveState":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":1},"text":"// This method is called when the web server stops the servlet (which\n// happens when the web server is shutting down, or when the servlet is\n// not in active use.)  This method saves the counts to a file so they\n// can be restored when the servlet is restarted.\npublic void destroy() {\n    try // Try to save the state\n    {\n        saveState();\n    }// Ignore any problems: we did the best we could\n     catch (Exception e) {\n    }\n}\n","name":"destroy","className":"Counter","variables":{"e":1},"constants":{},"javaDoc":"","comments":"Try to save the state Ignore any problems: we did the best we could  can be restored when the servlet is restarted.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"print":1,"getAttribute":1,"saveState":1,"getRequestURI":1,"log":1,"intValue":1,"getWriter":1,"get":1,"currentTimeMillis":2,"put":1,"getParameter":1},"annotations":[],"exceptions":["IOException"],"concepts":["Synchronization"],"types":{"Integer":1,"String":1,"PrintWriter":1},"expressions":{"NullLiteralExpr":3,"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":53,"CastExpr":2,"StringLiteralExpr":1,"MethodCallExpr":12,"AssignExpr":6},"statements":{"IfStmt":4,"BlockStmt":3,"SynchronizedStmt":1,"ExpressionStmt":13},"text":"/**\n     * This method is called when the servlet is invoked.  It looks for a\n     * request parameter named \"counter\", and uses its value as the name of\n     * the counter variable to increment.  If it doesn't find the request\n     * parameter, then it uses the URL of the request as the name of the\n     * counter.  This is useful when the servlet is mapped to a URL suffix.\n     * This method also checks how much time has elapsed since it last saved\n     * its state, and saves the state again if necessary.  This prevents it\n     * from losing too much data if the server crashes or shuts down without\n     * calling the destroy() method.\n     **/\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    // Get the name of the counter as a request parameter\n    String counterName = request.getParameter(PARAMETER_NAME);\n    // is included by another servlet\n    if (counterName == null)\n        counterName = (String) request.getAttribute(ATTRIBUTE_NAME);\n    // If it wasn't a parameter or attribute, use the request URL.\n    if (counterName == null)\n        counterName = request.getRequestURI();\n    // What is the current count?\n    Integer count;\n    // prevents them from updating the counts hashtable at the same time\n    synchronized (counts) {\n        // Get the counter value from the hashtable\n        count = (Integer) counts.get(counterName);\n        // Increment the counter, or if it is new, log and start it at 1\n        if (count != null)\n            count = new Integer(count.intValue() + 1);\n        else {\n            // If this is a counter we haven't used before, send a message\n            // to the log file, just so we can track what we're counting\n            log(\"Starting new counter: \" + counterName);\n            // Start counting at 1!\n            count = new Integer(1);\n        }\n        // Store the incremented (or new) counter value into the hashtable\n        counts.put(counterName, count);\n        // server crashes unexpectedly.  \n        if (System.currentTimeMillis() - lastSaveTime > saveInterval) {\n            saveState();\n            lastSaveTime = System.currentTimeMillis();\n        }\n    }\n    // End of synchronized block\n    // Finally, output the counter value.  Since this servlet is usually\n    // included within the output of other servlets, we don't bother\n    // setting the content type.\n    PrintWriter out = response.getWriter();\n    out.print(count);\n}\n     // If we didn't find it there, see if it was passed to us as a\n\n     // request attribute, which happens when the output of this servlet\n\n     // This block of code is synchronized because multiple requests may\n\n     // be running at the same time in different threads.  Synchronization\n\n         // Check whether saveInterval milliseconds have elapsed since we\n\n         // last saved our state.  If so, save it again.  This prevents\n\n         // us from losing more than saveInterval ms of data, even if the\n\n","name":"doGet","className":"Counter","variables":{"request":3,"counts":3,"response":1,"count":6,"lastSaveTime":2,"saveInterval":1,"System":2,"counterName":6,"out":2},"constants":{"1":2,"null":3,"\"Starting new counter: \"":1},"javaDoc":"This method is called when the servlet is invoked It looks for a request parameter named \"counter\" and uses its value as the name of the counter variable to increment If it doesn't find the request parameter then it uses the URL of the request as the name of the counter This is useful when the servlet is mapped to a URL suffix This method also checks how much time has elapsed since it last saved its state and saves the state again if necessary This prevents it from losing too much data if the server crashes or shuts down without calling the destroy() method","comments":"If we didn't find it there see if it was passed to us as a request attribute which happens when the output of this servlet This block of code is synchronized because multiple requests may be running at the same time in different threads Synchronization End of synchronized block Finally output the counter value Since this servlet is usually included within the output of other servlets we don't bother Get the name of the counter as a request parameter is included by another servlet If it wasn't a parameter or attribute use the request URL What is the current count? prevents them from updating the counts hashtable at the same time Check whether saveInterval milliseconds have elapsed since we last saved our state If so save it again This prevents us from losing more than saveInterval ms of data even if the Get the counter value from the hashtable Increment the counter or if it is new log and start it at 1 If this is a counter we haven't used before send a message to the log file just so we can track what we're counting Start counting at 1! Store the incremented (or new) counter value into the hashtable server crashes unexpectedly setting the content type \n     * This method is called when the servlet is invoked.  It looks for a\n     * request parameter named \"counter\", and uses its value as the name of\n     * the counter variable to increment.  If it doesn't find the request\n     * parameter, then it uses the URL of the request as the name of the\n     * counter.  This is useful when the servlet is mapped to a URL suffix.\n     * This method also checks how much time has elapsed since it last saved\n     * its state, and saves the state again if necessary.  This prevents it\n     * from losing too much data if the server crashes or shuts down without\n     * calling the destroy() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpServletRequest","HttpServletResponse"],"returnType":"void","methodCalls":{"doGet":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// The doPost method just calls doGet, so that this servlet can be\n// included in pages that are loaded with POST requests\npublic void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    doGet(request, response);\n}\n","name":"doPost","className":"Counter","variables":{},"constants":{},"javaDoc":"","comments":" included in pages that are loaded with POST requests","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"// Save the state of the counters by serializing the hashtable to\n// the file specified by the initialization parameter.\nvoid saveState() throws IOException {\n    ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(countfile)));\n    // Save the hashtable to the stream\n    out.writeObject(counts);\n    // Always remember to close your files!\n    out.close();\n}\n","name":"saveState","className":"Counter","variables":{"countfile":1,"out":3},"constants":{},"javaDoc":"","comments":"Save the hashtable to the stream Always remember to close your files!  the file specified by the initialization parameter.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"exists":1,"getMessage":1,"close":1,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException","Exception"],"concepts":["ExceptionHandling"],"types":{"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"CastExpr":1,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":3},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"// Load the initial state of the counters by de-serializing a hashtable\n// from the file specified by the initialization parameter.  If the file\n// doesn't exist yet, then start with an empty hashtable.\nvoid loadState() throws IOException {\n    if (!countfile.exists()) {\n        counts = new HashMap();\n        return;\n    }\n    ObjectInputStream in = null;\n    try {\n        in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(countfile)));\n        counts = (HashMap) in.readObject();\n    } catch (ClassNotFoundException e) {\n        throw new IOException(\"Count file contains bad data: \" + e.getMessage());\n    } finally {\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"loadState","className":"Counter","variables":{"countfile":2,"in":4,"e":3,"counts":2},"constants":{"null":1,"\"Count file contains bad data: \"":1},"javaDoc":"","comments":" doesn't exist yet, then start with an empty hashtable.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// The following property setter methods set the values of the fields above\n// When a JSP page uses this tag any tag attribute settings will be\n// translated into calls to these methods.\npublic void setAlign(String value) {\n    align = value;\n}\n","name":"setAlign","className":"DecorBox","variables":{"align":1,"value":1},"constants":{},"javaDoc":"","comments":" translated into calls to these methods.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setTitle(String value) {\n    title = value;\n}\n","name":"setTitle","className":"DecorBox","variables":{"title":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setTitleColor(String value) {\n    titleColor = value;\n}\n","name":"setTitleColor","className":"DecorBox","variables":{"titleColor":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setTitleAlign(String value) {\n    titleAlign = value;\n}\n","name":"setTitleAlign","className":"DecorBox","variables":{"value":1,"titleAlign":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setColor(String value) {\n    this.color = value;\n}\n","name":"setColor","className":"DecorBox","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBorderColor(String value) {\n    borderColor = value;\n}\n","name":"setBorderColor","className":"DecorBox","variables":{"borderColor":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setMargin(String value) {\n    margin = value;\n}\n","name":"setMargin","className":"DecorBox","variables":{"margin":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setBorderWidth(String value) {\n    borderWidth = value;\n}\n","name":"setBorderWidth","className":"DecorBox","variables":{"borderWidth":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PageContext"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"SuperExpr":1,"NameExpr":11,"StringLiteralExpr":7,"MethodCallExpr":1,"AssignExpr":8},"statements":{"ExpressionStmt":9},"text":"/**\n     * This inherited method is always the first property setter invoked\n     * by the JSP container.  We don't care about the page context here, but\n     * use this method to set the default values of the various properties.\n     * They are initialized here in case the JSP container wants to reuse\n     * this Tag object on multiple pages.\n     **/\npublic void setPageContext(PageContext context) {\n    // Important!  Let the superclass save the page context object.\n    // We'll need it in doStartTag() below.\n    super.setPageContext(context);\n    // Now set default values for all the other properties\n    align = \"center\";\n    title = null;\n    titleColor = \"white\";\n    titleAlign = \"left\";\n    color = \"lightblue\";\n    borderColor = \"black\";\n    margin = \"20\";\n    borderWidth = \"4\";\n}\n","name":"setPageContext","className":"DecorBox","variables":{"borderColor":1,"margin":1,"titleColor":1,"color":1,"borderWidth":1,"align":1,"title":1,"titleAlign":1},"constants":{"\"4\"":1,"\"20\"":1,"null":1,"\"white\"":1,"\"center\"":1,"\"black\"":1,"\"lightblue\"":1,"\"left\"":1},"javaDoc":"This inherited method is always the first property setter invoked by the JSP container We don't care about the page context here but use this method to set the default values of the various properties They are initialized here in case the JSP container wants to reuse this Tag object on multiple pages","comments":"Important! Let the superclass save the page context object We'll need it in doStartTag() below Now set default values for all the other properties \n     * This inherited method is always the first property setter invoked\n     * by the JSP container.  We don't care about the page context here, but\n     * use this method to set the default values of the various properties.\n     * They are initialized here in case the JSP container wants to reuse\n     * this Tag object on multiple pages.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getOut":1,"print":3,"getMessage":1},"annotations":[],"exceptions":["JspException","IOException"],"concepts":["ExceptionHandling"],"types":{"JspWriter":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":24,"NameExpr":25,"StringLiteralExpr":18,"MethodCallExpr":5},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * This method is called when a <decor:box> tag is encountered.  Any\n     * attributes will first be processed by calling the setter methods above.\n     **/\npublic int doStartTag() throws JspException {\n    try {\n        // Get the output stream from the PageContext object, which\n        // will have been passed to the setPageContext() method.\n        JspWriter out = pageContext.getOut();\n        // Output the HTML tags necessary to display the box. The <div>\n        // handles the alignment, and the <table> creates the border.\n        out.print(\"<div align='\" + align + \"'>\" + \"<table bgcolor='\" + borderColor + \"' \" + \"border='0' cellspacing='0' \" + \"cellpadding='\" + borderWidth + \"'>\");\n        // If there is a title, display it as a cell of the outer table\n        if (title != null)\n            out.print(\"<tr><td align='\" + titleAlign + \"'>\" + \"<font face='helvetica' size='+1' \" + \"color='\" + titleColor + \"'><b>\" + title + \"</b></font></td></tr>\");\n        // Now begin an inner table that has a different color than \n        // the border.\n        out.print(\"<tr><td><table bgcolor='\" + color + \"' \" + \"border='0' cellspacing='0' \" + \"cellpadding='\" + margin + \"'><tr><td>\");\n    } catch (IOException e) {\n        throw new JspException(e.getMessage());\n    }\n    // This return value tells the JSP class to process the body of the tag\n    return EVAL_BODY_INCLUDE;\n}\n         // Unlike a PrintWriter, a JspWriter can throw IOExceptions\n\n         // We have to catch them and wrap them in a JSPException\n\n","name":"doStartTag","className":"DecorBox","variables":{"pageContext":1,"borderColor":1,"margin":1,"titleColor":1,"color":1,"e":2,"borderWidth":1,"EVAL_BODY_INCLUDE":1,"align":1,"title":2,"out":4,"titleAlign":1},"constants":{"\"'><b>\"":1,"\"<tr><td align='\"":1,"\"</b></font></td></tr>\"":1,"\"color='\"":1,"\"border='0' cellspacing='0' \"":2,"\"cellpadding='\"":2,"\"<tr><td><table bgcolor='\"":1,"\"'><tr><td>\"":1,"null":1,"\"<table bgcolor='\"":1,"\"' \"":2,"\"'>\"":3,"\"<font face='helvetica' size='+1' \"":1,"\"<div align='\"":1},"javaDoc":"This method is called when a <decor:box> tag is encountered Any attributes will first be processed by calling the setter methods above","comments":"Get the output stream from the PageContext object which Output the HTML tags necessary to display the box The <div> Now begin an inner table that has a different color than will have been passed to the setPageContext() method handles the alignment and the <table> creates the border If there is a title display it as a cell of the outer table the border Unlike a PrintWriter a JspWriter can throw IOExceptions We have to catch them and wrap them in a JSPException This return value tells the JSP class to process the body of the tag \n     * This method is called when a <decor:box> tag is encountered.  Any\n     * attributes will first be processed by calling the setter methods above.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"getOut":1,"println":1,"getMessage":1},"annotations":[],"exceptions":["JspException","IOException"],"concepts":["ExceptionHandling"],"types":{"JspWriter":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n     * This method is called when the closing </decor:box> tag is encountered\n     **/\npublic int doEndTag() throws JspException {\n    // Catch IOExceptions and rethrow them as JspExceptions\n    try {\n        JspWriter out = pageContext.getOut();\n        out.println(\"</td></tr></table></td></tr></table></div>\");\n    } catch (IOException e) {\n        throw new JspException(e.getMessage());\n    }\n    // This return value says to continue processing the JSP page.\n    return EVAL_PAGE;\n}\n     // Try to output HTML to close the <table> and <div> tags.\n\n","name":"doEndTag","className":"DecorBox","variables":{"pageContext":1,"e":2,"EVAL_PAGE":1,"out":2},"constants":{"\"</td></tr></table></td></tr></table></div>\"":1},"javaDoc":"This method is called when the closing </decor:box> tag is encountered","comments":"Try to output HTML to close the <table> and <div> tags Catch IOExceptions and rethrow them as JspExceptions This return value says to continue processing the JSP page \n     * This method is called when the closing </decor:box> tag is encountered\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These are the getter and setter methods for the userName property\n// In a real program, setUserName() would probably look up information \n// about the user in a database of some kind.\npublic String getUserName() {\n    return username;\n}\n","name":"getUserName","className":"UserBean","variables":{"username":1},"constants":{},"javaDoc":"","comments":" about the user in a database of some kind.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setUserName(String username) {\n    this.username = username;\n}\n","name":"setUserName","className":"UserBean","variables":{"username":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These are the getter and setter methods for the favoriteColor property\npublic String getFavoriteColor() {\n    return favorite;\n}\n","name":"getFavoriteColor","className":"UserBean","variables":{"favorite":1},"constants":{},"javaDoc":"","comments":" These are the getter and setter methods for the favoriteColor property","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setFavoriteColor(String favorite) {\n    this.favorite = favorite;\n}\n","name":"setFavoriteColor","className":"UserBean","variables":{"favorite":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Return a list of colors the user is allowed to choose from\npublic String[] getColorChoices() {\n    return colors;\n}\n","name":"getColorChoices","className":"UserBean","variables":{"colors":1},"constants":{},"javaDoc":"","comments":" Return a list of colors the user is allowed to choose from","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"// This is a getter method for the \"customContent\" property.  In a more\n// sophisticated example, this method might query a database and return\n// current news clippings or stock quotes for the user.  Not here, though.\npublic String getCustomContent() {\n    return \"Your name backwards is: <tt>\" + new StringBuffer(username).reverse() + \"</tt>\";\n}\n","name":"getCustomContent","className":"UserBean","variables":{"username":1},"constants":{"\"</tt>\"":1,"\"Your name backwards is: <tt>\"":1},"javaDoc":"","comments":" current news clippings or stock quotes for the user.  Not here, though.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpSessionBindingEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":7,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method implements HttpSessionBindingListener.  If an instance of\n// this class is bound in a HttpSession object, then this method will\n// be invoked when the instance becomes unbound, which typically happens\n// when the session is invalidated because the user logged out or\n// was inactive for too long.  In a real example, this method would\n// probably save information about the user to a file or database.\npublic void valueUnbound(HttpSessionBindingEvent e) {\n    System.out.println(username + \" logged out or timed out.\" + \" Favorite color: \" + favorite);\n}\n","name":"valueUnbound","className":"UserBean","variables":{"favorite":1,"username":1},"constants":{"\" logged out or timed out.\"":1,"\" Favorite color: \"":1},"javaDoc":"","comments":" probably save information about the user to a file or database.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HttpSessionBindingEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Part of HttpSessionBindingListener; we don't care about it here\npublic void valueBound(HttpSessionBindingEvent e) {\n}\n","name":"valueBound","className":"UserBean","variables":{},"constants":{},"javaDoc":"","comments":" Part of HttpSessionBindingListener; we don't care about it here","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"generateKey":1,"writeKey":1,"addProvider":1,"System.out.flush":1,"encrypt":1,"getInstance":1,"System.err.println":3,"readKey":2,"decrypt":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"SecretKey":3,"SunJCE":1,"Cipher":1,"File":1,"Provider":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":5,"VariableDeclarationExpr":6,"ArrayAccessExpr":5,"BinaryExpr":4,"NameExpr":86,"StringLiteralExpr":11,"FieldAccessExpr":11,"ClassExpr":1,"MethodCallExpr":19},"statements":{"IfStmt":3,"TryStmt":2,"BlockStmt":7,"ExpressionStmt":17},"text":"/**\n     * The program.  The first argument must be -e, -d, or -g to encrypt,\n     * decrypt, or generate a key.  The second argument is the name of a file\n     * from which the key is read or to which it is written for -g.  The\n     * -e and -d arguments cause the program to read from standard input and\n     * encrypt or decrypt to standard output.\n     **/\npublic static void main(String[] args) {\n    try {\n        // encryption.  If not, explicitly install the SunJCE provider.\n        try {\n            Cipher c = Cipher.getInstance(\"DESede\");\n        } catch (Exception e) {\n            System.err.println(\"Installing SunJCE provider.\");\n            Provider sunjce = new com.sun.crypto.provider.SunJCE();\n            Security.addProvider(sunjce);\n        }\n        // This is where we'll read the key from or write it to\n        File keyfile = new File(args[1]);\n        // Now check the first arg to see what we're going to do\n        if (args[0].equals(\"-g\")) {\n            // Generate a key\n            System.out.print(\"Generating key. This may take some time...\");\n            System.out.flush();\n            SecretKey key = generateKey();\n            writeKey(key, keyfile);\n            System.out.println(\"done.\");\n            System.out.println(\"Secret key written to \" + args[1] + \". Protect that file carefully!\");\n        } else if (args[0].equals(\"-e\")) {\n            // Encrypt stdin to stdout\n            SecretKey key = readKey(keyfile);\n            encrypt(key, System.in, System.out);\n        } else if (args[0].equals(\"-d\")) {\n         // Check to see whether there is a provider that can do TripleDES\n\n            // Decrypt stdin to stdout\n            SecretKey key = readKey(keyfile);\n            decrypt(key, System.in, System.out);\n         // An exception here probably means the JCE provider hasn't\n\n         // been permanently installed on this system by listing it \n\n         // in the $JAVA_HOME/jre/lib/security/java.security file.\n\n         // Therefore, we have to install the JCE provider explicitly.\n\n        }\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java \" + TripleDES.class.getName() + \" -d|-e|-g <keyfile>\");\n    }\n}\n","name":"main","className":"TripleDES","variables":{"args":5,"sunjce":1,"c":1,"e":2,"keyfile":1,"Cipher":1,"Security":1,"key":3},"constants":{"\"DESede\"":1,"\"Installing SunJCE provider.\"":1,"0":3,"\"done.\"":1,"1":2,"\" -d|-e|-g <keyfile>\"":1,"\"-g\"":1,"\". Protect that file carefully!\"":1,"\"-e\"":1,"\"-d\"":1,"\"Generating key. This may take some time...\"":1,"\"Usage: java \"":1,"\"Secret key written to \"":1},"javaDoc":"The program The first argument must be -e -d or -g to encrypt decrypt or generate a key The second argument is the name of a file from which the key is read or to which it is written for -g The -e and -d arguments cause the program to read from standard input and encrypt or decrypt to standard output","comments":"Check to see whether there is a provider that can do TripleDES encryption If not explicitly install the SunJCE provider An exception here probably means the JCE provider hasn't been permanently installed on this system by listing it in the $JAVA_HOME/jre/lib/security/java security file Therefore we have to install the JCE provider explicitly This is where we'll read the key from or write it to Now check the first arg to see what we're going to do Generate a key Encrypt stdin to stdout Decrypt stdin to stdout \n     * The program.  The first argument must be -e, -d, or -g to encrypt,\n     * decrypt, or generate a key.  The second argument is the name of a file\n     * from which the key is read or to which it is written for -g.  The\n     * -e and -d arguments cause the program to read from standard input and\n     * encrypt or decrypt to standard output.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"SecretKey","methodCalls":{"generateKey":1,"getInstance":1},"annotations":[],"exceptions":["NoSuchAlgorithmException"],"concepts":[],"types":{"KeyGenerator":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Generate a secret TripleDES encryption/decryption key */\npublic static SecretKey generateKey() throws NoSuchAlgorithmException {\n    // Get a key generator for Triple DES (a.k.a DESede)\n    KeyGenerator keygen = KeyGenerator.getInstance(\"DESede\");\n    // Use it to generate a key\n    return keygen.generateKey();\n}\n","name":"generateKey","className":"TripleDES","variables":{"KeyGenerator":1,"keygen":2},"constants":{"\"DESede\"":1},"javaDoc":"Generate a secret TripleDES encryption/decryption key","comments":"Get a key generator for Triple DES (a k a DESede) Use it to generate a key  Generate a secret TripleDES encryption/decryption key ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["SecretKey","File"],"returnType":"void","methodCalls":{"getKey":1,"getKeySpec":1,"getInstance":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException","NoSuchAlgorithmException","InvalidKeySpecException"],"concepts":["Casting"],"types":{"byte[]":1,"FileOutputStream":1,"DESedeKeySpec":1,"SecretKeyFactory":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"NameExpr":18,"StringLiteralExpr":1,"CastExpr":1,"ClassExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/** Save the specified TripleDES SecretKey to the specified file */\npublic static void writeKey(SecretKey key, File f) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n    // Convert the secret key to an array of bytes like this\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    DESedeKeySpec keyspec = (DESedeKeySpec) keyfactory.getKeySpec(key, DESedeKeySpec.class);\n    byte[] rawkey = keyspec.getKey();\n    // Write the raw key to the file\n    FileOutputStream out = new FileOutputStream(f);\n    out.write(rawkey);\n    out.close();\n}\n","name":"writeKey","className":"TripleDES","variables":{"keyfactory":2,"rawkey":1,"f":1,"keyspec":2,"SecretKeyFactory":1,"out":3},"constants":{"\"DESede\"":1},"javaDoc":"Save the specified TripleDES SecretKey to the specified file","comments":"Convert the secret key to an array of bytes like this Write the raw key to the file  Save the specified TripleDES SecretKey to the specified file ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File"],"returnType":"SecretKey","methodCalls":{"readFully":1,"length":1,"generateSecret":1,"getInstance":1,"close":1},"annotations":[],"exceptions":["IOException","NoSuchAlgorithmException","InvalidKeySpecException","InvalidKeyException"],"concepts":[],"types":{"byte[]":1,"SecretKey":1,"DESedeKeySpec":1,"DataInputStream":1,"SecretKeyFactory":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"NameExpr":20,"CastExpr":1,"StringLiteralExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":5},"statements":{"ReturnStmt":1,"ExpressionStmt":7},"text":"/** Read a TripleDES secret key from the specified file */\npublic static SecretKey readKey(File f) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {\n    // Read the raw bytes from the keyfile\n    DataInputStream in = new DataInputStream(new FileInputStream(f));\n    byte[] rawkey = new byte[(int) f.length()];\n    in.readFully(rawkey);\n    in.close();\n    // Convert the raw bytes to a secret key like this\n    DESedeKeySpec keyspec = new DESedeKeySpec(rawkey);\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    SecretKey key = keyfactory.generateSecret(keyspec);\n    return key;\n}\n","name":"readKey","className":"TripleDES","variables":{"rawkey":2,"keyfactory":2,"in":3,"f":2,"keyspec":1,"SecretKeyFactory":1,"key":2},"constants":{"\"DESede\"":1},"javaDoc":"Read a TripleDES secret key from the specified file","comments":"Read the raw bytes from the keyfile Convert the raw bytes to a secret key like this  Read a TripleDES secret key from the specified file ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["SecretKey","InputStream","OutputStream"],"returnType":"void","methodCalls":{"init":1,"java.util.Arrays.fill":1,"read":1,"getInstance":1,"write":1,"close":1},"annotations":[],"exceptions":["NoSuchPaddingException","NoSuchAlgorithmException","IOException","InvalidKeyException"],"concepts":[],"types":{"byte[]":1,"CipherOutputStream":1,"Cipher":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":33,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1,"CastExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"/** \n     * Use the specified TripleDES key to encrypt bytes from the input stream\n     * and write them to the output stream.  This method uses \n     * CipherOutputStream to perform the encryption and write bytes at the\n     * same time.\n     **/\npublic static void encrypt(SecretKey key, InputStream in, OutputStream out) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IOException {\n    // Create and initialize the encryption engine\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    // Create a special output stream to do the work for us\n    CipherOutputStream cos = new CipherOutputStream(out, cipher);\n    // Read from the input and write to the encrypting output stream\n    byte[] buffer = new byte[2048];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1) {\n        cos.write(buffer, 0, bytesRead);\n    }\n    cos.close();\n    // For extra security, don't leave any plaintext hanging around memory.\n    java.util.Arrays.fill(buffer, (byte) 0);\n}\n","name":"encrypt","className":"TripleDES","variables":{"cipher":3,"in":1,"cos":3,"bytesRead":2,"Cipher":1,"buffer":1,"out":1},"constants":{"0":2,"1":1,"\"DESede\"":1,"2048":1},"javaDoc":"Use the specified TripleDES key to encrypt bytes from the input stream and write them to the output stream This method uses CipherOutputStream to perform the encryption and write bytes at the same time","comments":"Create and initialize the encryption engine Create a special output stream to do the work for us Read from the input and write to the encrypting output stream For extra security don't leave any plaintext hanging around memory  \n     * Use the specified TripleDES key to encrypt bytes from the input stream\n     * and write them to the output stream.  This method uses \n     * CipherOutputStream to perform the encryption and write bytes at the\n     * same time.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["SecretKey","InputStream","OutputStream"],"returnType":"void","methodCalls":{"init":1,"read":1,"flush":1,"update":1,"getInstance":1,"write":2,"doFinal":1},"annotations":[],"exceptions":["IllegalBlockSizeException","NoSuchPaddingException","NoSuchAlgorithmException","IOException","BadPaddingException","InvalidKeyException"],"concepts":[],"types":{"byte[]":1,"Cipher":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"MethodCallExpr":8,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":7},"text":"/** \n     * Use the specified TripleDES key to decrypt bytes ready from the input \n     * stream and write them to the output stream.  This method uses \n     * uses Cipher directly to show how it can be done without \n     * CipherInputStream and CipherOutputStream.\n     **/\npublic static void decrypt(SecretKey key, InputStream in, OutputStream out) throws NoSuchAlgorithmException, InvalidKeyException, IOException, IllegalBlockSizeException, NoSuchPaddingException, BadPaddingException {\n    // Create and initialize the decryption engine\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    // Read bytes, decrypt, and write them out.\n    byte[] buffer = new byte[2048];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1) {\n        out.write(cipher.update(buffer, 0, bytesRead));\n    }\n    // Write out the final bunch of decrypted bytes\n    out.write(cipher.doFinal());\n    out.flush();\n}\n","name":"decrypt","className":"TripleDES","variables":{"cipher":4,"in":1,"bytesRead":2,"Cipher":1,"buffer":1,"out":3},"constants":{"0":1,"1":1,"\"DESede\"":1,"2048":1},"javaDoc":"Use the specified TripleDES key to decrypt bytes ready from the input stream and write them to the output stream This method uses uses Cipher directly to show how it can be done without CipherInputStream and CipherOutputStream","comments":"Create and initialize the decryption engine Read bytes decrypt and write them out Write out the final bunch of decrypted bytes  \n     * Use the specified TripleDES key to decrypt bytes ready from the input \n     * stream and write them to the output stream.  This method uses \n     * uses Cipher directly to show how it can be done without \n     * CipherInputStream and CipherOutputStream.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"exit":1,"setSecurityManager":1,"addService":1,"loadClass":1,"newInstance":1,"System.err.println":2,"getSecurityManager":1,"System.out.println":1},"annotations":[],"exceptions":["// Display a message if anything goes wrong\nException"],"concepts":["Casting","PolyMorphism","ExceptionHandling"],"types":{"Server":1,"URLClassLoader":1,"ClassLoader":1,"Class":1,"URL":1,"int":2,"Server.Service":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"ArrayAccessExpr":3,"BinaryExpr":5,"NameExpr":51,"StringLiteralExpr":4,"UnaryExpr":2,"NullLiteralExpr":2,"ArrayInitializerExpr":1,"CastExpr":1,"FieldAccessExpr":4,"ClassExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    try {\n        // one with the -Djava.security.manager argument\n        if (System.getSecurityManager() == null) {\n            System.out.println(\"Establishing a security manager\");\n            System.setSecurityManager(new SecurityManager());\n        }\n        // Create a Server object\n        Server server = new Server(null, 5);\n        // Create the ClassLoader that we'll use to load Service classes.\n        // The classes should be stored in the JAR file or the directory\n        // specified as a URL by the first command-line argument\n        URL serviceURL = new URL(args[0]);\n        ClassLoader loader = new java.net.URLClassLoader(new URL[] { serviceURL });\n        // Parse the argument list, which should contain Service name/port\n        // pairs.  For each pair, load the named Service using the class\n        // loader, then instantiate it with newInstance(), then tell the\n        // server to start running it.\n        int i = 1;\n        while (i < args.length) {\n            // Dynamically load the Service class using the class loader\n            Class serviceClass = loader.loadClass(args[i++]);\n            // Dynamically instantiate the class.  \n            Server.Service service = (Server.Service) serviceClass.newInstance();\n            // Parse the port #\n            int port = Integer.parseInt(args[i++]);\n            // Run service\n            server.addService(service, port);\n             // Install a Security manager, if the user didn't already install\n\n        }\n    } catch (// Display a message if anything goes wrong\n    Exception // Display a message if anything goes wrong\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java \" + SafeServer.class.getName() + \" <url> <servicename> <port>\\n\" + \"\\t[<servicename> <port> ... ]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"SafeServer","variables":{"args":3,"Integer":1,"server":2,"serviceClass":2,"port":1,"e":1,"loader":2,"service":1,"serviceURL":2,"i":4,"System":3},"constants":{"0":1,"1":2,"\" <url> <servicename> <port>\\n\"":1,"\"Establishing a security manager\"":1,"null":2,"5":1,"\"Usage: java \"":1,"\"\\t[<servicename> <port> ... ]\"":1},"javaDoc":"","comments":"Install a Security manager if the user didn't already install Create the ClassLoader that we'll use to load Service classes The classes should be stored in the JAR file or the directory Parse the argument list which should contain Service name/port pairs For each pair load the named Service using the class loader then instantiate it with newInstance() then tell the one with the -Djava security manager argument Create a Server object specified as a URL by the first command-line argument server to start running it Dynamically load the Service class using the class loader Dynamically instantiate the class Parse the port # Run service Display a message if anything goes wrong Display a message if anything goes wrong ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"exit":1,"println":26,"getProperty":3,"setSecurityManager":1,"close":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"FileReader":1,"String":1,"File":2,"PrintWriter":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"BinaryExpr":13,"NameExpr":116,"StringLiteralExpr":23,"UnaryExpr":1,"MethodCallExpr":33},"statements":{"TryStmt":7,"BlockStmt":14,"ExpressionStmt":36},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(o);\n    // Try to install our own security manager.  If we can do this,\n    // we can defeat any access control.\n    out.println(\"Trying to create and install a security manager...\");\n    try {\n        System.setSecurityManager(new SecurityManager());\n        out.println(\"Success!\");\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    // Try to make the Server and the Java VM exit.\n    // This is a denial of service attack, and it should not succeed!\n    out.println();\n    out.println(\"Trying to exit...\");\n    try {\n        System.exit(-1);\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    // The default system policy allows this property to be read\n    out.println();\n    out.println(\"Attempting to find java version...\");\n    try {\n        out.println(System.getProperty(\"java.version\"));\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    // The default system policy does not allow this property to be read\n    out.println();\n    out.println(\"Attempting to find home directory...\");\n    try {\n        out.println(System.getProperty(\"user.home\"));\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    // Our custom policy explicitly allows this property to be read\n    out.println();\n    out.println(\"Attempting to read service.tmp property...\");\n    try {\n        String tmpdir = System.getProperty(\"service.tmp\");\n        out.println(tmpdir);\n        File dir = new File(tmpdir);\n        File f = new File(dir, \"testfile\");\n        // Check whether we've been given permission to write files to\n        // the tmpdir directory\n        out.println();\n        out.println(\"Attempting to write a file in \" + tmpdir + \"...\");\n        try {\n            new FileOutputStream(f);\n            out.println(\"Opened file for writing: \" + f);\n        } catch (Exception e) {\n            out.println(\"Failed: \" + e);\n        }\n        // Check whether we've been given permission to read files from\n        // the tmpdir directory\n        out.println();\n        out.println(\"Attempting to read from \" + tmpdir + \"...\");\n        try {\n            FileReader in = new FileReader(f);\n            out.println(\"Opened file for reading: \" + f);\n        } catch (Exception e) {\n            out.println(\"Failed: \" + e);\n        }\n    } catch (Exception e) {\n        out.println(\"Failed: \" + e);\n    }\n    // Close the Service sockets\n    out.close();\n    i.close();\n}\n","name":"serve","className":"SecureService","variables":{"tmpdir":4,"e":14,"in":1,"f":5,"i":1,"dir":2,"System":5,"out":28,"o":1},"constants":{"\"Attempting to write a file in \"":1,"\"...\"":2,"\"Attempting to find home directory...\"":1,"\"Trying to create and install a security manager...\"":1,"\"Attempting to read service.tmp property...\"":1,"\"Attempting to find java version...\"":1,"\"java.version\"":1,"\"Opened file for reading: \"":1,"\"service.tmp\"":1,"1":1,"\"user.home\"":1,"\"testfile\"":1,"\"Opened file for writing: \"":1,"\"Attempting to read from \"":1,"\"Success!\"":1,"\"Trying to exit...\"":1,"\"Failed: \"":7},"javaDoc":"","comments":"Try to install our own security manager If we can do this Try to make the Server and the Java VM exit we can defeat any access control This is a denial of service attack and it should not succeed! The default system policy allows this property to be read The default system policy does not allow this property to be read Our custom policy explicitly allows this property to be read Check whether we've been given permission to write files to Check whether we've been given permission to read files from the tmpdir directory the tmpdir directory Close the Service sockets ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"toCharArray":1,"getProperty":1,"load":1,"size":1,"verify":1,"create":1,"getInstance":1,"getDefaultType":1,"System.out.println":1},"annotations":[],"exceptions":["Exception","IllegalArgumentException"],"concepts":["PolyMorphism"],"types":{"boolean":1,"BufferedInputStream":1,"InputStream":1,"ArrayList":1,"List":1,"String":7,"File":2,"KeyStore":1,"int":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":2,"VariableDeclarationExpr":14,"ArrayAccessExpr":19,"BinaryExpr":14,"StringLiteralExpr":15,"NameExpr":130,"UnaryExpr":14,"AssignExpr":13,"NullLiteralExpr":12,"BooleanLiteralExpr":2,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":19},"statements":{"IfStmt":16,"BlockStmt":4,"ForStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":31},"text":"public static void main(String[] args) throws Exception {\n    // Set the default values of the command-line arguments\n    // Verify manifest or create one?\n    boolean verify = false;\n    // Manifest file name\n    String manifestfile = \"MANIFEST\";\n    // Algorithm for message digests\n    String digestAlgorithm = \"MD5\";\n    // Signer. No sig. by default\n    String signername = null;\n    // Algorithm for digital sig.\n    String signatureAlgorithm = \"DSA\";\n    // Private keys are protected\n    String password = null;\n    // Where are keys stored\n    File keystoreFile = null;\n    // What kind of keystore\n    String keystoreType = null;\n    // How to access keystore\n    String keystorePassword = null;\n    // The files to digest\n    List filelist = new ArrayList();\n    // Parse the command-line arguments, overriding the defaults above\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-v\"))\n            verify = true;\n        else if (args[i].equals(\"-m\"))\n            manifestfile = args[++i];\n        else if (args[i].equals(\"-da\") && !verify)\n            digestAlgorithm = args[++i];\n        else if (args[i].equals(\"-s\") && !verify)\n            signername = args[++i];\n        else if (args[i].equals(\"-sa\") && !verify)\n            signatureAlgorithm = args[++i];\n        else if (args[i].equals(\"-p\"))\n            password = args[++i];\n        else if (args[i].equals(\"-keystore\"))\n            keystoreFile = new File(args[++i]);\n        else if (args[i].equals(\"-keystoreType\"))\n            keystoreType = args[++i];\n        else if (args[i].equals(\"-keystorePassword\"))\n            keystorePassword = args[++i];\n        else if (!verify)\n            filelist.add(args[i]);\n        else\n            throw new IllegalArgumentException(args[i]);\n    }\n    // If certain arguments weren't supplied, get default values.\n    if (keystoreFile == null) {\n        File dir = new File(System.getProperty(\"user.home\"));\n        keystoreFile = new File(dir, \".keystore\");\n    }\n    if (keystoreType == null)\n        keystoreType = KeyStore.getDefaultType();\n    if (keystorePassword == null)\n        keystorePassword = password;\n    if (!verify && signername != null && password == null) {\n        System.out.println(\"Use -p to specify a password.\");\n        return;\n    }\n    // Get the keystore we'll use for signing or verifying signatures\n    // If no password was provided, then assume we won't be dealing with \n    // signatures, and skip the keystore.\n    KeyStore keystore = null;\n    if (keystorePassword != null) {\n        keystore = KeyStore.getInstance(keystoreType);\n        InputStream in = new BufferedInputStream(new FileInputStream(keystoreFile));\n        keystore.load(in, keystorePassword.toCharArray());\n    }\n    // Otherwise, create a new manifest for the specified files\n    if (verify || (filelist.size() == 0))\n        verify(manifestfile, keystore);\n    else\n        create(manifestfile, digestAlgorithm, signername, signatureAlgorithm, keystore, password, filelist);\n}\n     // If -v was specified or no file were given, verify a manifest\n\n","name":"main","className":"Manifest","variables":{"manifestfile":2,"keystorePassword":6,"in":1,"filelist":3,"i":22,"digestAlgorithm":2,"dir":2,"KeyStore":2,"signatureAlgorithm":2,"System":1,"args":19,"password":4,"keystoreType":4,"verify":8,"keystoreFile":5,"keystore":3,"signername":3},"constants":{"\"MANIFEST\"":1,"\"MD5\"":1,"\"-keystorePassword\"":1,"\"Use -p to specify a password.\"":1,"\"-v\"":1,"false":1,"\"-s\"":1,"\"-keystore\"":1,"\"DSA\"":1,"\"-p\"":1,"\"-da\"":1,"0":2,"\"-m\"":1,"null":12,"\"user.home\"":1,"\"-keystoreType\"":1,"true":1,"\"-sa\"":1,"\".keystore\"":1},"javaDoc":"","comments":"Set the default values of the command-line arguments Get the keystore we'll use for signing or verifying signatures If no password was provided then assume we won't be dealing with If -v was specified or no file were given verify a manifest Verify manifest or create one? Manifest file name Algorithm for message digests Signer No sig by default Algorithm for digital sig Private keys are protected Where are keys stored What kind of keystore How to access keystore The files to digest Parse the command-line arguments overriding the defaults above If certain arguments weren't supplied get default values signatures and skip the keystore Otherwise create a new manifest for the specified files ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String","KeyStore","String","List"],"returnType":"void","methodCalls":{"getKey":1,"toCharArray":1,"System.out.flush":3,"sign":1,"update":2,"sort":1,"store":2,"getBytes":1,"put":5,"initSign":1,"size":1,"get":1,"getInstance":2,"hexEncode":2,"System.err.println":1,"getFileDigest":1,"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":["UnrecoverableKeyException","NoSuchAlgorithmException","SignatureException","KeyStoreException","IOException","InvalidKeyException"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":2,"PrivateKey":1,"Signature":1,"FileOutputStream":1,"String":1,"Properties":1,"MessageDigest":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":10,"BinaryExpr":8,"NameExpr":138,"StringLiteralExpr":12,"CharLiteralExpr":1,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":6,"CastExpr":2,"FieldAccessExpr":9,"MethodCallExpr":31},"statements":{"ContinueStmt":1,"IfStmt":4,"BlockStmt":7,"TryStmt":1,"ForStmt":1,"ExpressionStmt":32},"text":"/**\n     * This method creates a manifest file with the specified name, for\n     * the specified vector of files, using the named message digest\n     * algorithm.  If signername is non-null, it adds a digital signature\n     * to the manifest, using the named signature algorithm.  This method can\n     * throw a bunch of exceptions.\n     **/\npublic static void create(String manifestfile, String digestAlgorithm, String signername, String signatureAlgorithm, KeyStore keystore, String password, List filelist) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException, KeyStoreException, UnrecoverableKeyException, IOException {\n    // For computing a signature, we have to process the files in a fixed,\n    // repeatable order, so sort them alphabetically.\n    Collections.sort(filelist);\n    int numfiles = filelist.size();\n    Properties manifest = new Properties(), metadata = new Properties();\n    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n    Signature signature = null;\n    byte[] digest;\n    // If a signer name was specified, then prepare to sign the manifest\n    if (signername != null) {\n        // Get a Signature object\n        signature = Signature.getInstance(signatureAlgorithm);\n        // Look up the private key of the signer from the keystore\n        PrivateKey key = (PrivateKey) keystore.getKey(signername, password.toCharArray());\n        // No prepare to create a signature for the specified signer\n        signature.initSign(key);\n    }\n    // Now, loop through the files, in a well-known alphabetical order\n    System.out.print(\"Computing message digests\");\n    for (int i = 0; i < numfiles; i++) {\n        String filename = (String) filelist.get(i);\n        // Compute the digest for each, and skip files that don't exist.\n        try {\n            digest = getFileDigest(filename, md);\n        } catch (IOException e) {\n            System.err.println(\"\\nSkipping \" + filename + \": \" + e);\n            continue;\n        }\n        // and of the digest as part of the data to sign.\n        if (signature != null) {\n            signature.update(filename.getBytes());\n            signature.update(digest);\n        }\n        // Store the filename and the encoded digest bytes in the manifest\n        manifest.put(filename, hexEncode(digest));\n        System.out.print('.');\n        System.out.flush();\n    }\n    // If a signer was specified, compute signature for the manifest\n    byte[] signaturebytes = null;\n    if (signature != null) {\n        System.out.print(\"done\\nComputing digital signature...\");\n        System.out.flush();\n        // Compute the digital signature by encrypting a message digest of\n        // all the bytes passed to the update() method using the private\n        // key of the signer.  This is a time consuming operation.\n        signaturebytes = signature.sign();\n    }\n    // Tell the user what comes next\n    System.out.print(\"done\\nWriting manifest...\");\n    System.out.flush();\n    // Store some metadata about this manifest, including the name of the\n    // message digest algorithm it uses\n    metadata.put(\"__META.DIGESTALGORITHM\", digestAlgorithm);\n    // If we're signing the manifest, store some more metadata\n    if (signername != null) {\n        // Store the name of the signer\n        metadata.put(\"__META.SIGNER\", signername);\n        // Store the name of the algorithm\n        metadata.put(\"__META.SIGNATUREALGORITHM\", signatureAlgorithm);\n        // And generate the signature, encode it, and store it\n        metadata.put(\"__META.SIGNATURE\", hexEncode(signaturebytes));\n    }\n    // Now, save the manifest data and the metadata to the manifest file\n    FileOutputStream f = new FileOutputStream(manifestfile);\n    manifest.store(f, \"Manifest message digests\");\n    metadata.store(f, \"Manifest metadata\");\n    System.out.println(\"done\");\n}\n             // If we're computing a signature, use the bytes of the filename \n\n","name":"create","className":"Manifest","variables":{"metadata":6,"manifestfile":1,"signature":8,"e":2,"manifest":3,"f":1,"filelist":2,"i":3,"signaturebytes":2,"password":1,"filename":3,"md":1,"Signature":1,"numfiles":2,"digest":2,"keystore":1,"Collections":1,"MessageDigest":1,"signername":2,"key":1},"constants":{"'.'":1,"\"done\\nComputing digital signature...\"":1,"\"done\"":1,"\"__META.SIGNER\"":1,"\": \"":1,"\"Computing message digests\"":1,"\"done\\nWriting manifest...\"":1,"0":1,"\"__META.SIGNATURE\"":1,"\"__META.SIGNATUREALGORITHM\"":1,"\"__META.DIGESTALGORITHM\"":1,"null":6,"\"Manifest message digests\"":1,"\"\\nSkipping \"":1,"\"Manifest metadata\"":1},"javaDoc":"This method creates a manifest file with the specified name for the specified vector of files using the named message digest algorithm If signername is non-null it adds a digital signature to the manifest using the named signature algorithm This method can throw a bunch of exceptions","comments":"For computing a signature we have to process the files in a fixed Store some metadata about this manifest including the name of the repeatable order so sort them alphabetically If a signer name was specified then prepare to sign the manifest Get a Signature object Look up the private key of the signer from the keystore No prepare to create a signature for the specified signer Now loop through the files in a well-known alphabetical order If we're computing a signature use the bytes of the filename Compute the digest for each and skip files that don't exist and of the digest as part of the data to sign Store the filename and the encoded digest bytes in the manifest If a signer was specified compute signature for the manifest Compute the digital signature by encrypting a message digest of all the bytes passed to the update() method using the private key of the signer This is a time consuming operation Tell the user what comes next message digest algorithm it uses If we're signing the manifest store some more metadata Store the name of the signer Store the name of the algorithm And generate the signature encode it and store it Now save the manifest data and the metadata to the manifest file \n     * This method creates a manifest file with the specified name, for\n     * the specified vector of files, using the named message digest\n     * algorithm.  If signername is non-null, it adds a digital signature\n     * to the manifest, using the named signature algorithm.  This method can\n     * throw a bunch of exceptions.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","KeyStore"],"returnType":"void","methodCalls":{"update":2,"getBytes":1,"initVerify":1,"load":1,"getCertificate":1,"hasMoreElements":1,"get":2,"verify":1,"hexEncode":1,"System.out.print":3,"System.out.println":6,"add":1,"getProperty":6,"System.out.flush":3,"sort":1,"getPublicKey":1,"exit":1,"size":1,"propertyNames":1,"equals":1,"getInstance":2,"getFileDigest":1,"hexDecode":2,"nextElement":1,"startsWith":1},"annotations":[],"exceptions":["NoSuchAlgorithmException","SignatureException","KeyStoreException","IOException","InvalidKeyException"],"concepts":["Casting","PolyMorphism","ExceptionHandling"],"types":{"byte[]":1,"Enumeration":1,"PublicKey":1,"Signature":1,"ArrayList":1,"List":1,"String":8,"Properties":1,"MessageDigest":1,"int":3},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":18,"BinaryExpr":14,"NameExpr":177,"StringLiteralExpr":17,"CastExpr":3,"FieldAccessExpr":12,"UnaryExpr":5,"MethodCallExpr":43,"AssignExpr":1},"statements":{"ContinueStmt":1,"IfStmt":5,"WhileStmt":1,"BlockStmt":7,"TryStmt":1,"ForStmt":2,"ExpressionStmt":36},"text":"/**\n     * This method verifies the digital signature of the named manifest\n     * file, if it has one, and if that verification succeeds, it verifies\n     * the message digest of each file in filelist that is also named in the\n     * manifest.  This method can throw a bunch of exceptions\n     **/\npublic static void verify(String manifestfile, KeyStore keystore) throws NoSuchAlgorithmException, SignatureException, InvalidKeyException, KeyStoreException, IOException {\n    Properties manifest = new Properties();\n    manifest.load(new FileInputStream(manifestfile));\n    String digestAlgorithm = manifest.getProperty(\"__META.DIGESTALGORITHM\");\n    String signername = manifest.getProperty(\"__META.SIGNER\");\n    String signatureAlgorithm = manifest.getProperty(\"__META.SIGNATUREALGORITHM\");\n    String hexsignature = manifest.getProperty(\"__META.SIGNATURE\");\n    // Get a list of filenames in the manifest.  \n    List files = new ArrayList();\n    Enumeration names = manifest.propertyNames();\n    while (names.hasMoreElements()) {\n        String s = (String) names.nextElement();\n        if (!s.startsWith(\"__META\"))\n            files.add(s);\n    }\n    int numfiles = files.size();\n    // If we've got a signature but no keystore, warn the user\n    if (signername != null && keystore == null)\n        System.out.println(\"Can't verify digital signature without \" + \"a keystore.\");\n    // verify that signature first\n    if (signername != null && keystore != null) {\n        System.out.print(\"Verifying digital signature...\");\n        System.out.flush();\n        // To verify the signature, we must process the files in exactly\n        // the same order we did when we created the signature.  We\n        // guarantee this order by sorting the filenames.\n        Collections.sort(files);\n        // Create a Signature object to do signature verification with.\n        // Initialize it with the signer's public key from the keystore\n        Signature signature = Signature.getInstance(signatureAlgorithm);\n        PublicKey publickey = keystore.getCertificate(signername).getPublicKey();\n        signature.initVerify(publickey);\n        // signature.\n        for (int i = 0; i < numfiles; i++) {\n            String filename = (String) files.get(i);\n            signature.update(filename.getBytes());\n            signature.update(hexDecode(manifest.getProperty(filename)));\n        }\n        // signature is not verified, print an error message and exit.\n        if (!signature.verify(hexDecode(hexsignature))) {\n            System.out.println(\"\\nManifest has an invalid signature\");\n            System.exit(0);\n        }\n        // Tell the user we're done with this lengthy computation\n        System.out.println(\"verified.\");\n    }\n    // Tell the user we're starting the next phase of verification\n    System.out.print(\"Verifying file message digests\");\n    System.out.flush();\n    // Get a MessageDigest object to compute digests\n    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n    // Loop through all files\n    for (int i = 0; i < numfiles; i++) {\n        String filename = (String) files.get(i);\n        // Look up the encoded digest from the manifest file\n        String hexdigest = manifest.getProperty(filename);\n        // Compute the digest for the file.\n        byte[] digest;\n        try {\n            digest = getFileDigest(filename, md);\n        } catch (IOException e) {\n            System.out.println(\"\\nSkipping \" + filename + \": \" + e);\n            continue;\n        }\n        // message.\n        if (!hexdigest.equals(hexEncode(digest)))\n            System.out.println(\"\\nFile '\" + filename + \"' failed verification.\");\n        // Send one dot of output for each file we process.  Since\n        // computing message digests takes some time, this lets the user\n        // know that the program is functioning and making progress\n        System.out.print(\".\");\n        System.out.flush();\n    }\n    // And tell the user we're done with verification.\n    System.out.println(\"done.\");\n}\n         // If the manifest contained metadata about a digital signature, then\n\n             // Now loop through these files in their known sorted order For\n\n             // each one, send the bytes of the filename and of the digest to\n\n             // the signature object for use in computing the signature.  It is\n\n             // important that this be done in exactly the same order when\n\n             // verifying the signature as it was done when creating the\n\n             // Now decode the signature read from the manifest file and pass\n\n             // it to the verify() method of the signature object.  If the\n\n             // Encode the computed digest and compare it to the encoded digest\n\n             // from the manifest.  If they are not equal, print an error\n\n","name":"verify","className":"Manifest","variables":{"manifestfile":1,"signature":5,"e":2,"manifest":9,"publickey":1,"i":6,"digestAlgorithm":1,"hexsignature":1,"signatureAlgorithm":1,"System":1,"names":3,"s":2,"filename":5,"hexdigest":2,"Signature":1,"md":1,"numfiles":3,"digest":2,"files":5,"keystore":3,"signername":3,"Collections":1,"MessageDigest":1},"constants":{"\"Verifying digital signature...\"":1,"\"__META.SIGNER\"":1,"\"__META\"":1,"\"a keystore.\"":1,"\": \"":1,"\"verified.\"":1,"\"__META.SIGNATURE\"":1,"0":3,"\"\\nFile '\"":1,"\"done.\"":1,"\"Verifying file message digests\"":1,"\"__META.SIGNATUREALGORITHM\"":1,"\"__META.DIGESTALGORITHM\"":1,"null":4,"\"\\nManifest has an invalid signature\"":1,"\"Can't verify digital signature without \"":1,"\"' failed verification.\"":1,"\".\"":1,"\"\\nSkipping \"":1},"javaDoc":"This method verifies the digital signature of the named manifest file if it has one and if that verification succeeds it verifies the message digest of each file in filelist that is also named in the manifest This method can throw a bunch of exceptions","comments":"If the manifest contained metadata about a digital signature then Get a list of filenames in the manifest If we've got a signature but no keystore warn the user verify that signature first To verify the signature we must process the files in exactly the same order we did when we created the signature We Create a Signature object to do signature verification with Now loop through these files in their known sorted order For each one send the bytes of the filename and of the digest to the signature object for use in computing the signature It is important that this be done in exactly the same order when verifying the signature as it was done when creating the Now decode the signature read from the manifest file and pass it to the verify() method of the signature object If the guarantee this order by sorting the filenames Initialize it with the signer's public key from the keystore signature signature is not verified print an error message and exit Tell the user we're done with this lengthy computation Tell the user we're starting the next phase of verification Get a MessageDigest object to compute digests Loop through all files Encode the computed digest and compare it to the encoded digest from the manifest If they are not equal print an error Send one dot of output for each file we process Since computing message digests takes some time this lets the user Look up the encoded digest from the manifest file Compute the digest for the file message know that the program is functioning and making progress And tell the user we're done with verification \n     * This method verifies the digital signature of the named manifest\n     * file, if it has one, and if that verification succeeds, it verifies\n     * the message digest of each file in filelist that is also named in the\n     * manifest.  This method can throw a bunch of exceptions\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","MessageDigest"],"returnType":"byte[]","methodCalls":{"read":1,"digest":1,"reset":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"DigestInputStream":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"EmptyStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n     * This convenience method is used by both create() and verify().  It\n     * reads the contents of a named file and computes a message digest\n     * for it, using the specified MessageDigest object.\n     **/\npublic static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    // Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n    // Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    // the update() method of the MessageDigest\n    while (in.read(buffer) != -1) /* do nothing */\n    ;\n    // Finally, compute and return the digest value.\n    return md.digest();\n}\n         // Read to the end of the file, discarding everything we read.\n\n         // The DigestInputStream automatically passes all the bytes read to\n\n","name":"getFileDigest","className":"Manifest","variables":{"filename":1,"in":2,"md":3},"constants":{"1":1},"javaDoc":"This convenience method is used by both create() and verify() It reads the contents of a named file and computes a message digest for it using the specified MessageDigest object","comments":"Read to the end of the file discarding everything we read The DigestInputStream automatically passes all the bytes read to Make sure there is nothing left behind in the MessageDigest Create a stream to read from the file and compute the digest the update() method of the MessageDigest do nothing Finally compute and return the digest value \n     * This convenience method is used by both create() and verify().  It\n     * reads the contents of a named file and computes a message digest\n     * for it, using the specified MessageDigest object.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["byte[]"],"returnType":"String","methodCalls":{"toString":1,"append":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"byte":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":5,"NameExpr":23,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * A convenience method to convert an array of bytes to a String.  We do\n     * this simply by converting each byte to two hexadecimal digits.\n     * Something like Base 64 encoding is more compact, but harder to encode.\n     **/\npublic static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}\n","name":"hexEncode","className":"Manifest","variables":{"b":3,"s":4,"bytes":1,"i":4,"digits":2},"constants":{"0":1,"2":1,"4":1,"0xf0":1,"0x0f":1},"javaDoc":"A convenience method to convert an array of bytes to a String We do this simply by converting each byte to two hexadecimal digits Something like Base 64 encoding is more compact but harder to encode","comments":"\n     * A convenience method to convert an array of bytes to a String.  We do\n     * this simply by converting each byte to two hexadecimal digits.\n     * Something like Base 64 encoding is more compact, but harder to encode.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"byte[]","methodCalls":{"length":1,"charAt":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":3},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":21,"NameExpr":34,"StringLiteralExpr":1,"CharLiteralExpr":12,"UnaryExpr":1,"AssignExpr":5,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":10,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":4,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":8},"text":"/**\n     * A convenience method to convert in the other direction, from a string\n     * of hexadecimal digits to an array of bytes.\n     **/\npublic static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n        int len = s.length();\n        byte[] r = new byte[len / 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9'))\n                digit1 -= '0';\n            else if ((digit1 >= 'a') && (digit1 <= 'f'))\n                digit1 -= 'a' - 10;\n            if ((digit2 >= '0') && (digit2 <= '9'))\n                digit2 -= '0';\n            else if ((digit2 >= 'a') && (digit2 <= 'f'))\n                digit2 -= 'a' - 10;\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}\n","name":"hexDecode","className":"Manifest","variables":{"r":3,"s":3,"len":2,"e":1,"digit1":8,"i":6,"digit2":8},"constants":{"0":1,"1":1,"2":3,"4":1,"'9'":2,"\"hexDecode(): invalid input\"":1,"'f'":2,"'a'":4,"'0'":4,"10":2},"javaDoc":"A convenience method to convert in the other direction from a string of hexadecimal digits to an array of bytes","comments":"\n     * A convenience method to convert in the other direction, from a string\n     * of hexadecimal digits to an array of bytes.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"compute":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/**\n     * This method overrides the run() method of Thread.  It provides\n     * the body for this thread.\n     **/\npublic void run() {\n    for (int i = 0; i < 5; i++) compute();\n}\n","name":"run","className":"ThreadDemo","variables":{"i":3},"constants":{"0":1,"5":1},"javaDoc":"This method overrides the run() method of Thread It provides the body for this thread","comments":"\n     * This method overrides the run() method of Thread.  It provides\n     * the body for this thread.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"compute":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":4,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"public void run() {\n    for (int i = 0; i < 5; i++) compute();\n}\n","name":"run","className":"","variables":{"i":3},"constants":{"0":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"compute":2,"parseInt":2,"start":2,"setPriority":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"ThreadDemo":1,"int":2,"Thread":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":36,"FieldAccessExpr":2,"UnaryExpr":2,"MethodCallExpr":8},"statements":{"IfStmt":2,"BlockStmt":1,"ForStmt":2,"ExpressionStmt":8},"text":"/** \n     * This main method creates and starts two threads in addition to the \n     * initial thread that the interpreter creates to invoke the main() method.\n     **/\npublic static void main(String[] args) {\n    // Create the first thread: an instance of this class.  Its body is\n    // the run() method above\n    ThreadDemo thread1 = new ThreadDemo();\n    // Create the second thread by passing a Runnable object to the \n    // Thread() construtor.  The body of this thread is the run() method\n    // of the anonymous Runnable object below.\n    Thread thread2 = new Thread(new Runnable() {\n\n        public void run() {\n            for (int i = 0; i < 5; i++) compute();\n        }\n    });\n    // Set the priorities of these two threads, if any are specified\n    if (args.length >= 1)\n        thread1.setPriority(Integer.parseInt(args[0]));\n    if (args.length >= 2)\n        thread2.setPriority(Integer.parseInt(args[1]));\n    // Start the two threads running\n    thread1.start();\n    thread2.start();\n    // Java interpreter.  Now that thread does some stuff, too.\n    for (int i = 0; i < 5; i++) compute();\n// We could wait for the threads to stop running with these lines\n// But they aren't necessary here, so we don't bother.\n// try {\n//     thread1.join();\n//     thread2.join();\n// } catch (InterruptedException e) {}\n// The Java VM exits only when the main() method returns, and when all\n// threads stop running (except for daemon threads--see setDaemon()).\n}\n     // This main() method is run by the initial thread created by the\n\n","name":"main","className":"ThreadDemo","variables":{"Integer":2,"args":2,"thread1":3,"thread2":3,"i":6,"run":1},"constants":{"0":3,"1":2,"2":1,"5":2},"javaDoc":"This main method creates and starts two threads in addition to the initial thread that the interpreter creates to invoke the main() method","comments":"Create the first thread: an instance of this class Its body is Create the second thread by passing a Runnable object to the Thread() construtor The body of this thread is the run() method This main() method is run by the initial thread created by the We could wait for the threads to stop running with these lines But they aren't necessary here so we don't bother try { thread1 join(); thread2 join(); } catch (InterruptedException e) {} The Java VM exits only when the main() method returns and when all threads stop running (except for daemon threads--see setDaemon()) the run() method above of the anonymous Runnable object below Set the priorities of these two threads if any are specified Start the two threads running Java interpreter Now that thread does some stuff too  \n     * This main method creates and starts two threads in addition to the \n     * initial thread that the interpreter creates to invoke the main() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"random":1,"currentThread":1,"set":1,"getName":1,"intValue":1,"get":1,"yield":1,"System.out.println":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"Integer":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":7,"VariableDeclarationExpr":2,"BinaryExpr":7,"NameExpr":37,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":8},"text":"/** This is the dummy method our threads all call */\nstatic synchronized void compute() {\n    // Figure out how many times we've been called by the current thread\n    Integer n = (Integer) numcalls.get();\n    if (n == null)\n        n = new Integer(1);\n    else\n        n = new Integer(n.intValue() + 1);\n    numcalls.set(n);\n    // Display the name of the thread, and the number of times called\n    System.out.println(Thread.currentThread().getName() + \": \" + n);\n    // Do a long computation, simulating a \"compute-bound\" thread\n    for (int i = 0, j = 0; i < 1000000; i++) j += i;\n    // delays by causing it to sleep for a random amount of time:\n    try {\n        // Stop running for a random number of milliseconds\n        Thread.sleep((int) (Math.random() * 100 + 1));\n    } catch (InterruptedException e) {\n    }\n    // Each thread politely offers the other threads a chance to run.\n    // This is important so that a compute-bound thread does not \"starve\"\n    // other threads of equal priority.\n    Thread.yield();\n}\n     // Alternatively, we can simulate a thread subject to network or I/O\n\n","name":"compute","className":"ThreadDemo","variables":{"numcalls":2,"e":1,"i":4,"j":2,"Math":1,"n":6,"Thread":3},"constants":{"0":2,"1":3,"100":1,"null":1,"1000000":1,"\": \"":1},"javaDoc":"This is the dummy method our threads all call","comments":"Alternatively we can simulate a thread subject to network or I/O Each thread politely offers the other threads a chance to run This is important so that a compute-bound thread does not \"starve\" Figure out how many times we've been called by the current thread Display the name of the thread and the number of times called Do a long computation simulating a \"compute-bound\" thread delays by causing it to sleep for a random amount of time: Stop running for a random number of milliseconds other threads of equal priority  This is the dummy method our threads all call ","isEmpty":false,"hasInnerClass":false,"modifier":40}
{"paramTypes":[],"returnType":"Timer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** This constructor create a Timer that does not use a daemon thread */\npublic Timer() {\n    this(false);\n}\n","name":"Timer","className":"Timer","variables":{},"constants":{"false":1},"javaDoc":"This constructor create a Timer that does not use a daemon thread","comments":" This constructor create a Timer that does not use a daemon thread ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"Timer","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":5,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** The main constructor: the internal thread is a daemon if specified */\npublic Timer(boolean isDaemon) {\n    // TimerThread is defined below\n    timer = new TimerThread(isDaemon);\n    // Start the thread running\n    timer.start();\n}\n","name":"Timer","className":"Timer","variables":{"timer":2,"isDaemon":1},"constants":{},"javaDoc":"The main constructor: the internal thread is a daemon if specified","comments":"TimerThread is defined below Start the thread running  The main constructor: the internal thread is a daemon if specified ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"clear":1,"pleaseStop":1,"notify":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":3},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":3},"text":"/** Stop the timer thread, and discard all scheduled tasks */\npublic void cancel() {\n    synchronized (tasks) {\n        // Only one thread at a time!\n        // Set a flag asking the thread to stop\n        timer.pleaseStop();\n        // Discard all tasks\n        tasks.clear();\n        // Wake up the thread if it is in wait().\n        tasks.notify();\n    }\n}\n","name":"cancel","className":"Timer","variables":{"timer":1,"tasks":3},"constants":{},"javaDoc":"Stop the timer thread and discard all scheduled tasks","comments":"Only one thread at a time! Set a flag asking the thread to stop Discard all tasks Wake up the thread if it is in wait()  Stop the timer thread, and discard all scheduled tasks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","long"],"returnType":"void","methodCalls":{"schedule":2,"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Schedule a single execution after delay milliseconds */\npublic void schedule(TimerTask task, long delay) {\n    task.schedule(System.currentTimeMillis() + delay, 0, false);\n    schedule(task);\n}\n","name":"schedule","className":"Timer","variables":{"task":1,"delay":1,"System":1},"constants":{"0":1,"false":1},"javaDoc":"Schedule a single execution after delay milliseconds","comments":" Schedule a single execution after delay milliseconds ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","Date"],"returnType":"void","methodCalls":{"schedule":2,"getTime":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Schedule a single execution at the specified time */\npublic void schedule(TimerTask task, Date time) {\n    task.schedule(time.getTime(), 0, false);\n    schedule(task);\n}\n","name":"schedule","className":"Timer","variables":{"task":1,"time":1},"constants":{"0":1,"false":1},"javaDoc":"Schedule a single execution at the specified time","comments":" Schedule a single execution at the specified time ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","Date","long"],"returnType":"void","methodCalls":{"schedule":2,"getTime":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Schedule a periodic execution starting at the specified time */\npublic void schedule(TimerTask task, Date firstTime, long period) {\n    task.schedule(firstTime.getTime(), period, false);\n    schedule(task);\n}\n","name":"schedule","className":"Timer","variables":{"firstTime":1,"task":1},"constants":{"false":1},"javaDoc":"Schedule a periodic execution starting at the specified time","comments":" Schedule a periodic execution starting at the specified time ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","long","long"],"returnType":"void","methodCalls":{"schedule":2,"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Schedule a periodic execution starting after the specified delay */\npublic void schedule(TimerTask task, long delay, long period) {\n    task.schedule(System.currentTimeMillis() + delay, period, false);\n    schedule(task);\n}\n","name":"schedule","className":"Timer","variables":{"task":1,"delay":1,"System":1},"constants":{"false":1},"javaDoc":"Schedule a periodic execution starting after the specified delay","comments":" Schedule a periodic execution starting after the specified delay ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","long","long"],"returnType":"void","methodCalls":{"schedule":2,"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":11,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** \n     * Schedule a periodic execution starting after the specified delay.\n     * Schedule fixed-rate executions period ms after the start of the last.\n     * Instead of fixed-interval executions measured from the end of the last.\n     **/\npublic void scheduleAtFixedRate(TimerTask task, long delay, long period) {\n    task.schedule(System.currentTimeMillis() + delay, period, true);\n    schedule(task);\n}\n","name":"scheduleAtFixedRate","className":"Timer","variables":{"task":1,"delay":1,"System":1},"constants":{"true":1},"javaDoc":"Schedule a periodic execution starting after the specified delay Schedule fixed-rate executions period ms after the start of the last Instead of fixed-interval executions measured from the end of the last","comments":" \n     * Schedule a periodic execution starting after the specified delay.\n     * Schedule fixed-rate executions period ms after the start of the last.\n     * Instead of fixed-interval executions measured from the end of the last.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask","Date","long"],"returnType":"void","methodCalls":{"schedule":2,"getTime":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":10,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Schedule a periodic execution starting after the specified time */\npublic void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) {\n    task.schedule(firstTime.getTime(), period, true);\n    schedule(task);\n}\n","name":"scheduleAtFixedRate","className":"Timer","variables":{"firstTime":1,"task":1},"constants":{"true":1},"javaDoc":"Schedule a periodic execution starting after the specified time","comments":" Schedule a periodic execution starting after the specified time ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TimerTask"],"returnType":"void","methodCalls":{"add":1,"notify":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":2},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":2},"text":"// This internal method adds a task to the sorted set of tasks\nvoid schedule(TimerTask task) {\n    synchronized (tasks) {\n        // Only one thread can modify tasks at a time!\n        // Add the task to the sorted set of tasks\n        tasks.add(task);\n        // Wake up the thread if it is waiting\n        tasks.notify();\n    }\n}\n","name":"schedule","className":"Timer","variables":{"tasks":3},"constants":{},"javaDoc":"","comments":"Only one thread can modify tasks at a time! Add the task to the sorted set of tasks Wake up the thread if it is waiting  This internal method adds a task to the sorted set of tasks","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"TimerTask":2,"long":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":3,"BinaryExpr":3,"CastExpr":2,"NameExpr":10,"FieldAccessExpr":2,"UnaryExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3,"ExpressionStmt":3},"text":"public int compare(Object a, Object b) {\n    TimerTask t1 = (TimerTask) a;\n    TimerTask t2 = (TimerTask) b;\n    long diff = t1.nextTime - t2.nextTime;\n    if (diff < 0)\n        return -1;\n    else if (diff > 0)\n        return 1;\n    else\n        return 0;\n}\n","name":"compare","className":"TimerTaskComparator","variables":{"a":1,"b":1,"diff":3,"t1":1,"t2":1},"constants":{"0":3,"1":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean equals(Object o) {\n    return this == o;\n}\n","name":"equals","className":"TimerTaskComparator","variables":{"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"TimerThread","methodCalls":{"setDaemon":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// The constructor\npublic TimerThread(boolean isDaemon) {\n    setDaemon(isDaemon);\n}\n","name":"TimerThread","className":"TimerThread","variables":{},"constants":{},"javaDoc":"","comments":" The constructor","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Ask the thread to stop by setting the flag above\npublic void pleaseStop() {\n    stopped = true;\n}\n","name":"pleaseStop","className":"TimerThread","variables":{"stopped":1},"constants":{"true":1},"javaDoc":"","comments":" Ask the thread to stop by setting the flag above","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"reschedule":1,"schedule":1,"wait":1,"currentTimeMillis":1,"isEmpty":1,"run":1,"first":1,"remove":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"TimerTask":2,"long":1},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":42,"CastExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"AssignExpr":5,"MethodCallExpr":8},"statements":{"ContinueStmt":3,"IfStmt":5,"WhileStmt":1,"BlockStmt":9,"TryStmt":1,"SynchronizedStmt":1,"ExpressionStmt":12},"text":"// This is the body of the thread\npublic void run() {\n    // Is there a task to run right now?\n    TimerTask readyToRun = null;\n    // The thread loops until the stopped flag is set to true.\n    while (!stopped) {\n        // If there is a task that is ready to run, then run it!\n        if (readyToRun != null) {\n            if (readyToRun.cancelled) {\n                // If it was cancelled, skip.\n                readyToRun = null;\n                continue;\n            }\n            // Run the task.\n            readyToRun.run();\n            // again, then insert it back into the set of tasks.\n            if (readyToRun.reschedule())\n                schedule(readyToRun);\n            // We've run it, so there is nothing to run now\n            readyToRun = null;\n            // Go back to top of the loop to see if we've been stopped\n            continue;\n        }\n        // Now acquire a lock on the set of tasks\n        synchronized (tasks) {\n            // how many ms 'till the next execution?\n            long timeout;\n            if (tasks.isEmpty()) {\n                // If there aren't any tasks\n                // Wait 'till notified of a new task\n                timeout = 0;\n            } else {\n                // If there are scheduled tasks, then get the first one\n                // Since the set is sorted, this is the next one.\n                TimerTask t = (TimerTask) tasks.first();\n                // How long 'till it is next run?\n                timeout = t.nextTime - System.currentTimeMillis();\n                // Check whether it needs to run now\n                if (timeout <= 0) {\n                    // Save it as ready to run\n                    readyToRun = t;\n                    // Remove it from the set\n                    tasks.remove(t);\n                    // we run the task\n                    continue;\n                }\n            }\n            // called when something new is added to the set of tasks.\n            try {\n                tasks.wait(timeout);\n            } catch (InterruptedException e) {\n            }\n        // When we wake up, go back up to the top of the while loop\n        }\n    }\n}\n             // Ask it to reschedule itself, and if it wants to run \n\n             // If we get here, there is nothing ready to run now,\n\n             // so wait for time to run out, or wait 'till notify() is\n\n                 // Break out of the synchronized section before\n\n","name":"run","className":"TimerThread","variables":{"stopped":1,"t":2,"e":1,"readyToRun":7,"tasks":5,"timeout":4,"System":1},"constants":{"0":2,"null":4},"javaDoc":"","comments":"Is there a task to run right now? The thread loops until the stopped flag is set to true If there is a task that is ready to run then run it! Ask it to reschedule itself and if it wants to run If it was cancelled skip Run the task again then insert it back into the set of tasks We've run it so there is nothing to run now Go back to top of the loop to see if we've been stopped Now acquire a lock on the set of tasks If we get here there is nothing ready to run now so wait for time to run out or wait 'till notify() is When we wake up go back up to the top of the while loop how many ms 'till the next execution? If there aren't any tasks Wait 'till notified of a new task If there are scheduled tasks then get the first one Since the set is sorted this is the next one How long 'till it is next run? Check whether it needs to run now Break out of the synchronized section before Save it as ready to run Remove it from the set we run the task called when something new is added to the set of tasks  This is the body of the thread","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    System.out.println(\"boom\");\n}\n","name":"run","className":"","variables":{},"constants":{"\"boom\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void run() {\n    System.out.println(\"\\tBOOM\");\n}\n","name":"run","className":"","variables":{},"constants":{"\"\\tBOOM\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"cancel":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void run() {\n    t1.cancel();\n    t2.cancel();\n}\n","name":"run","className":"","variables":{"t1":1,"t2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"cancel":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":10,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void run() {\n    System.out.println(times--);\n    if (times == 0)\n        timer.cancel();\n}\n","name":"run","className":"","variables":{"timer":1,"times":2},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"cancel":3,"scheduleAtFixedRate":1,"schedule":3,"System.out.println":3},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables","PolyMorphism"],"types":{"TimerTask":6,"Timer":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":9,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":49,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":4,"ExpressionStmt":14},"text":"public static void main(String[] args) {\n    final TimerTask t1 = new // Task 1: print \"boom\"\n    TimerTask() {\n\n        public void run() {\n            System.out.println(\"boom\");\n        }\n    };\n    final TimerTask t2 = new // Task 2: print \"BOOM\"\n    TimerTask() {\n\n        public void run() {\n            System.out.println(\"\\tBOOM\");\n        }\n    };\n    final TimerTask t3 = new // Task 3: cancel the tasks\n    TimerTask() {\n\n        public void run() {\n            t1.cancel();\n            t2.cancel();\n        }\n    };\n    // Create a timer, and schedule some tasks\n    final Timer timer = new Timer();\n    // boom every .5sec starting now\n    timer.schedule(t1, 0, 500);\n    // BOOM every 2s, starting in 2s\n    timer.schedule(t2, 2000, 2000);\n    // Stop them after 5 seconds\n    timer.schedule(t3, 5000);\n    // Schedule a final task: starting in 5 seconds, count\n    // down from 5, then destroy the timer, which, since it is\n    // the only remaining thread, will cause the program to exit.\n    timer.scheduleAtFixedRate(new TimerTask() {\n\n        public int times = 5;\n\n        public void run() {\n            System.out.println(times--);\n            if (times == 0)\n                timer.cancel();\n        }\n    }, 5000, 500);\n}\n","name":"main","className":"Test","variables":{"timer":6,"times":3,"run":4,"t1":2,"t2":2,"t3":1},"constants":{"0":2,"\"\\tBOOM\"":1,"5000":2,"500":2,"5":1,"\"boom\"":1,"2000":2},"javaDoc":"","comments":"Schedule a final task: starting in 5 seconds count down from 5 then destroy the timer which since it is Task 1: print \"boom\" Task 2: print \"BOOM\" Task 3: cancel the tasks Create a timer and schedule some tasks boom every 5sec starting now BOOM every 2s starting in 2s Stop them after 5 seconds the only remaining thread will cause the program to exit ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":2,"ExpressionStmt":3},"text":"public void run() {\n    // Lock resource 1\n    synchronized (resource1) {\n        System.out.println(\"Thread 1: locked resource 1\");\n        // deadlock to happen here...\n        try {\n            Thread.sleep(50);\n        } catch (InterruptedException e) {\n        }\n        // Now wait 'till we can get a lock on resource 2\n        synchronized (resource2) {\n            System.out.println(\"Thread 1: locked resource 2\");\n        }\n    }\n}\n             // Pause for a bit, simulating some file I/O or\n\n             // something.  Basically, we just want to give the\n\n             // other thread a chance to run.  Threads and deadlock\n\n             // are asynchronous things, but we're trying to force\n\n","name":"run","className":"","variables":{"e":1,"resource2":1,"resource1":1,"Thread":1},"constants":{"\"Thread 1: locked resource 2\"":1,"50":1,"\"Thread 1: locked resource 1\"":1},"javaDoc":"","comments":"Lock resource 1 Pause for a bit simulating some file I/O or something Basically we just want to give the other thread a chance to run Threads and deadlock are asynchronous things but we're trying to force deadlock to happen here Now wait 'till we can get a lock on resource 2 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"System.out.println":2},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling","Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":2,"ExpressionStmt":3},"text":"public void run() {\n    // This thread locks resource 2 right away\n    synchronized (resource2) {\n        System.out.println(\"Thread 2: locked resource 2\");\n        // Then it pauses, just like the first thread.\n        try {\n            Thread.sleep(50);\n        } catch (InterruptedException e) {\n        }\n        // thread can run, and the program freezes up.\n        synchronized (resource1) {\n            System.out.println(\"Thread 2: locked resource 1\");\n        }\n    }\n}\n             // Then it tries to lock resource1.  But wait!  Thread\n\n             // 1 locked resource1, and won't release it 'till it\n\n             // gets a lock on resource2.  This thread holds the\n\n             // lock on resource2, and won't release it 'till it\n\n             // gets resource1.  We're at an impasse. Neither\n\n","name":"run","className":"","variables":{"e":1,"resource2":1,"Thread":1,"resource1":1},"constants":{"\"Thread 2: locked resource 1\"":1,"\"Thread 2: locked resource 2\"":1,"50":1},"javaDoc":"","comments":"This thread locks resource 2 right away Then it tries to lock resource1 But wait! Thread 1 locked resource1 and won't release it 'till it gets a lock on resource2 This thread holds the lock on resource2 and won't release it 'till it gets resource1 We're at an impasse Neither Then it pauses just like the first thread thread can run and the program freezes up ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"sleep":2,"start":2,"System.out.println":4},"annotations":[],"exceptions":["InterruptedException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling","Synchronization"],"types":{"Object":2,"Thread":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"StringLiteralExpr":6,"NameExpr":40,"FieldAccessExpr":4,"MethodCallExpr":8},"statements":{"BlockStmt":10,"TryStmt":2,"SynchronizedStmt":4,"ExpressionStmt":12},"text":"public static void main(String[] args) {\n    // These are the two resource objects we'll try to get locks for\n    final Object resource1 = \"resource1\";\n    final Object resource2 = \"resource2\";\n    // Here's the first thread.  It tries to lock resource1 then resource2\n    Thread t1 = new Thread() {\n\n        public void run() {\n            // Lock resource 1\n            synchronized (resource1) {\n                System.out.println(\"Thread 1: locked resource 1\");\n                // deadlock to happen here...\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                }\n                // Now wait 'till we can get a lock on resource 2\n                synchronized (resource2) {\n                    System.out.println(\"Thread 1: locked resource 2\");\n                }\n            }\n        }\n    };\n    // Here's the second thread.  It tries to lock resource2 then resource1\n    Thread t2 = new Thread() {\n\n        public void run() {\n            // This thread locks resource 2 right away\n            synchronized (resource2) {\n                System.out.println(\"Thread 2: locked resource 2\");\n                // Then it pauses, just like the first thread.\n             // Pause for a bit, simulating some file I/O or\n\n             // something.  Basically, we just want to give the\n\n             // other thread a chance to run.  Threads and deadlock\n\n             // are asynchronous things, but we're trying to force\n\n                try {\n                    Thread.sleep(50);\n                } catch (InterruptedException e) {\n                }\n                // thread can run, and the program freezes up.\n                synchronized (resource1) {\n                    System.out.println(\"Thread 2: locked resource 1\");\n                }\n            }\n        }\n    };\n    // Start the two threads. If all goes as planned, deadlock will occur, \n    // and the program will never exit.\n    t1.start();\n    t2.start();\n}\n             // Then it tries to lock resource1.  But wait!  Thread\n\n             // 1 locked resource1, and won't release it 'till it\n\n             // gets a lock on resource2.  This thread holds the\n\n             // lock on resource2, and won't release it 'till it\n\n             // gets resource1.  We're at an impasse. Neither\n\n","name":"main","className":"Deadlock","variables":{"e":2,"resource2":3,"run":2,"t1":2,"t2":2,"resource1":3,"Thread":2},"constants":{"\"Thread 1: locked resource 2\"":1,"\"Thread 2: locked resource 1\"":1,"\"Thread 2: locked resource 2\"":1,"\"resource2\"":1,"\"resource1\"":1,"50":2,"\"Thread 1: locked resource 1\"":1},"javaDoc":"","comments":"Start the two threads If all goes as planned deadlock will occur These are the two resource objects we'll try to get locks for Here's the first thread It tries to lock resource1 then resource2 Lock resource 1 Pause for a bit simulating some file I/O or something Basically we just want to give the other thread a chance to run Threads and deadlock are asynchronous things but we're trying to force deadlock to happen here Now wait 'till we can get a lock on resource 2 Here's the second thread It tries to lock resource2 then resource1 This thread locks resource 2 right away Then it tries to lock resource1 But wait! Thread 1 locked resource1 and won't release it 'till it gets a lock on resource2 This thread holds the lock on resource2 and won't release it 'till it gets resource1 We're at an impasse Neither Then it pauses just like the first thread thread can run and the program freezes up and the program will never exit ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"TimerTask","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"protected TimerTask() {\n}\n","name":"TimerTask","className":"TimerTask","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BooleanLiteralExpr":4,"BinaryExpr":1,"NameExpr":3,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"ReturnStmt":3,"ExpressionStmt":1},"text":"/**\n     * Cancel the execution of the task.  Return true if it was actually\n     * running, or false if it was already cancelled or never scheduled.\n     **/\npublic boolean cancel() {\n    // Already cancelled;\n    if (cancelled)\n        return false;\n    // Cancel it\n    cancelled = true;\n    // Never scheduled;\n    if (nextTime == -1)\n        return false;\n    return true;\n}\n","name":"cancel","className":"TimerTask","variables":{"nextTime":1,"cancelled":2},"constants":{"1":1,"false":2,"true":2},"javaDoc":"Cancel the execution of the task Return true if it was actually running or false if it was already cancelled or never scheduled","comments":"Already cancelled; Cancel it Never scheduled; \n     * Cancel the execution of the task.  Return true if it was actually\n     * running, or false if it was already cancelled or never scheduled.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * When it the timer scheduled to execute? The run() method can use this\n     * to see whether it was invoked when it was supposed to be \n     **/\npublic long scheduledExecutionTime() {\n    return nextTime;\n}\n","name":"scheduledExecutionTime","className":"TimerTask","variables":{"nextTime":1},"constants":{},"javaDoc":"When it the timer scheduled to execute? The run() method can use this to see whether it was invoked when it was supposed to be","comments":"\n     * When it the timer scheduled to execute? The run() method can use this\n     * to see whether it was invoked when it was supposed to be \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Abstract"],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Subclasses must override this to provide that code that is to be run.\n     * The Timer class will invoke this from its internal thread.\n     **/\npublic abstract void run();\n","name":"run","className":"TimerTask","variables":{},"constants":{},"javaDoc":"Subclasses must override this to provide that code that is to be run The Timer class will invoke this from its internal thread","comments":"\n     * Subclasses must override this to provide that code that is to be run.\n     * The Timer class will invoke this from its internal thread.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1025}
{"paramTypes":["long","long","boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"// This method is used by Timer to tell the Task how it is scheduled.\nvoid schedule(long nextTime, long period, boolean fixedRate) {\n    this.nextTime = nextTime;\n    this.period = period;\n    this.fixedRate = fixedRate;\n}\n","name":"schedule","className":"TimerTask","variables":{"period":1,"nextTime":1,"fixedRate":1},"constants":{},"javaDoc":"","comments":" This method is used by Timer to tell the Task how it is scheduled.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"boolean","methodCalls":{"currentTimeMillis":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":10,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"// This will be called by Timer after Timer calls the run method.\nboolean reschedule() {\n    // Don't run it again\n    if (period == 0 || cancelled)\n        return false;\n    if (fixedRate)\n        nextTime += period;\n    else\n        nextTime = System.currentTimeMillis() + period;\n    return true;\n}\n","name":"reschedule","className":"TimerTask","variables":{"period":3,"nextTime":2,"fixedRate":1,"cancelled":1,"System":1},"constants":{"0":1,"false":1,"true":1},"javaDoc":"","comments":"Don't run it again  This will be called by Timer after Timer calls the run method.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["PrintWriter","Thread","String"],"returnType":"void","methodCalls":{"isAlive":1,"println":1,"getName":1,"isDaemon":1,"getPriority":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":7,"NameExpr":17,"StringLiteralExpr":6,"EnclosedExpr":2,"ConditionalExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Display information about a thread. */\nprivate static void printThreadInfo(PrintWriter out, Thread t, String indent) {\n    if (t == null)\n        return;\n    out.println(indent + \"Thread: \" + t.getName() + \"  Priority: \" + t.getPriority() + (t.isDaemon() ? \" Daemon\" : \"\") + (t.isAlive() ? \"\" : \" Not Alive\"));\n}\n","name":"printThreadInfo","className":"ThreadLister","variables":{"t":5,"indent":1,"out":1},"constants":{"\"\"":2,"null":1,"\"Thread: \"":1,"\" Not Alive\"":1,"\" Daemon\"":1,"\"  Priority: \"":1},"javaDoc":"Display information about a thread","comments":" Display information about a thread. ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["PrintWriter","ThreadGroup","String"],"returnType":"void","methodCalls":{"activeCount":1,"println":1,"printGroupInfo":1,"getName":1,"getMaxPriority":1,"printThreadInfo":1,"isDaemon":1,"activeGroupCount":1,"enumerate":2},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"ThreadGroup[]":1,"Thread[]":1,"int":4},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":6,"ArrayAccessExpr":2,"BinaryExpr":10,"NameExpr":48,"StringLiteralExpr":6,"ConditionalExpr":1,"UnaryExpr":2,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":2,"MethodCallExpr":10},"statements":{"IfStmt":1,"ReturnStmt":1,"ForStmt":2,"ExpressionStmt":9},"text":"/** Display info about a thread group and its threads and groups */\nprivate static void printGroupInfo(PrintWriter out, ThreadGroup g, String indent) {\n    if (g == null)\n        return;\n    int num_threads = g.activeCount();\n    int num_groups = g.activeGroupCount();\n    Thread[] threads = new Thread[num_threads];\n    ThreadGroup[] groups = new ThreadGroup[num_groups];\n    g.enumerate(threads, false);\n    g.enumerate(groups, false);\n    out.println(indent + \"Thread Group: \" + g.getName() + \"  Max Priority: \" + g.getMaxPriority() + (g.isDaemon() ? \" Daemon\" : \"\"));\n    for (int i = 0; i < num_threads; i++) printThreadInfo(out, threads[i], indent + \"    \");\n    for (int i = 0; i < num_groups; i++) printGroupInfo(out, groups[i], indent + \"    \");\n}\n","name":"printGroupInfo","className":"ThreadLister","variables":{"indent":3,"g":8,"num_threads":3,"threads":2,"groups":2,"i":8,"num_groups":3,"out":1},"constants":{"\"\"":1,"0":2,"null":1,"\"Thread Group: \"":1,"\"    \"":2,"\"  Max Priority: \"":1,"false":2,"\" Daemon\"":1},"javaDoc":"Display info about a thread group and its threads and groups","comments":" Display info about a thread group and its threads and groups ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"currentThread":1,"getParent":2,"printGroupInfo":1,"getThreadGroup":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ThreadGroup":3},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":1,"AssignExpr":5,"MethodCallExpr":5},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":9},"text":"/** Find the root thread group and list it recursively */\npublic static void listAllThreads(PrintWriter out) {\n    ThreadGroup current_thread_group;\n    ThreadGroup root_thread_group;\n    ThreadGroup parent;\n    // Get the current thread group\n    current_thread_group = Thread.currentThread().getThreadGroup();\n    // Now go find the root thread group\n    root_thread_group = current_thread_group;\n    parent = root_thread_group.getParent();\n    while (parent != null) {\n        root_thread_group = parent;\n        parent = parent.getParent();\n    }\n    // And list it, recursively\n    printGroupInfo(out, root_thread_group, \"\");\n}\n","name":"listAllThreads","className":"ThreadLister","variables":{"parent":6,"root_thread_group":4,"current_thread_group":3,"Thread":1},"constants":{"\"\"":1,"null":1},"javaDoc":"Find the root thread group and list it recursively","comments":"Get the current thread group Now go find the root thread group And list it recursively  Find the root thread group and list it recursively ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1,"toString":1,"close":1,"listAllThreads":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JTextArea":1,"StringWriter":1,"JFrame":1,"String":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":30,"FieldAccessExpr":1,"MethodCallExpr":8},"statements":{"ExpressionStmt":11},"text":"/**\n     * The main() method create a simple graphical user interface to display\n     * the threads in.  This allows us to see the \"event dispatch thread\" used\n     * by AWT and Swing.\n     **/\npublic static void main(String[] args) {\n    // Create a simple Swing GUI\n    JFrame frame = new JFrame(\"ThreadLister Demo\");\n    JTextArea textarea = new JTextArea();\n    frame.getContentPane().add(new JScrollPane(textarea), BorderLayout.CENTER);\n    frame.setSize(500, 400);\n    frame.setVisible(true);\n    // Get the threadlisting as a string using a StringWriter stream\n    // To capture the listing \n    StringWriter sout = new StringWriter();\n    PrintWriter out = new PrintWriter(sout);\n    // List threads to stream\n    ThreadLister.listAllThreads(out);\n    out.close();\n    // Get listing as a string\n    String threadListing = sout.toString();\n    // Finally, display the thread listing in the GUI\n    textarea.setText(threadListing);\n}\n","name":"main","className":"ThreadLister","variables":{"ThreadLister":1,"textarea":3,"threadListing":1,"sout":3,"frame":4,"out":2},"constants":{"400":1,"500":1,"true":1,"\"ThreadLister Demo\"":1},"javaDoc":"The main() method create a simple graphical user interface to display the threads in This allows us to see the \"event dispatch thread\" used by AWT and Swing","comments":"Get the threadlisting as a string using a StringWriter stream Create a simple Swing GUI To capture the listing List threads to stream Get listing as a string Finally display the thread listing in the GUI \n     * The main() method create a simple graphical user interface to display\n     * the threads in.  This allows us to see the \"event dispatch thread\" used\n     * by AWT and Swing.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"println":3,"print":1,"read":1,"flush":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":2,"char[]":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":31,"StringLiteralExpr":1,"CharLiteralExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":8},"text":"public void run() {\n    char[] buffer = new char[1024];\n    int chars_read;\n    try {\n        // Read characters until the stream closes\n        while ((chars_read = from_server.read(buffer)) != -1) {\n            // faster than the network is, which is good enough\n            for (int i = 0; i < chars_read; i++) {\n                if (buffer[i] == '\\n')\n                    to_user.println();\n                else\n                    to_user.print(buffer[i]);\n            }\n            to_user.flush();\n        }\n    } catch (IOException e) {\n        to_user.println(e);\n    }\n    // When the server closes the connection, the loop above\n    // will end.  Tell the user what happened, and call\n    // System.exit(), causing the main thread to exit along\n    // with this one.\n    to_user.println(\"Connection closed by server.\");\n    System.exit(0);\n}\n                 // Loop through the array of characters, and \n\n                 // print them out, converting all \\n characters\n\n                 // to the local platform's line terminator.\n\n                 // This could be more efficient, but it is probably\n\n","name":"run","className":"","variables":{"chars_read":3,"to_user":5,"e":1,"i":5,"from_server":1,"buffer":3,"System":1},"constants":{"0":2,"1":1,"1024":1,"'\\n'":1,"\"Connection closed by server.\"":1},"javaDoc":"","comments":"When the server closes the connection the loop above will end Tell the user what happened and call System exit() causing the main thread to exit along Read characters until the stream closes Loop through the array of characters and print them out converting all \\n characters to the local platform's line terminator This could be more efficient but it is probably faster than the network is which is good enough with this one ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getInetAddress":1,"currentThread":1,"read":1,"start":1,"readLine":1,"getInputStream":1,"parseInt":1,"exit":2,"println":5,"print":2,"getPort":1,"flush":2,"getPriority":1,"getOutputStream":1,"System.err.println":2,"setPriority":1,"close":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException","Exception"],"concepts":["InnerMethod","FinalVariables","PolyMorphism","ExceptionHandling"],"types":{"InputStreamReader":1,"BufferedReader":1,"Reader":1,"String":2,"int":3,"Socket":1,"PrintWriter":2,"Thread":1,"char[]":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":8,"VariableDeclarationExpr":12,"ArrayAccessExpr":4,"BinaryExpr":10,"NameExpr":106,"StringLiteralExpr":7,"CharLiteralExpr":1,"UnaryExpr":2,"AssignExpr":2,"NullLiteralExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":25},"statements":{"IfStmt":2,"WhileStmt":2,"TryStmt":2,"BlockStmt":8,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":27},"text":"public static void main(String[] args) throws IOException {\n    try {\n        // Check the number of arguments\n        if (args.length != 2)\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Parse the host and port specifications\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        // Connect to the specified host and port\n        Socket s = new Socket(host, port);\n        // Set up streams for reading from and writing to the server.\n        // The from_server stream is final for use in the inner class below\n        final Reader from_server = new InputStreamReader(s.getInputStream());\n        PrintWriter to_server = new PrintWriter(s.getOutputStream());\n        // Set up streams for reading from and writing to the console\n        // The to_user stream is final for use in the anonymous class below\n        BufferedReader from_user = new BufferedReader(new InputStreamReader(System.in));\n        // Pass true for auto-flush on println()\n        final PrintWriter to_user = new PrintWriter(System.out, true);\n        // Tell the user that we've connected\n        to_user.println(\"Connected to \" + s.getInetAddress() + \":\" + s.getPort());\n        // Create a thread that gets output from the server and displays \n        // it to the user.  We use a separate thread for this so that we\n        // can receive asynchronous output\n        Thread t = new Thread() {\n\n            public void run() {\n                char[] buffer = new char[1024];\n                int chars_read;\n                try {\n                    // Read characters until the stream closes\n                    while ((chars_read = from_server.read(buffer)) != -1) {\n                        // faster than the network is, which is good enough\n                        for (int i = 0; i < chars_read; i++) {\n                            if (buffer[i] == '\\n')\n                                to_user.println();\n                            else\n                                to_user.print(buffer[i]);\n                        }\n                        to_user.flush();\n                    }\n                } catch (IOException e) {\n                    to_user.println(e);\n                }\n                // When the server closes the connection, the loop above\n                // will end.  Tell the user what happened, and call\n                // System.exit(), causing the main thread to exit along\n                // with this one.\n                to_user.println(\"Connection closed by server.\");\n                System.exit(0);\n            }\n        };\n        // We set the priority of the server-to-user thread above to be\n        // one level higher than the main thread.  We shouldn't have to do\n        // this, but on some operating systems, output sent to the console\n        // doesn't appear when a thread at the same priority level is\n        // blocked waiting for input from the console.\n        t.setPriority(Thread.currentThread().getPriority() + 1);\n        // Now start the server-to-user thread\n                 // Loop through the array of characters, and \n\n                 // print them out, converting all \\n characters\n\n                 // to the local platform's line terminator.\n\n                 // This could be more efficient, but it is probably\n\n        t.start();\n        // In parallel, read the user's input and pass it on to the server.\n        String line;\n        while ((line = from_user.readLine()) != null) {\n            to_server.print(line + \"\\n\");\n            to_server.flush();\n        }\n        // If the user types a Ctrl-D (Unix) or Ctrl-Z (Windows) to end\n        // their input, we'll get an EOF, and the loop above will exit.\n        // When this happens, we stop the server-to-user thread and close\n        // the socket.\n        s.close();\n        to_user.println(\"Connection closed by client.\");\n        System.exit(0);\n    }// If anything goes wrong, print an error message\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GenericClient <hostname> <port>\");\n    }\n}\n","name":"main","className":"GenericClient","variables":{"to_user":8,"chars_read":3,"e":2,"line":3,"i":5,"from_server":2,"run":1,"System":2,"from_user":2,"Thread":1,"args":2,"Integer":1,"to_server":3,"s":6,"t":3,"port":2,"host":2,"buffer":3},"constants":{"\"Connection closed by client.\"":1,"\":\"":1,"\"Connection closed by server.\"":1,"\"Usage: java GenericClient <hostname> <port>\"":1,"0":4,"1":3,"2":1,"\"Connected to \"":1,"null":1,"1024":1,"true":1,"\"Wrong number of args\"":1,"'\\n'":1,"\"\\n\"":1},"javaDoc":"","comments":"Set up streams for reading from and writing to the server Set up streams for reading from and writing to the console Create a thread that gets output from the server and displays it to the user We use a separate thread for this so that we We set the priority of the server-to-user thread above to be one level higher than the main thread We shouldn't have to do this but on some operating systems output sent to the console doesn't appear when a thread at the same priority level is If the user types a Ctrl-D (Unix) or Ctrl-Z (Windows) to end their input we'll get an EOF and the loop above will exit When this happens we stop the server-to-user thread and close the socket Check the number of arguments Parse the host and port specifications Connect to the specified host and port The from_server stream is final for use in the inner class below The to_user stream is final for use in the anonymous class below Pass true for auto-flush on println() Tell the user that we've connected can receive asynchronous output When the server closes the connection the loop above will end Tell the user what happened and call System exit() causing the main thread to exit along Read characters until the stream closes Loop through the array of characters and print them out converting all \\n characters to the local platform's line terminator This could be more efficient but it is probably faster than the network is which is good enough with this one blocked waiting for input from the console Now start the server-to-user thread In parallel read the user's input and pass it on to the server If anything goes wrong print an error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"read":1,"length":1,"getByName":1,"System.err.println":2,"send":1,"close":1,"getBytes":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"byte[]":1,"DatagramSocket":1,"DatagramPacket":1,"String":2,"File":1,"InetAddress":1,"int":4,"FileInputStream":1},"expressions":{"IntegerLiteralExpr":9,"ObjectCreationExpr":5,"VariableDeclarationExpr":12,"ArrayAccessExpr":6,"BinaryExpr":7,"NameExpr":73,"StringLiteralExpr":3,"UnaryExpr":2,"AssignExpr":5,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":5,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":20,"DoStmt":1},"text":"public static void main(String args[]) {\n    try {\n        // Check the number of arguments\n        if (args.length < 3)\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Parse the arguments\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        // Figure out the message to send.  \n        // If the third argument is -f, then send the contents of the file\n        // specified as the fourth argument.  Otherwise, concatenate the \n        // third and all remaining arguments and send that.\n        byte[] message;\n        if (args[2].equals(\"-f\")) {\n            File f = new File(args[3]);\n            // figure out how big the file is\n            int len = (int) f.length();\n            // create a buffer big enough\n            message = new byte[len];\n            FileInputStream in = new FileInputStream(f);\n            int bytes_read = 0, n;\n            do {\n                // loop until we've read it all\n                n = in.read(message, bytes_read, len - bytes_read);\n                bytes_read += n;\n            } while ((bytes_read < len) && (n != -1));\n        } else {\n            // Otherwise, just combine all the remaining arguments.\n            String msg = args[2];\n            for (int i = 3; i < args.length; i++) msg += \" \" + args[i];\n            message = msg.getBytes();\n        }\n        // Get the internet address of the specified host\n        InetAddress address = InetAddress.getByName(host);\n        // Initialize a datagram packet with data and address\n        DatagramPacket packet = new DatagramPacket(message, message.length, address, port);\n        // Create a datagram socket, send the packet through it, close it.\n        DatagramSocket dsocket = new DatagramSocket();\n        dsocket.send(packet);\n        dsocket.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(usage);\n    }\n}\n","name":"main","className":"UDPSend","variables":{"msg":3,"dsocket":3,"address":2,"in":2,"e":1,"f":3,"i":4,"bytes_read":4,"message":4,"packet":1,"n":4,"args":6,"Integer":1,"len":4,"port":2,"host":1,"InetAddress":1},"constants":{"0":2,"1":2,"2":2,"3":3,"\" \"":1,"\"-f\"":1,"\"Wrong number of args\"":1},"javaDoc":"","comments":"Figure out the message to send If the third argument is -f then send the contents of the file specified as the fourth argument Otherwise concatenate the Check the number of arguments Parse the arguments third and all remaining arguments and send that figure out how big the file is create a buffer big enough loop until we've read it all Otherwise just combine all the remaining arguments Get the internet address of the specified host Initialize a datagram packet with data and address Create a datagram socket send the packet through it close it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"exit":1,"addService":1,"System.err.println":2},"annotations":[],"exceptions":["// Print an error message if anything goes wrong\nException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"Server":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":6,"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":42,"StringLiteralExpr":3,"FieldAccessExpr":5,"EnclosedExpr":2,"UnaryExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":9},"text":"/** \n     * Create a Server object, and add Proxy service objects to it to provide\n     * proxy service as specified by the command-line arguments.\n     **/\npublic static void main(String[] args) {\n    try {\n        // Check number of args.  Must be a multiple of 3 and > 0.\n        if ((args.length == 0) || (args.length % 3 != 0))\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Create the Server object\n        // log stream, max connections\n        Server s = new Server(null, 12);\n        // Loop through the arguments parsing (host, remoteport, localport)\n        // tuples.  For each, create a Proxy, and add it to the server.\n        int i = 0;\n        while (i < args.length) {\n            String host = args[i++];\n            int remoteport = Integer.parseInt(args[i++]);\n            int localport = Integer.parseInt(args[i++]);\n            s.addService(new Proxy(host, remoteport), localport);\n        }\n    } catch (// Print an error message if anything goes wrong\n    Exception // Print an error message if anything goes wrong\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java ProxyServer \" + \"<host> <remoteport> <localport> ...\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"ProxyServer","variables":{"args":3,"Integer":2,"s":2,"e":1,"host":2,"i":5,"remoteport":2,"localport":1,"System":1},"constants":{"0":3,"\"Usage: java ProxyServer \"":1,"12":1,"1":1,"3":1,"null":1,"\"<host> <remoteport> <localport> ...\"":1,"\"Wrong number of args\"":1},"javaDoc":"Create a Server object and add Proxy service objects to it to provide proxy service as specified by the command-line arguments","comments":"Create the Server object Loop through the arguments parsing (host remoteport localport) Check number of args Must be a multiple of 3 and > 0 log stream max connections tuples For each create a Proxy and add it to the server Print an error message if anything goes wrong Print an error message if anything goes wrong  \n     * Create a Server object, and add Proxy service objects to it to provide\n     * proxy service as specified by the command-line arguments.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int"],"returnType":"Proxy","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Remember the host and port we are a proxy for */\npublic Proxy(String host, int port) {\n    this.host = host;\n    this.port = port;\n}\n","name":"Proxy","className":"Proxy","variables":{"port":1,"host":1},"constants":{},"javaDoc":"Remember the host and port we are a proxy for","comments":" Remember the host and port we are a proxy for ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":6,"ExpressionStmt":7},"text":"public void run() {\n    // Copy bytes 'till EOF from client\n    byte[] buffer = new byte[2048];\n    int bytes_read;\n    try {\n        while ((bytes_read = from_client.read(buffer)) != -1) {\n            to_server.write(buffer, 0, bytes_read);\n            to_server.flush();\n        }\n    } catch (IOException e) {\n    } finally {\n        // When the thread is done\n        try {\n            // close the server socket\n            server.close();\n            // and the client streams\n            to_client.close();\n            from_client.close();\n        } catch (IOException e) {\n        }\n    }\n}\n","name":"run","className":"","variables":{"to_server":2,"server":1,"from_client":2,"e":2,"to_client":1,"bytes_read":2,"buffer":1},"constants":{"0":1,"1":1,"2048":1},"javaDoc":"","comments":"Copy bytes 'till EOF from client When the thread is done close the server socket and the client streams ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":3},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":6,"ExpressionStmt":7},"text":"public void run() {\n    byte[] buffer = new byte[2048];\n    int bytes_read;\n    try {\n        while ((bytes_read = from_server.read(buffer)) != -1) {\n            to_client.write(buffer, 0, bytes_read);\n            to_client.flush();\n        }\n    } catch (IOException e) {\n    } finally {\n        try {\n            // close down \n            server.close();\n            to_client.close();\n            from_client.close();\n        } catch (IOException e) {\n        }\n    }\n}\n","name":"run","className":"","variables":{"server":1,"from_client":1,"e":2,"to_client":3,"bytes_read":2,"from_server":1,"buffer":1},"constants":{"0":1,"1":1,"2048":1},"javaDoc":"","comments":"close down ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":1,"read":2,"flush":3,"start":2,"getOutputStream":1,"join":2,"getInputStream":1,"close":8,"write":2},"annotations":[],"exceptions":["IOException","InterruptedException","Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"byte[]":2,"InputStream":2,"OutputStream":2,"Thread[]":1,"Socket":1,"int":2,"PrintWriter":1,"Thread":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":9,"VariableDeclarationExpr":13,"ArrayAccessExpr":2,"BinaryExpr":6,"NameExpr":92,"StringLiteralExpr":3,"EnclosedExpr":2,"ArrayCreationExpr":3,"UnaryExpr":2,"AssignExpr":7,"MethodCallExpr":22},"statements":{"WhileStmt":2,"TryStmt":7,"BlockStmt":20,"ReturnStmt":1,"ExpressionStmt":36},"text":"/** The server invokes this method when a client connects. */\npublic void serve(InputStream in, OutputStream out) {\n    // These are some sockets we'll use.  They are final so they can\n    // be used by the anonymous classes defined below.\n    final InputStream from_client = in;\n    final OutputStream to_client = out;\n    final InputStream from_server;\n    final OutputStream to_server;\n    // Try to establish a connection to the specified server and port\n    // and get sockets to talk to it.  Tell our client if we fail.\n    final Socket server;\n    try {\n        server = new Socket(host, port);\n        from_server = server.getInputStream();\n        to_server = server.getOutputStream();\n    } catch (Exception e) {\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));\n        pw.print(\"Proxy server could not connect to \" + host + \":\" + port + \"\\n\");\n        pw.flush();\n        pw.close();\n        try {\n            in.close();\n        } catch (IOException ex) {\n        }\n        return;\n    }\n    // Create an array to hold two Threads.  It is declared final so\n    // that it can be used by the anonymous classes below.  We use an\n    // array instead of two variables because given the structure of\n    // this program two variables would not work if declared final.\n    final Thread[] threads = new Thread[2];\n    // Define and create a thread to copy bytes from client to server\n    Thread c2s = new Thread() {\n\n        public void run() {\n            // Copy bytes 'till EOF from client\n            byte[] buffer = new byte[2048];\n            int bytes_read;\n            try {\n                while ((bytes_read = from_client.read(buffer)) != -1) {\n                    to_server.write(buffer, 0, bytes_read);\n                    to_server.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                // When the thread is done\n                try {\n                    // close the server socket\n                    server.close();\n                    // and the client streams\n                    to_client.close();\n                    from_client.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    };\n    // Define and create a thread to copy bytes from server to client.\n    // This thread works just like the one above.\n    Thread s2c = new Thread() {\n\n        public void run() {\n            byte[] buffer = new byte[2048];\n            int bytes_read;\n            try {\n                while ((bytes_read = from_server.read(buffer)) != -1) {\n                    to_client.write(buffer, 0, bytes_read);\n                    to_client.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    // close down \n                    server.close();\n                    to_client.close();\n                    from_client.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    };\n    // Store the threads into the final threads[] array, so that the \n    // anonymous classes can refer to each other.\n    threads[0] = c2s;\n    threads[1] = s2c;\n    // start the threads\n    c2s.start();\n    s2c.start();\n    // Wait for them to exit\n    try {\n        c2s.join();\n        s2c.join();\n    } catch (InterruptedException e) {\n    }\n}\n","name":"serve","className":"Proxy","variables":{"server":6,"from_client":4,"in":2,"e":6,"c2s":4,"s2c":4,"pw":4,"to_client":5,"threads":3,"from_server":3,"run":2,"bytes_read":4,"out":2,"to_server":4,"ex":1,"port":2,"host":2,"buffer":2},"constants":{"\"Proxy server could not connect to \"":1,"0":3,"1":3,"2":1,"2048":2,"\":\"":1,"\"\\n\"":1},"javaDoc":"The server invokes this method when a client connects","comments":"These are some sockets we'll use They are final so they can Try to establish a connection to the specified server and port Create an array to hold two Threads It is declared final so that it can be used by the anonymous classes below We use an array instead of two variables because given the structure of Define and create a thread to copy bytes from server to client Store the threads into the final threads[] array so that the be used by the anonymous classes defined below and get sockets to talk to it Tell our client if we fail this program two variables would not work if declared final Define and create a thread to copy bytes from client to server Copy bytes 'till EOF from client When the thread is done close the server socket and the client streams This thread works just like the one above close down anonymous classes can refer to each other start the threads Wait for them to exit  The server invokes this method when a client connects. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"print":4,"length":1,"getOutputStream":1,"readLine":1,"System.err.println":2,"getInputStream":1,"close":3,"accept":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"ServerSocket":1,"String":1,"int":1,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":54,"StringLiteralExpr":5,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":15,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"TryStmt":1,"BlockStmt":4,"ForStmt":1,"ExpressionStmt":15},"text":"public static void main(String args[]) {\n    try {\n        // Get the port to listen on\n        int port = Integer.parseInt(args[0]);\n        // Create a ServerSocket to listen on that port.\n        ServerSocket ss = new ServerSocket(port);\n        // Now enter an infinite loop, waiting for & handling connections.\n        for (; ; ) {\n            // Wait for a client to connect.  The method will block;\n            // when it returns the socket will be connected to the client\n            Socket client = ss.accept();\n            // Get input and output streams to talk to the client \n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(client.getOutputStream());\n            // Start sending our reply, using the HTTP 1.0 protocol\n            // Version & status code\n            out.print(\"HTTP/1.0 200 \\n\");\n            // The type of data\n            out.print(\"Content-Type: text/plain\\n\");\n            // End of headers\n            out.print(\"\\n\");\n            // Now, read the HTTP request from the client, and send it\n            // right back to the client as part of the body of our\n            // response.  The client doesn't disconnect, so we never get\n            // an EOF.  It does sends an empty line at the end of the\n            // headers, though.  So when we see the empty line, we stop\n            // reading.  This means we don't mirror the contents of POST\n            // requests, for example.  Note that the readLine() method \n            // works with Unix, Windows, and Mac line terminators.\n            String line;\n            while ((line = in.readLine()) != null) {\n                if (line.length() == 0)\n                    break;\n                out.print(line + \"\\n\");\n            }\n            // Close socket, breaking the connection to the client, and\n            // closing the input and output streams\n            // Flush and close the output stream\n            out.close();\n            // Close the input stream\n            in.close();\n            // Close the socket itself\n            client.close();\n        }\n    // Now loop again, waiting for the next connection\n    }// If anything goes wrong, print an error message\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java HttpMirror <port>\");\n    }\n}\n","name":"main","className":"HttpMirror","variables":{"Integer":1,"args":1,"ss":2,"port":2,"in":3,"e":1,"line":4,"client":4,"out":6},"constants":{"0":2,"\"HTTP/1.0 200 \\n\"":1,"null":1,"\"Usage: java HttpMirror <port>\"":1,"\"Content-Type: text/plain\\n\"":1,"\"\\n\"":2},"javaDoc":"","comments":"Now loop again waiting for the next connection Get the port to listen on Create a ServerSocket to listen on that port Now enter an infinite loop waiting for & handling connections Wait for a client to connect The method will block; Start sending our reply using the HTTP 1 0 protocol Now read the HTTP request from the client and send it right back to the client as part of the body of our response The client doesn't disconnect so we never get an EOF It does sends an empty line at the end of the headers though So when we see the empty line we stop reading This means we don't mirror the contents of POST requests for example Note that the readLine() method Close socket breaking the connection to the client and closing the input and output streams when it returns the socket will be connected to the client Get input and output streams to talk to the client Version & status code The type of data End of headers works with Unix Windows and Mac line terminators Flush and close the output stream Close the input stream Close the socket itself If anything goes wrong print an error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getProperty":1,"getHostName":1,"System.out.flush":1,"openConnection":1,"getProperties":1,"readLine":4,"setDoInput":1,"put":1,"getLocalHost":1,"print":5,"equals":1,"getOutputStream":1,"System.err.println":2,"close":1,"System.out.print":3,"connect":1,"setDoOutput":1,"System.out.println":3},"annotations":[],"exceptions":["// Handle any exceptions, print error message.\nException"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":4,"URL":1,"URLConnection":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":5,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":16,"NameExpr":121,"StringLiteralExpr":22,"AssignExpr":1,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"FieldAccessExpr":11,"EnclosedExpr":1,"MethodCallExpr":30},"statements":{"IfStmt":2,"BreakStmt":1,"TryStmt":1,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":28},"text":"public static void main(String[] args) {\n    try {\n        // If the user specified a mailhost, tell the system about it.\n        if (args.length >= 1)\n            System.getProperties().put(\"mail.host\", args[0]);\n        // A Reader stream to read from the console\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        // Ask the user for the from, to, and subject lines\n        System.out.print(\"From: \");\n        String from = in.readLine();\n        System.out.print(\"To: \");\n        String to = in.readLine();\n        System.out.print(\"Subject: \");\n        String subject = in.readLine();\n        // Establish a network connection for sending mail\n        // Create a mailto: URL \n        URL u = new URL(\"mailto:\" + to);\n        // Create its URLConnection\n        URLConnection c = u.openConnection();\n        // Specify no input from it\n        c.setDoInput(false);\n        // Specify we'll do output\n        c.setDoOutput(true);\n        // Tell the user\n        System.out.println(\"Connecting...\");\n        // Tell them right now\n        System.out.flush();\n        // Connect to mail host\n        c.connect();\n        PrintWriter // Get output stream to host\n        out = new PrintWriter(new OutputStreamWriter(c.getOutputStream()));\n        // Write out mail headers.  Don't let users fake the From address\n        out.print(\"From: \\\"\" + from + \"\\\" <\" + System.getProperty(\"user.name\") + \"@\" + InetAddress.getLocalHost().getHostName() + \">\\n\");\n        out.print(\"To: \" + to + \"\\n\");\n        out.print(\"Subject: \" + subject + \"\\n\");\n        // blank line to end the list of headers\n        out.print(\"\\n\");\n        // Now ask the user to enter the body of the message\n        System.out.println(\"Enter the message. \" + \"End with a '.' on a line by itself.\");\n        // Read message line by line and send it out.\n        String line;\n        for (; ; ) {\n            line = in.readLine();\n            if ((line == null) || line.equals(\".\"))\n                break;\n            out.print(line + \"\\n\");\n        }\n        // Close (and flush) the stream to terminate the message \n        out.close();\n        // Tell the user it was successfully sent.\n        System.out.println(\"Message sent.\");\n    } catch (// Handle any exceptions, print error message.\n    Exception // Handle any exceptions, print error message.\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java SendMail [<mailhost>]\");\n    }\n}\n","name":"main","className":"SendMail","variables":{"args":1,"c":5,"in":5,"u":2,"e":1,"subject":2,"line":5,"from":2,"to":3,"InetAddress":1,"System":2,"out":7},"constants":{"\"From: \"":1,"\"@\"":1,"\"Enter the message. \"":1,"\"To: \"":2,"false":1,"\">\\n\"":1,"\"Message sent.\"":1,"0":1,"\"user.name\"":1,"1":1,"\"Subject: \"":2,"\"mailto:\"":1,"null":1,"\".\"":1,"\"End with a '.' on a line by itself.\"":1,"true":1,"\"Connecting...\"":1,"\"From: \\\"\"":1,"\"mail.host\"":1,"\"\\\" <\"":1,"\"Usage: java SendMail [<mailhost>]\"":1,"\"\\n\"":4},"javaDoc":"","comments":"Establish a network connection for sending mail If the user specified a mailhost tell the system about it A Reader stream to read from the console Ask the user for the from to and subject lines Create a mailto: URL Create its URLConnection Specify no input from it Specify we'll do output Tell the user Tell them right now Connect to mail host Get output stream to host Write out mail headers Don't let users fake the From address blank line to end the list of headers Now ask the user to enter the body of the message Read message line by line and send it out Close (and flush) the stream to terminate the message Tell the user it was successfully sent Handle any exceptions print error message Handle any exceptions print error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"runServer":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":36,"StringLiteralExpr":6,"FieldAccessExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":7},"text":"/** The main method parses arguments and passes them to runServer */\npublic static void main(String[] args) throws IOException {\n    try {\n        // Check the number of arguments\n        if (args.length != 3)\n            throw new IllegalArgumentException(\"Wrong number of args.\");\n        // Get the command-line arguments: the host and port we are proxy\n        // for and the local port that we listen for connections on.\n        String host = args[0];\n        int remoteport = Integer.parseInt(args[1]);\n        int localport = Integer.parseInt(args[2]);\n        // Print a start-up message\n        System.out.println(\"Starting proxy for \" + host + \":\" + remoteport + \" on port \" + localport);\n        // And start running the server\n        // never returns\n        runServer(host, remoteport, localport);\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java SimpleProxyServer \" + \"<host> <remoteport> <localport>\");\n    }\n}\n","name":"main","className":"SimpleProxyServer","variables":{"args":3,"Integer":2,"e":1,"host":2,"remoteport":2,"localport":2},"constants":{"0":1,"1":1,"2":1,"3":1,"\"<host> <remoteport> <localport>\"":1,"\" on port \"":1,"\"Usage: java SimpleProxyServer \"":1,"\"Starting proxy for \"":1,"\":\"":1,"\"Wrong number of args.\"":1},"javaDoc":"The main method parses arguments and passes them to runServer","comments":"Get the command-line arguments: the host and port we are proxy And start running the server Check the number of arguments for and the local port that we listen for connections on Print a start-up message never returns  The main method parses arguments and passes them to runServer ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"flush":1,"write":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":16,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ExpressionStmt":4},"text":"public void run() {\n    int bytes_read;\n    try {\n        while ((bytes_read = from_client.read(request)) != -1) {\n            to_server.write(request, 0, bytes_read);\n            to_server.flush();\n        }\n    } catch (IOException e) {\n    }\n    // server-to-client loop in the main thread exit.\n    try {\n        to_server.close();\n    } catch (IOException e) {\n    }\n}\n                         // the client closed the connection to us, so close our\n\n                         // connection to the server.  This will also cause the \n\n","name":"run","className":"","variables":{"to_server":3,"from_client":1,"e":2,"bytes_read":2},"constants":{"0":1,"1":1},"javaDoc":"","comments":"the client closed the connection to us so close our connection to the server This will also cause the server-to-client loop in the main thread exit ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","int"],"returnType":"void","methodCalls":{"print":1,"read":2,"flush":3,"start":1,"getOutputStream":2,"System.err.println":1,"getInputStream":2,"close":5,"write":2,"accept":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"byte[]":2,"InputStream":2,"OutputStream":2,"ServerSocket":1,"Socket":1,"int":2,"PrintWriter":1,"Thread":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":6,"VariableDeclarationExpr":12,"BinaryExpr":10,"NameExpr":84,"StringLiteralExpr":4,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ArrayCreationExpr":2,"MethodCallExpr":20},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":3,"BlockStmt":17,"TryStmt":6,"ExpressionStmt":27},"text":"/**\n     * This method runs a single-threaded proxy server for \n     * host:remoteport on the specified local port.  It never returns.\n     **/\npublic static void runServer(String host, int remoteport, int localport) throws IOException {\n    // Create a ServerSocket to listen for connections with\n    ServerSocket ss = new ServerSocket(localport);\n    // Create buffers for client-to-server and server-to-client transfer.\n    // We make one final so it can be used in an anonymous class below.\n    // Note the assumptions about the volume of traffic in each direction.\n    final byte[] request = new byte[1024];\n    byte[] reply = new byte[4096];\n    // This is a server that never returns, so enter an infinite loop.\n    while (true) {\n        // Variables to hold the sockets to the client and to the server.\n        Socket client = null, server = null;\n        try {\n            // Wait for a connection on the local port\n            client = ss.accept();\n            // Get client streams.  Make them final so they can\n            // be used in the anonymous thread below.\n            final InputStream from_client = client.getInputStream();\n            final OutputStream to_client = client.getOutputStream();\n            // client, disconnect, and continue waiting for connections.\n            try {\n                server = new Socket(host, remoteport);\n            } catch (IOException e) {\n                PrintWriter out = new PrintWriter(to_client);\n                out.print(\"Proxy server cannot connect to \" + host + \":\" + remoteport + \":\\n\" + e + \"\\n\");\n                out.flush();\n                client.close();\n                continue;\n            }\n            // Get server streams.\n            final InputStream from_server = server.getInputStream();\n            final OutputStream to_server = server.getOutputStream();\n            // Make a thread to read the client's requests and pass them\n            // to the server.  We have to use a separate thread because\n            // requests and responses may be asynchronous.\n            Thread t = new Thread() {\n\n                public void run() {\n                    int bytes_read;\n                    try {\n                        while ((bytes_read = from_client.read(request)) != -1) {\n                            to_server.write(request, 0, bytes_read);\n                            to_server.flush();\n                        }\n                    } catch (IOException e) {\n                    }\n                    // server-to-client loop in the main thread exit.\n                    try {\n                        to_server.close();\n                    } catch (IOException e) {\n                    }\n                }\n            };\n            // Start the client-to-server request thread running\n            t.start();\n            // Meanwhile, in the main thread, read the server's responses\n            // and pass them back to the client.  This will be done in\n            // parallel with the client-to-server request thread above.\n            int bytes_read;\n            try {\n                while ((bytes_read = from_server.read(reply)) != -1) {\n                    to_client.write(reply, 0, bytes_read);\n                    to_client.flush();\n                }\n            } catch (IOException e) {\n            }\n            // The server closed its connection to us, so we close our \n                 // Make a connection to the real server.\n\n                 // If we cannot connect to the server, send an error to the \n\n            // connection to our client.\n            // This will make the other thread exit.\n            to_client.close();\n        } catch (IOException e) {\n            System.err.println(e);\n        } finally {\n            // Close the sockets no matter what happens.\n            try {\n                if (server != null)\n                    server.close();\n                if (client != null)\n                    client.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}\n                         // the client closed the connection to us, so close our\n\n                         // connection to the server.  This will also cause the \n\n","name":"runServer","className":"SimpleProxyServer","variables":{"ss":2,"request":1,"server":6,"from_client":2,"e":7,"to_client":5,"from_server":2,"run":1,"bytes_read":4,"out":3,"to_server":4,"t":2,"host":2,"client":7,"localport":1,"remoteport":2,"reply":1},"constants":{"0":2,"4096":1,"1":2,"\":\\n\"":1,"null":4,"\"Proxy server cannot connect to \"":1,"1024":1,"true":1,"\":\"":1,"\"\\n\"":1},"javaDoc":"This method runs a single-threaded proxy server for host:remoteport on the specified local port It never returns","comments":"Create buffers for client-to-server and server-to-client transfer We make one final so it can be used in an anonymous class below Create a ServerSocket to listen for connections with Note the assumptions about the volume of traffic in each direction This is a server that never returns so enter an infinite loop Variables to hold the sockets to the client and to the server Get client streams Make them final so they can Make a connection to the real server If we cannot connect to the server send an error to the Make a thread to read the client's requests and pass them to the server We have to use a separate thread because Meanwhile in the main thread read the server's responses and pass them back to the client This will be done in The server closed its connection to us so we close our connection to our client Wait for a connection on the local port be used in the anonymous thread below client disconnect and continue waiting for connections Get server streams requests and responses may be asynchronous the client closed the connection to us so close our connection to the server This will also cause the server-to-client loop in the main thread exit Start the client-to-server request thread running parallel with the client-to-server request thread above This will make the other thread exit Close the sockets no matter what happens \n     * This method runs a single-threaded proxy server for \n     * host:remoteport on the specified local port.  It never returns.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["URL"],"returnType":"void","methodCalls":{"getContentEncoding":1,"getLastModified":1,"getExpiration":1,"openConnection":1,"getResponseCode":1,"getContentType":1,"getDate":1,"getContentLength":1,"getResponseMessage":1,"getRequestMethod":1,"connect":1,"System.out.println":9},"annotations":[],"exceptions":["IOException"],"concepts":["Casting"],"types":{"HttpURLConnection":1,"URLConnection":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":9,"NameExpr":80,"StringLiteralExpr":9,"CastExpr":1,"FieldAccessExpr":9,"InstanceOfExpr":1,"MethodCallExpr":20},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":12},"text":"/** Use the URLConnection class to get info about the URL */\npublic static void printinfo(URL url) throws IOException {\n    // Get URLConnection from URL\n    URLConnection c = url.openConnection();\n    // Open a connection to URL\n    c.connect();\n    // Display some information about the URL contents\n    System.out.println(\"  Content Type: \" + c.getContentType());\n    System.out.println(\"  Content Encoding: \" + c.getContentEncoding());\n    System.out.println(\"  Content Length: \" + c.getContentLength());\n    System.out.println(\"  Date: \" + new Date(c.getDate()));\n    System.out.println(\"  Last Modified: \" + new Date(c.getLastModified()));\n    System.out.println(\"  Expiration: \" + new Date(c.getExpiration()));\n    // If it is an HTTP connection, display some additional information.\n    if (c instanceof HttpURLConnection) {\n        HttpURLConnection h = (HttpURLConnection) c;\n        System.out.println(\"  Request Method: \" + h.getRequestMethod());\n        System.out.println(\"  Response Message: \" + h.getResponseMessage());\n        System.out.println(\"  Response Code: \" + h.getResponseCode());\n    }\n}\n","name":"printinfo","className":"GetURLInfo","variables":{"c":10,"h":4,"url":1},"constants":{"\"  Content Encoding: \"":1,"\"  Response Message: \"":1,"\"  Content Type: \"":1,"\"  Response Code: \"":1,"\"  Last Modified: \"":1,"\"  Request Method: \"":1,"\"  Content Length: \"":1,"\"  Date: \"":1,"\"  Expiration: \"":1},"javaDoc":"Use the URLConnection class to get info about the URL","comments":"Get URLConnection from URL Open a connection to URL Display some information about the URL contents If it is an HTTP connection display some additional information  Use the URLConnection class to get info about the URL ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"printinfo":1,"System.err.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** Create a URL, call printinfo() to display information about it. */\npublic static void main(String[] args) {\n    try {\n        printinfo(new URL(args[0]));\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GetURLInfo <url>\");\n    }\n}\n","name":"main","className":"GetURLInfo","variables":{"args":1,"e":1},"constants":{"0":1,"\"Usage: java GetURLInfo <url>\"":1},"javaDoc":"Create a URL call printinfo() to display information about it","comments":" Create a URL, call printinfo() to display information about it. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"receive":1,"setLength":1,"getHostName":1,"getLength":1,"getAddress":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"DatagramSocket":1,"DatagramPacket":1,"String":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":49,"StringLiteralExpr":2,"FieldAccessExpr":6,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":10},"text":"public static void main(String args[]) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Get the port from the command line\n        int port = Integer.parseInt(args[0]);\n        // Create a socket to listen on the port.\n        DatagramSocket dsocket = new DatagramSocket(port);\n        // Create a buffer to read datagrams into.  If anyone sends us a \n        // packet containing more than will fit into this buffer, the\n        // excess will simply be discarded!\n        byte[] buffer = new byte[2048];\n        // Create a packet to receive data into the buffer\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        // Now loop forever, waiting to receive packets and printing them.\n        for (; ; ) {\n            // Wait to receive a datagram\n            dsocket.receive(packet);\n            // Convert the contents to a string, and display them\n            String msg = new String(buffer, 0, packet.getLength());\n            System.out.println(packet.getAddress().getHostName() + \": \" + msg);\n            // Reset the length of the packet before reusing it.\n            // Prior to Java 1.1, we'd just create a new packet each time.\n            packet.setLength(buffer.length);\n        }\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(usage);\n    }\n}\n","name":"main","className":"UDPReceive","variables":{"Integer":1,"args":1,"dsocket":2,"msg":2,"port":2,"e":1,"buffer":3,"packet":4},"constants":{"0":2,"1":1,"2048":1,"\": \"":1,"\"Wrong number of args\"":1},"javaDoc":"","comments":"Create a buffer to read datagrams into If anyone sends us a packet containing more than will fit into this buffer the Get the port from the command line Create a socket to listen on the port excess will simply be discarded! Create a packet to receive data into the buffer Now loop forever waiting to receive packets and printing them Reset the length of the packet before reusing it Wait to receive a datagram Convert the contents to a string and display them Prior to Java 1 1 we'd just create a new packet each time ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"getProtocol":1,"getFile":1,"getInputStream":1,"print":1,"getPort":1,"flush":1,"equals":1,"getOutputStream":1,"System.err.println":2,"write":1,"close":2,"getHost":1},"annotations":[],"exceptions":["// Report any errors that arise\nException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"String":3,"URL":1,"int":2,"Socket":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":10,"ObjectCreationExpr":6,"VariableDeclarationExpr":11,"ArrayAccessExpr":2,"BinaryExpr":8,"NameExpr":75,"StringLiteralExpr":6,"UnaryExpr":3,"AssignExpr":4,"FieldAccessExpr":6,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":15},"statements":{"IfStmt":4,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":2,"ExpressionStmt":21},"text":"public static void main(String[] args) {\n    try {\n        // Check the arguments\n        if ((args.length != 1) && (args.length != 2))\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Get an output stream to write the URL contents to\n        OutputStream to_file;\n        if (args.length == 2)\n            to_file = new FileOutputStream(args[1]);\n        else\n            to_file = System.out;\n        // Now use the URL class to parse the user-specified URL into\n        // its various parts.  \n        URL url = new URL(args[0]);\n        String protocol = url.getProtocol();\n        if (// Check that we support the protocol\n        !protocol.equals(\"http\"))\n            throw new IllegalArgumentException(\"Must use 'http:' protocol\");\n        String host = url.getHost();\n        int port = url.getPort();\n        // if no port, use the default HTTP port\n        if (port == -1)\n            port = 80;\n        String filename = url.getFile();\n        // Open a network socket connection to the specified host and port\n        Socket socket = new Socket(host, port);\n        // Get input and output streams for the socket\n        InputStream from_server = socket.getInputStream();\n        PrintWriter to_server = new PrintWriter(socket.getOutputStream());\n        // Send the HTTP GET command to the Web server, specifying the file\n        // This uses an old and very simple version of the HTTP protocol\n        to_server.print(\"GET \" + filename + \"\\n\\n\");\n        // Send it right now!\n        to_server.flush();\n        // Now read the server's response, and write it to the file\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = from_server.read(buffer)) != -1) to_file.write(buffer, 0, bytes_read);\n        // When the server closes the connection, we close our stuff\n        socket.close();\n        to_file.close();\n    } catch (// Report any errors that arise\n    Exception // Report any errors that arise\n    e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java HttpClient <URL> [<filename>]\");\n    }\n}\n","name":"main","className":"HttpClient","variables":{"e":1,"to_file":5,"from_server":2,"bytes_read":2,"url":5,"args":2,"to_server":3,"protocol":2,"filename":2,"port":4,"host":2,"socket":4,"buffer":1},"constants":{"0":2,"\"Usage: java HttpClient <URL> [<filename>]\"":1,"1":4,"4096":1,"2":2,"\"\\n\\n\"":1,"80":1,"\"Wrong number of args\"":1,"\"GET \"":1,"\"http\"":1,"\"Must use 'http:' protocol\"":1},"javaDoc":"","comments":"Now use the URL class to parse the user-specified URL into Send the HTTP GET command to the Web server specifying the file Check the arguments Get an output stream to write the URL contents to its various parts Check that we support the protocol if no port use the default HTTP port Open a network socket connection to the specified host and port Get input and output streams for the socket This uses an old and very simple version of the HTTP protocol Send it right now! Now read the server's response and write it to the file When the server closes the connection we close our stuff Report any errors that arise Report any errors that arise ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"read":1,"System.err.println":2,"openStream":1,"write":1,"close":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"InputStream":1,"OutputStream":1,"URL":1,"int":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":5,"NameExpr":47,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":4,"NullLiteralExpr":2,"FieldAccessExpr":6,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":2,"BlockStmt":5,"ThrowStmt":1,"ExpressionStmt":13},"text":"public static void main(String[] args) {\n    InputStream in = null;\n    OutputStream out = null;\n    try {\n        // Check the arguments\n        if ((args.length != 1) && (args.length != 2))\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Set up the streams\n        // Create the URL\n        URL url = new URL(args[0]);\n        // Open a stream to it\n        in = url.openStream();\n        if (// Get an appropriate output stream\n        args.length == 2)\n            out = new FileOutputStream(args[1]);\n        else\n            out = System.out;\n        // Now copy bytes from the URL to the output stream\n        byte[] buffer = new byte[4096];\n        int bytes_read;\n        while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n    }// On exceptions, print error message and usage message.\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java GetURL <URL> [<filename>]\");\n    } finally {\n        // Always close the streams, no matter what.\n        try {\n            in.close();\n            out.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"GetURL","variables":{"args":2,"in":4,"e":2,"bytes_read":2,"buffer":1,"url":2,"out":5},"constants":{"0":2,"1":3,"4096":1,"2":2,"null":2,"\"Usage: java GetURL <URL> [<filename>]\"":1,"\"Wrong number of args\"":1},"javaDoc":"","comments":"Set up the streams Check the arguments Create the URL Open a stream to it Get an appropriate output stream Now copy bytes from the URL to the output stream On exceptions print error message and usage message Always close the streams no matter what ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"addActionListener":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/**\n     * The init method just creates a button to display in the applet.\n     * When the user clicks the button, we'll check who is logged on.\n     **/\npublic void init() {\n    who = new Button(\"Who?\");\n    who.setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n    who.addActionListener(this);\n    this.add(who);\n}\n","name":"init","className":"Who","variables":{"who":3},"constants":{"\"Who?\"":1,"14":1,"\"SansSerif\"":1},"javaDoc":"The init method just creates a button to display in the applet When the user clicks the button we'll check who is logged on","comments":"\n     * The init method just creates a button to display in the applet.\n     * When the user clicks the button, we'll check who is logged on.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** \n     * When the button is clicked, start a thread that will connect to\n     * the finger server and display who is logged on\n     **/\npublic void actionPerformed(ActionEvent e) {\n    new Thread(this).start();\n}\n","name":"actionPerformed","className":"Who","variables":{},"constants":{},"javaDoc":"When the button is clicked start a thread that will connect to the finger server and display who is logged on","comments":" \n     * When the button is clicked, start a thread that will connect to\n     * the finger server and display who is logged on\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"getSource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":5,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    ((Frame) e.getSource()).dispose();\n}\n","name":"windowClosing","className":"","variables":{"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"show":1,"setTitle":2,"readLine":1,"pack":1,"getInputStream":1,"setEnabled":2,"addWindowListener":1,"print":1,"flush":1,"getSource":1,"getOutputStream":1,"toString":1,"setFont":1,"close":3,"getHost":1,"append":3},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["InnerMethod","ExceptionHandling"],"types":{"Frame":1,"TextArea":1,"BufferedReader":1,"String":2,"Socket":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":2,"NameExpr":85,"StringLiteralExpr":7,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":2,"ThisExpr":1,"MethodCallExpr":25},"statements":{"WhileStmt":1,"BlockStmt":7,"TryStmt":2,"ExpressionStmt":28},"text":"/**\n     * This is the method that does the networking and displays the results.\n     * It is implemented as the body of a separate thread because it might\n     * take some time to complete, and applet methods need to return promptly.\n     **/\npublic void run() {\n    // Disable the button so we don't get multiple queries at once...\n    who.setEnabled(false);\n    // Create a window to display the output in\n    Frame f = new Frame(\"Who's Logged On: Connecting...\");\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            ((Frame) e.getSource()).dispose();\n        }\n    });\n    TextArea t = new TextArea(10, 80);\n    t.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 10));\n    f.add(t, \"Center\");\n    f.pack();\n    f.show();\n    // Find out  who's logged on\n    Socket s = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n    try {\n        // Connect to port 79 (the standard finger port) on the host\n        // that the applet was loaded from.\n        String hostname = this.getCodeBase().getHost();\n        s = new Socket(hostname, 79);\n        // Set up the streams\n        out = new PrintWriter(new OutputStreamWriter(s.getOutputStream()));\n        in = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        // Send a blank line to the finger server, telling it that we want\n        // a listing of everyone logged on instead of information about an\n        // individual user.\n        out.print(\"\\n\");\n        // Send it now!\n        out.flush();\n        // Now read the server's response and display it in the textarea\n        // The server should send lines terminated with \\n.  The \n        // readLine() method will detect these lines, even when running\n        // on a Mac that terminates lines with \\r\n        String line;\n        while ((line = in.readLine()) != null) {\n            t.append(line);\n            t.append(\"\\n\");\n        }\n        // Update the window title to indicate we're finished\n        f.setTitle(\"Who's Logged On: \" + hostname);\n    }// If something goes wrong, we'll just display the exception message\n     catch (IOException e) {\n        t.append(e.toString());\n        f.setTitle(\"Who's Logged On: Error\");\n    } finally // And finally, don't forget to close the streams!\n    {\n        try {\n            in.close();\n            out.close();\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // And enable the button again\n    who.setEnabled(true);\n}\n","name":"run","className":"Who","variables":{"hostname":3,"s":5,"t":5,"e":5,"windowClosing":1,"in":4,"f":7,"line":2,"who":2,"out":5},"constants":{"\"MonoSpaced\"":1,"79":1,"null":4,"false":1,"80":1,"true":1,"\"Who's Logged On: \"":1,"\"Who's Logged On: Connecting...\"":1,"\"Center\"":1,"\"Who's Logged On: Error\"":1,"\"\\n\"":2,"10":2},"javaDoc":"This is the method that does the networking and displays the results It is implemented as the body of a separate thread because it might take some time to complete and applet methods need to return promptly","comments":"Disable the button so we don't get multiple queries at once Create a window to display the output in Find out who's logged on Connect to port 79 (the standard finger port) on the host Send a blank line to the finger server telling it that we want a listing of everyone logged on instead of information about an Now read the server's response and display it in the textarea The server should send lines terminated with \\n The readLine() method will detect these lines even when running that the applet was loaded from Set up the streams individual user Send it now! on a Mac that terminates lines with \\r Update the window title to indicate we're finished If something goes wrong we'll just display the exception message And finally don't forget to close the streams! And enable the button again \n     * This is the method that does the networking and displays the results.\n     * It is implemented as the body of a separate thread because it might\n     * take some time to complete, and applet methods need to return promptly.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":2,"exit":1,"forName":1,"addService":2,"newInstance":1,"System.err.println":2},"annotations":[],"exceptions":["IllegalArgumentException","// Display a message if anything goes wrong\nException"],"concepts":["Casting","ExceptionHandling"],"types":{"Server":1,"Service":1,"Class":1,"String":2,"int":3},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":3,"VariableDeclarationExpr":8,"ArrayAccessExpr":5,"BinaryExpr":5,"NameExpr":61,"StringLiteralExpr":6,"CastExpr":1,"FieldAccessExpr":5,"UnaryExpr":5,"MethodCallExpr":10},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":1,"BlockStmt":5,"ThrowStmt":1,"ExpressionStmt":14},"text":"/**\n     * A main() method for running the server as a standalone program.  The\n     * command-line arguments to the program should be pairs of servicenames\n     * and port numbers.  For each pair, the program will dynamically load the\n     * named Service class, instantiate it, and tell the server to provide\n     * that Service on the specified port.  The special -control argument\n     * should be followed by a password and port, and will start special\n     * server control service running on the specified port, protected by the\n     * specified password.\n     **/\npublic static void main(String[] args) {\n    try {\n        if (// Check number of arguments\n        args.length < 2)\n            throw new IllegalArgumentException(\"Must specify a service\");\n        // Create a Server object that uses standard out as its log and\n        // has a limit of ten concurrent connections at once.\n        Server s = new Server(System.out, 10);\n        // Parse the argument list\n        int i = 0;\n        while (i < args.length) {\n            if (args[i].equals(\"-control\")) {\n                // Handle the -control arg\n                i++;\n                String password = args[i++];\n                int port = Integer.parseInt(args[i++]);\n                // add control service\n                s.addService(new Control(s, password), port);\n            } else {\n                // Otherwise start a named service on the specified port.\n                // Dynamically load and instantiate a Service class\n                String serviceName = args[i++];\n                Class serviceClass = Class.forName(serviceName);\n                Service service = (Service) serviceClass.newInstance();\n                int port = Integer.parseInt(args[i++]);\n                s.addService(service, port);\n            }\n        }\n    } catch (// Display a message if anything goes wrong\n    Exception // Display a message if anything goes wrong\n    e) {\n        System.err.println(\"Server: \" + e);\n        System.err.println(\"Usage: java Server \" + \"[-control <password> <port>] \" + \"[<servicename> <port> ... ]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"Server","variables":{"args":5,"Integer":2,"password":2,"s":4,"serviceClass":2,"port":2,"e":2,"service":1,"i":8,"Class":1,"serviceName":1,"System":1},"constants":{"0":1,"1":1,"2":1,"\"[<servicename> <port> ... ]\"":1,"\"Usage: java Server \"":1,"\"Must specify a service\"":1,"\"[-control <password> <port>] \"":1,"\"Server: \"":1,"\"-control\"":1,"10":1},"javaDoc":"A main() method for running the server as a standalone program The command-line arguments to the program should be pairs of servicenames and port numbers For each pair the program will dynamically load the named Service class instantiate it and tell the server to provide that Service on the specified port The special -control argument should be followed by a password and port and will start special server control service running on the specified port protected by the specified password","comments":"Create a Server object that uses standard out as its log and Check number of arguments has a limit of ten concurrent connections at once Parse the argument list Handle the -control arg add control service Otherwise start a named service on the specified port Dynamically load and instantiate a Service class Display a message if anything goes wrong Display a message if anything goes wrong \n     * A main() method for running the server as a standalone program.  The\n     * command-line arguments to the program should be pairs of servicenames\n     * and port numbers.  For each pair, the program will dynamically load the\n     * named Service class, instantiate it, and tell the server to provide\n     * that Service on the specified port.  The special -control argument\n     * should be followed by a password and port, and will start special\n     * server control service running on the specified port, protected by the\n     * specified password.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["OutputStream","int"],"returnType":"Server","methodCalls":{"log":1,"setLogStream":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":14,"StringLiteralExpr":1,"ClassExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":4},"statements":{"ExpressionStmt":6},"text":"/**\n     * This is the Server() constructor.  It must be passed a stream \n     * to send log output to (may be null), and the limit on the number of\n     * concurrent connections.  \n     **/\npublic Server(OutputStream logStream, int maxConnections) {\n    setLogStream(logStream);\n    log(\"Starting server\");\n    threadGroup = new ThreadGroup(Server.class.getName());\n    this.maxConnections = maxConnections;\n    services = new HashMap();\n    connections = new HashSet(maxConnections);\n}\n","name":"Server","className":"Server","variables":{"threadGroup":1,"services":1,"connections":1,"maxConnections":2},"constants":{"\"Starting server\"":1},"javaDoc":"This is the Server() constructor It must be passed a stream to send log output to (may be null) and the limit on the number of concurrent connections","comments":"\n     * This is the Server() constructor.  It must be passed a stream \n     * to send log output to (may be null), and the limit on the number of\n     * concurrent connections.  \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["OutputStream"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** \n     * A public method to set the current logging stream.  Pass null\n     * to turn logging off\n     **/\npublic synchronized void setLogStream(OutputStream out) {\n    if (out != null)\n        logStream = new PrintWriter(out);\n    else\n        logStream = null;\n}\n","name":"setLogStream","className":"Server","variables":{"logStream":2,"out":2},"constants":{"null":2},"javaDoc":"A public method to set the current logging stream Pass null to turn logging off","comments":" \n     * A public method to set the current logging stream.  Pass null\n     * to turn logging off\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"flush":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":8,"StringLiteralExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** Write the specified string to the log */\nprotected synchronized void log(String s) {\n    if (logStream != null) {\n        logStream.println(\"[\" + new Date() + \"] \" + s);\n        logStream.flush();\n    }\n}\n","name":"log","className":"Server","variables":{"s":1,"logStream":3},"constants":{"null":1,"\"[\"":1,"\"] \"":1},"javaDoc":"Write the specified string to the log","comments":" Write the specified string to the log ","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"log":1,"toString":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Write the specified object to the log */\nprotected void log(Object o) {\n    log(o.toString());\n}\n","name":"log","className":"Server","variables":{"o":1},"constants":{},"javaDoc":"Write the specified object to the log","comments":" Write the specified object to the log ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Service","int"],"returnType":"void","methodCalls":{"getClass":1,"getName":1,"log":1,"get":1,"start":1,"put":1},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":["Synchronization"],"types":{"Integer":1,"Listener":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":25,"StringLiteralExpr":4,"MethodCallExpr":6},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n     * This method makes the server start providing a new service.\n     * It runs the specified Service object on the specified port.\n     **/\npublic synchronized void addService(Service service, int port) throws IOException {\n    // the hashtable key\n    Integer key = new Integer(port);\n    // Check whether a service is already on that port\n    if (services.get(key) != null)\n        throw new IllegalArgumentException(\"Port \" + port + \" already in use.\");\n    // Create a Listener object to listen for connections on the port\n    Listener listener = new Listener(threadGroup, port, service);\n    // Store it in the hashtable\n    services.put(key, listener);\n    // Log it\n    log(\"Starting service \" + service.getClass().getName() + \" on port \" + port);\n    // Start the listener running.\n    listener.start();\n}\n","name":"addService","className":"Server","variables":{"threadGroup":1,"port":4,"service":2,"listener":2,"services":2,"key":1},"constants":{"null":1,"\" on port \"":1,"\"Starting service \"":1,"\"Port \"":1,"\" already in use.\"":1},"javaDoc":"This method makes the server start providing a new service It runs the specified Service object on the specified port","comments":"the hashtable key Check whether a service is already on that port Create a Listener object to listen for connections on the port Store it in the hashtable Log it Start the listener running \n     * This method makes the server start providing a new service.\n     * It runs the specified Service object on the specified port.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"getName":1,"log":1,"listener.service.getClass":1,"get":1,"pleaseStop":1,"remove":1},"annotations":[],"exceptions":[],"concepts":["Casting","FinalVariables","Synchronization"],"types":{"Integer":1,"Listener":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":23,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/**\n     * This method makes the server stop providing a service on a port.\n     * It does not terminate any pending connections to that service, merely\n     * causes the server to stop accepting new connections\n     **/\npublic synchronized void removeService(int port) {\n    // hashtable key\n    Integer key = new Integer(port);\n    // Look up the Listener object for the port in the hashtable\n    final Listener listener = (Listener) services.get(key);\n    if (listener == null)\n        return;\n    // Ask the listener to stop\n    listener.pleaseStop();\n    // Remove it from the hashtable\n    services.remove(key);\n    // And log it.\n    log(\"Stopping service \" + listener.service.getClass().getName() + \" on port \" + port);\n}\n","name":"removeService","className":"Server","variables":{"port":2,"listener":3,"services":2,"key":1},"constants":{"\"Stopping service \"":1,"null":1,"\" on port \"":1},"javaDoc":"This method makes the server stop providing a service on a port It does not terminate any pending connections to that service merely causes the server to stop accepting new connections","comments":"hashtable key Look up the Listener object for the port in the hashtable Ask the listener to stop Remove it from the hashtable And log it \n     * This method makes the server stop providing a service on a port.\n     * It does not terminate any pending connections to that service, merely\n     * causes the server to stop accepting new connections\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["ThreadGroup","int","Service"],"returnType":"Listener","methodCalls":{"setSoTimeout":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":4},"text":"/**\n\t * The Listener constructor creates a thread for itself in the\n\t * threadgroup.  It creates a ServerSocket to listen for connections\n\t * on the specified port.  It arranges for the ServerSocket to be\n\t * interruptible, so that services can be removed from the server.\n\t **/\npublic Listener(ThreadGroup group, int port, Service service) throws IOException {\n    super(group, \"Listener:\" + port);\n    listen_socket = new ServerSocket(port);\n    // give it a non-zero timeout so accept() can be interrupted\n    listen_socket.setSoTimeout(600000);\n    this.port = port;\n    this.service = service;\n}\n","name":"Listener","className":"Listener","variables":{"port":3,"service":1,"listen_socket":2,"group":1},"constants":{"600000":1,"\"Listener:\"":1},"javaDoc":"The Listener constructor creates a thread for itself in the threadgroup It creates a ServerSocket to listen for connections on the specified port It arranges for the ServerSocket to be interruptible so that services can be removed from the server","comments":"give it a non-zero timeout so accept() can be interrupted \n\t * The Listener constructor creates a thread for itself in the\n\t * threadgroup.  It creates a ServerSocket to listen for connections\n\t * on the specified port.  It arranges for the ServerSocket to be\n\t * interruptible, so that services can be removed from the server.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":7,"FieldAccessExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":3},"text":"/** \n\t * This is the polite way to get a Listener to stop accepting\n\t * connections\n\t ***/\npublic void pleaseStop() {\n    // Set the stop flag\n    this.stop = true;\n    // Stop blocking in accept()\n    this.interrupt();\n    try // Stop listening.\n    {\n        listen_socket.close();\n    } catch (IOException e) {\n    }\n}\n","name":"pleaseStop","className":"Listener","variables":{"e":1,"listen_socket":1},"constants":{"true":1},"javaDoc":"This is the polite way to get a Listener to stop accepting connections","comments":"Set the stop flag Stop blocking in accept() Stop listening  \n\t * This is the polite way to get a Listener to stop accepting\n\t * connections\n\t **","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":1,"addConnection":1,"accept":1},"annotations":[],"exceptions":["InterruptedIOException","IOException"],"concepts":["ExceptionHandling"],"types":{"Socket":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"WhileStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":3},"text":"/**\n\t * A Listener is a Thread, and this is its body.\n\t * Wait for connection requests, accept them, and pass the socket on\n\t * to the addConnection method of the server.\n\t **/\npublic void run() {\n    while (!stop) {\n        // loop until we're asked to stop.\n        try {\n            Socket client = listen_socket.accept();\n            addConnection(client, service);\n        } catch (InterruptedIOException e) {\n        } catch (IOException e) {\n            log(e);\n        }\n    }\n}\n","name":"run","className":"Listener","variables":{"stop":1,"e":2,"client":1,"listen_socket":1},"constants":{},"javaDoc":"A Listener is a Thread and this is its body Wait for connection requests accept them and pass the socket on to the addConnection method of the server","comments":"loop until we're asked to stop \n\t * A Listener is a Thread, and this is its body.\n\t * Wait for connection requests, accept them, and pass the socket on\n\t * to the addConnection method of the server.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Socket","Service"],"returnType":"void","methodCalls":{"getInetAddress":2,"add":1,"getClass":1,"getLocalPort":1,"getName":1,"log":3,"start":1,"print":1,"getPort":2,"size":1,"flush":1,"getOutputStream":1,"getHostAddress":2,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Connection":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":13,"NameExpr":56,"StringLiteralExpr":9,"MethodCallExpr":19},"statements":{"IfStmt":1,"BlockStmt":4,"TryStmt":1,"ExpressionStmt":10},"text":"/**\n     * This is the method that Listener objects call when they accept a\n     * connection from a client.  It either creates a Connection object \n     * for the connection and adds it to the list of current connections,\n     * or, if the limit on connections has been reached, it closes the \n     * connection. \n     **/\nprotected synchronized void addConnection(Socket s, Service service) {\n    // If the connection limit has been reached\n    if (connections.size() >= maxConnections) {\n        try {\n            // Then tell the client it is being rejected.\n            PrintWriter out = new PrintWriter(s.getOutputStream());\n            out.print(\"Connection refused; \" + \"the server is busy; please try again later.\\n\");\n            out.flush();\n            // And close the connection to the rejected client.\n            s.close();\n            // And log it, of course\n            log(\"Connection refused to \" + s.getInetAddress().getHostAddress() + \":\" + s.getPort() + \": max connections reached.\");\n        } catch (IOException e) {\n            log(e);\n        }\n    } else {\n        // Otherwise, if the limit has not been reached\n        // Create a Connection thread to handle this connection\n        Connection c = new Connection(s, service);\n        // Add it to the list of current connections\n        connections.add(c);\n        // Log this new connection\n        log(\"Connected to \" + s.getInetAddress().getHostAddress() + \":\" + s.getPort() + \" on port \" + s.getLocalPort() + \" for service \" + service.getClass().getName());\n        // And start the Connection thread to provide the service\n        c.start();\n    }\n}\n","name":"addConnection","className":"Server","variables":{"s":8,"c":2,"e":1,"service":2,"connections":2,"maxConnections":1,"out":3},"constants":{"\"Connected to \"":1,"\"Connection refused; \"":1,"\" on port \"":1,"\"Connection refused to \"":1,"\" for service \"":1,"\":\"":2,"\"the server is busy; please try again later.\\n\"":1,"\": max connections reached.\"":1},"javaDoc":"This is the method that Listener objects call when they accept a connection from a client It either creates a Connection object for the connection and adds it to the list of current connections or if the limit on connections has been reached it closes the connection","comments":"If the connection limit has been reached Then tell the client it is being rejected And close the connection to the rejected client And log it of course Otherwise if the limit has not been reached Create a Connection thread to handle this connection Add it to the list of current connections Log this new connection And start the Connection thread to provide the service \n     * This is the method that Listener objects call when they accept a\n     * connection from a client.  It either creates a Connection object \n     * for the connection and adds it to the list of current connections,\n     * or, if the limit on connections has been reached, it closes the \n     * connection. \n     *","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["Connection"],"returnType":"void","methodCalls":{"c.client.getInetAddress":1,"log":1,"getHostAddress":1,"c.client.getPort":1,"remove":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":3,"FieldAccessExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":2},"text":"/**\n     * A Connection thread calls this method just before it exits.  It removes\n     * the specified Connection from the set of connections.\n     **/\nprotected synchronized void endConnection(Connection c) {\n    connections.remove(c);\n    log(\"Connection to \" + c.client.getInetAddress().getHostAddress() + \":\" + c.client.getPort() + \" closed.\");\n}\n","name":"endConnection","className":"Server","variables":{"connections":1},"constants":{"\"Connection to \"":1,"\":\"":1,"\" closed.\"":1},"javaDoc":"A Connection thread calls this method just before it exits It removes the specified Connection from the set of connections","comments":"\n     * A Connection thread calls this method just before it exits.  It removes\n     * the specified Connection from the set of connections.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Change the current connection limit */\npublic synchronized void setMaxConnections(int max) {\n    maxConnections = max;\n}\n","name":"setMaxConnections","className":"Server","variables":{"max":1,"maxConnections":1},"constants":{},"javaDoc":"Change the current connection limit","comments":" Change the current connection limit ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"next":2,"c.service.getClass":1,"getName":2,"c.client.getInetAddress":1,"c.client.getLocalPort":1,"listener.service.getClass":1,"hasNext":2,"iterator":2,"print":3,"get":1,"getHostAddress":1,"c.client.getPort":1,"keySet":1},"annotations":[],"exceptions":[],"concepts":["Casting","Synchronization"],"types":{"Integer":1,"Listener":1,"Iterator":2,"Connection":1},"expressions":{"VariableDeclarationExpr":5,"BinaryExpr":14,"NameExpr":66,"CastExpr":3,"StringLiteralExpr":10,"FieldAccessExpr":5,"MethodCallExpr":19},"statements":{"WhileStmt":2,"BlockStmt":2,"ExpressionStmt":8},"text":"/**\n     * This method displays status information about the server on the\n     * specified stream.  It can be used for debugging, and is used by the\n     * Control service later in this example.\n     **/\npublic synchronized void displayStatus(PrintWriter out) {\n    // Display a list of all Services that are being provided\n    Iterator keys = services.keySet().iterator();\n    while (keys.hasNext()) {\n        Integer port = (Integer) keys.next();\n        Listener listener = (Listener) services.get(port);\n        out.print(\"SERVICE \" + listener.service.getClass().getName() + \" ON PORT \" + port + \"\\n\");\n    }\n    // Display the current connection limit\n    out.print(\"MAX CONNECTIONS: \" + maxConnections + \"\\n\");\n    // Display a list of all current connections\n    Iterator conns = connections.iterator();\n    while (conns.hasNext()) {\n        Connection c = (Connection) conns.next();\n        out.print(\"CONNECTED TO \" + c.client.getInetAddress().getHostAddress() + \":\" + c.client.getPort() + \" ON PORT \" + c.client.getLocalPort() + \" FOR SERVICE \" + c.service.getClass().getName() + \"\\n\");\n    }\n}\n","name":"displayStatus","className":"Server","variables":{"conns":3,"c":1,"port":2,"keys":3,"listener":1,"services":2,"connections":1,"out":3,"maxConnections":1},"constants":{"\"CONNECTED TO \"":1,"\"SERVICE \"":1,"\" ON PORT \"":2,"\" FOR SERVICE \"":1,"\"MAX CONNECTIONS: \"":1,"\":\"":1,"\"\\n\"":3},"javaDoc":"This method displays status information about the server on the specified stream It can be used for debugging and is used by the Control service later in this example","comments":"Display a list of all Services that are being provided Display the current connection limit Display a list of all current connections \n     * This method displays status information about the server on the\n     * specified stream.  It can be used for debugging, and is used by the\n     * Control service later in this example.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["Socket","Service"],"returnType":"Connection","methodCalls":{"getInetAddress":1,"getPort":1,"getHostAddress":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":14,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":3,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"/**\n\t * This constructor just saves some state and calls the superclass\n\t * constructor to create a thread to handle the connection.  Connection\n\t * objects are created by Listener threads.  These threads are part of\n\t * the server's ThreadGroup, so all Connection threads are part of that\n\t * group, too.\n\t **/\npublic Connection(Socket client, Service service) {\n    super(\"Server.Connection:\" + client.getInetAddress().getHostAddress() + \":\" + client.getPort());\n    this.client = client;\n    this.service = service;\n}\n","name":"Connection","className":"Connection","variables":{"service":1,"client":3},"constants":{"\"Server.Connection:\"":1,"\":\"":1},"javaDoc":"This constructor just saves some state and calls the superclass constructor to create a thread to handle the connection Connection objects are created by Listener threads These threads are part of the server's ThreadGroup so all Connection threads are part of that group too","comments":"\n\t * This constructor just saves some state and calls the superclass\n\t * constructor to create a thread to handle the connection.  Connection\n\t * objects are created by Listener threads.  These threads are part of\n\t * the server's ThreadGroup, so all Connection threads are part of that\n\t * group, too.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"log":1,"getOutputStream":1,"serve":1,"endConnection":1,"getInputStream":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"InputStream":1,"OutputStream":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":16,"ThisExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":1,"BlockStmt":3,"ExpressionStmt":5},"text":"/**\n\t * This is the body of each and every Connection thread.\n\t * All it does is pass the client input and output streams to the\n\t * serve() method of the specified Service object.  That method is\n\t * responsible for reading from and writing to those streams to\n\t * provide the actual service.  Recall that the Service object has\n\t * been passed from the Server.addService() method to a Listener\n\t * object to the addConnection() method to this Connection object, and\n\t * is now finally being used to provide the service.  Note that just\n\t * before this thread exits it always calls the endConnection() method\n\t * to remove itself from the set of connections\n\t **/\npublic void run() {\n    try {\n        InputStream in = client.getInputStream();\n        OutputStream out = client.getOutputStream();\n        service.serve(in, out);\n    } catch (IOException e) {\n        log(e);\n    } finally {\n        endConnection(this);\n    }\n}\n","name":"run","className":"Connection","variables":{"in":1,"e":1,"service":1,"client":2,"out":1},"constants":{},"javaDoc":"This is the body of each and every Connection thread All it does is pass the client input and output streams to the serve() method of the specified Service object That method is responsible for reading from and writing to those streams to provide the actual service Recall that the Service object has been passed from the Server addService() method to a Listener object to the addConnection() method to this Connection object and is now finally being used to provide the service Note that just before this thread exits it always calls the endConnection() method to remove itself from the set of connections","comments":"\n\t * This is the body of each and every Connection thread.\n\t * All it does is pass the client input and output streams to the\n\t * serve() method of the specified Service object.  That method is\n\t * responsible for reading from and writing to those streams to\n\t * provide the actual service.  Recall that the Service object has\n\t * been passed from the Server.addService() method to a Listener\n\t * object to the addConnection() method to this Connection object, and\n\t * is now finally being used to provide the service.  Note that just\n\t * before this thread exits it always calls the endConnection() method\n\t * to remove itself from the set of connections\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void serve(InputStream in, OutputStream out) throws IOException;\n","name":"serve","className":"Service","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(o);\n    out.print(new Date() + \"\\n\");\n    out.close();\n    i.close();\n}\n","name":"serve","className":"Time","variables":{"i":1,"out":3,"o":1},"constants":{"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":5,"flush":1,"equals":1,"length":1,"readLine":1,"close":2,"charAt":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1,"int":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":4,"NameExpr":42,"StringLiteralExpr":5,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":2,"ExpressionStmt":11},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(o)));\n    out.print(\"Welcome to the line reversal server.\\n\");\n    out.print(\"Enter lines.  End with a '.' on a line by itself.\\n\");\n    for (; ; ) {\n        out.print(\"> \");\n        out.flush();\n        String line = in.readLine();\n        if ((line == null) || line.equals(\".\"))\n            break;\n        for (int j = line.length() - 1; j >= 0; j--) out.print(line.charAt(j));\n        out.print(\"\\n\");\n    }\n    out.close();\n    in.close();\n}\n","name":"serve","className":"Reverse","variables":{"in":3,"line":5,"i":1,"j":3,"out":8,"o":1},"constants":{"0":1,"\"Welcome to the line reversal server.\\n\"":1,"1":1,"\"Enter lines.  End with a '.' on a line by itself.\\n\"":1,"null":1,"\".\"":1,"\"> \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":3,"length":1,"readLine":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"BufferedReader":1,"String":1,"PrintWriter":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":25,"StringLiteralExpr":3,"EnclosedExpr":1,"MethodCallExpr":7,"AssignExpr":1},"statements":{"IfStmt":1,"WhileStmt":1,"BreakStmt":1,"BlockStmt":1,"ExpressionStmt":8},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(o);\n    out.print(\"HTTP/1.0 200 \\n\");\n    out.print(\"Content-Type: text/plain\\n\\n\");\n    String line;\n    while ((line = in.readLine()) != null) {\n        if (line.length() == 0)\n            break;\n        out.print(line + \"\\n\");\n    }\n    out.close();\n    in.close();\n}\n","name":"serve","className":"HTTPMirror","variables":{"in":3,"line":4,"i":1,"out":5,"o":1},"constants":{"0":1,"\"HTTP/1.0 200 \\n\"":1,"null":1,"\"Content-Type: text/plain\\n\\n\"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":1,"UnaryExpr":1},"statements":{"ReturnStmt":1},"text":"public synchronized int nextId() {\n    return id++;\n}\n","name":"nextId","className":"UniqueID","variables":{"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"print":1,"nextId":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"PrintWriter":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":12,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void serve(InputStream i, OutputStream o) throws IOException {\n    PrintWriter out = new PrintWriter(o);\n    out.print(\"You are client #: \" + nextId() + \"\\n\");\n    out.close();\n    i.close();\n}\n","name":"serve","className":"UniqueID","variables":{"i":1,"out":3,"o":1},"constants":{"\"You are client #: \"":1,"\"\\n\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Server","String"],"returnType":"Control","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n\t * Create a new Control service.  It will control the specified Server\n\t * object, and will require the specified password for authorization\n\t * Note that this Service does not have a no argument constructor,\n\t * which means that it cannot be dynamically instantiated and added as\n\t * the other, generic services above can be.\n\t **/\npublic Control(Server server, String password) {\n    this.server = server;\n    this.password = password;\n}\n","name":"Control","className":"Control","variables":{"server":1,"password":1},"constants":{},"javaDoc":"Create a new Control service It will control the specified Server object and will require the specified password for authorization Note that this Service does not have a no argument constructor which means that it cannot be dynamically instantiated and added as the other generic services above can be","comments":"\n\t * Create a new Control service.  It will control the specified Server\n\t * object, and will require the specified password for authorization\n\t * Note that this Service does not have a no argument constructor,\n\t * which means that it cannot be dynamically instantiated and added as\n\t * the other, generic services above can be.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["InputStream","OutputStream"],"returnType":"void","methodCalls":{"hasMoreTokens":1,"forName":1,"toLowerCase":1,"newInstance":1,"displayStatus":1,"readLine":1,"setMaxConnections":1,"parseInt":3,"print":14,"flush":1,"removeService":1,"addService":1,"nextToken":6,"equals":8,"close":3},"annotations":[],"exceptions":["IOException","NoSuchMethodError","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"StringTokenizer":1,"boolean":1,"BufferedReader":1,"Service":1,"Class":1,"String":4,"int":3,"PrintWriter":1},"expressions":{"ObjectCreationExpr":5,"VariableDeclarationExpr":13,"BinaryExpr":11,"NameExpr":154,"StringLiteralExpr":31,"UnaryExpr":5,"AssignExpr":5,"NullLiteralExpr":1,"BooleanLiteralExpr":4,"CastExpr":1,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":44},"statements":{"ContinueStmt":1,"IfStmt":15,"BreakStmt":2,"BlockStmt":17,"TryStmt":2,"SynchronizedStmt":1,"ReturnStmt":1,"ForStmt":1,"ThrowStmt":1,"ExpressionStmt":40},"text":"/**\n\t * This is the serve method that provides the service.  It reads a\n\t * line the client, and uses java.util.StringTokenizer to parse it\n\t * into commands and arguments.  It does various things depending on\n\t * the command.\n\t **/\npublic void serve(InputStream i, OutputStream o) throws IOException {\n    // Setup the streams\n    BufferedReader in = new BufferedReader(new InputStreamReader(i));\n    PrintWriter out = new PrintWriter(o);\n    // For reading client input lines\n    String line;\n    // Has the user has given the password yet?\n    boolean authorized = false;\n    // synchronized block to prevent a race condition.\n    synchronized (this) {\n        if (connected) {\n            out.print(\"ONLY ONE CONTROL CONNECTION ALLOWED.\\n\");\n            out.close();\n            return;\n        } else\n            connected = true;\n    }\n    // This is the main loop: read a command, parse it, and handle it\n    for (; ; ) {\n        // infinite loop\n        // Display a prompt\n        out.print(\"> \");\n        // Make it appear right away\n        out.flush();\n        // Get the user's input\n        line = in.readLine();\n        // Quit if we get EOF.\n        if (line == null)\n            break;\n        try {\n            // Use a StringTokenizer to parse the user's command\n            StringTokenizer t = new StringTokenizer(line);\n            // if input was empty\n            if (!t.hasMoreTokens())\n                continue;\n            // Get first word of the input and convert to lower case\n            String command = t.nextToken().toLowerCase();\n            // appropriate thing for each command\n            if (command.equals(\"password\")) {\n                // Password command\n                // Get the next word\n                String p = t.nextToken();\n                if (p.equals(this.password)) {\n                    // Is it the password?\n                    // Say so\n                    out.print(\"OK\\n\");\n                    // Grant authorization\n                    authorized = true;\n                } else\n                    // Otherwise fail\n                    out.print(\"INVALID PASSWORD\\n\");\n            } else if (command.equals(\"add\")) {\n                // Check whether password has been given\n                if (!authorized)\n                    out.print(\"PASSWORD REQUIRED\\n\");\n                else {\n                    // Get the name of the service and try to\n                    // dynamically load and instantiate it.\n                    // Exceptions will be handled below\n                    String serviceName = t.nextToken();\n                    Class serviceClass = Class.forName(serviceName);\n                    Service service;\n                    try {\n                        service = (Service) serviceClass.newInstance();\n                    } catch (NoSuchMethodError e) {\n                        throw new IllegalArgumentException(\"Service must have a \" + \"no-argument constructor\");\n                    }\n                    int port = Integer.parseInt(t.nextToken());\n                    // If no exceptions occurred, add the service\n                    server.addService(service, port);\n                    // acknowledge\n                    out.print(\"SERVICE ADDED\\n\");\n                }\n            } else if (command.equals(\"remove\")) {\n                // Remove service\n                if (!authorized)\n                    out.print(\"PASSWORD REQUIRED\\n\");\n                else {\n                    int port = Integer.parseInt(t.nextToken());\n                    // remove the service\n                    server.removeService(port);\n                    // acknowledge\n                    out.print(\"SERVICE REMOVED\\n\");\n                }\n            } else if (command.equals(\"max\")) {\n                // Set connection limit\n                if (!authorized)\n                    out.print(\"PASSWORD REQUIRED\\n\");\n                else {\n                    int max = Integer.parseInt(t.nextToken());\n                    server.setMaxConnections(max);\n                    out.print(\"MAX CONNECTIONS CHANGED\\n\");\n                }\n            } else if (command.equals(\"status\")) {\n                // Status Display\n                if (!authorized)\n                    out.print(\"PASSWORD REQUIRED\\n\");\n                else\n                    server.displayStatus(out);\n            } else if (command.equals(\"help\")) {\n                // Help command\n                // Display command syntax.  Password not required\n                out.print(\"COMMANDS:\\n\" + \"\\tpassword <password>\\n\" + \"\\tadd <service> <port>\\n\" + \"\\tremove <port>\\n\" + \"\\tmax <max-connections>\\n\" + \"\\tstatus\\n\" + \"\\thelp\\n\" + \"\\tquit\\n\");\n            } else if (// Quit command.\n            command.equals(\"quit\"))\n                // Quit command.\n                break;\n            else\n                // Error\n                out.print(\"UNRECOGNIZED COMMAND\\n\");\n        } catch (Exception e) {\n            out.print(\"ERROR WHILE PARSING OR EXECUTING COMMAND:\\n\" + e + \"\\n\");\n        }\n    }\n    // Finally, when the loop command loop ends, close the streams\n    // and set our connected flag to false so that other clients can\n    // now connect.\n    connected = false;\n    out.close();\n    in.close();\n}\n             // If there is already a client connected to this service, display\n\n             // a message to this client and close the connection.  We use a\n\n                     // Now compare to each of the possible commands, doing the\n\n                                                        // Add Service command\n\n                     // If an exception occurred during the command, print an\n\n                     // error message, then output details of the exception.\n\n","name":"serve","className":"Control","variables":{"server":4,"serviceClass":2,"in":3,"e":3,"max":1,"line":4,"i":1,"serviceName":1,"command":8,"out":18,"o":1,"connected":3,"p":2,"Integer":3,"t":8,"port":2,"service":2,"authorized":6,"Class":1},"constants":{"\"remove\"":1,"\"\\tquit\\n\"":1,"\"UNRECOGNIZED COMMAND\\n\"":1,"\"ERROR WHILE PARSING OR EXECUTING COMMAND:\\n\"":1,"\"> \"":1,"\"SERVICE ADDED\\n\"":1,"\"\\tstatus\\n\"":1,"\"add\"":1,"\"SERVICE REMOVED\\n\"":1,"\"\\tmax <max-connections>\\n\"":1,"\"OK\\n\"":1,"\"status\"":1,"\"Service must have a \"":1,"\"\\thelp\\n\"":1,"\"quit\"":1,"\"\\tadd <service> <port>\\n\"":1,"\"\\tpassword <password>\\n\"":1,"false":2,"\"no-argument constructor\"":1,"\"MAX CONNECTIONS CHANGED\\n\"":1,"\"ONLY ONE CONTROL CONNECTION ALLOWED.\\n\"":1,"\"password\"":1,"\"\\tremove <port>\\n\"":1,"\"COMMANDS:\\n\"":1,"\"INVALID PASSWORD\\n\"":1,"\"max\"":1,"\"help\"":1,"null":1,"true":2,"\"PASSWORD REQUIRED\\n\"":4,"\"\\n\"":1},"javaDoc":"This is the serve method that provides the service It reads a line the client and uses java util StringTokenizer to parse it into commands and arguments It does various things depending on the command","comments":"If there is already a client connected to this service display a message to this client and close the connection We use a Finally when the loop command loop ends close the streams and set our connected flag to false so that other clients can Setup the streams For reading client input lines Has the user has given the password yet? synchronized block to prevent a race condition This is the main loop: read a command parse it and handle it infinite loop Display a prompt Make it appear right away Get the user's input Quit if we get EOF Now compare to each of the possible commands doing the Use a StringTokenizer to parse the user's command if input was empty Get first word of the input and convert to lower case appropriate thing for each command Password command Get the next word Is it the password? Say so Grant authorization Otherwise fail Add Service command Check whether password has been given Get the name of the service and try to dynamically load and instantiate it Exceptions will be handled below If no exceptions occurred add the service acknowledge Remove service remove the service acknowledge Set connection limit Status Display Help command Display command syntax Password not required Quit command Quit command Error If an exception occurred during the command print an error message then output details of the exception now connect \n\t * This is the serve method that provides the service.  It reads a\n\t * line the client, and uses java.util.StringTokenizer to parse it\n\t * into commands and arguments.  It does various things depending on\n\t * the command.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Throwable"],"returnType":"void","methodCalls":{"getClass":2,"getName":2,"printStackTrace":3,"format":1,"getMessage":2,"getString":1,"getBundle":1,"substring":2,"parseInt":1,"lastIndexOf":1,"toString":1,"indexOf":3,"getSuperclass":1,"System.out.println":1},"annotations":[],"exceptions":["MissingResourceException","Exception"],"concepts":["ExceptionHandling"],"types":{"StringWriter":1,"ResourceBundle":1,"Class":1,"String":4,"int":3,"Object[]":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":4,"VariableDeclarationExpr":12,"BinaryExpr":9,"NameExpr":98,"StringLiteralExpr":3,"CharLiteralExpr":4,"ConditionalExpr":1,"AssignExpr":7,"NullLiteralExpr":5,"ArrayInitializerExpr":1,"FieldAccessExpr":3,"ClassExpr":1,"EnclosedExpr":4,"MethodCallExpr":22},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":3,"BlockStmt":8,"EmptyStmt":1,"ReturnStmt":2,"ExpressionStmt":23},"text":"public static void display(Throwable error) {\n    ResourceBundle bundle;\n    // If none, print the error in a non-localized way.\n    try {\n        bundle = ResourceBundle.getBundle(\"Errors\");\n    } catch (MissingResourceException e) {\n        error.printStackTrace(System.err);\n        return;\n    }\n    // Look up a localized message resource in that bundle, using the\n    // classname of the error (or its superclasses) as the resource name.\n    // If no resource was found, display the error without localization.\n    String message = null;\n    Class c = error.getClass();\n    while ((message == null) && (c != Object.class)) {\n        try {\n            message = bundle.getString(c.getName());\n        } catch (MissingResourceException e) {\n            c = c.getSuperclass();\n        }\n    }\n    if (message == null) {\n        error.printStackTrace(System.err);\n        return;\n    }\n    // Try to figure out the filename and line number of the\n    // exception.  Output the error's stack trace into a string, and\n    // use the heuristic that the first line number that appears in\n    // the stack trace is after the first or  second colon.  We assume that\n    // this stack frame is the first one the programmer has any control\n    // over, and so report it as the location of the exception.\n    // Note that this is implementation-dependent and not robust...\n         // Try to get the resource bundle.\n\n    String filename = \"\";\n    int linenum = 0;\n    try {\n        // Output stream to a string.\n        StringWriter sw = new StringWriter();\n        // PrintWriter wrapper.\n        PrintWriter out = new PrintWriter(sw);\n        // Print stacktrace.\n        error.printStackTrace(out);\n        // Get it as a string.\n        String trace = sw.toString();\n        // Look for first colon.\n        int pos = trace.indexOf(':');\n        if (// If the error has a message\n        error.getMessage() != null)\n            // look for second colon.\n            pos = trace.indexOf(':', pos + 1);\n        // Look for end of line #\n        int pos2 = trace.indexOf(')', pos);\n        // line #\n        linenum = Integer.parseInt(trace.substring(pos + 1, pos2));\n        // Back to start of filename.\n        pos2 = trace.lastIndexOf('(', pos);\n        // Get filename.\n        filename = trace.substring(pos2 + 1, pos);\n    }// Ignore exceptions.\n     catch (Exception e) {\n        ;\n    }\n    // Set up an array of arguments to use with the message\n    String errmsg = error.getMessage();\n    Object[] args = { ((errmsg != null) ? errmsg : \"\"), error.getClass().getName(), filename, new Integer(linenum), new Date() };\n    // Finally, display the localized error message, using\n    // MessageFormat.format() to substitute the arguments into the message.\n    System.out.println(MessageFormat.format(message, args));\n}\n","name":"display","className":"LocalizedError","variables":{"c":5,"sw":3,"MessageFormat":1,"e":3,"errmsg":3,"pos2":3,"error":7,"message":4,"out":1,"Integer":1,"args":1,"trace":7,"filename":3,"pos":4,"linenum":3,"ResourceBundle":1,"bundle":3},"constants":{"\"\"":2,"0":1,"1":3,"null":5,"':'":2,"')'":1,"'('":1,"\"Errors\"":1},"javaDoc":"","comments":"Try to get the resource bundle Look up a localized message resource in that bundle using the classname of the error (or its superclasses) as the resource name Try to figure out the filename and line number of the exception Output the error's stack trace into a string and use the heuristic that the first line number that appears in the stack trace is after the first or second colon We assume that this stack frame is the first one the programmer has any control over and so report it as the location of the exception Finally display the localized error message using If none print the error in a non-localized way If no resource was found display the error without localization Note that this is implementation-dependent and not robust Output stream to a string PrintWriter wrapper Print stacktrace Get it as a string Look for first colon If the error has a message look for second colon Look for end of line # line # Back to start of filename Get filename Ignore exceptions Set up an array of arguments to use with the message MessageFormat format() to substitute the arguments into the message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"display":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"FileReader":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"/** \n     * This is a simple test program that demonstrates the display() method.\n     * You can use it to generate and display a FileNotFoundException or an\n     * ArrayIndexOutOfBoundsException\n     **/\npublic static void main(String[] args) {\n    try {\n        FileReader in = new FileReader(args[0]);\n    } catch (Exception e) {\n        LocalizedError.display(e);\n    }\n}\n","name":"main","className":"LocalizedError","variables":{"args":1,"in":1,"e":1,"LocalizedError":1},"constants":{"0":1},"javaDoc":"This is a simple test program that demonstrates the display() method You can use it to generate and display a FileNotFoundException or an ArrayIndexOutOfBoundsException","comments":" \n     * This is a simple test program that demonstrates the display() method.\n     * You can use it to generate and display a FileNotFoundException or an\n     * ArrayIndexOutOfBoundsException\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["EquityPosition[]","Date"],"returnType":"Portfolio","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"public Portfolio(EquityPosition[] positions, Date lastQuoteTime) {\n    this.positions = positions;\n    this.lastQuoteTime = lastQuoteTime;\n}\n","name":"Portfolio","className":"Portfolio","variables":{"lastQuoteTime":1,"positions":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"getDateTimeInstance":1,"println":3,"print":5,"flush":1,"format":6,"getInstance":1,"getCurrencyInstance":1,"getPercentInstance":1,"getDateInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"DateFormat":2,"int":1,"NumberFormat":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":8,"BinaryExpr":11,"NameExpr":108,"StringLiteralExpr":9,"FieldAccessExpr":12,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":20},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":15},"text":"public void print(PrintWriter out) {\n    // Obtain NumberFormat and DateFormat objects to format our data.\n    NumberFormat number = NumberFormat.getInstance();\n    NumberFormat price = NumberFormat.getCurrencyInstance();\n    NumberFormat percent = NumberFormat.getPercentInstance();\n    DateFormat shortdate = DateFormat.getDateInstance(DateFormat.MEDIUM);\n    DateFormat fulldate = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);\n    // Print some introductory data.\n    out.println(\"Portfolio value at \" + fulldate.format(lastQuoteTime) + \":\");\n    out.println(\"Symbol\\tShares\\tPurchased\\tAt\\t\" + \"Quote\\tChange\");\n    // Display the table using the format() methods of the Format objects.\n    for (int i = 0; i < positions.length; i++) {\n        out.print(positions[i].name + \"\\t\");\n        out.print(number.format(positions[i].shares) + \"\\t\");\n        out.print(shortdate.format(positions[i].purchased) + \"\\t\");\n        out.print(price.format(positions[i].bought) + \"\\t\");\n        out.print(price.format(positions[i].current) + \"\\t\");\n        double change = (positions[i].current - positions[i].bought) / positions[i].bought;\n        out.println(percent.format(change));\n        out.flush();\n    }\n}\n","name":"print","className":"Portfolio","variables":{"fulldate":2,"number":2,"price":3,"DateFormat":2,"change":1,"i":11,"positions":8,"percent":2,"NumberFormat":3,"shortdate":2,"out":9},"constants":{"0":1,"\"Portfolio value at \"":1,"\"Quote\\tChange\"":1,"\"\\t\"":5,"\":\"":1,"\"Symbol\\tShares\\tPurchased\\tAt\\t\"":1},"javaDoc":"","comments":"Obtain NumberFormat and DateFormat objects to format our data Print some introductory data Display the table using the format() methods of the Format objects ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","Date","double","double"],"returnType":"EquityPosition","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"AssignExpr":5},"statements":{"ExpressionStmt":5},"text":"EquityPosition(String n, int s, Date when, double then, double now) {\n    name = n;\n    shares = s;\n    purchased = when;\n    bought = then;\n    current = now;\n}\n","name":"EquityPosition","className":"EquityPosition","variables":{"shares":1,"current":1,"s":1,"purchased":1,"bought":1,"now":1,"name":1,"then":1,"when":1,"n":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"print":1,"setDefault":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Portfolio":1,"EquityPosition[]":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":15,"VariableDeclarationExpr":2,"ArrayInitializerExpr":1,"DoubleLiteralExpr":6,"ArrayAccessExpr":2,"BinaryExpr":1,"StringLiteralExpr":3,"NameExpr":15,"FieldAccessExpr":2,"ArrayCreationExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":4},"text":"/**\n     * This is a test program that demonstrates the class\n     **/\npublic static void main(String[] args) {\n    // This is the portfolio to display.  Note we use a deprecated\n    // Date() constructor here for convenience. It represents the year\n    // offset from 1900, and will cause a warning message when compiling.\n    EquityPosition[] positions = new EquityPosition[] { new EquityPosition(\"XXX\", 400, new Date(100, 1, 3), 11.90, 13.00), new EquityPosition(\"YYY\", 1100, new Date(100, 2, 2), 71.09, 27.25), new EquityPosition(\"ZZZ\", 6000, new Date(100, 4, 17), 23.37, 89.12) };\n    // Create the portfolio from these positions\n    Portfolio portfolio = new Portfolio(positions, new Date());\n    // specified on the command line.\n    if (args.length == 2)\n        Locale.setDefault(new Locale(args[0], args[1]));\n    // Now print the portfolio\n    portfolio.print(new PrintWriter(System.out));\n}\n         // Set the default locale using the language code and country code\n\n","name":"main","className":"Portfolio","variables":{"Locale":1,"args":2,"portfolio":2,"positions":2},"constants":{"89.12":1,"\"YYY\"":1,"71.09":1,"\"ZZZ\"":1,"6000":1,"\"XXX\"":1,"13.00":1,"17":1,"23.37":1,"11.90":1,"0":1,"100":3,"1":2,"2":3,"3":1,"400":1,"4":1,"27.25":1,"1100":1},"javaDoc":"This is a test program that demonstrates the class","comments":"This is the portfolio to display Note we use a deprecated Date() constructor here for convenience It represents the year Set the default locale using the language code and country code offset from 1900 and will cause a warning message when compiling Create the portfolio from these positions specified on the command line Now print the portfolio \n     * This is a test program that demonstrates the class\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResourceBundle","String","String[]","ActionListener"],"returnType":"JMenu","methodCalls":{"add":1,"addActionListener":1,"setActionCommand":1,"getString":3,"getKeyStroke":1,"setAccelerator":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{"String":3,"JMenuItem":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"ArrayAccessExpr":4,"BinaryExpr":9,"NameExpr":52,"StringLiteralExpr":5,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":8},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":8,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":13},"text":"/** The convenience method that creates menu panes */\npublic static JMenu create(ResourceBundle bundle, String menuname, String[] itemnames, ActionListener listener) {\n    // Get the menu title from the bundle.  Use name as default label.\n    String menulabel;\n    try {\n        menulabel = bundle.getString(menuname + \".label\");\n    } catch (MissingResourceException e) {\n        menulabel = menuname;\n    }\n    // Create the menu pane.\n    JMenu menu = new JMenu(menulabel);\n    // For each named item in the menu.\n    for (int i = 0; i < itemnames.length; i++) {\n        // Look up the label for the item, using name as default.\n        String itemlabel;\n        try {\n            itemlabel = bundle.getString(menuname + \".\" + itemnames[i] + \".label\");\n        } catch (MissingResourceException e) {\n            itemlabel = itemnames[i];\n        }\n        JMenuItem item = new JMenuItem(itemlabel);\n        // Look up an accelerator for the menu item\n        try {\n            String acceleratorText = bundle.getString(menuname + \".\" + itemnames[i] + \".accelerator\");\n            item.setAccelerator(KeyStroke.getKeyStroke(acceleratorText));\n        } catch (MissingResourceException e) {\n        }\n        // Register an action listener and command for the item.\n        if (listener != null) {\n            item.addActionListener(listener);\n            item.setActionCommand(itemnames[i]);\n        }\n        // Add the item to the menu.\n        menu.add(item);\n    }\n    // Return the automatically created localized menu.\n    return menu;\n}\n","name":"create","className":"SimpleMenu","variables":{"item":4,"menuname":4,"e":3,"menulabel":4,"KeyStroke":1,"listener":1,"i":7,"menu":3,"bundle":3,"acceleratorText":1,"itemnames":4,"itemlabel":4},"constants":{"0":1,"\".accelerator\"":1,"null":1,"\".\"":2,"\".label\"":2},"javaDoc":"The convenience method that creates menu panes","comments":"Get the menu title from the bundle Use name as default label Create the menu pane For each named item in the menu Look up the label for the item using name as default Look up an accelerator for the menu item Register an action listener and command for the item Add the item to the menu Return the automatically created localized menu  The convenience method that creates menu panes ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"equals":3,"getContentPane":1,"getActionCommand":1,"setBackground":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"Component":1},"expressions":{"VariableDeclarationExpr":2,"NameExpr":33,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":8},"statements":{"IfStmt":3,"ExpressionStmt":5},"text":"public void actionPerformed(ActionEvent e) {\n    String s = e.getActionCommand();\n    Component c = f.getContentPane();\n    if (s.equals(\"red\"))\n        c.setBackground(Color.red);\n    else if (s.equals(\"green\"))\n        c.setBackground(Color.green);\n    else if (s.equals(\"blue\"))\n        c.setBackground(Color.blue);\n}\n","name":"actionPerformed","className":"","variables":{"s":4,"c":4,"e":1,"f":1},"constants":{"\"red\"":1,"\"blue\"":1,"\"green\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setJMenuBar":1,"add":1,"setVisible":1,"setSize":1,"getDisplayName":1,"equals":3,"getContentPane":1,"create":1,"getDefault":2,"getActionCommand":1,"setBackground":3,"getBundle":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"Locale":1,"ActionListener":1,"JFrame":1,"ResourceBundle":1,"String":1,"Component":1,"JMenuBar":1,"JMenu":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":4,"VariableDeclarationExpr":8,"ArrayAccessExpr":2,"BinaryExpr":2,"NameExpr":74,"StringLiteralExpr":9,"AssignExpr":2,"ArrayInitializerExpr":1,"BooleanLiteralExpr":1,"FieldAccessExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":4,"BlockStmt":1,"ExpressionStmt":17},"text":"/** A simple test program for the above code */\npublic static void main(String[] args) {\n    // Get the locale: default, or specified on command-line\n    Locale locale;\n    if (args.length == 2)\n        locale = new Locale(args[0], args[1]);\n    else\n        locale = Locale.getDefault();\n    // Get the resource bundle for that Locale.  This will throw an\n    // (unchecked) MissingResourceException if no bundle is found.\n    ResourceBundle bundle = ResourceBundle.getBundle(\"com.davidflanagan.examples.i18n.Menus\", locale);\n    // Create a simple GUI window to display the menu with\n    final JFrame f = new JFrame(// Window title\n    \"SimpleMenu: \" + locale.getDisplayName(Locale.getDefault()));\n    // Create a menubar.\n    JMenuBar menubar = new JMenuBar();\n    // Add menubar to window\n    f.setJMenuBar(menubar);\n    // Define an action listener for that our menu will use.\n    ActionListener listener = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String s = e.getActionCommand();\n            Component c = f.getContentPane();\n            if (s.equals(\"red\"))\n                c.setBackground(Color.red);\n            else if (s.equals(\"green\"))\n                c.setBackground(Color.green);\n            else if (s.equals(\"blue\"))\n                c.setBackground(Color.blue);\n        }\n    };\n    // Now create a menu using our convenience routine with the resource\n    // bundle and action listener we've created\n    JMenu menu = SimpleMenu.create(bundle, \"colors\", new String[] { \"red\", \"green\", \"blue\" }, listener);\n    // Finally add the menu to the GUI, and pop it up\n    // Add the menu to the menubar\n    menubar.add(menu);\n    // Set the window size.\n    f.setSize(300, 150);\n    // Pop the window up.\n    f.setVisible(true);\n}\n","name":"main","className":"SimpleMenu","variables":{"Locale":2,"c":4,"e":2,"f":5,"listener":1,"SimpleMenu":1,"locale":4,"menu":1,"args":2,"menubar":2,"actionPerformed":1,"s":4,"ResourceBundle":1,"bundle":1},"constants":{"0":1,"\"colors\"":1,"1":1,"2":1,"300":1,"\"red\"":2,"true":1,"\"blue\"":2,"\"com.davidflanagan.examples.i18n.Menus\"":1,"150":1,"\"green\"":2},"javaDoc":"A simple test program for the above code","comments":"Get the resource bundle for that Locale This will throw an Now create a menu using our convenience routine with the resource Finally add the menu to the GUI and pop it up Get the locale: default or specified on command-line (unchecked) MissingResourceException if no bundle is found Create a simple GUI window to display the menu with Window title Create a menubar Add menubar to window Define an action listener for that our menu will use bundle and action listener we've created Add the menu to the menubar Set the window size Pop the window up  A simple test program for the above code ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"usage":2,"display":1,"convert":1},"annotations":[],"exceptions":["// Handle exceptions.\nException"],"concepts":["ExceptionHandling"],"types":{"String":2,"int":1},"expressions":{"NullLiteralExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":8,"BinaryExpr":3,"NameExpr":54,"StringLiteralExpr":4,"FieldAccessExpr":2,"UnaryExpr":5,"MethodCallExpr":9,"AssignExpr":4},"statements":{"IfStmt":5,"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"public static void main(String[] args) {\n    String from = null, to = null;\n    String infile = null, outfile = null;\n    for (int i = 0; i < args.length; i++) {\n        // All args require another.\n        if (i == args.length - 1)\n            usage();\n        if (args[i].equals(\"-from\"))\n            from = args[++i];\n        else if (args[i].equals(\"-to\"))\n            to = args[++i];\n        else if (args[i].equals(\"-in\"))\n            infile = args[++i];\n        else if (args[i].equals(\"-out\"))\n            outfile = args[++i];\n        else\n            usage();\n    }\n                                                // Parse command-line arguments.\n\n    try // Attempt conversion.\n    {\n        convert(infile, outfile, from, to);\n    } catch (// Handle exceptions.\n    Exception // Handle exceptions.\n    e) {\n        LocalizedError.display(e);\n        System.exit(1);\n    }\n}\n                                         // Defined at the end of this chapter.\n\n","name":"main","className":"ConvertEncoding","variables":{"args":8,"e":1,"outfile":2,"LocalizedError":1,"i":12,"from":2,"to":2,"infile":2,"System":1},"constants":{"0":1,"1":2,"null":4,"\"-in\"":1,"\"-to\"":1,"\"-out\"":1,"\"-from\"":1},"javaDoc":"","comments":"Parse command-line arguments All args require another Attempt conversion Defined at the end of this chapter Handle exceptions Handle exceptions ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":8,"StringLiteralExpr":4,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public static void usage() {\n    System.err.println(\"Usage: java ConvertEncoding <options>\\n\" + \"Options:\\n\\t-from <encoding>\\n\\t\" + \"-to <encoding>\\n\\t\" + \"-in <file>\\n\\t-out <file>\");\n    System.exit(1);\n}\n","name":"usage","className":"ConvertEncoding","variables":{"System":1},"constants":{"1":1,"\"Options:\\n\\t-from <encoding>\\n\\t\"":1,"\"-to <encoding>\\n\\t\"":1,"\"Usage: java ConvertEncoding <options>\\n\"":1,"\"-in <file>\\n\\t-out <file>\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String"],"returnType":"void","methodCalls":{"getProperty":2,"read":1,"write":1,"close":2},"annotations":[],"exceptions":["UnsupportedEncodingException","IOException"],"concepts":["PolyMorphism"],"types":{"InputStream":1,"OutputStream":1,"BufferedReader":1,"Reader":1,"Writer":1,"int":1,"BufferedWriter":1,"char[]":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":5,"NameExpr":44,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":7,"NullLiteralExpr":4,"FieldAccessExpr":2,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":4,"WhileStmt":1,"ExpressionStmt":15},"text":"public static void convert(String infile, String outfile, String from, String to) throws IOException, UnsupportedEncodingException {\n    // Set up byte streams.\n    InputStream in;\n    if (infile != null)\n        in = new FileInputStream(infile);\n    else\n        in = System.in;\n    OutputStream out;\n    if (outfile != null)\n        out = new FileOutputStream(outfile);\n    else\n        out = System.out;\n    // Use default encoding if no encoding is specified.\n    if (from == null)\n        from = System.getProperty(\"file.encoding\");\n    if (to == null)\n        to = System.getProperty(\"file.encoding\");\n    // Set up character streams.\n    Reader r = new BufferedReader(new InputStreamReader(in, from));\n    Writer w = new BufferedWriter(new OutputStreamWriter(out, to));\n    // Copy characters from input to output.  The InputStreamReader\n    // converts from the input encoding to Unicode, and the\n    // OutputStreamWriter converts from Unicode to the output encoding.\n    // Characters that cannot be represented in the output encoding are\n    // output as '?'\n    char[] buffer = new char[4096];\n    int len;\n    while (// Read a block of input.\n    (len = r.read(buffer)) != -1) // And write it out.\n    w.write(buffer, 0, len);\n    // Close the input.\n    r.close();\n    // Flush and close output.\n    w.close();\n}\n","name":"convert","className":"ConvertEncoding","variables":{"r":3,"len":2,"in":4,"outfile":2,"w":3,"from":3,"infile":2,"to":3,"buffer":1,"System":2,"out":4},"constants":{"0":1,"4096":1,"1":1,"null":4,"\"file.encoding\"":2},"javaDoc":"","comments":"Copy characters from input to output The InputStreamReader converts from the input encoding to Unicode and the OutputStreamWriter converts from Unicode to the output encoding Characters that cannot be represented in the output encoding are Set up byte streams Use default encoding if no encoding is specified Set up character streams output as '?' Read a block of input And write it out Close the input Flush and close output ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["AdjustmentEvent"],"returnType":"void","methodCalls":{"getValue":1,"setBase":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"CastExpr":1,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void adjustmentValueChanged(AdjustmentEvent e) {\n    page = e.getValue();\n    p.setBase((char) (page * 0x100));\n}\n","name":"adjustmentValueChanged","className":"","variables":{"p":1,"e":1,"page":2},"constants":{"0x100":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"setValue":1,"setBase":1,"getKeyCode":1,"isShiftDown":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":2,"BinaryExpr":10,"NameExpr":44,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":5,"MethodCallExpr":5,"AssignExpr":6},"statements":{"IfStmt":7,"BlockStmt":3,"ExpressionStmt":10},"text":"public void keyPressed(KeyEvent e) {\n    int code = e.getKeyCode();\n    int oldpage = page;\n    if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {\n        if (e.isShiftDown())\n            page -= 0x10;\n        else\n            page -= 1;\n        if (page < 0)\n            page = 0;\n    } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {\n        if (e.isShiftDown())\n            page += 0x10;\n        else\n            page += 1;\n        if (page > 0xff)\n            page = 0xff;\n    }\n    if (page != oldpage) {\n        // if anything has changed...\n        // update the display\n        p.setBase((char) (page * 0x100));\n        // and update scrollbar to match\n        b.setValue(page);\n    }\n}\n","name":"keyPressed","className":"","variables":{"p":1,"oldpage":2,"b":1,"code":5,"e":3,"page":11},"constants":{"0x10":2,"0":2,"1":2,"0x100":1,"0xff":2},"javaDoc":"","comments":"if anything has changed update the display and update scrollbar to match ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"UnicodeDisplay","methodCalls":{"add":4,"getValue":1,"exit":1,"setUnitIncrement":1,"addAdjustmentListener":1,"setValue":1,"makemenu":2,"getContentPane":2,"setBlockIncrement":1,"setBase":3,"getKeyCode":1,"isShiftDown":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"int":2,"JMenuBar":1},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":18,"VariableDeclarationExpr":3,"BinaryExpr":12,"NameExpr":107,"StringLiteralExpr":11,"AssignExpr":9,"ArrayInitializerExpr":2,"CastExpr":3,"FieldAccessExpr":5,"EnclosedExpr":7,"ArrayCreationExpr":2,"ThisExpr":5,"MethodCallExpr":23},"statements":{"IfStmt":7,"BlockStmt":6,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":27},"text":"/** \n     * This constructor creates the frame, menubar, and scrollbar\n     * that work along with the UnicodePanel class, defined below\n     **/\npublic UnicodeDisplay(String name) {\n    super(name);\n    // Create the panel\n    p = new UnicodePanel();\n    // Initialize it\n    p.setBase((char) (page * 0x100));\n    // Center it\n    getContentPane().add(p, \"Center\");\n    // Create and set up a scrollbar, and put it on the right\n    b = new JScrollBar(Scrollbar.VERTICAL, 0, 1, 0, 0xFF);\n    b.setUnitIncrement(1);\n    b.setBlockIncrement(0x10);\n    b.addAdjustmentListener(new AdjustmentListener() {\n\n        public void adjustmentValueChanged(AdjustmentEvent e) {\n            page = e.getValue();\n            p.setBase((char) (page * 0x100));\n        }\n    });\n    getContentPane().add(b, \"East\");\n    // Set things up so we respond to window close requests\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Handle Page Up and Page Down and the up and down arrow keys\n    this.addKeyListener(new KeyAdapter() {\n\n        public void keyPressed(KeyEvent e) {\n            int code = e.getKeyCode();\n            int oldpage = page;\n            if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {\n                if (e.isShiftDown())\n                    page -= 0x10;\n                else\n                    page -= 1;\n                if (page < 0)\n                    page = 0;\n            } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {\n                if (e.isShiftDown())\n                    page += 0x10;\n                else\n                    page += 1;\n                if (page > 0xff)\n                    page = 0xff;\n            }\n            if (page != oldpage) {\n                // if anything has changed...\n                // update the display\n                p.setBase((char) (page * 0x100));\n                // and update scrollbar to match\n                b.setValue(page);\n            }\n        }\n    });\n    // Set up a menu system to change fonts.  Use a convenience method.\n    JMenuBar menubar = new JMenuBar();\n    this.setJMenuBar(menubar);\n    menubar.add(makemenu(\"Font Family\", new String[] { \"Serif\", \"SansSerif\", \"Monospaced\" }, this));\n    menubar.add(makemenu(\"Font Style\", new String[] { \"Plain\", \"Italic\", \"Bold\", \"BoldItalic\" }, this));\n}\n","name":"UnicodeDisplay","className":"UnicodeDisplay","variables":{"p":4,"menubar":3,"b":5,"oldpage":2,"keyPressed":1,"code":5,"e":7,"windowClosing":1,"name":1,"adjustmentValueChanged":1,"page":14,"System":1},"constants":{"\"Bold\"":1,"\"SansSerif\"":1,"\"Font Family\"":1,"\"Monospaced\"":1,"\"Center\"":1,"\"Font Style\"":1,"\"Plain\"":1,"0":5,"0x10":3,"1":4,"0x100":3,"\"BoldItalic\"":1,"\"Italic\"":1,"\"East\"":1,"\"Serif\"":1,"0xFF":1,"0xff":2},"javaDoc":"This constructor creates the frame menubar and scrollbar that work along with the UnicodePanel class defined below","comments":"Create the panel Initialize it Center it Create and set up a scrollbar and put it on the right Set things up so we respond to window close requests Handle Page Up and Page Down and the up and down arrow keys if anything has changed update the display and update scrollbar to match Set up a menu system to change fonts Use a convenience method  \n     * This constructor creates the frame, menubar, and scrollbar\n     * that work along with the UnicodePanel class, defined below\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"equals":7,"getActionCommand":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":51,"StringLiteralExpr":10,"FieldAccessExpr":5,"MethodCallExpr":9,"AssignExpr":7},"statements":{"IfStmt":7,"ExpressionStmt":9},"text":"/** This method handles the items in the menubars */\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (cmd.equals(\"Serif\"))\n        fontfamily = \"Serif\";\n    else if (cmd.equals(\"SansSerif\"))\n        fontfamily = \"SansSerif\";\n    else if (cmd.equals(\"Monospaced\"))\n        fontfamily = \"Monospaced\";\n    else if (cmd.equals(\"Plain\"))\n        fontstyle = Font.PLAIN;\n    else if (cmd.equals(\"Italic\"))\n        fontstyle = Font.ITALIC;\n    else if (cmd.equals(\"Bold\"))\n        fontstyle = Font.BOLD;\n    else if (cmd.equals(\"BoldItalic\"))\n        fontstyle = Font.BOLD + Font.ITALIC;\n    p.setFont(fontfamily, fontstyle);\n}\n","name":"actionPerformed","className":"UnicodeDisplay","variables":{"p":1,"fontstyle":4,"e":1,"fontfamily":3,"cmd":8},"constants":{"\"Bold\"":1,"\"BoldItalic\"":1,"\"SansSerif\"":2,"\"Italic\"":1,"\"Monospaced\"":2,"\"Serif\"":2,"\"Plain\"":1},"javaDoc":"This method handles the items in the menubars","comments":" This method handles the items in the menubars ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String[]","ActionListener"],"returnType":"JMenu","methodCalls":{"add":1,"addActionListener":1,"setActionCommand":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JMenuItem":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":22,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** A convenience method to create a Menu from an array of items */\nprivate JMenu makemenu(String name, String[] itemnames, ActionListener listener) {\n    JMenu m = new JMenu(name);\n    for (int i = 0; i < itemnames.length; i++) {\n        JMenuItem item = new JMenuItem(itemnames[i]);\n        item.addActionListener(listener);\n        // okay here, though\n        item.setActionCommand(itemnames[i]);\n        m.add(item);\n    }\n    return m;\n}\n","name":"makemenu","className":"UnicodeDisplay","variables":{"item":3,"name":1,"i":5,"m":3,"itemnames":2},"constants":{"0":1},"javaDoc":"A convenience method to create a Menu from an array of items","comments":"okay here though  A convenience method to create a Menu from an array of items ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":1,"pack":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"UnicodeDisplay":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/** The main() program just create a window, packs it, and shows it */\npublic static void main(String[] args) {\n    UnicodeDisplay f = new UnicodeDisplay(\"Unicode Displayer\");\n    f.pack();\n    f.show();\n}\n","name":"main","className":"UnicodeDisplay","variables":{"f":3},"constants":{"\"Unicode Displayer\"":1},"javaDoc":"The main() program just create a window packs it and shows it","comments":" The main() program just create a window, packs it, and shows it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Specify where to begin displaying, and re-display */\npublic void setBase(char base) {\n    this.base = base;\n    repaint();\n}\n","name":"setBase","className":"UnicodePanel","variables":{"base":1},"constants":{},"javaDoc":"Specify where to begin displaying and re-display","comments":" Specify where to begin displaying, and re-display ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Set a new font name or style, and redisplay */\npublic void setFont(String family, int style) {\n    this.font = new Font(family, style, 18);\n    repaint();\n}\n","name":"setFont","className":"UnicodePanel","variables":{"style":1,"family":1},"constants":{"18":1},"javaDoc":"Set a new font name or style and redisplay","comments":" Set a new font name or style, and redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawChars":1,"toString":2,"setFont":2,"drawString":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":6,"char[]":1},"expressions":{"IntegerLiteralExpr":19,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":19,"CastExpr":2,"NameExpr":56,"EnclosedExpr":1,"UnaryExpr":4,"ArrayCreationExpr":1,"MethodCallExpr":7,"AssignExpr":1},"statements":{"BlockStmt":4,"ForStmt":4,"ExpressionStmt":11},"text":"/**\n\t * The paintComponent() method actually draws the page of glyphs \n\t **/\npublic void paintComponent(Graphics g) {\n    // Start on a 16-character boundary\n    int start = (int) base & 0xFFF0;\n    // Draw the headings in a special font\n    g.setFont(headingfont);\n    // Draw 0..F on top\n    for (int i = 0; i < 16; i++) {\n        String s = Integer.toString(i, 16);\n        g.drawString(s, x0 + i * charspacing, y0 - 20);\n    }\n    // Draw column down left.\n    for (int i = 0; i < 16; i++) {\n        int j = start + i * 16;\n        String s = Integer.toString(j, 16);\n        g.drawString(s, 10, y0 + i * lineheight);\n    }\n    // Now draw the characters\n    g.setFont(font);\n    char[] c = new char[1];\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 16; j++) {\n            c[0] = (char) (start + j * 16 + i);\n            g.drawChars(c, 0, 1, x0 + i * charspacing, y0 + j * lineheight);\n        }\n    }\n}\n","name":"paintComponent","className":"UnicodePanel","variables":{"Integer":2,"charspacing":2,"s":2,"c":2,"g":5,"y0":3,"lineheight":2,"start":3,"x0":2,"i":14,"j":6,"base":1},"constants":{"0":6,"1":2,"16":8,"0xFFF0":1,"20":1,"10":1},"javaDoc":"The paintComponent() method actually draws the page of glyphs","comments":"Start on a 16-character boundary Draw the headings in a special font Draw 0 F on top Draw column down left Now draw the characters \n\t * The paintComponent() method actually draws the page of glyphs \n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":4,"NameExpr":4},"statements":{"ReturnStmt":1},"text":"/** Custom components like this one should always have this method */\npublic Dimension getPreferredSize() {\n    return new Dimension(x0 + 16 * charspacing, y0 + 16 * lineheight);\n}\n","name":"getPreferredSize","className":"UnicodePanel","variables":{"charspacing":1,"y0":1,"lineheight":1,"x0":1},"constants":{"16":2},"javaDoc":"Custom components like this one should always have this method","comments":" Custom components like this one should always have this method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JTextComponent"],"returnType":"PrintableDocument","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"DoubleLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * This constructor allows printing the contents of any JTextComponent\n     * using a default PageFormat and a default scale factor.  The default\n     * scale factor is .75 because the default fonts are overly large.\n     */\npublic PrintableDocument(JTextComponent textComponent) {\n    this(textComponent, new PageFormat(), .75);\n}\n","name":"PrintableDocument","className":"PrintableDocument","variables":{"textComponent":1},"constants":{".75":1},"javaDoc":"This constructor allows printing the contents of any JTextComponent using a default PageFormat and a default scale factor The default scale factor is 75 because the default fonts are overly large","comments":"\n     * This constructor allows printing the contents of any JTextComponent\n     * using a default PageFormat and a default scale factor.  The default\n     * scale factor is .75 because the default fonts are overly large.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JTextComponent","PageFormat","double"],"returnType":"PrintableDocument","methodCalls":{"getViewFactory":1,"getDefaultRootElement":1,"getImageableHeight":1,"getDocument":1,"getEditorKit":1,"paginate":1,"getWidth":1,"getImageableX":1,"getImageableY":1,"getPreferredSpan":1,"getUI":1,"setSize":1,"size":1,"create":1,"getImageableWidth":1,"setParent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"EditorKit":1,"double":2,"Element":1,"ViewFactory":1,"Document":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":6,"BinaryExpr":7,"NameExpr":84,"CastExpr":4,"FieldAccessExpr":7,"ThisExpr":6,"AssignExpr":9,"MethodCallExpr":16},"statements":{"IfStmt":1,"ExpressionStmt":18},"text":"/** \n     * This constructor allows the contents of any JTextComponent to be\n     * printed, using any specified PageFormat object and any scaling factor.\n     **/\npublic PrintableDocument(JTextComponent textComponent, PageFormat format, double scalefactor) {\n    // Remember the page format, and ask it for the printable area\n    this.format = format;\n    this.scalefactor = scalefactor;\n    this.printX = format.getImageableX() / scalefactor;\n    this.printY = format.getImageableY() / scalefactor;\n    this.printWidth = format.getImageableWidth() / scalefactor;\n    this.printHeight = format.getImageableHeight() / scalefactor;\n    double paperWidth = format.getWidth() / scalefactor;\n    // Get the document and its root Element from the text component\n    Document document = textComponent.getDocument();\n    Element rootElement = document.getDefaultRootElement();\n    // Get the EditorKit and its ViewFactory from the text component\n    EditorKit editorKit = textComponent.getUI().getEditorKit(textComponent);\n    ViewFactory viewFactory = editorKit.getViewFactory();\n    // Use the ViewFactory to create a root View object for the document\n    // This is the object we'll print.  \n    root = viewFactory.create(rootElement);\n    // The Swing text architecture requires us to call setParent() on\n    // our root View before we use it for anything.  In order to do this,\n    // we need a View object that can serve as the parent.  We use a \n    // custom implementation defined below.\n    root.setParent(new ParentView(root, viewFactory, textComponent));\n    // Tell the view how wide the page is; it has to format itself\n    // to fit within this width.  The height doesn't really matter here\n    root.setSize((float) printWidth, (float) printHeight);\n    // Now that the view has formatted itself for the specified width,\n    // Ask it how tall it is.  \n    double documentHeight = root.getPreferredSpan(View.Y_AXIS);\n    // Set up the rectangle that tells the view where to draw itself\n    // We'll use it in other methods of this class.\n    drawRect = new Rectangle(0, 0, (int) printWidth, (int) documentHeight);\n    // figure out where the page breaks are.\n    if (documentHeight > printHeight)\n        paginate(root, drawRect);\n    // Once we've broken it into pages, figure out how many pages.\n    numPages = pageLengths.size() + 1;\n}\n     // Now if the document is taller than one page, we have to \n\n","name":"PrintableDocument","className":"PrintableDocument","variables":{"scalefactor":6,"textComponent":3,"documentHeight":3,"rootElement":1,"document":2,"format":6,"printWidth":2,"pageLengths":1,"editorKit":2,"printHeight":2,"numPages":1,"paperWidth":1,"root":5,"viewFactory":3,"drawRect":1},"constants":{"0":2,"1":1},"javaDoc":"This constructor allows the contents of any JTextComponent to be printed using any specified PageFormat object and any scaling factor","comments":"Use the ViewFactory to create a root View object for the document The Swing text architecture requires us to call setParent() on our root View before we use it for anything In order to do this we need a View object that can serve as the parent We use a Tell the view how wide the page is; it has to format itself Now that the view has formatted itself for the specified width Set up the rectangle that tells the view where to draw itself Now if the document is taller than one page we have to Remember the page format and ask it for the printable area Get the document and its root Element from the text component Get the EditorKit and its ViewFactory from the text component This is the object we'll print custom implementation defined below to fit within this width The height doesn't really matter here Ask it how tall it is We'll use it in other methods of this class figure out where the page breaks are Once we've broken it into pages figure out how many pages  \n     * This constructor allows the contents of any JTextComponent to be\n     * printed, using any specified PageFormat object and any scaling factor.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["View","Rectangle2D"],"returnType":"void","methodCalls":{"getHeight":2,"setSize":1,"getY":4,"breakPage":3,"getBounds2D":1,"getChildAllocation":1,"paginate":1,"getViewCount":2,"getView":1,"getPreferredSpan":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Shape":1,"double":2,"Rectangle2D":1,"View":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":23,"NameExpr":81,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":4,"UnaryExpr":1,"MethodCallExpr":17},"statements":{"ContinueStmt":7,"IfStmt":8,"BlockStmt":5,"ForStmt":1,"ExpressionStmt":11},"text":"/**\n     * This method loops through the children of the specified view,\n     * recursing as necessary, and inserts pages breaks when needed.\n     * It makes a rudimentary attempt to avoid \"widows\" and \"orphans\".\n     **/\nprotected void paginate(View v, Rectangle2D allocation) {\n    // Figure out how tall this view is, and tell it to allocate\n    // that space among its children\n    double myheight = v.getPreferredSpan(View.Y_AXIS);\n    v.setSize((float) printWidth, (float) myheight);\n    // Now loop through each of the children\n    int numkids = v.getViewCount();\n    for (int i = 0; i < numkids; i++) {\n        // this is the child we're working with\n        View kid = v.getView(i);\n        // Figure out its size and location\n        Shape kidshape = v.getChildAllocation(i, allocation);\n        if (kidshape == null)\n            continue;\n        Rectangle2D kidbox = kidshape.getBounds2D();\n        // This is the Y coordinate of the bottom of the child\n        double kidpos = kidbox.getY() + kidbox.getHeight() - pageStart;\n        // I.e. we want to prevent \"widows\"\n        if ((numkids > 1) && (i == 0)) {\n            // on to the next child\n            if (kidpos < printY + printHeight * MARGIN_ADJUST)\n                continue;\n            // Otherwise, the child is near the bottom of the page, so\n            // break the page before this child and place this child on\n            // the new page.\n            breakPage(kidbox.getY());\n            continue;\n        }\n        // prevent \"orphans\"\n        if ((numkids > 1) && (i == numkids - 1)) {\n            // If it fits normally, just move on to the next one\n            if (kidpos < printY + printHeight)\n                continue;\n            // page at the end of the group\n            if (kidpos < printY + printHeight / MARGIN_ADJUST) {\n                breakPage(allocation.getY() + allocation.getHeight());\n                continue;\n            }\n        }\n        // then move on to the next child.\n        if (kidpos < printY + printHeight)\n            continue;\n        // no children, then break the page before this child and continue.\n        if (kid.getViewCount() == 0) {\n            breakPage(kidbox.getY());\n            continue;\n        }\n        // If we get here, then the child did not fit on the page, but it\n        // has kids of its own, so recurse to see if any of those kids\n        // will fit on the page.\n        paginate(kid, kidbox);\n    }\n}\n         // If this is the first child of a group, then we want to ensure\n\n         // that it doesn't get left by itself at the bottom of a page.\n\n         // If this is the last child of a group, we don't want it to\n\n         // appear by itself at the top of a new page, so allow it to\n\n         // squeeze past the bottom margin if necessary.  This helps to\n\n         // If the child is not the first or last of a group, then we use\n\n         // the bottom margin strictly.  If the child fits on the page,\n\n         // If we get here, the child doesn't fit on this page.  If it has\n\n         // If it is not near the end of the page, then just move\n\n         // Otherwise, if it fits with extra space, then break the\n\n","name":"paginate","className":"PrintableDocument","variables":{"allocation":2,"kidpos":5,"kid":2,"printWidth":1,"kidbox":5,"i":5,"kidshape":3,"printHeight":4,"numkids":5,"v":5,"pageStart":1,"myheight":2,"printY":4,"MARGIN_ADJUST":2},"constants":{"0":3,"1":3,"null":1},"javaDoc":"This method loops through the children of the specified view recursing as necessary and inserts pages breaks when needed It makes a rudimentary attempt to avoid \"widows\" and \"orphans\"","comments":"Figure out how tall this view is and tell it to allocate that space among its children Now loop through each of the children If this is the first child of a group then we want to ensure that it doesn't get left by itself at the bottom of a page If this is the last child of a group we don't want it to appear by itself at the top of a new page so allow it to squeeze past the bottom margin if necessary This helps to If the child is not the first or last of a group then we use the bottom margin strictly If the child fits on the page If we get here the child doesn't fit on this page If it has If we get here then the child did not fit on the page but it has kids of its own so recurse to see if any of those kids this is the child we're working with Figure out its size and location This is the Y coordinate of the bottom of the child I e we want to prevent \"widows\" If it is not near the end of the page then just move Otherwise the child is near the bottom of the page so break the page before this child and place this child on on to the next child the new page prevent \"orphans\" Otherwise if it fits with extra space then break the If it fits normally just move on to the next one page at the end of the group then move on to the next child no children then break the page before this child and continue will fit on the page \n     * This method loops through the children of the specified view,\n     * recursing as necessary, and inserts pages breaks when needed.\n     * It makes a rudimentary attempt to avoid \"widows\" and \"orphans\".\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"add":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"/** \n     * Break a page at the specified Y coordinate.  Store the necessary\n     * information into the pageLengths and pageOffsets lists\n     **/\nvoid breakPage(double y) {\n    double pageLength = y - pageStart - printY;\n    pageStart = y - printY;\n    pageLengths.add(new Double(pageLength));\n    pageOffsets.add(new Double(pageStart));\n}\n","name":"breakPage","className":"PrintableDocument","variables":{"pageLength":2,"pageStart":3,"y":2,"printY":2,"pageLengths":1,"pageOffsets":1},"constants":{},"javaDoc":"Break a page at the specified Y coordinate Store the necessary information into the pageLengths and pageOffsets lists","comments":" \n     * Break a page at the specified Y coordinate.  Store the necessary\n     * information into the pageLengths and pageOffsets lists\n     *","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of pages. This is a Pageable method.   */\npublic int getNumberOfPages() {\n    return numPages;\n}\n","name":"getNumberOfPages","className":"PrintableDocument","variables":{"numPages":1},"constants":{},"javaDoc":"Return the number of pages This is a Pageable method","comments":" Return the number of pages. This is a Pageable method.   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"PageFormat","methodCalls":{"getPaper":1,"getOrientation":1,"get":1,"clone":1,"setImageableArea":2,"setPaper":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"PageFormat":1,"double":1,"Paper":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":11,"NameExpr":48,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":6},"text":"/** \n     * Return the PageFormat object for the specified page.  This is a\n     * Pageable method. This implementation uses the computed length of the\n     * page in the returned PageFormat object.  The PrinterJob will use this\n     * as a clipping region, which will prevent extraneous parts of the\n     * document from being drawn in the top and bottom margins.\n     **/\npublic PageFormat getPageFormat(int pagenum) {\n    // On the last page, just return the user-specified page format\n    if (pagenum == numPages - 1)\n        return format;\n    // Otherwise, look up the height of this page and return an\n    // appropriate PageFormat.\n    double pageLength = ((Double) pageLengths.get(pagenum)).doubleValue();\n    PageFormat f = (PageFormat) format.clone();\n    Paper p = f.getPaper();\n    if (f.getOrientation() == PageFormat.PORTRAIT)\n        p.setImageableArea(printX * scalefactor, printY * scalefactor, printWidth * scalefactor, pageLength * scalefactor);\n    else\n        p.setImageableArea(printY * scalefactor, printX * scalefactor, pageLength * scalefactor, printWidth * scalefactor);\n    f.setPaper(p);\n    return f;\n}\n","name":"getPageFormat","className":"PrintableDocument","variables":{"p":3,"scalefactor":8,"numPages":1,"pageLength":3,"f":5,"format":2,"printWidth":2,"printY":2,"pagenum":1,"pageLengths":1,"printX":2},"constants":{"1":1},"javaDoc":"Return the PageFormat object for the specified page This is a Pageable method This implementation uses the computed length of the page in the returned PageFormat object The PrinterJob will use this as a clipping region which will prevent extraneous parts of the document from being drawn in the top and bottom margins","comments":"Otherwise look up the height of this page and return an On the last page just return the user-specified page format appropriate PageFormat  \n     * Return the PageFormat object for the specified page.  This is a\n     * Pageable method. This implementation uses the computed length of the\n     * page in the returned PageFormat object.  The PrinterJob will use this\n     * as a clipping region, which will prevent extraneous parts of the\n     * document from being drawn in the top and bottom margins.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Printable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * This Pageable method returns the Printable object for the specified\n     * page.  Since this class implements both Pageable and Printable, it just\n     * returns this.\n     **/\npublic Printable getPrintable(int pagenum) {\n    return this;\n}\n","name":"getPrintable","className":"PrintableDocument","variables":{},"constants":{},"javaDoc":"This Pageable method returns the Printable object for the specified page Since this class implements both Pageable and Printable it just returns this","comments":"\n     * This Pageable method returns the Printable object for the specified\n     * page.  Since this class implements both Pageable and Printable, it just\n     * returns this.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","PageFormat","int"],"returnType":"int","methodCalls":{"getStringBounds":1,"scale":1,"paint":1,"getWidth":1,"getImageableX":1,"translate":2,"drawString":1,"getImageableY":1,"getAscent":1,"getHeight":1,"setColor":1,"getFontRenderContext":1,"get":2,"getClip":1,"getLineMetrics":1,"setClip":2,"setFont":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Shape":1,"double":1,"Rectangle2D":1,"String":1,"FontRenderContext":1,"LineMetrics":1,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":8,"ObjectCreationExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":14,"NameExpr":99,"StringLiteralExpr":2,"UnaryExpr":3,"AssignExpr":2,"DoubleLiteralExpr":2,"CastExpr":8,"FieldAccessExpr":1,"EnclosedExpr":7,"MethodCallExpr":22},"statements":{"IfStmt":4,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":18},"text":"/**\n     * This is the basic Printable method that prints a specified page\n     **/\npublic int print(Graphics g, PageFormat format, int pageIndex) {\n    // Return an error code on attempts to print past the end of the doc\n    if (pageIndex >= numPages)\n        return NO_SUCH_PAGE;\n    // Cast the Graphics object so we can use Java2D operations\n    Graphics2D g2 = (Graphics2D) g;\n    // Translate to accomodate the top and left margins\n    g2.translate(format.getImageableX(), format.getImageableY());\n    // Scale the page by the specified scaling factor\n    g2.scale(scalefactor, scalefactor);\n    // But remember the original clipping region so we can restore it\n    if (pageIndex > 0) {\n        Shape originalClip = g.getClip();\n        g.setClip(new Rectangle(0, (int) -printY, (int) printWidth, (int) printY));\n        // Compute the header to display, measure it, then display it\n        String numString = \"- \" + (pageIndex + 1) + \" -\";\n        // Get string and font measurements\n        FontRenderContext frc = g2.getFontRenderContext();\n        Rectangle2D numBounds = headerFont.getStringBounds(numString, frc);\n        LineMetrics metrics = headerFont.getLineMetrics(numString, frc);\n        // Set the font\n        g.setFont(headerFont);\n        // Print with black ink\n        g.setColor(Color.black);\n        // Display the string\n        g.drawString(// Display the string\n        numString, (int) ((printWidth - numBounds.getWidth()) / 2), (int) (-(printY - numBounds.getHeight()) / 2 + metrics.getAscent()));\n        // Restore the clipping region\n        g.setClip(originalClip);\n    }\n    // Get the staring position and length of the page within the document\n    double pageStart = 0.0, pageLength = printHeight;\n    if (pageIndex > 0)\n        pageStart = ((Double) pageOffsets.get(pageIndex - 1)).doubleValue();\n    if (pageIndex < numPages - 1)\n        pageLength = ((Double) pageLengths.get(pageIndex)).doubleValue();\n    // Scroll so that the appropriate part of the document is lined up\n    // with the upper-left corner of the page\n    g2.translate(0.0, -pageStart);\n    // Now paint the entire document.  Because of the clipping region,\n    // only the desired portion of the document will actually be drawn on\n    // this sheet of paper.\n    root.paint(g, drawRect);\n    // Finally return a success code\n    return PAGE_EXISTS;\n}\n     // Display a page number centered in the area of the top margin.\n\n     // Set a new clipping region so we can draw into the top margin\n\n","name":"print","className":"PrintableDocument","variables":{"headerFont":2,"pageLength":2,"numString":1,"originalClip":1,"g":7,"format":2,"printWidth":2,"g2":5,"pageLengths":1,"NO_SUCH_PAGE":1,"numBounds":3,"numPages":2,"printHeight":1,"pageIndex":6,"frc":1,"pageStart":3,"root":1,"printY":3,"metrics":2,"pageOffsets":1,"PAGE_EXISTS":1},"constants":{"0":3,"1":3,"2":2,"0.0":2,"\" -\"":1,"\"- \"":1},"javaDoc":"This is the basic Printable method that prints a specified page","comments":"Display a page number centered in the area of the top margin Set a new clipping region so we can draw into the top margin Scroll so that the appropriate part of the document is lined up Now paint the entire document Because of the clipping region only the desired portion of the document will actually be drawn on Return an error code on attempts to print past the end of the doc Cast the Graphics object so we can use Java2D operations Translate to accomodate the top and left margins Scale the page by the specified scaling factor But remember the original clipping region so we can restore it Compute the header to display measure it then display it Get string and font measurements Set the font Print with black ink Display the string Display the string Display the string Restore the clipping region Get the staring position and length of the page within the document with the upper-left corner of the page this sheet of paper Finally return a success code \n     * This is the basic Printable method that prints a specified page\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["View","ViewFactory","Container"],"returnType":"ParentView","methodCalls":{"getElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public ParentView(View v, ViewFactory viewFactory, Container container) {\n    super(v.getElement());\n    this.viewFactory = viewFactory;\n    this.container = container;\n}\n","name":"ParentView","className":"ParentView","variables":{"container":1,"v":1,"viewFactory":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ViewFactory","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These methods return key pieces of information required by\n// the View hierarchy.\npublic ViewFactory getViewFactory() {\n    return viewFactory;\n}\n","name":"getViewFactory","className":"ParentView","variables":{"viewFactory":1},"constants":{},"javaDoc":"","comments":" the View hierarchy.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Container","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Container getContainer() {\n    return container;\n}\n","name":"getContainer","className":"ParentView","variables":{"container":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Shape"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// These methods are abstract in View, so we've got to provide\n// dummy implementations of them here, even though they're never used.\npublic void paint(Graphics g, Shape allocation) {\n}\n","name":"paint","className":"ParentView","variables":{},"constants":{},"javaDoc":"","comments":" dummy implementations of them here, even though they're never used.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getPreferredSpan(int axis) {\n    return 0.0f;\n}\n","name":"getPreferredSpan","className":"ParentView","variables":{},"constants":{"0.0f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float","float","Shape","Position.Bias[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {\n    return 0;\n}\n","name":"viewToModel","className":"ParentView","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Shape","Position.Bias"],"returnType":"Shape","methodCalls":{},"annotations":[],"exceptions":["BadLocationException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {\n    return a;\n}\n","name":"modelToView","className":"ParentView","variables":{"a":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printScribble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    printScribble();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame"],"returnType":"ScribblePrinter1","methodCalls":{"addActionListener":1,"printScribble":1,"enableEvents":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Button":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":26,"StringLiteralExpr":1,"FieldAccessExpr":4,"ThisExpr":3,"AssignExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ExpressionStmt":7},"text":"public ScribblePrinter1(Frame frame) {\n    // Remember the frame: we'll need it to create a PrintJob\n    this.frame = frame;\n    // Register event types we're interested in for scribbling\n    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);\n    // Add a print button to he layout, and respond to it by printing\n    Button b = new Button(\"Print\");\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            printScribble();\n        }\n    });\n    this.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));\n    this.add(b);\n}\n","name":"ScribblePrinter1","className":"ScribblePrinter1","variables":{"actionPerformed":1,"b":2,"e":1,"frame":1},"constants":{"5":2,"\"Print\"":1},"javaDoc":"","comments":"Remember the frame: we'll need it to create a PrintJob Register event types we're interested in for scribbling Add a print button to he layout and respond to it by printing ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Line":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":24,"CastExpr":1,"FieldAccessExpr":4,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"/** Redraw (or print) the scribble based on stored lines */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) {\n        Line l = (Line) lines.elementAt(i);\n        g.drawLine(l.x1, l.y1, l.x2, l.y2);\n    }\n}\n","name":"paint","className":"ScribblePrinter1","variables":{"g":1,"i":3,"lines":2,"l":1},"constants":{"0":1},"javaDoc":"Redraw (or print) the scribble based on stored lines","comments":" Redraw (or print) the scribble based on stored lines ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getPrintJob":1,"setClip":1,"dispose":1,"end":1,"getGraphics":1,"drawRect":1,"translate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1,"PrintJob":1,"Toolkit":1,"Dimension":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":8,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":43,"StringLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":2,"ThisExpr":3,"MethodCallExpr":10},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Print out the scribble */\npublic void printScribble() {\n    // Obtain a PrintJob\n    Toolkit toolkit = this.getToolkit();\n    PrintJob job = toolkit.getPrintJob(frame, \"ScribblePrinter1\", printprefs);\n    // If the user clicked Cancel in the print dialog, don't print\n    if (job == null)\n        return;\n    // Get the Graphics object we use to draw to the printer\n    Graphics g = job.getGraphics();\n    // Give the output a larger top and left margin.  Otherwise it will\n    // be scrunched up in the upper-left corner of the page.\n    g.translate(100, 100);\n    // Draw a border around the output area.\n    Dimension size = this.getSize();\n    g.drawRect(-1, -1, size.width + 2, size.height + 2);\n    // Set a clipping region so our scribbles don't go outside the border\n    // On-screen this happens automatically, but not on paper.\n    g.setClip(0, 0, size.width, size.height);\n    // Print this component and all components it contains\n    // This will invoke the paint() method, and will paint the button too.\n    // Use print() instead of printAll() if you don't the button to show.\n    this.printAll(g);\n    // Finish up.\n    // End the current page\n    g.dispose();\n    // End the print job\n    job.end();\n}\n","name":"printScribble","className":"ScribblePrinter1","variables":{"size":1,"toolkit":2,"g":5,"job":4},"constants":{"0":2,"100":2,"1":2,"2":2,"null":1,"\"ScribblePrinter1\"":1},"javaDoc":"Print out the scribble","comments":"Give the output a larger top and left margin Otherwise it will Set a clipping region so our scribbles don't go outside the border Print this component and all components it contains This will invoke the paint() method and will paint the button too Finish up Obtain a PrintJob If the user clicked Cancel in the print dialog don't print Get the Graphics object we use to draw to the printer be scrunched up in the upper-left corner of the page Draw a border around the output area On-screen this happens automatically but not on paper Use print() instead of printAll() if you don't the button to show End the current page End the print job  Print out the scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":17,"CastExpr":2,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Called when the user clicks to begin a scribble */\npublic void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // remember click position\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"ScribblePrinter1","variables":{"e":3,"last_x":1,"last_y":1},"constants":{},"javaDoc":"Called when the user clicks to begin a scribble","comments":"remember click position  Called when the user clicks to begin a scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":3,"getY":3,"getID":1,"getGraphics":1,"drawLine":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":1,"NameExpr":41,"CastExpr":4,"FieldAccessExpr":1,"MethodCallExpr":11,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":6},"text":"/** Called when the the user drags the mouse: does the scribbling */\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        Graphics g = getGraphics();\n        // draw the line\n        g.drawLine(last_x, last_y, e.getX(), e.getY());\n        lines.addElement(new // and save it\n        Line(// and save it\n        last_x, // and save it\n        last_y, (short) e.getX(), (short) e.getY()));\n        last_x = (short) e.getX();\n        last_y = (short) e.getY();\n    } else\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"ScribblePrinter1","variables":{"e":7,"g":2,"last_x":2,"last_y":2,"lines":1},"constants":{},"javaDoc":"Called when the the user drags the mouse: does the scribbling","comments":"draw the line and save it and save it and save it  Called when the the user drags the mouse: does the scribbling ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setSize":1,"show":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Frame":1,"ScribblePrinter1":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"StringLiteralExpr":1,"NameExpr":14,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":5},"text":"/** The main method.  Create a ScribblePrinter1 object and away we go! */\npublic static void main(String[] args) {\n    Frame frame = new Frame(\"ScribblePrinter1\");\n    ScribblePrinter1 s = new ScribblePrinter1(frame);\n    frame.add(s, BorderLayout.CENTER);\n    frame.setSize(400, 400);\n    frame.show();\n}\n","name":"main","className":"ScribblePrinter1","variables":{"s":1,"frame":5},"constants":{"400":2,"\"ScribblePrinter1\"":1},"javaDoc":"The main method Create a ScribblePrinter1 object and away we go!","comments":" The main method.  Create a ScribblePrinter1 object and away we go! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["short","short","short","short"],"returnType":"Line","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"public Line(short x1, short y1, short x2, short y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n","name":"Line","className":"Line","variables":{"y1":1,"x1":1,"y2":1,"x2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame","String","int","double","double","double","double"],"returnType":"HardcopyWriter","methodCalls":{"charWidth":1,"getProperty":1,"format":1,"regionMatches":1,"getDefault":1,"getPageDimension":1,"getToolkit":1,"getFontMetrics":2,"getAscent":2,"getScreenResolution":1,"getHeight":2,"getDateTimeInstance":1,"getPrintJob":1,"setTimeZone":1,"getPageResolution":1},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException","PrintCanceledException"],"concepts":["Synchronization"],"types":{"DateFormat":1,"Toolkit":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":5,"VariableDeclarationExpr":2,"BinaryExpr":19,"NameExpr":127,"StringLiteralExpr":5,"CharLiteralExpr":1,"AssignExpr":23,"NullLiteralExpr":1,"DoubleLiteralExpr":2,"BooleanLiteralExpr":1,"CastExpr":6,"FieldAccessExpr":8,"EnclosedExpr":8,"ThisExpr":2,"MethodCallExpr":18},"statements":{"IfStmt":2,"BlockStmt":2,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":26},"text":"/**\n     * The constructor for this class has a bunch of arguments:  \n     * The frame argument is required for all printing in Java.\n     * The jobname appears left justified at the top of each printed page.\n     * The font size is specified in points, as on-screen font sizes are.\n     * The margins are specified in inches (or fractions of inches).\n     **/\npublic HardcopyWriter(Frame frame, String jobname, int fontsize, double leftmargin, double rightmargin, double topmargin, double bottommargin) throws HardcopyWriter.PrintCanceledException {\n    // Get the PrintJob object with which we'll do all the printing.\n    // The call is synchronized on the static printprops object, which \n    // means that only one print dialog can be popped up at a time.\n    // If the user clicks Cancel in the print dialog, throw an exception.\n    // get Toolkit from Frame\n    Toolkit toolkit = frame.getToolkit();\n    synchronized (printprops) {\n        job = toolkit.getPrintJob(frame, jobname, printprops);\n    }\n    if (job == null)\n        throw new PrintCanceledException(\"User cancelled print request\");\n    // query the page size\n    pagesize = job.getPageDimension();\n    // query the page resolution\n    pagedpi = job.getPageResolution();\n    // we've got to fake them.\n    if (System.getProperty(\"os.name\").regionMatches(true, 0, \"windows\", 0, 7)) {\n        // Use screen dpi, which is what the PrintJob tries to emulate\n        pagedpi = toolkit.getScreenResolution();\n        // Assume a 8.5\" x 11\" page size.  A4 paper users must change this.\n        pagesize = new Dimension((int) (8.5 * pagedpi), 11 * pagedpi);\n        // We also have to adjust the fontsize.  It is specified in points,\n        // (1 point = 1/72 of an inch) but Windows measures it in pixels.\n        fontsize = fontsize * pagedpi / 72;\n    }\n    // Compute coordinates of the upper-left corner of the page.\n    // I.e. the coordinates of (leftmargin, topmargin).  Also compute\n    // the width and height inside of the margins.\n    x0 = (int) (leftmargin * pagedpi);\n    y0 = (int) (topmargin * pagedpi);\n    width = pagesize.width - (int) ((leftmargin + rightmargin) * pagedpi);\n    height = pagesize.height - (int) ((topmargin + bottommargin) * pagedpi);\n    // Get body font and font size\n    font = new Font(\"Monospaced\", Font.PLAIN, fontsize);\n    metrics = frame.getFontMetrics(font);\n    lineheight = metrics.getHeight();\n    lineascent = metrics.getAscent();\n    // Assumes a monospaced font!\n    charwidth = metrics.charWidth('0');\n    // Now compute columns and lines will fit inside the margins\n    chars_per_line = width / charwidth;\n    lines_per_page = height / lineheight;\n    // Get header font information\n    // And compute baseline of page header: 1/8\" above the top margin\n    headerfont = new Font(\"SansSerif\", Font.ITALIC, fontsize);\n    headermetrics = frame.getFontMetrics(headerfont);\n    headery = y0 - (int) (0.125 * pagedpi) - headermetrics.getHeight() + headermetrics.getAscent();\n    // Compute the date/time string to display in the page header\n    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT);\n    df.setTimeZone(TimeZone.getDefault());\n    time = df.format(new Date());\n    // save name\n    this.jobname = jobname;\n    // save font size\n    this.fontsize = fontsize;\n}\n     // Bug Workaround:\n\n     // On windows, getPageDimension() and getPageResolution don't work, so\n\n","name":"HardcopyWriter","className":"HardcopyWriter","variables":{"df":3,"charwidth":2,"lineheight":2,"fontsize":5,"System":1,"rightmargin":1,"printprops":1,"y0":2,"pagesize":2,"jobname":1,"height":2,"chars_per_line":1,"lines_per_page":1,"lineascent":1,"leftmargin":2,"topmargin":2,"headery":1,"headermetrics":3,"TimeZone":1,"bottommargin":1,"pagedpi":10,"toolkit":3,"DateFormat":1,"x0":1,"width":2,"headerfont":1,"metrics":4,"time":1,"job":4,"frame":3,"font":1},"constants":{"11":1,"\"SansSerif\"":1,"\"Monospaced\"":1,"\"User cancelled print request\"":1,"0.125":1,"\"os.name\"":1,"0":2,"null":1,"7":1,"true":1,"\"windows\"":1,"72":1,"'0'":1,"8.5":1},"javaDoc":"The constructor for this class has a bunch of arguments: The frame argument is required for all printing in Java The jobname appears left justified at the top of each printed page The font size is specified in points as on-screen font sizes are The margins are specified in inches (or fractions of inches)","comments":"Get the PrintJob object with which we'll do all the printing The call is synchronized on the static printprops object which means that only one print dialog can be popped up at a time If the user clicks Cancel in the print dialog throw an exception Bug Workaround: On windows getPageDimension() and getPageResolution don't work so Compute coordinates of the upper-left corner of the page I e the coordinates of (leftmargin topmargin) Also compute Get header font information get Toolkit from Frame query the page size query the page resolution we've got to fake them We also have to adjust the fontsize It is specified in points Use screen dpi which is what the PrintJob tries to emulate Assume a 8 5\" x 11\" page size A4 paper users must change this (1 point = 1/72 of an inch) but Windows measures it in pixels the width and height inside of the margins Get body font and font size Assumes a monospaced font! Now compute columns and lines will fit inside the margins And compute baseline of page header: 1/8\" above the top margin Compute the date/time string to display in the page header save name save font size \n     * The constructor for this class has a bunch of arguments:  \n     * The frame argument is required for all printing in Java.\n     * The jobname appears left justified at the top of each printed page.\n     * The font size is specified in points, as on-screen font sizes are.\n     * The margins are specified in inches (or fractions of inches).\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"newline":3,"drawChars":1,"newpage":2,"isSpaceChar":2,"isWhitespace":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":7,"BinaryExpr":18,"NameExpr":63,"CharLiteralExpr":4,"UnaryExpr":5,"AssignExpr":3,"NullLiteralExpr":2,"BooleanLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":3,"ThisExpr":1,"MethodCallExpr":9},"statements":{"ContinueStmt":3,"IfStmt":9,"BlockStmt":6,"SynchronizedStmt":1,"ForStmt":1,"ExpressionStmt":11},"text":"/**\n     * This is the write() method of the stream.  All Writer subclasses \n     * implement this.  All other versions of write() are variants of this one\n     **/\npublic void write(char[] buffer, int index, int len) {\n    synchronized (this.lock) {\n        // Loop through all the characters passed to us\n        for (int i = index; i < index + len; i++) {\n            // If we haven't begun a page (or a new page), do that now.\n            if (page == null)\n                newpage();\n            // unless it is a \\n immediately after a \\r.\n            if (buffer[i] == '\\n') {\n                if (!last_char_was_return)\n                    newline();\n                continue;\n            }\n            if (buffer[i] == '\\r') {\n                newline();\n                last_char_was_return = true;\n                continue;\n            } else\n                last_char_was_return = false;\n            // If it some other non-printing character, ignore it.\n            if (Character.isWhitespace(buffer[i]) && !Character.isSpaceChar(buffer[i]) && (buffer[i] != '\\t'))\n                continue;\n            // If no more characters will fit on the line, start new line.\n            if (charnum >= chars_per_line) {\n                newline();\n                // Also start a new page, if necessary\n                if (page == null)\n                    newpage();\n            }\n            // printer uses we need to position each character individually\n            if (Character.isSpaceChar(buffer[i]))\n                charnum++;\n            else if (buffer[i] == '\\t')\n                charnum += 8 - (charnum % 8);\n            else {\n                page.drawChars(buffer, i, 1, x0 + charnum * charwidth, y0 + (linenum * lineheight) + lineascent);\n                charnum++;\n            }\n        }\n    }\n}\n                                // For thread safety\n\n         // If the character is a line terminator, then begin new line, \n\n         // Now print the character:\n\n         // If it is a space, skip one space, without output.\n\n         // If it is a tab, skip the necessary number of spaces.\n\n         // Otherwise, print the character.\n\n         // It is inefficient to draw only one character at a time, but\n\n         // because our FontMetrics don't match up exactly to what the\n\n","name":"write","className":"HardcopyWriter","variables":{"chars_per_line":1,"lineascent":1,"last_char_was_return":3,"Character":3,"charwidth":1,"lineheight":1,"i":10,"index":2,"len":1,"y0":1,"x0":1,"linenum":1,"page":3,"buffer":7,"charnum":6},"constants":{"1":1,"null":2,"true":1,"false":1,"8":2,"'\\r'":1,"'\\t'":2,"'\\n'":1},"javaDoc":"This is the write() method of the stream All Writer subclasses implement this All other versions of write() are variants of this one","comments":"For thread safety Loop through all the characters passed to us If the character is a line terminator then begin new line Now print the character: If it is a space skip one space without output If it is a tab skip the necessary number of spaces Otherwise print the character It is inefficient to draw only one character at a time but because our FontMetrics don't match up exactly to what the If we haven't begun a page (or a new page) do that now unless it is a \\n immediately after a \\r If it some other non-printing character ignore it If no more characters will fit on the line start new line Also start a new page if necessary printer uses we need to position each character individually \n     * This is the write() method of the stream.  All Writer subclasses \n     * implement this.  All other versions of write() are variants of this one\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n     * This is the flush() method that all Writer subclasses must implement.\n     * There is no way to flush a PrintJob without prematurely printing the\n     * page, so we don't do anything.\n     **/\npublic void flush() {\n/* do nothing */\n}\n","name":"flush","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"This is the flush() method that all Writer subclasses must implement There is no way to flush a PrintJob without prematurely printing the page so we don't do anything","comments":"do nothing  \n     * This is the flush() method that all Writer subclasses must implement.\n     * There is no way to flush a PrintJob without prematurely printing the\n     * page, so we don't do anything.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"dispose":1,"end":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":9,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":2},"text":"/**\n     * This is the close() method that all Writer subclasses must implement.\n     * Print the pending page (if any) and terminate the PrintJob.\n     */\npublic void close() {\n    synchronized (this.lock) {\n        // Send page to the printer\n        if (page != null)\n            page.dispose();\n        // Terminate the job\n        job.end();\n    }\n}\n","name":"close","className":"HardcopyWriter","variables":{"page":2,"job":1},"constants":{"null":1},"javaDoc":"This is the close() method that all Writer subclasses must implement Print the pending page (if any) and terminate the PrintJob","comments":"Send page to the printer Terminate the job \n     * This is the close() method that all Writer subclasses must implement.\n     * Print the pending page (if any) and terminate the PrintJob.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Font":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"SynchronizedStmt":1,"ExpressionStmt":4},"text":"/**\n     * Set the font style.  The argument should be one of the font style \n     * constants defined by the java.awt.Font class.  All subsequent output\n     * will be in that style.  This method relies on all styles of the\n     * Monospaced font having the same metrics.\n     **/\npublic void setFontStyle(int style) {\n    synchronized (this.lock) {\n        // Try to set a new font, but restore current one if it fails\n        Font current = font;\n        try {\n            font = new Font(\"Monospaced\", style, fontsize);\n        } catch (Exception e) {\n            font = current;\n        }\n        // If a page is pending, set the new font. Otherwise newpage() will\n        if (page != null)\n            page.setFont(font);\n    }\n}\n","name":"setFontStyle","className":"HardcopyWriter","variables":{"current":2,"e":1,"fontsize":1,"style":1,"page":2,"font":3},"constants":{"null":1,"\"Monospaced\"":1},"javaDoc":"Set the font style The argument should be one of the font style constants defined by the java awt Font class All subsequent output will be in that style This method relies on all styles of the Monospaced font having the same metrics","comments":"Try to set a new font but restore current one if it fails If a page is pending set the new font Otherwise newpage() will \n     * Set the font style.  The argument should be one of the font style \n     * constants defined by the java.awt.Font class.  All subsequent output\n     * will be in that style.  This method relies on all styles of the\n     * Monospaced font having the same metrics.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"newpage":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":1},"text":"/** End the current page.  Subsequent output will be on a new page. */\npublic void pageBreak() {\n    synchronized (this.lock) {\n        newpage();\n    }\n}\n","name":"pageBreak","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"End the current page Subsequent output will be on a new page","comments":" End the current page.  Subsequent output will be on a new page. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"FieldAccessExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of columns of characters that fit on the page */\npublic int getCharactersPerLine() {\n    return this.chars_per_line;\n}\n","name":"getCharactersPerLine","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"Return the number of columns of characters that fit on the page","comments":" Return the number of columns of characters that fit on the page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"FieldAccessExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of lines that fit on a page */\npublic int getLinesPerPage() {\n    return this.lines_per_page;\n}\n","name":"getLinesPerPage","className":"HardcopyWriter","variables":{},"constants":{},"javaDoc":"Return the number of lines that fit on a page","comments":" Return the number of lines that fit on a page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/** This internal method begins a new line */\nprotected void newline() {\n    // Reset character number to 0\n    charnum = 0;\n    // Increment line number\n    linenum++;\n    if (linenum >= lines_per_page) {\n        // If we've reached the end of page\n        //  send page to printer\n        page.dispose();\n        //  but don't start a new page yet.\n        page = null;\n    }\n}\n","name":"newline","className":"HardcopyWriter","variables":{"lines_per_page":1,"linenum":2,"page":2,"charnum":1},"constants":{"0":1,"null":1},"javaDoc":"This internal method begins a new line","comments":"Reset character number to 0 Increment line number If we've reached the end of page send page to printer but don't start a new page yet  This internal method begins a new line ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"stringWidth":2,"getGraphics":1,"setFont":2,"drawLine":1,"getDescent":1,"drawString":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"BinaryExpr":10,"NameExpr":60,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":1,"AssignExpr":4,"MethodCallExpr":10},"statements":{"ExpressionStmt":14},"text":"/** This internal method begins a new page and prints the header. */\nprotected void newpage() {\n    // Begin the new page\n    page = job.getGraphics();\n    // Reset line and char number\n    linenum = 0;\n    // Reset line and char number\n    charnum = 0;\n    // Increment page number\n    pagenum++;\n    // Set the header font.\n    page.setFont(headerfont);\n    // Print job name left justified\n    page.drawString(jobname, x0, headery);\n    // Print the page # centered.\n    String s = \"- \" + pagenum + \" -\";\n    int w = headermetrics.stringWidth(s);\n    page.drawString(s, x0 + (this.width - w) / 2, headery);\n    // Print date right justified\n    w = headermetrics.stringWidth(time);\n    page.drawString(time, x0 + width - w, headery);\n    // Draw a line beneath the header\n    int y = headery + headermetrics.getDescent() + 1;\n    page.drawLine(x0, y, x0 + width, y);\n    // Set the basic monospaced font for the rest of the page.\n    page.setFont(font);\n}\n","name":"newpage","className":"HardcopyWriter","variables":{"headermetrics":3,"s":1,"w":4,"x0":3,"width":2,"linenum":1,"y":1,"page":7,"headery":1,"job":1,"pagenum":2,"charnum":1},"constants":{"0":2,"1":1,"2":1,"\" -\"":1,"\"- \"":1},"javaDoc":"This internal method begins a new page and prints the header","comments":"Begin the new page Reset line and char number Reset line and char number Increment page number Set the header font Print job name left justified Print the page # centered Print date right justified Draw a line beneath the header Set the basic monospaced font for the rest of the page  This internal method begins a new page and prints the header. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String"],"returnType":"PrintCanceledException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public PrintCanceledException(String msg) {\n    super(msg);\n}\n","name":"PrintCanceledException","className":"PrintCanceledException","variables":{"msg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"exit":3,"setSize":1,"read":1,"show":1,"System.err.println":2,"write":1,"close":2},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"Frame":1,"FileReader":1,"HardcopyWriter":1,"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":13,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":4,"UnaryExpr":1,"AssignExpr":2,"NullLiteralExpr":1,"DoubleLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":12},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ExpressionStmt":17},"text":"public static void main(String[] args) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong # of arguments\");\n        FileReader in = new FileReader(args[0]);\n        HardcopyWriter out = null;\n        Frame f = new Frame(\"PrintFile: \" + args[0]);\n        f.setSize(200, 50);\n        f.show();\n        try {\n            out = new HardcopyWriter(f, args[0], 10, .5, .5, .5, .5);\n        } catch (HardcopyWriter.PrintCanceledException e) {\n            System.exit(0);\n        }\n        f.setVisible(false);\n        char[] buffer = new char[4096];\n        int numchars;\n        while ((numchars = in.read(buffer)) != -1) out.write(buffer, 0, numchars);\n        in.close();\n        out.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: \" + \"java HardcopyWriter$PrintFile <filename>\");\n        System.exit(1);\n    }\n    System.exit(0);\n}\n","name":"main","className":"PrintFile","variables":{"args":3,"in":3,"e":2,"f":5,"numchars":2,"buffer":1,"System":3,"out":4},"constants":{"\"java HardcopyWriter$PrintFile <filename>\"":1,"4096":1,"\"PrintFile: \"":1,".5":4,"false":1,"0":6,"1":3,"200":1,"null":1,"\"Usage: \"":1,"50":1,"\"Wrong # of arguments\"":1,"10":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"show":1},"annotations":[],"exceptions":[],"concepts":["PolyMorphism"],"types":{"Frame":1,"Demo":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** The main method of the program.  Create a test window */\npublic static void main(String[] args) {\n    Frame f = new Demo();\n    f.show();\n}\n","name":"main","className":"Demo","variables":{"f":2},"constants":{},"javaDoc":"The main method of the program Create a test window","comments":" The main method of the program.  Create a test window ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Demo","methodCalls":{"add":2,"addActionListener":2,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":5,"NameExpr":27,"FieldAccessExpr":1,"ThisExpr":4,"MethodCallExpr":7,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":10},"text":"/** Constructor for the test program's window. */\npublic Demo() {\n    // Call frame constructor\n    super(\"HardcopyWriter Test\");\n    // Add a panel to the frame\n    Panel p = new Panel();\n    // Center it\n    this.add(p, \"Center\");\n    p.setFont(new // Set a default font\n    Font(// Set a default font\n    \"SansSerif\", Font.BOLD, 18));\n    // Create a Print button\n    print = new Button(\"Print Test Page\");\n    // Create a Quit button\n    quit = new Button(\"Quit\");\n    // Specify that we'll handle\n    print.addActionListener(this);\n    //   button presses\n    quit.addActionListener(this);\n    // Add the buttons to panel\n    p.add(print);\n    p.add(quit);\n    // Set the frame size\n    this.pack();\n}\n","name":"Demo","className":"Demo","variables":{"p":4,"print":2,"quit":2},"constants":{"\"Quit\"":1,"\"HardcopyWriter Test\"":1,"18":1,"\"Center\"":1,"\"Print Test Page\"":1},"javaDoc":"Constructor for the test program's window","comments":"Call frame constructor Add a panel to the frame Center it Set a default font Set a default font Create a Print button Create a Quit button Specify that we'll handle button presses Add the buttons to panel Set the frame size  Constructor for the test program's window. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"getSource":1,"printDemoPage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":12,"MethodCallExpr":3},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"/** Handle the button presses */\npublic void actionPerformed(ActionEvent e) {\n    Object o = e.getSource();\n    if (o == quit)\n        System.exit(0);\n    else if (o == print)\n        printDemoPage();\n}\n","name":"actionPerformed","className":"Demo","variables":{"print":1,"e":1,"quit":1,"System":1,"o":3},"constants":{"0":1},"javaDoc":"Handle the button presses","comments":" Handle the button presses ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"print":6,"println":19,"getCharactersPerLine":1,"getLinesPerPage":1,"close":1,"setFontStyle":8},"annotations":[],"exceptions":["HardcopyWriter.PrintCanceledException"],"concepts":["ExceptionHandling"],"types":{"int[]":1,"HardcopyWriter":1,"int":5,"PrintWriter":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":8,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":18,"NameExpr":186,"StringLiteralExpr":27,"UnaryExpr":4,"AssignExpr":1,"DoubleLiteralExpr":4,"ArrayInitializerExpr":1,"FieldAccessExpr":21,"ThisExpr":1,"MethodCallExpr":36},"statements":{"TryStmt":1,"BlockStmt":3,"ReturnStmt":1,"ForStmt":4,"ExpressionStmt":39},"text":"/** Print the demo page */\npublic void printDemoPage() {\n    // Create a HardcopyWriter, using a 14 point font and 3/4\" margins.\n    HardcopyWriter hw;\n    try {\n        hw = new HardcopyWriter(this, \"Demo Page\", 14, .75, .75, .75, .75);\n    } catch (HardcopyWriter.PrintCanceledException e) {\n        return;\n    }\n    // Send output to it through a PrintWriter stream\n    PrintWriter out = new PrintWriter(hw);\n    // Figure out the size of the page\n    int rows = hw.getLinesPerPage(), cols = hw.getCharactersPerLine();\n    // Mark upper left and upper-right corners\n    // upper-left corner\n    out.print(\"+\");\n    // space over\n    for (int i = 0; i < cols - 2; i++) out.print(\" \");\n    // upper-right corner\n    out.print(\"+\");\n    // Display a title\n    hw.setFontStyle(Font.BOLD + Font.ITALIC);\n    out.println(\"\\n\\t\\tHardcopy Writer Demo Page\\n\\n\");\n    // Demonstrate font styles\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Font Styles:\");\n    int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC, Font.ITALIC + Font.BOLD };\n    for (int i = 0; i < styles.length; i++) {\n        hw.setFontStyle(styles[i]);\n        out.println(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz\");\n        out.println(\"1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\\\`'\\\"_~|\");\n    }\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"\\n\");\n    // Demonstrate tab stops\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Tab Stops:\");\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"          1         2         3         4         5\");\n    out.println(\"012345678901234567890123456789012345678901234567890\");\n    out.println(\"^\\t^\\t^\\t^\\t^\\t^\\t^\");\n    out.println(\"\\n\");\n    // Output some information about page dimensions and resolution\n    hw.setFontStyle(Font.BOLD);\n    out.println(\"Dimensions:\");\n    hw.setFontStyle(Font.PLAIN);\n    out.println(\"\\tResolution: \" + hw.pagedpi + \" dots per inch\");\n    out.println(\"\\tPage width (pixels): \" + hw.pagesize.width);\n    out.println(\"\\tPage height (pixels): \" + hw.pagesize.height);\n    out.println(\"\\tWidth inside margins (pixels): \" + hw.width);\n    out.println(\"\\tHeight inside margins (pixels): \" + hw.height);\n    out.println(\"\\tCharacters per line: \" + cols);\n    out.println(\"\\tLines per page: \" + rows);\n    // Skip down to the bottom of the page\n    for (int i = 0; i < rows - 30; i++) out.println();\n    // And mark the lower left and lower right\n    // lower-left\n    out.print(\"+\");\n    // space-over\n    for (int i = 0; i < cols - 2; i++) out.print(\" \");\n    // lower-right\n    out.print(\"+\");\n    // Close the output stream, forcing the page to be printed\n    out.close();\n}\n","name":"printDemoPage","className":"Demo","variables":{"e":1,"i":13,"styles":2,"rows":3,"cols":4,"hw":13,"out":27},"constants":{"\"Font Styles:\"":1,"\"^\\t^\\t^\\t^\\t^\\t^\\t^\"":1,"\"\\tPage width (pixels): \"":1,"\"\\tResolution: \"":1,"\"\\n\\t\\tHardcopy Writer Demo Page\\n\\n\"":1,"\"abcdefghijklmnopqrstuvwxyz\"":1,"\"\\tPage height (pixels): \"":1,"\"\\tCharacters per line: \"":1,".75":4,"\"Tab Stops:\"":1,"\"Demo Page\"":1,"30":1,"\"\\tLines per page: \"":1,"14":1,"\" \"":2,"\"          1         2         3         4         5\"":1,"\"Dimensions:\"":1,"\"\\tHeight inside margins (pixels): \"":1,"\"012345678901234567890123456789012345678901234567890\"":1,"\"\\tWidth inside margins (pixels): \"":1,"0":4,"\" dots per inch\"":1,"2":2,"\"1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\\\`'\\\"_~|\"":1,"\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"":1,"\"+\"":4,"\"\\n\"":2},"javaDoc":"Print the demo page","comments":"Mark upper left and upper-right corners And mark the lower left and lower right Create a HardcopyWriter using a 14 point font and 3/4\" margins Send output to it through a PrintWriter stream Figure out the size of the page upper-left corner space over upper-right corner Display a title Demonstrate font styles Demonstrate tab stops Output some information about page dimensions and resolution Skip down to the bottom of the page lower-left space-over lower-right Close the output stream forcing the page to be printed  Print the demo page ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"printScribble":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    printScribble();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribblePrinter2","methodCalls":{"addActionListener":1,"printScribble":1,"enableEvents":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"JButton":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":23,"StringLiteralExpr":1,"FieldAccessExpr":3,"ThisExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ExpressionStmt":6},"text":"public ScribblePrinter2() {\n    // Register event types we're interested in for scribbling\n    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);\n    // Add a print button to he layout, and respond to it by printing\n    JButton b = new JButton(\"Print\");\n    b.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            printScribble();\n        }\n    });\n    this.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 5));\n    this.add(b);\n}\n","name":"ScribblePrinter2","className":"ScribblePrinter2","variables":{"actionPerformed":1,"b":2,"e":1},"constants":{"5":2,"\"Print\"":1},"javaDoc":"","comments":"Register event types we're interested in for scribbling Add a print button to he layout and respond to it by printing ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"setStroke":1,"draw":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Graphics2D":1},"expressions":{"VariableDeclarationExpr":1,"SuperExpr":1,"NameExpr":12,"CastExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/** Redraw (or print) the scribble based on stored lines */\npublic void paintComponent(Graphics g) {\n    // Allow the superclass to draw itself\n    super.paintComponent(g);\n    Graphics2D g2 = (Graphics2D) g;\n    // Specify wide lines\n    g2.setStroke(linestyle);\n    // Draw the scribble\n    g2.draw(scribble);\n}\n","name":"paintComponent","className":"ScribblePrinter2","variables":{"g":1,"g2":3},"constants":{},"javaDoc":"Redraw (or print) the scribble based on stored lines","comments":"Allow the superclass to draw itself Specify wide lines Draw the scribble  Redraw (or print) the scribble based on stored lines ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"defaultPage":1,"printDialog":1,"print":1,"getPrinterJob":1,"System.err.println":1,"setPrintable":1},"annotations":[],"exceptions":["PrinterException"],"concepts":["ExceptionHandling"],"types":{"PrinterJob":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":21,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/**\n     * Print out the scribble.  This is the method invoked by the Print button;\n     * it is not part of the Printable interface\n     **/\npublic void printScribble() {\n    // Obtain a java.awt.print.PrinterJob  (not java.awt.PrintJob)\n    PrinterJob job = PrinterJob.getPrinterJob();\n    // Tell the PrinterJob to print us (since we implement Printable)\n    // using the default page layout\n    job.setPrintable(this, job.defaultPage());\n    // The method returns false if the user cancelled the print request\n    if (job.printDialog()) {\n        // method defined by the Printable interface.\n        try {\n            job.print();\n        } catch (PrinterException e) {\n            System.err.println(e);\n        }\n    }\n}\n     // Display the print dialog that allows the user to set options.\n\n         // If not cancelled, start printing!  This will call the print()\n\n","name":"printScribble","className":"ScribblePrinter2","variables":{"e":1,"job":5,"PrinterJob":1},"constants":{},"javaDoc":"Print out the scribble This is the method invoked by the Print button; it is not part of the Printable interface","comments":"Tell the PrinterJob to print us (since we implement Printable) Display the print dialog that allows the user to set options Obtain a java awt print PrinterJob (not java awt PrintJob) using the default page layout The method returns false if the user cancelled the print request If not cancelled start printing! This will call the print() method defined by the Printable interface \n     * Print out the scribble.  This is the method invoked by the Print button;\n     * it is not part of the Printable interface\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","PageFormat","int"],"returnType":"int","methodCalls":{"getImageableHeight":1,"scale":2,"getImageableWidth":1,"setClip":1,"getImageableX":1,"drawRect":1,"translate":2,"getImageableY":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"double":4,"Dimension":1,"Graphics2D":1},"expressions":{"IntegerLiteralExpr":9,"VariableDeclarationExpr":6,"BinaryExpr":11,"NameExpr":91,"CastExpr":1,"FieldAccessExpr":12,"EnclosedExpr":2,"UnaryExpr":2,"ThisExpr":2,"MethodCallExpr":12,"AssignExpr":4},"statements":{"IfStmt":3,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":17},"text":"/**\n     * This is the method defined by the Printable interface.  It prints the\n     * scribble to the specified Graphics object, respecting the paper size\n     * and margins specified by the PageFormat.  If the specified page number\n     * is not page 0, it returns a code saying that printing is complete.  The\n     * method must be prepared to be called multiple times per printing request\n     **/\npublic int print(Graphics g, PageFormat format, int pagenum) {\n    // We are only one page long; reject any other page numbers\n    if (pagenum > 0)\n        return Printable.NO_SUCH_PAGE;\n    // The Java 1.2 printing API passes us a Graphics object, but we\n    // can always cast it to a Graphics2D object\n    Graphics2D g2 = (Graphics2D) g;\n    // Translate to accomodate the requested top and left margins.\n    g2.translate(format.getImageableX(), format.getImageableY());\n    // Figure out how big the drawing is, and how big the page \n    // (excluding margins) is\n    // Scribble size\n    Dimension size = this.getSize();\n    // Page width\n    double pageWidth = format.getImageableWidth();\n    // Page height\n    double pageHeight = format.getImageableHeight();\n    // If the scribble is too wide or tall for the page, scale it down\n    if (size.width > pageWidth) {\n        // How much to scale\n        double factor = pageWidth / size.width;\n        // Adjust coordinate system\n        g2.scale(factor, factor);\n        // Adjust page size up\n        pageWidth /= factor;\n        pageHeight /= factor;\n    }\n    if (size.height > pageHeight) {\n        // Do the same thing for height\n        double factor = pageHeight / size.height;\n        g2.scale(factor, factor);\n        pageWidth /= factor;\n        pageHeight /= factor;\n    }\n    // Now we know the scribble will fit on the page.  Center it by\n    // translating as necessary.\n    g2.translate((pageWidth - size.width) / 2, (pageHeight - size.height) / 2);\n    // Draw a line around the outside of the drawing area\n    g2.drawRect(-1, -1, size.width + 2, size.height + 2);\n    // Set a clipping region so the scribbles don't go out of bounds\n    g2.setClip(0, 0, size.width, size.height);\n    // Finally, print the component by calling the paintComponent() method.\n    // Or, call paint() to paint the component, its background, border, and\n    // children, including the Print JButton\n    this.paintComponent(g);\n    // Tell the PrinterJob that the page number was valid\n    return Printable.PAGE_EXISTS;\n}\n","name":"print","className":"ScribblePrinter2","variables":{"size":1,"g":1,"format":4,"g2":7,"pagenum":1,"factor":6,"pageHeight":6,"pageWidth":6},"constants":{"0":3,"1":2,"2":4},"javaDoc":"This is the method defined by the Printable interface It prints the scribble to the specified Graphics object respecting the paper size and margins specified by the PageFormat If the specified page number is not page 0 it returns a code saying that printing is complete The method must be prepared to be called multiple times per printing request","comments":"The Java 1 2 printing API passes us a Graphics object but we Figure out how big the drawing is and how big the page (excluding margins) is Now we know the scribble will fit on the page Center it by Finally print the component by calling the paintComponent() method Or call paint() to paint the component its background border and We are only one page long; reject any other page numbers can always cast it to a Graphics2D object Translate to accomodate the requested top and left margins Scribble size Page width Page height If the scribble is too wide or tall for the page scale it down How much to scale Adjust coordinate system Adjust page size up Do the same thing for height translating as necessary Draw a line around the outside of the drawing area Set a clipping region so the scribbles don't go out of bounds children including the Print JButton Tell the PrinterJob that the page number was valid \n     * This is the method defined by the Printable interface.  It prints the\n     * scribble to the specified Graphics object, respecting the paper size\n     * and margins specified by the PageFormat.  If the specified page number\n     * is not page 0, it returns a code saying that printing is complete.  The\n     * method must be prepared to be called multiple times per printing request\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"getID":1,"moveTo":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":18,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"/** Called when the user clicks to begin a scribble */\npublic void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        // Start a new line \n        scribble.moveTo(e.getX(), e.getY());\n    } else\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"ScribblePrinter2","variables":{"e":3,"scribble":1},"constants":{},"javaDoc":"Called when the user clicks to begin a scribble","comments":"Start a new line  Called when the user clicks to begin a scribble ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"lineTo":1,"getID":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":20,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/** Called when the the user drags the mouse: does the scribbling */\npublic void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED) {\n        // Add a line to the scribble\n        scribble.lineTo(e.getX(), e.getY());\n        // Redraw the whole scribble. Clean but a little slow\n        repaint();\n    } else\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"ScribblePrinter2","variables":{"e":3,"scribble":1},"constants":{},"javaDoc":"Called when the the user drags the mouse: does the scribbling","comments":"Add a line to the scribble Redraw the whole scribble Clean but a little slow  Called when the the user drags the mouse: does the scribbling ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"getContentPane":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JFrame":1,"ScribblePrinter2":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":15,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"/** The main method.  Create a ScribblePrinter2 object and away we go! */\npublic static void main(String[] args) {\n    JFrame frame = new JFrame(\"ScribblePrinter2\");\n    ScribblePrinter2 s = new ScribblePrinter2();\n    frame.getContentPane().add(s, BorderLayout.CENTER);\n    frame.setSize(400, 400);\n    frame.setVisible(true);\n}\n","name":"main","className":"ScribblePrinter2","variables":{"s":1,"frame":4},"constants":{"400":2,"true":1,"\"ScribblePrinter2\"":1},"javaDoc":"The main method Create a ScribblePrinter2 object and away we go!","comments":" The main method.  Create a ScribblePrinter2 object and away we go! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["TreeWalker"],"returnType":"DOMTreeWalkerTreeModel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Create a TreeModel for the specified TreeWalker */\npublic DOMTreeWalkerTreeModel(TreeWalker walker) {\n    this.walker = walker;\n}\n","name":"DOMTreeWalkerTreeModel","className":"DOMTreeWalkerTreeModel","variables":{"walker":1},"constants":{},"javaDoc":"Create a TreeModel for the specified TreeWalker","comments":" Create a TreeModel for the specified TreeWalker ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Document"],"returnType":"DOMTreeWalkerTreeModel","methodCalls":{"createTreeWalker":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"DocumentTraversal":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"NameExpr":9,"FieldAccessExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/** \n     * Create a TreeModel for a TreeWalker that returns all nodes\n     * in the specified document\n     **/\npublic DOMTreeWalkerTreeModel(Document document) {\n    DocumentTraversal dt = (DocumentTraversal) document;\n    walker = dt.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n}\n","name":"DOMTreeWalkerTreeModel","className":"DOMTreeWalkerTreeModel","variables":{"dt":2,"document":1,"walker":1},"constants":{"null":1,"false":1},"javaDoc":"Create a TreeModel for a TreeWalker that returns all nodes in the specified document","comments":" \n     * Create a TreeModel for a TreeWalker that returns all nodes\n     * in the specified document\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Element"],"returnType":"DOMTreeWalkerTreeModel","methodCalls":{"getOwnerDocument":1,"createTreeWalker":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"DocumentTraversal":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"NameExpr":11,"FieldAccessExpr":1,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** \n     * Create a TreeModel for a TreeWalker that returns the specified \n     * element and all of its descendant nodes.\n     **/\npublic DOMTreeWalkerTreeModel(Element element) {\n    DocumentTraversal dt = (DocumentTraversal) element.getOwnerDocument();\n    walker = dt.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false);\n}\n","name":"DOMTreeWalkerTreeModel","className":"DOMTreeWalkerTreeModel","variables":{"dt":2,"walker":1,"element":1},"constants":{"null":1,"false":1},"javaDoc":"Create a TreeModel for a TreeWalker that returns the specified element and all of its descendant nodes","comments":" \n     * Create a TreeModel for a TreeWalker that returns the specified \n     * element and all of its descendant nodes.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{"getRoot":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"// Return the root of the tree \npublic Object getRoot() {\n    return walker.getRoot();\n}\n","name":"getRoot","className":"DOMTreeWalkerTreeModel","variables":{"walker":1},"constants":{},"javaDoc":"","comments":" Return the root of the tree ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"setCurrentNode":1,"firstChild":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":8,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"// Is this node a leaf? (Leaf nodes are displayed differently by JTree)\npublic boolean isLeaf(Object node) {\n    // Set current node\n    walker.setCurrentNode((Node) node);\n    // Ask for a child\n    Node child = walker.firstChild();\n    // Does it have any?\n    return (child == null);\n}\n","name":"isLeaf","className":"DOMTreeWalkerTreeModel","variables":{"node":1,"walker":2,"child":2},"constants":{"null":1},"javaDoc":"","comments":"Set current node Ask for a child Does it have any?  Is this node a leaf? (Leaf nodes are displayed differently by JTree)","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"setCurrentNode":1,"firstChild":1,"nextSibling":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":14,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// How many children does this node have?\npublic int getChildCount(Object node) {\n    // Set the current node\n    walker.setCurrentNode((Node) node);\n    // TreeWalker doesn't count children for us, so we count ourselves\n    int numkids = 0;\n    // Start with the first child\n    Node child = walker.firstChild();\n    while (child != null) {\n        // Loop 'till there are no more\n        // Update the count\n        numkids++;\n        // Get next child\n        child = walker.nextSibling();\n    }\n    // This is the number of children\n    return numkids;\n}\n","name":"getChildCount","className":"DOMTreeWalkerTreeModel","variables":{"node":1,"numkids":3,"walker":3,"child":3},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Set the current node TreeWalker doesn't count children for us so we count ourselves Start with the first child Loop 'till there are no more Update the count Get next child This is the number of children  How many children does this node have?","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","int"],"returnType":"Object","methodCalls":{"setCurrentNode":1,"firstChild":1,"nextSibling":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// Return the specified child of a parent node.\npublic Object getChild(Object parent, int index) {\n    // Set the current node\n    walker.setCurrentNode((Node) parent);\n    // TreeWalker provides sequential access to children, not random\n    // access, so we've got to loop through the kids one by one\n    Node child = walker.firstChild();\n    while (index-- > 0) child = walker.nextSibling();\n    return child;\n}\n","name":"getChild","className":"DOMTreeWalkerTreeModel","variables":{"parent":1,"index":1,"walker":3,"child":3},"constants":{"0":1},"javaDoc":"","comments":"TreeWalker provides sequential access to children not random Set the current node access so we've got to loop through the kids one by one  Return the specified child of a parent node.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"setCurrentNode":1,"firstChild":1,"nextSibling":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Node":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":16,"CastExpr":1,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// Return the index of the child node in the parent node\npublic int getIndexOfChild(Object parent, Object child) {\n    // Set current node\n    walker.setCurrentNode((Node) parent);\n    int index = 0;\n    // Start with first child\n    Node c = walker.firstChild();\n    while ((c != child) && (c != null)) {\n        // Loop 'till we find a match\n        index++;\n        // Get the next child\n        c = walker.nextSibling();\n    }\n    // Return matching position\n    return index;\n}\n","name":"getIndexOfChild","className":"DOMTreeWalkerTreeModel","variables":{"parent":1,"c":4,"index":3,"walker":3,"child":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Set current node Start with first child Loop 'till we find a match Get the next child Return matching position  Return the index of the child node in the parent node","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreePath","Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Only required for editable trees; unimplemented here.\npublic void valueForPathChanged(TreePath path, Object newvalue) {\n}\n","name":"valueForPathChanged","className":"DOMTreeWalkerTreeModel","variables":{},"constants":{},"javaDoc":"","comments":" Only required for editable trees; unimplemented here.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeModelListener"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// This TreeModel never fires any events (since it is not editable)\n// so event listener registration methods are left unimplemented\npublic void addTreeModelListener(TreeModelListener l) {\n}\n","name":"addTreeModelListener","className":"DOMTreeWalkerTreeModel","variables":{},"constants":{},"javaDoc":"","comments":" so event listener registration methods are left unimplemented","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeModelListener"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void removeTreeModelListener(TreeModelListener l) {\n}\n","name":"removeTreeModelListener","className":"DOMTreeWalkerTreeModel","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"short","methodCalls":{"trim":1,"length":1,"getNodeType":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":19,"CastExpr":1,"FieldAccessExpr":3,"EnclosedExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"ReturnStmt":2},"text":"public short acceptNode(Node n) {\n    if (n.getNodeType() == Node.TEXT_NODE) {\n        // If nothing is left, then reject the node\n        if (((Text) n).getData().trim().length() == 0)\n            return NodeFilter.FILTER_REJECT;\n    }\n    return NodeFilter.FILTER_ACCEPT;\n}\n             // Use trim() to strip off leading and trailing space.\n\n","name":"acceptNode","className":"","variables":{"n":2},"constants":{"0":1},"javaDoc":"","comments":"Use trim() to strip off leading and trailing space If nothing is left then reject the node ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"setSize":1,"trim":1,"getDocument":1,"length":1,"getNodeType":1,"getContentPane":1,"parse":1,"createTreeWalker":1},"annotations":[],"exceptions":["IOException","SAXException"],"concepts":["Casting","InnerMethod","PolyMorphism"],"types":{"InputSource":2,"JTree":1,"JFrame":1,"BufferedReader":1,"Reader":1,"TreeWalker":1,"DocumentTraversal":1,"DOMParser":2,"Document":1,"int":1,"NodeFilter":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":4,"VariableDeclarationExpr":10,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":56,"StringLiteralExpr":1,"UnaryExpr":1,"BooleanLiteralExpr":2,"CastExpr":2,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":2,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":14},"text":"/**\n     * This main() method demonstrates the use of this class, the use of the\n     * Xerces DOM parser, and the creation of a DOM Level 2 TreeWalker object.\n     **/\npublic static void main(String[] args) throws IOException, SAXException {\n    // Obtain an instance of a Xerces parser to build a DOM tree.\n    // Note that we are not using the JAXP API here, so this\n    // code uses Apache Xerces APIs that are not standards\n    DOMParser parser = new org.apache.xerces.parsers.DOMParser();\n    // Get a java.io.Reader for the input XML file and \n    // wrap the input file in a SAX input source\n    Reader in = new BufferedReader(new FileReader(args[0]));\n    InputSource input = new org.xml.sax.InputSource(in);\n    // Tell the Xerces parser to parse the input source\n    parser.parse(input);\n    // Ask the parser to give us our DOM Document.  Once we've got the DOM\n    // tree, we don't have to use the Apache Xerces APIs any more; from\n    // here on, we use the standard DOM APIs\n    Document document = parser.getDocument();\n    // If we're using a DOM Level 2 implementation, then our Document\n    // object ought to implement DocumentTraversal \n    DocumentTraversal traversal = (DocumentTraversal) document;\n    // For this demonstration, we create a NodeFilter that filters out\n    // Text nodes containing only space; these just clutter up the tree\n    NodeFilter filter = new NodeFilter() {\n\n        public short acceptNode(Node n) {\n            if (n.getNodeType() == Node.TEXT_NODE) {\n                // If nothing is left, then reject the node\n                if (((Text) n).getData().trim().length() == 0)\n                    return NodeFilter.FILTER_REJECT;\n            }\n            return NodeFilter.FILTER_ACCEPT;\n        }\n    };\n    // This set of flags says to \"show\" all node types except comments\n    int whatToShow = NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_COMMENT;\n    // Create a TreeWalker using the filter and the flags\n    TreeWalker walker = traversal.createTreeWalker(document, whatToShow, filter, false);\n    // Instantiate a TreeModel and a JTree to display it\n    JTree tree = new JTree(new DOMTreeWalkerTreeModel(walker));\n    // Create a frame and a scrollpane to display the tree, and pop them up\n    JFrame frame = new JFrame(\"DOMTreeWalkerTreeModel Demo\");\n    frame.getContentPane().add(new JScrollPane(tree));\n    frame.setSize(500, 250);\n    frame.setVisible(true);\n}\n             // Use trim() to strip off leading and trailing space.\n\n","name":"main","className":"DOMTreeWalkerTreeModel","variables":{"in":2,"document":2,"tree":2,"whatToShow":1,"walker":2,"n":3,"args":1,"filter":1,"input":1,"acceptNode":1,"parser":3,"traversal":2,"frame":4},"constants":{"0":2,"500":1,"false":1,"true":1,"\"DOMTreeWalkerTreeModel Demo\"":1,"250":1},"javaDoc":"This main() method demonstrates the use of this class the use of the Xerces DOM parser and the creation of a DOM Level 2 TreeWalker object","comments":"Obtain an instance of a Xerces parser to build a DOM tree Note that we are not using the JAXP API here so this Get a java io Reader for the input XML file and Ask the parser to give us our DOM Document Once we've got the DOM tree we don't have to use the Apache Xerces APIs any more; from If we're using a DOM Level 2 implementation then our Document For this demonstration we create a NodeFilter that filters out code uses Apache Xerces APIs that are not standards wrap the input file in a SAX input source Tell the Xerces parser to parse the input source here on we use the standard DOM APIs object ought to implement DocumentTraversal Text nodes containing only space; these just clutter up the tree Use trim() to strip off leading and trailing space If nothing is left then reject the node This set of flags says to \"show\" all node types except comments Create a TreeWalker using the filter and the flags Instantiate a TreeModel and a JTree to display it Create a frame and a scrollpane to display the tree and pop them up \n     * This main() method demonstrates the use of this class, the use of the\n     * Xerces DOM parser, and the creation of a DOM Level 2 TreeWalker object.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setSystemId":1,"setValidating":1,"newInstance":1,"parse":1,"newSAXParser":1},"annotations":[],"exceptions":["IOException","ParserConfigurationException","SAXException"],"concepts":["PolyMorphism"],"types":{"org.xml.sax.InputSource":1,"InputSource":1,"ListServlets1":1,"javax.xml.parsers.SAXParserFactory":1,"javax.xml.parsers.SAXParser":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":21,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":7},"text":"/** The main method sets things up for parsing */\npublic static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {\n    // Create a JAXP \"parser factory\" for creating SAX parsers\n    javax.xml.parsers.SAXParserFactory spf = SAXParserFactory.newInstance();\n    // Configure the parser factory for the type of parsers we require\n    // No validation required\n    spf.setValidating(false);\n    // Now use the parser factory to create a SAXParser object\n    // Note that SAXParser is a JAXP class, not a SAX class\n    javax.xml.parsers.SAXParser sp = spf.newSAXParser();\n    // Create a SAX input source for the file argument\n    org.xml.sax.InputSource input = new InputSource(new FileReader(args[0]));\n    // Give the InputSource an absolute URL for the file, so that\n    // it can resolve relative URLs in a <!DOCTYPE> declaration, e.g.\n    input.setSystemId(\"file://\" + new File(args[0]).getAbsolutePath());\n    // Create an instance of this class; it defines all the handler methods\n    ListServlets1 handler = new ListServlets1();\n    // Finally, tell the parser to parse the input and notify the handler\n    sp.parse(input, handler);\n// Instead of using the SAXParser.parse() method, which is part of the\n// JAXP API, we could also use the SAX1 API directly.  Note the\n// difference between the JAXP class javax.xml.parsers.SAXParser and\n// the SAX1 class org.xml.sax.Parser\n//\n// org.xml.sax.Parser parser = sp.getParser();  // Get the SAX parser\n// parser.setDocumentHandler(handler);          // Set main handler\n// parser.setErrorHandler(handler);             // Set error handler\n// parser.parse(input);                         // Parse!\n}\n","name":"main","className":"ListServlets1","variables":{"args":2,"input":2,"handler":1,"spf":3,"sp":2,"SAXParserFactory":1},"constants":{"0":2,"\"file://\"":1,"false":1},"javaDoc":"The main method sets things up for parsing","comments":"Configure the parser factory for the type of parsers we require Now use the parser factory to create a SAXParser object Give the InputSource an absolute URL for the file so that Instead of using the SAXParser parse() method which is part of the JAXP API we could also use the SAX1 API directly Note the difference between the JAXP class javax xml parsers SAXParser and the SAX1 class org xml sax Parser  org xml sax Parser parser = sp getParser(); // Get the SAX parser parser setDocumentHandler(handler); // Set main handler parser setErrorHandler(handler); // Set error handler parser parse(input); // Parse! Create a JAXP \"parser factory\" for creating SAX parsers No validation required Note that SAXParser is a JAXP class not a SAX class Create a SAX input source for the file argument it can resolve relative URLs in a <!DOCTYPE> declaration e g Create an instance of this class; it defines all the handler methods Finally tell the parser to parse the input and notify the handler  The main method sets things up for parsing ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// When the parser encounters plain text (not XML elements), it calls\n// this method, which accumulates them in a string buffer\npublic void characters(char[] buffer, int start, int length) {\n    accumulator.append(buffer, start, length);\n}\n","name":"characters","className":"ListServlets1","variables":{"accumulator":1},"constants":{},"javaDoc":"","comments":" this method, which accumulates them in a string buffer","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","AttributeList"],"returnType":"void","methodCalls":{"getValue":1,"setLength":1,"equals":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":10,"StringLiteralExpr":2,"MethodCallExpr":3,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"// Every time the parser encounters the beginning of a new element, it\n// calls this method, which resets the string buffer\npublic void startElement(String name, AttributeList attributes) {\n    // Ready to accumulate new text\n    accumulator.setLength(0);\n    // If its a servlet tag, look for id attribute\n    if (name.equals(\"servlet\"))\n        servletId = attributes.getValue(\"id\");\n}\n","name":"startElement","className":"ListServlets1","variables":{"name":1,"servletId":1,"accumulator":1,"attributes":1},"constants":{"0":1,"\"servlet\"":1,"\"id\"":1},"javaDoc":"","comments":"Ready to accumulate new text If its a servlet tag look for id attribute  calls this method, which resets the string buffer","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"trim":2,"equals":3,"toString":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":7,"NameExpr":30,"StringLiteralExpr":8,"FieldAccessExpr":1,"EnclosedExpr":2,"ConditionalExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":3},"text":"// When the parser encounters the end of an element, it calls this method\npublic void endElement(String name) {\n    if (name.equals(\"servlet-name\")) {\n        // After </servlet-name>, we know the servlet name saved up\n        servletName = accumulator.toString().trim();\n    } else if (name.equals(\"servlet-class\")) {\n        // After </servlet-class>, we've got the class name accumulated\n        servletClass = accumulator.toString().trim();\n    } else if (name.equals(\"servlet\")) {\n        // Assuming the document is valid, then when we parse </servlet>,\n        // we know we've got a servlet name and class name to print out\n        System.out.println(\"Servlet \" + servletName + ((servletId != null) ? \" (id=\" + servletId + \")\" : \"\") + \": \" + servletClass);\n    }\n}\n","name":"endElement","className":"ListServlets1","variables":{"servletClass":2,"name":3,"servletId":2,"accumulator":2,"servletName":2},"constants":{"\"\"":1,"\"servlet\"":1,"null":1,"\" (id=\"":1,"\": \"":1,"\"servlet-name\"":1,"\")\"":1,"\"servlet-class\"":1,"\"Servlet \"":1},"javaDoc":"","comments":"After </servlet-name> we know the servlet name saved up After </servlet-class> we've got the class name accumulated Assuming the document is valid then when we parse </servlet> we know we've got a servlet name and class name to print out  When the parser encounters the end of an element, it calls this method","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"/** This method is called when warnings occur */\npublic void warning(SAXParseException exception) {\n    System.err.println(\"WARNING: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n}\n","name":"warning","className":"ListServlets1","variables":{"exception":2},"constants":{"\": \"":1,"\"WARNING: line \"":1},"javaDoc":"This method is called when warnings occur","comments":" This method is called when warnings occur ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"/** This method is called when errors occur */\npublic void error(SAXParseException exception) {\n    System.err.println(\"ERROR: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n}\n","name":"error","className":"ListServlets1","variables":{"exception":2},"constants":{"\"ERROR: line \"":1,"\": \"":1},"javaDoc":"This method is called when errors occur","comments":" This method is called when errors occur ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["SAXException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ThrowStmt":1,"ExpressionStmt":1},"text":"/** This method is called when non-recoverable errors occur. */\npublic void fatalError(SAXParseException exception) throws SAXException {\n    System.err.println(\"FATAL: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n    throw (exception);\n}\n","name":"fatalError","className":"ListServlets1","variables":{"exception":3},"constants":{"\"FATAL: line \"":1,"\": \"":1},"javaDoc":"This method is called when non-recoverable errors occur","comments":" This method is called when non-recoverable errors occur. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setFeature":1,"setContentHandler":1,"setErrorHandler":1,"parse":1},"annotations":[],"exceptions":["IOException","SAXException"],"concepts":["PolyMorphism"],"types":{"org.xml.sax.XMLReader":1,"org.xml.sax.InputSource":1,"InputSource":1,"ListServlets2":1,"SAXParser":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BooleanLiteralExpr":1,"NameExpr":16,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":7},"text":"/** The main method sets things up for parsing */\npublic static void main(String[] args) throws IOException, SAXException {\n    // Create the parser we'll use.  The parser implementation is a \n    // Xerces class, but we use it only through the SAX XMLReader API\n    org.xml.sax.XMLReader parser = new org.apache.xerces.parsers.SAXParser();\n    // Specify that we don't want validation.  This is the SAX2\n    // API for requesting parser features.  Note the use of a\n    // globally unique URL as the feature name.  Non-validation is\n    // actually the default, so this line isn't really necessary.\n    parser.setFeature(\"http://xml.org/sax/features/validation\", false);\n    // Instantiate this class to provide handlers for the parser and \n    // tell the parser about the handlers\n    ListServlets2 handler = new ListServlets2();\n    parser.setContentHandler(handler);\n    parser.setErrorHandler(handler);\n    // Create an input source that describes the file to parse.\n    // Then tell the parser to parse input from that source\n    org.xml.sax.InputSource input = new InputSource(new FileReader(args[0]));\n    parser.parse(input);\n}\n","name":"main","className":"ListServlets2","variables":{"args":1,"handler":1,"input":1,"parser":5},"constants":{"0":1,"\"http://xml.org/sax/features/validation\"":1,"false":1},"javaDoc":"The main method sets things up for parsing","comments":"Create the parser we'll use The parser implementation is a Specify that we don't want validation This is the SAX2 API for requesting parser features Note the use of a globally unique URL as the feature name Non-validation is Instantiate this class to provide handlers for the parser and Create an input source that describes the file to parse Xerces class but we use it only through the SAX XMLReader API actually the default so this line isn't really necessary tell the parser about the handlers Then tell the parser to parse input from that source  The main method sets things up for parsing ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"NameExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"// Called at the beginning of parsing.  We use it as an init() method\npublic void startDocument() {\n    accumulator = new StringBuffer();\n    nameToClass = new HashMap();\n    nameToPatterns = new HashMap();\n}\n","name":"startDocument","className":"ListServlets2","variables":{"nameToClass":1,"accumulator":1,"nameToPatterns":1},"constants":{},"javaDoc":"","comments":" Called at the beginning of parsing.  We use it as an init() method","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"append":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// When the parser encounters plain text (not XML elements), it calls\n// this method, which accumulates them in a string buffer.\n// Note that this method may be called multiple times, even with no\n// intervening elements.\npublic void characters(char[] buffer, int start, int length) {\n    accumulator.append(buffer, start, length);\n}\n","name":"characters","className":"ListServlets2","variables":{"accumulator":1},"constants":{},"javaDoc":"","comments":" intervening elements.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String","Attributes"],"returnType":"void","methodCalls":{"setLength":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// At the beginning of each new element, erase any accumulated text.\npublic void startElement(String namespaceURL, String localName, String qname, Attributes attributes) {\n    accumulator.setLength(0);\n}\n","name":"startElement","className":"ListServlets2","variables":{"accumulator":1},"constants":{"0":1},"javaDoc":"","comments":" At the beginning of each new element, erase any accumulated text.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","String"],"returnType":"void","methodCalls":{"add":1,"trim":3,"equals":5,"get":1,"toString":3,"put":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"List":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":53,"StringLiteralExpr":5,"CastExpr":1,"MethodCallExpr":15,"AssignExpr":4},"statements":{"IfStmt":6,"BlockStmt":6,"ExpressionStmt":8},"text":"// Take special action when we reach the end of selected elements.\n// Although we don't use a validating parser, this method does assume\n// that the web.xml file we're parsing is valid.\npublic void endElement(String namespaceURL, String localName, String qname) {\n    if (localName.equals(\"servlet-name\")) {\n        // Store servlet name\n        servletName = accumulator.toString().trim();\n    } else if (localName.equals(\"servlet-class\")) {\n        // Store servlet class\n        servletClass = accumulator.toString().trim();\n    } else if (localName.equals(\"url-pattern\")) {\n        // Store servlet pattern\n        servletPattern = accumulator.toString().trim();\n    } else if (localName.equals(\"servlet\")) {\n        // Map name to class\n        nameToClass.put(servletName, servletClass);\n    } else if (localName.equals(\"servlet-mapping\")) {\n        // Map name to pattern\n        List patterns = (List) nameToPatterns.get(servletName);\n        if (patterns == null) {\n            patterns = new ArrayList();\n            nameToPatterns.put(servletName, patterns);\n        }\n        patterns.add(servletPattern);\n    }\n}\n","name":"endElement","className":"ListServlets2","variables":{"localName":5,"servletClass":1,"servletPattern":1,"patterns":4,"nameToClass":1,"accumulator":3,"servletName":1,"nameToPatterns":2},"constants":{"\"servlet\"":1,"\"url-pattern\"":1,"null":1,"\"servlet-name\"":1,"\"servlet-class\"":1,"\"servlet-mapping\"":1},"javaDoc":"","comments":"Store servlet name Store servlet class Store servlet pattern Map name to class Map name to pattern  that the web.xml file we're parsing is valid.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"next":2,"iterator":2,"get":2,"hasNext":2,"sort":1,"keySet":1,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":["Casting","PolyMorphism"],"types":{"ArrayList":1,"Iterator":2,"List":2,"String":2},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":4,"NameExpr":61,"CastExpr":3,"StringLiteralExpr":4,"FieldAccessExpr":5,"MethodCallExpr":15},"statements":{"IfStmt":1,"BlockStmt":3,"ForStmt":2,"ExpressionStmt":10},"text":"// Called at the end of parsing.  Used here to print our results.\npublic void endDocument() {\n    List servletNames = new ArrayList(nameToClass.keySet());\n    Collections.sort(servletNames);\n    for (Iterator iterator = servletNames.iterator(); iterator.hasNext(); ) {\n        String name = (String) iterator.next();\n        String classname = (String) nameToClass.get(name);\n        List patterns = (List) nameToPatterns.get(name);\n        System.out.println(\"Servlet: \" + name);\n        System.out.println(\"Class: \" + classname);\n        if (patterns != null) {\n            System.out.println(\"Patterns:\");\n            for (Iterator i = patterns.iterator(); i.hasNext(); ) {\n                System.out.println(\"\\t\" + i.next());\n            }\n        }\n        System.out.println();\n    }\n}\n","name":"endDocument","className":"ListServlets2","variables":{"iterator":3,"classname":2,"servletNames":2,"patterns":3,"nameToClass":2,"name":2,"i":3,"Collections":1,"nameToPatterns":1},"constants":{"\"Class: \"":1,"\"Patterns:\"":1,"null":1,"\"\\t\"":1,"\"Servlet: \"":1},"javaDoc":"","comments":" Called at the end of parsing.  Used here to print our results.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"// Issue a warning\npublic void warning(SAXParseException exception) {\n    System.err.println(\"WARNING: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n}\n","name":"warning","className":"ListServlets2","variables":{"exception":2},"constants":{"\": \"":1,"\"WARNING: line \"":1},"javaDoc":"","comments":" Issue a warning","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"// Report a parsing error\npublic void error(SAXParseException exception) {\n    System.err.println(\"ERROR: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n}\n","name":"error","className":"ListServlets2","variables":{"exception":2},"constants":{"\"ERROR: line \"":1,"\": \"":1},"javaDoc":"","comments":" Report a parsing error","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getLineNumber":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["SAXException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ThrowStmt":1,"ExpressionStmt":1},"text":"// Report a non-recoverable error and exit\npublic void fatalError(SAXParseException exception) throws SAXException {\n    System.err.println(\"FATAL: line \" + exception.getLineNumber() + \": \" + exception.getMessage());\n    throw (exception);\n}\n","name":"fatalError","className":"ListServlets2","variables":{"exception":3},"constants":{"\"FATAL: line \"":1,"\": \"":1},"javaDoc":"","comments":" Report a non-recoverable error and exit","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"XMLDocumentWriter","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Initialize the output stream */\npublic XMLDocumentWriter(PrintWriter out) {\n    this.out = out;\n}\n","name":"XMLDocumentWriter","className":"XMLDocumentWriter","variables":{"out":1},"constants":{},"javaDoc":"Initialize the output stream","comments":" Initialize the output stream ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Close the output stream. */\npublic void close() {\n    out.close();\n}\n","name":"close","className":"XMLDocumentWriter","variables":{"out":1},"constants":{},"javaDoc":"Close the output stream","comments":" Close the output stream. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node"],"returnType":"void","methodCalls":{"write":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{},"expressions":{"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Output a DOM Node (such as a Document) to the output stream */\npublic void write(Node node) {\n    write(node, \"\");\n}\n","name":"write","className":"XMLDocumentWriter","variables":{},"constants":{"\"\"":1},"javaDoc":"Output a DOM Node (such as a Document) to the output stream","comments":" Output a DOM Node (such as a Document) to the output stream ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Node","String"],"returnType":"void","methodCalls":{"getClass":1,"item":1,"getNextSibling":2,"getName":2,"getAttributes":1,"length":1,"getNodeName":2,"getNodeValue":1,"println":9,"print":2,"getTarget":1,"trim":1,"getNodeType":1,"getFirstChild":2,"getTagName":2,"getLength":1,"System.err.println":1,"write":2,"fixup":2,"getData":4},"annotations":[],"exceptions":[],"concepts":["Casting","Recursion"],"types":{"Comment":1,"NamedNodeMap":1,"CDATASection":1,"Node":3,"Element":1,"DocumentType":1,"Text":1,"String":2,"Document":1,"int":1,"ProcessingInstruction":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":2,"VariableDeclarationExpr":14,"BinaryExpr":37,"NameExpr":166,"CastExpr":7,"StringLiteralExpr":23,"FieldAccessExpr":9,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":39,"AssignExpr":2},"statements":{"SwitchStmt":1,"IfStmt":1,"WhileStmt":2,"BreakStmt":9,"BlockStmt":11,"SwitchEntryStmt":9,"ForStmt":1,"ExpressionStmt":29},"text":"/**\n     * Output the specified DOM Node object, printing it using the specified\n     * indentation string\n     **/\npublic void write(Node node, String indent) {\n    // The output depends on the type of the node\n    switch(node.getNodeType()) {\n        case Node.DOCUMENT_NODE:\n            {\n                // If its a Document node\n                Document doc = (Document) node;\n                // Output header\n                out.println(indent + \"<?xml version='1.0'?>\");\n                // Get the first node\n                Node child = doc.getFirstChild();\n                while (child != null) {\n                    // Loop 'till no more nodes\n                    // Output node\n                    write(child, indent);\n                    // Get next node\n                    child = child.getNextSibling();\n                }\n                break;\n            }\n        case Node.DOCUMENT_TYPE_NODE:\n            {\n                // It is a <!DOCTYPE> tag\n                DocumentType doctype = (DocumentType) node;\n                // Note that the DOM Level 1 does not give us information about\n                // the the public or system ids of the doctype, so we can't output\n                // a complete <!DOCTYPE> tag here.  We can do better with Level 2.\n                out.println(\"<!DOCTYPE \" + doctype.getName() + \">\");\n                break;\n            }\n        case Node.ELEMENT_NODE:\n            {\n                // Most nodes are Elements\n                Element elt = (Element) node;\n                // Begin start tag\n                out.print(indent + \"<\" + elt.getTagName());\n                // Get attributes\n                NamedNodeMap attrs = elt.getAttributes();\n                for (int i = 0; i < attrs.getLength(); i++) {\n                    // Loop through them\n                    Node a = attrs.item(i);\n                    out.print(// Print attr. name\n                    \" \" + a.getNodeName() + \"='\" + fixup(a.getNodeValue()) + // Print attr. value\n                    \"'\");\n                }\n                // Finish start tag\n                out.println(\">\");\n                // Increase indent\n                String newindent = indent + \"    \";\n                // Get child\n                Node child = elt.getFirstChild();\n                while (child != null) {\n                    // Loop \n                    // Output child\n                    write(child, newindent);\n                    // Get next child\n                    child = child.getNextSibling();\n                }\n                out.println(// Output end tag\n                indent + \"</\" + elt.getTagName() + \">\");\n                break;\n            }\n        case Node.TEXT_NODE:\n            {\n                // Plain text node\n                Text textNode = (Text) node;\n                // Strip off space\n                String text = textNode.getData().trim();\n                if (// If non-empty\n                (text != null) && text.length() > 0)\n                    // print text\n                    out.println(indent + fixup(text));\n                break;\n            }\n        case Node.PROCESSING_INSTRUCTION_NODE:\n            {\n                // Handle PI nodes\n                ProcessingInstruction pi = (ProcessingInstruction) node;\n                out.println(indent + \"<?\" + pi.getTarget() + \" \" + pi.getData() + \"?>\");\n                break;\n            }\n        case Node.ENTITY_REFERENCE_NODE:\n            {\n                // Handle entities\n                out.println(indent + \"&\" + node.getNodeName() + \";\");\n                break;\n            }\n        case Node.CDATA_SECTION_NODE:\n            {\n                // Output CDATA sections\n                CDATASection cdata = (CDATASection) node;\n                // Careful! Don't put a CDATA section in the program itself!\n                out.println(indent + \"<\" + \"![CDATA[\" + cdata.getData() + \"]]\" + \">\");\n                break;\n            }\n        case Node.COMMENT_NODE:\n            {\n                // Comments\n                Comment c = (Comment) node;\n                out.println(indent + \"<!--\" + c.getData() + \"-->\");\n                break;\n            }\n        default:\n            // Hopefully, this won't happen too much!\n            System.err.println(\"Ignoring node: \" + node.getClass().getName());\n            break;\n    }\n}\n","name":"write","className":"XMLDocumentWriter","variables":{"a":3,"newindent":1,"c":2,"textNode":2,"indent":9,"i":3,"elt":5,"out":11,"attrs":3,"cdata":2,"doctype":2,"node":10,"doc":2,"pi":3,"text":3,"child":8},"constants":{"\" \"":2,"\">\"":4,"\"='\"":1,"\"<\"":2,"\";\"":1,"\"<?\"":1,"0":2,"\"]]\"":1,"\"?>\"":1,"\"-->\"":1,"\"Ignoring node: \"":1,"null":3,"\"    \"":1,"\"<!DOCTYPE \"":1,"\"<!--\"":1,"\"<?xml version='1.0'?>\"":1,"\"![CDATA[\"":1,"\"</\"":1,"\"&\"":1},"javaDoc":"Output the specified DOM Node object printing it using the specified indentation string","comments":"The output depends on the type of the node If its a Document node Output header Get the first node Loop 'till no more nodes Output node Get next node Note that the DOM Level 1 does not give us information about the the public or system ids of the doctype so we can't output It is a <!DOCTYPE> tag a complete <!DOCTYPE> tag here We can do better with Level 2 Most nodes are Elements Begin start tag Get attributes Loop through them Print attr name Print attr value Finish start tag Increase indent Get child Loop Output child Get next child Output end tag Plain text node Strip off space If non-empty print text Handle PI nodes Handle entities Output CDATA sections Careful! Don't put a CDATA section in the program itself! Comments Hopefully this won't happen too much! \n     * Output the specified DOM Node object, printing it using the specified\n     * indentation string\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"length":1,"toString":1,"charAt":1,"append":6},"annotations":[],"exceptions":[],"concepts":[],"types":{"StringBuffer":1,"char":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":33,"StringLiteralExpr":5,"CharLiteralExpr":5,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"SwitchStmt":1,"BreakStmt":6,"BlockStmt":1,"SwitchEntryStmt":6,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"// This method replaces reserved characters with entities.\nString fixup(String s) {\n    StringBuffer sb = new StringBuffer();\n    int len = s.length();\n    for (int i = 0; i < len; i++) {\n        char c = s.charAt(i);\n        switch(c) {\n            default:\n                sb.append(c);\n                break;\n            case '<':\n                sb.append(\"&lt;\");\n                break;\n            case '>':\n                sb.append(\"&gt;\");\n                break;\n            case '&':\n                sb.append(\"&amp;\");\n                break;\n            case '\"':\n                sb.append(\"&quot;\");\n                break;\n            case '\\'':\n                sb.append(\"&apos;\");\n                break;\n        }\n    }\n    return sb.toString();\n}\n","name":"fixup","className":"XMLDocumentWriter","variables":{"s":2,"c":2,"len":2,"i":3,"sb":8},"constants":{"0":1,"'>'":1,"\"&amp;\"":1,"'<'":1,"\"&gt;\"":1,"'\\''":1,"\"&apos;\"":1,"'&'":1,"\"&quot;\"":1,"\"&lt;\"":1,"'\"'":1},"javaDoc":"","comments":" This method replaces reserved characters with entities.","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"output":1,"addServlet":1,"getServletClass":1,"System.out.println":1},"annotations":[],"exceptions":["IOException","ParserConfigurationException","SAXException"],"concepts":[],"types":{"WebAppConfig":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** The main method creates and demonstrates a WebAppConfig object */\npublic static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {\n    // Create a new WebAppConfig object that represents the web.xml\n    // file specified by the first command-line argument\n    WebAppConfig config = new WebAppConfig(new File(args[0]));\n    // Query the tree for the class name associated with the specified\n    // servlet name\n    System.out.println(\"Class for servlet \" + args[1] + \" is \" + config.getServletClass(args[1]));\n    // Add a new servlet name-to-class mapping to the DOM tree\n    config.addServlet(\"foo\", \"bar\");\n    // And write out an XML version of the DOM tree to standard out\n    config.output(new PrintWriter(new OutputStreamWriter(System.out)));\n}\n","name":"main","className":"WebAppConfig","variables":{"args":3,"config":4},"constants":{"0":1,"1":2,"\"foo\"":1,"\" is \"":1,"\"bar\"":1,"\"Class for servlet \"":1},"javaDoc":"The main method creates and demonstrates a WebAppConfig object","comments":"Create a new WebAppConfig object that represents the web xml Query the tree for the class name associated with the specified file specified by the first command-line argument servlet name Add a new servlet name-to-class mapping to the DOM tree And write out an XML version of the DOM tree to standard out  The main method creates and demonstrates a WebAppConfig object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void warning(SAXParseException e) {\n    System.err.println(\"WARNING: \" + e.getMessage());\n}\n","name":"warning","className":"","variables":{"e":1},"constants":{"\"WARNING: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void error(SAXParseException e) {\n    System.err.println(\"ERROR: \" + e.getMessage());\n}\n","name":"error","className":"","variables":{"e":1},"constants":{"\"ERROR: \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["SAXParseException"],"returnType":"void","methodCalls":{"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["SAXException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":9,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ThrowStmt":1,"ExpressionStmt":1},"text":"public void fatalError(SAXParseException e) throws SAXException {\n    System.err.println(\"FATAL: \" + e.getMessage());\n    // re-throw the error\n    throw e;\n}\n","name":"fatalError","className":"","variables":{"e":2},"constants":{"\"FATAL: \"":1},"javaDoc":"","comments":"re-throw the error ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"WebAppConfig","methodCalls":{"newDocumentBuilder":1,"setErrorHandler":1,"setValidating":1,"getMessage":3,"newInstance":1,"parse":1,"System.err.println":3},"annotations":[],"exceptions":["IOException","ParserConfigurationException","SAXException"],"concepts":["InnerMethod"],"types":{"javax.xml.parsers.DocumentBuilder":1,"javax.xml.parsers.DocumentBuilderFactory":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":3,"NameExpr":48,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":11,"AssignExpr":1},"statements":{"BlockStmt":3,"ThrowStmt":1,"ExpressionStmt":8},"text":"/**\n     * This constructor method is passed an XML file.  It uses the JAXP API to\n     * obtain a DOM parser, and to parse the file into a DOM Document object,\n     * which is used by the remaining methods of the class.\n     **/\npublic WebAppConfig(File configfile) throws IOException, SAXException, ParserConfigurationException {\n    // Get a JAXP parser factory object\n    javax.xml.parsers.DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    // Tell the factory what kind of parser we want \n    dbf.setValidating(false);\n    // Use the factory to get a JAXP parser object\n    javax.xml.parsers.DocumentBuilder parser = dbf.newDocumentBuilder();\n    // Tell the parser how to handle errors.  Note that in the JAXP API,\n    // DOM parsers rely on the SAX API for error handling\n    parser.setErrorHandler(new org.xml.sax.ErrorHandler() {\n\n        public void warning(SAXParseException e) {\n            System.err.println(\"WARNING: \" + e.getMessage());\n        }\n\n        public void error(SAXParseException e) {\n            System.err.println(\"ERROR: \" + e.getMessage());\n        }\n\n        public void fatalError(SAXParseException e) throws SAXException {\n            System.err.println(\"FATAL: \" + e.getMessage());\n            // re-throw the error\n            throw e;\n        }\n    });\n    // Finally, use the JAXP parser to parse the file.  This call returns\n    // A Document object.  Now that we have this object, the rest of this\n    // class uses the DOM API to work with it; JAXP is no longer required.\n    document = parser.parse(configfile);\n}\n","name":"WebAppConfig","className":"WebAppConfig","variables":{"DocumentBuilderFactory":1,"parser":3,"e":7,"fatalError":1,"document":1,"dbf":3,"warning":1,"error":1},"constants":{"\"ERROR: \"":1,"\"FATAL: \"":1,"false":1,"\"WARNING: \"":1},"javaDoc":"This constructor method is passed an XML file It uses the JAXP API to obtain a DOM parser and to parse the file into a DOM Document object which is used by the remaining methods of the class","comments":"Tell the parser how to handle errors Note that in the JAXP API Finally use the JAXP parser to parse the file This call returns A Document object Now that we have this object the rest of this Get a JAXP parser factory object Tell the factory what kind of parser we want Use the factory to get a JAXP parser object DOM parsers rely on the SAX API for error handling re-throw the error class uses the DOM API to work with it; JAXP is no longer required \n     * This constructor method is passed an XML file.  It uses the JAXP API to\n     * obtain a DOM parser, and to parse the file into a DOM Document object,\n     * which is used by the remaining methods of the class.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"getNodeValue":1,"item":3,"trim":2,"equals":1,"getLength":1,"getFirstChild":2,"getElementsByTagName":3},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"NodeList":1,"Element":3,"Text":1,"String":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":3,"VariableDeclarationExpr":8,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":3,"CastExpr":5,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":14},"statements":{"ContinueStmt":1,"IfStmt":3,"BlockStmt":3,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":7},"text":"/**\n     * This method looks for specific Element nodes in the DOM tree in order\n     * to figure out the classname associated with the specified servlet name\n     **/\npublic String getServletClass(String servletName) {\n    // Find all <servlet> elements and loop through them.\n    NodeList servletnodes = document.getElementsByTagName(\"servlet\");\n    int numservlets = servletnodes.getLength();\n    for (int i = 0; i < numservlets; i++) {\n        Element servletTag = (Element) servletnodes.item(i);\n        // Get the first <servlet-name> tag within the <servlet> tag\n        Element nameTag = (Element) servletTag.getElementsByTagName(\"servlet-name\").item(0);\n        if (nameTag == null)\n            continue;\n        // The <servlet-name> tag should have a single child of type\n        // Text.  Get that child, and extract its text.  Use trim()\n        // to strip whitespace from the beginning and end of it.\n        String name = ((Text) nameTag.getFirstChild()).getData().trim();\n        // If this <servlet-name> tag has the right name\n        if (servletName.equals(name)) {\n            // Get the matching <servlet-class> tag\n            Element classTag = (Element) servletTag.getElementsByTagName(\"servlet-class\").item(0);\n            if (classTag != null) {\n                // Extract the tag's text as above, and return it\n                Text classTagContent = (Text) classTag.getFirstChild();\n                return classTagContent.getNodeValue().trim();\n            }\n        }\n    }\n    // If we get here, no matching servlet name was found\n    return null;\n}\n","name":"getServletClass","className":"WebAppConfig","variables":{"servletnodes":3,"servletTag":3,"document":1,"classTag":3,"name":1,"i":3,"numservlets":2,"servletName":1,"nameTag":3,"classTagContent":2},"constants":{"0":3,"\"servlet\"":1,"null":3,"\"servlet-name\"":1,"\"servlet-class\"":1},"javaDoc":"This method looks for specific Element nodes in the DOM tree in order to figure out the classname associated with the specified servlet name","comments":"Find all <servlet> elements and loop through them The <servlet-name> tag should have a single child of type Text Get that child and extract its text Use trim() Get the first <servlet-name> tag within the <servlet> tag to strip whitespace from the beginning and end of it If this <servlet-name> tag has the right name Get the matching <servlet-class> tag Extract the tag's text as above and return it If we get here no matching servlet name was found \n     * This method looks for specific Element nodes in the DOM tree in order\n     * to figure out the classname associated with the specified servlet name\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"appendChild":4,"item":1,"createTextNode":2,"createElement":3,"getParentNode":1,"getElementsByTagName":1,"insertBefore":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Element":4,"NodeList":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":44,"StringLiteralExpr":4,"CastExpr":1,"MethodCallExpr":13},"statements":{"ExpressionStmt":10},"text":"/**\n     * This method adds a new name-to-class mapping in in the form of\n     * a <servlet> sub-tree to the document.\n     **/\npublic void addServlet(String servletName, String className) {\n    // Create the <servlet> tag\n    Element newNode = document.createElement(\"servlet\");\n    // Create the <servlet-name> and <servlet-class> tags\n    Element nameNode = document.createElement(\"servlet-name\");\n    Element classNode = document.createElement(\"servlet-class\");\n    // Add the name and classname text to those tags\n    nameNode.appendChild(document.createTextNode(servletName));\n    classNode.appendChild(document.createTextNode(className));\n    // And add those tags to the servlet tag\n    newNode.appendChild(nameNode);\n    newNode.appendChild(classNode);\n    // Now that we've created the new sub-tree, figure out where to put\n    // it.  This code looks for another servlet tag and inserts the new\n    // one right before it. Note that this code will fail if the document\n    // does not already contain at least one <servlet> tag.\n    NodeList servletnodes = document.getElementsByTagName(\"servlet\");\n    Element firstServlet = (Element) servletnodes.item(0);\n    // Insert the new node before the first servlet node\n    firstServlet.getParentNode().insertBefore(newNode, firstServlet);\n}\n","name":"addServlet","className":"WebAppConfig","variables":{"classNode":2,"servletnodes":2,"document":6,"firstServlet":2,"newNode":3,"nameNode":2},"constants":{"0":1,"\"servlet\"":2,"\"servlet-name\"":1,"\"servlet-class\"":1},"javaDoc":"This method adds a new name-to-class mapping in in the form of a <servlet> sub-tree to the document","comments":"Now that we've created the new sub-tree figure out where to put it This code looks for another servlet tag and inserts the new one right before it Note that this code will fail if the document Create the <servlet> tag Create the <servlet-name> and <servlet-class> tags Add the name and classname text to those tags And add those tags to the servlet tag does not already contain at least one <servlet> tag Insert the new node before the first servlet node \n     * This method adds a new name-to-class mapping in in the form of\n     * a <servlet> sub-tree to the document.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{"write":1,"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"XMLDocumentWriter":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * Output the DOM tree to the specified stream as an XML document.\n     * See the XMLDocumentWriter example for the details.\n     **/\npublic void output(PrintWriter out) {\n    XMLDocumentWriter docwriter = new XMLDocumentWriter(out);\n    docwriter.write(document);\n    docwriter.close();\n}\n","name":"output","className":"WebAppConfig","variables":{"docwriter":3,"out":1},"constants":{},"javaDoc":"Output the DOM tree to the specified stream as an XML document See the XMLDocumentWriter example for the details","comments":"\n     * Output the DOM tree to the specified stream as an XML document.\n     * See the XMLDocumentWriter example for the details.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"output":1,"addServlet":1,"getServletClass":1,"System.out.println":1},"annotations":[],"exceptions":["IOException","JDOMException"],"concepts":[],"types":{"WebAppConfig2":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"ArrayAccessExpr":3,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":4,"FieldAccessExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** The main method creates and demonstrates a WebAppConfig2 object */\npublic static void main(String[] args) throws IOException, JDOMException {\n    // Create a new WebAppConfig object that represents the web.xml\n    // file specified by the first command-line argument\n    WebAppConfig2 config = new WebAppConfig2(new File(args[0]));\n    // Query the tree for the class name associated with the servlet\n    // name specified as the 2nd command-line argument\n    System.out.println(\"Class for servlet \" + args[1] + \" is \" + config.getServletClass(args[1]));\n    // Add a new servlet name-to-class mapping to the DOM tree\n    config.addServlet(\"foo\", \"bar\");\n    // And write out an XML version of the DOM tree to standard out\n    config.output(System.out);\n}\n","name":"main","className":"WebAppConfig2","variables":{"args":3,"config":4},"constants":{"0":1,"1":2,"\"foo\"":1,"\" is \"":1,"\"bar\"":1,"\"Class for servlet \"":1},"javaDoc":"The main method creates and demonstrates a WebAppConfig2 object","comments":"Create a new WebAppConfig object that represents the web xml Query the tree for the class name associated with the servlet file specified by the first command-line argument name specified as the 2nd command-line argument Add a new servlet name-to-class mapping to the DOM tree And write out an XML version of the DOM tree to standard out  The main method creates and demonstrates a WebAppConfig2 object ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File"],"returnType":"WebAppConfig2","methodCalls":{"build":1},"annotations":[],"exceptions":["IOException","JDOMException"],"concepts":[],"types":{"SAXBuilder":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"StringLiteralExpr":1,"NameExpr":5,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n     * Read the specified File and parse it to create a JDOM tree\n     **/\npublic WebAppConfig2(File configfile) throws IOException, JDOMException {\n    // JDOM can build JDOM trees from a variety of input sources.  One\n    // of those input sources is a SAX parser.  \n    SAXBuilder builder = new SAXBuilder(\"org.apache.xerces.parsers.SAXParser\");\n    // Parse the specified file and convert it to a JDOM document\n    document = builder.build(configfile);\n}\n","name":"WebAppConfig2","className":"WebAppConfig2","variables":{"document":1,"builder":2},"constants":{"\"org.apache.xerces.parsers.SAXParser\"":1},"javaDoc":"Read the specified File and parse it to create a JDOM tree","comments":"JDOM can build JDOM trees from a variety of input sources One of those input sources is a SAX parser Parse the specified file and convert it to a JDOM document \n     * Read the specified File and parse it to create a JDOM tree\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"next":1,"getChildren":1,"getRootElement":1,"iterator":1,"getContent":2,"getChild":2,"equals":1,"hasNext":1},"annotations":[],"exceptions":["JDOMException"],"concepts":["Casting"],"types":{"Element":2,"Iterator":1,"List":1,"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":29,"StringLiteralExpr":3,"CastExpr":1,"MethodCallExpr":10},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":4},"text":"/**\n     * This method looks for specific Element nodes in the JDOM tree in order\n     * to figure out the classname associated with the specified servlet name\n     **/\npublic String getServletClass(String servletName) throws JDOMException {\n    // Get the root element of the document.\n    Element root = document.getRootElement();\n    // Find all <servlet> elements in the document, and loop through them\n    // to find one with the specified name.  Note the use of java.util.List\n    // instead of org.w3c.dom.NodeList.\n    List servlets = root.getChildren(\"servlet\");\n    for (Iterator i = servlets.iterator(); i.hasNext(); ) {\n        Element servlet = (Element) i.next();\n        // Get the text of the <servlet-name> tag within the <servlet> tag\n        String name = servlet.getChild(\"servlet-name\").getContent();\n        if (name.equals(servletName)) {\n            // If the names match, return the text of the <servlet-class>\n            return servlet.getChild(\"servlet-class\").getContent();\n        }\n    }\n    return null;\n}\n","name":"getServletClass","className":"WebAppConfig2","variables":{"servlet":3,"root":2,"document":1,"servlets":2,"name":2,"i":3},"constants":{"\"servlet\"":1,"null":1,"\"servlet-name\"":1,"\"servlet-class\"":1},"javaDoc":"This method looks for specific Element nodes in the JDOM tree in order to figure out the classname associated with the specified servlet name","comments":"Find all <servlet> elements in the document and loop through them to find one with the specified name Note the use of java util List Get the root element of the document instead of org w3c dom NodeList Get the text of the <servlet-name> tag within the <servlet> tag If the names match return the text of the <servlet-class> \n     * This method looks for specific Element nodes in the JDOM tree in order\n     * to figure out the classname associated with the specified servlet name\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"add":1,"getChildren":1,"setContent":2,"getRootElement":1,"getParent":1,"getChild":1,"addChild":2,"indexOf":1},"annotations":[],"exceptions":["JDOMException"],"concepts":[],"types":{"Element":6,"List":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":7,"StringLiteralExpr":4,"NameExpr":36,"MethodCallExpr":10},"statements":{"ExpressionStmt":12},"text":"/**\n     * This method adds a new name-to-class mapping in in the form of\n     * a <servlet> sub-tree to the document.\n     **/\npublic void addServlet(String servletName, String className) throws JDOMException {\n    // Create the new Element that represents our new servlet\n    Element newServletName = new Element(\"servlet-name\");\n    newServletName.setContent(servletName);\n    Element newServletClass = new Element(\"servlet-class\");\n    newServletClass.setContent(className);\n    Element newServlet = new Element(\"servlet\");\n    newServlet.addChild(newServletName);\n    newServlet.addChild(newServletClass);\n    // find the first <servlet> child in the document\n    Element root = document.getRootElement();\n    Element firstServlet = root.getChild(\"servlet\");\n    // Now insert our new servlet tag before the one we just found.\n    Element parent = firstServlet.getParent();\n    List children = parent.getChildren();\n    children.add(children.indexOf(firstServlet), newServlet);\n}\n","name":"addServlet","className":"WebAppConfig2","variables":{"parent":2,"newServlet":3,"children":3,"newServletName":2,"root":2,"document":1,"firstServlet":2,"newServletClass":2},"constants":{"\"servlet\"":2,"\"servlet-name\"":1,"\"servlet-class\"":1},"javaDoc":"This method adds a new name-to-class mapping in in the form of a <servlet> sub-tree to the document","comments":"Create the new Element that represents our new servlet find the first <servlet> child in the document Now insert our new servlet tag before the one we just found \n     * This method adds a new name-to-class mapping in in the form of\n     * a <servlet> sub-tree to the document.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["OutputStream"],"returnType":"void","methodCalls":{"output":1},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism"],"types":{"XMLOutputter":2},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"StringLiteralExpr":1,"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n     * Output the JDOM tree to the specified stream as an XML document.\n     **/\npublic void output(OutputStream out) throws IOException {\n    // JDOM can output JDOM trees in a variety of ways (such as converting\n    // them to DOM trees or SAX event streams).  Here we use an \"outputter\"\n    // that converts a JDOM tree to an XML document\n    XMLOutputter outputter = new // indentation\n    XMLOutputter(// indentation\n    \"  \", // use newlines\n    true);\n    outputter.output(document, out);\n}\n","name":"output","className":"WebAppConfig2","variables":{"outputter":2},"constants":{},"javaDoc":"Output the JDOM tree to the specified stream as an XML document","comments":"JDOM can output JDOM trees in a variety of ways (such as converting them to DOM trees or SAX event streams) Here we use an \"outputter\" that converts a JDOM tree to an XML document indentation indentation use newlines \n     * Output the JDOM tree to the specified stream as an XML document.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"rot13":1,"equals":1,"length":1,"setCharAt":1,"readLine":1,"System.out.print":1,"charAt":1,"System.out.println":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"StringBuffer":1,"BufferedReader":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":2,"FieldAccessExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":2,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    // Get set up to read lines of text from the user\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    for (; ; ) {\n        // Loop forever\n        // Print a prompt\n        System.out.print(\"> \");\n        // Read a line\n        String line = in.readLine();\n        if (// If EOF or \"quit\"...\n        (line == null) || line.equals(\"quit\"))\n            // ...break out of loop\n            break;\n        // Use a StringBuffer\n        StringBuffer buf = new StringBuffer(line);\n        for (// For each character...\n        int i = 0; // For each character...\n        i < buf.length(); // For each character...\n        i++) // ..read, encode, store\n        buf.setCharAt(i, rot13(buf.charAt(i)));\n        // Print encoded line\n        System.out.println(buf);\n    }\n}\n","name":"main","className":"Rot13Input","variables":{"buf":4,"in":2,"line":4,"i":3},"constants":{"0":1,"\"quit\"":1,"null":1,"\"> \"":1},"javaDoc":"","comments":"Get set up to read lines of text from the user Loop forever Print a prompt Read a line If EOF or \"quit\" break out of loop Use a StringBuffer For each character For each character For each character read encode store Print encoded line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["char"],"returnType":"char","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":4,"BinaryExpr":8,"NameExpr":11,"CharLiteralExpr":6,"EnclosedExpr":4,"AssignExpr":4},"statements":{"IfStmt":4,"BlockStmt":2,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * This method performs the Rot13 substitution cipher.  It \"rotates\"\n     * each letter 13 places through the alphabet.  Since the Latin alphabet\n     * has 26 letters, this method both encodes and decodes.\n     **/\npublic static char rot13(char c) {\n    if ((c >= 'A') && (c <= 'Z')) {\n        // For uppercase letters\n        // Rotate forward 13\n        c += 13;\n        // And subtract 26 if necessary\n        if (c > 'Z')\n            c -= 26;\n    }\n    if ((c >= 'a') && (c <= 'z')) {\n        // Do the same for lowercase letters\n        c += 13;\n        if (c > 'z')\n            c -= 26;\n    }\n    // Return the modified letter\n    return c;\n}\n","name":"rot13","className":"Rot13Input","variables":{"c":11},"constants":{"13":2,"'Z'":2,"26":2,"'z'":2,"'A'":1,"'a'":1},"javaDoc":"This method performs the Rot13 substitution cipher It \"rotates\" each letter 13 places through the alphabet Since the Latin alphabet has 26 letters this method both encodes and decodes","comments":"For uppercase letters Rotate forward 13 And subtract 26 if necessary Do the same for lowercase letters Return the modified letter \n     * This method performs the Rot13 substitution cipher.  It \"rotates\"\n     * each letter 13 places through the alphabet.  Since the Latin alphabet\n     * has 26 letters, this method both encodes and decodes.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":1,"FieldAccessExpr":4,"UnaryExpr":2,"MethodCallExpr":5},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":3},"text":"public static void main(String[] args) {\n    // Loop backwards through the array of arguments\n    for (int i = args.length - 1; i >= 0; i--) {\n        // Loop backwards through the characters in each argument\n        for (int j = args[i].length() - 1; j >= 0; j--) {\n            // Print out character j of argument i.\n            System.out.print(args[i].charAt(j));\n        }\n        // Add a space at the end of each argument.\n        System.out.print(\" \");\n    }\n    // And terminate the line when we're done.\n    System.out.println();\n}\n","name":"main","className":"Reverse","variables":{"args":2,"i":5,"j":3},"constants":{"0":2,"1":2,"\" \"":1},"javaDoc":"","comments":"Loop backwards through the array of arguments Loop backwards through the characters in each argument Print out character j of argument i Add a space at the end of each argument And terminate the line when we're done ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":14,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":4,"FieldAccessExpr":5,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":4,"BlockStmt":1,"SwitchEntryStmt":12,"ForStmt":1,"ExpressionStmt":5},"text":"public static void main(String[] args) {\n    for (int i = 1; i <= 100; i++) {\n        // count from 1 to 100\n        switch(// What's the remainder when divided by 35?\n        i % 35) {\n            case // For multiples of 35...\n            0:\n                // print \"fizzbuzz\".\n                System.out.print(\"fizzbuzz \");\n                // Don't forget this statement!\n                break;\n            // If the remainder is any of these\n            case 5:\n            // If the remainder is any of these\n            case 10:\n            // If the remainder is any of these\n            case 15:\n            case 20:\n            case 25:\n            case // then the number is a multiple of 5\n            30:\n                // so print \"fizz\".\n                System.out.print(\"fizz \");\n                break;\n            case 7:\n            case 14:\n            case 21:\n            case // For any multiple of 7...\n            28:\n                // print \"buzz\".\n                System.out.print(\"buzz \");\n                break;\n            default:\n                // For any other number...\n                // print the number.\n                System.out.print(i + \" \");\n                break;\n        }\n    }\n    System.out.println();\n}\n","name":"main","className":"FizzBuzz2","variables":{"i":5},"constants":{"35":1,"25":1,"14":1,"15":1,"\"fizz \"":1,"\" \"":1,"\"buzz \"":1,"1":1,"100":1,"5":1,"7":1,"\"fizzbuzz \"":1,"20":1,"10":1,"21":1},"javaDoc":"","comments":"count from 1 to 100 What's the remainder when divided by 35? For multiples of 35 print \"fizzbuzz\" Don't forget this statement! If the remainder is any of these If the remainder is any of these If the remainder is any of these then the number is a multiple of 5 so print \"fizz\" For any multiple of 7 print \"buzz\" For any other number print the number ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"long","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"ArrayAccessExpr":3,"BinaryExpr":6,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":2},"text":"public static long factorial(int x) throws IllegalArgumentException {\n    // Check if x is too big or too small.  Throw an exception if so.\n    if (// \".length\" returns length of any array\n    x >= table.length)\n        throw new IllegalArgumentException(\"Overflow; x is too large.\");\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be non-negative.\");\n    // Compute and cache any values that are not yet cached.\n    while (last < x) {\n        table[last + 1] = table[last] * (last + 1);\n        last++;\n    }\n    // Now return the cached factorial of x.\n    return table[x];\n}\n","name":"factorial","className":"Factorial3","variables":{"last":5,"x":4,"table":3},"constants":{"0":1,"1":2,"\"x must be non-negative.\"":1,"\"Overflow; x is too large.\"":1},"javaDoc":"","comments":"Check if x is too big or too small Throw an exception if so \" length\" returns length of any array Compute and cache any values that are not yet cached Now return the cached factorial of x ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"BigInteger","methodCalls":{"add":1,"size":1,"valueOf":1,"get":2,"multiply":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["Casting","Synchronization"],"types":{"BigInteger":2,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":26,"StringLiteralExpr":1,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ThrowStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** The factorial() method, using BigIntegers cached in a ArrayList */\npublic static synchronized BigInteger factorial(int x) {\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be non-negative.\");\n    for (int size = table.size(); size <= x; size++) {\n        BigInteger lastfact = (BigInteger) table.get(size - 1);\n        BigInteger nextfact = lastfact.multiply(BigInteger.valueOf(size));\n        table.add(nextfact);\n    }\n    return (BigInteger) table.get(x);\n}\n","name":"factorial","className":"Factorial4","variables":{"nextfact":1,"size":4,"x":2,"lastfact":2,"BigInteger":1,"table":4},"constants":{"0":1,"1":1,"\"x must be non-negative.\"":1},"javaDoc":"The factorial() method using BigIntegers cached in a ArrayList","comments":" The factorial() method, using BigIntegers cached in a ArrayList ","isEmpty":false,"hasInnerClass":false,"modifier":41}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"factorial":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/**\n     * A simple main() method that we can use as a standalone test program\n     * for our factorial() method.  \n     **/\npublic static void main(String[] args) {\n    for (int i = 0; i <= 50; i++) System.out.println(i + \"! = \" + factorial(i));\n}\n","name":"main","className":"Factorial4","variables":{"i":4},"constants":{"0":1,"50":1,"\"! = \"":1},"javaDoc":"A simple main() method that we can use as a standalone test program for our factorial() method","comments":"\n     * A simple main() method that we can use as a standalone test program\n     * for our factorial() method.  \n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public static void main(String[] args) {\n    // All programs must have main()\n    // Say hello!\n    System.out.println(\"Hello World!\");\n}\n","name":"main","className":"Hello","variables":{},"constants":{"\"Hello World!\"":1},"javaDoc":"","comments":"All programs must have main() Say hello! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"factorial":1,"getMessage":1,"System.out.println":5},"annotations":[],"exceptions":["NumberFormatException","ArrayIndexOutOfBoundsException","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":5,"FieldAccessExpr":5,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":4,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // If something goes wrong, handle it in the catch clause below.\n    try {\n        int x = Integer.parseInt(args[0]);\n        System.out.println(x + \"! = \" + Factorial4.factorial(x));\n    }// Thrown if args[0] is undefined.\n     catch (ArrayIndexOutOfBoundsException e) {\n        System.out.println(\"You must specify an argument\");\n        System.out.println(\"Usage: java FactComputer <number>\");\n    }// The argument is not a number.  Thrown by Integer.parseInt().\n     catch (NumberFormatException e) {\n        System.out.println(\"The argument you specify must be an integer\");\n    }// The argument is < 0.  Thrown by Factorial4.factorial()\n     catch (IllegalArgumentException e) {\n        System.out.println(\"Bad argument: \" + e.getMessage());\n    }\n}\n         // Try to compute a factorial.\n\n         // The user forgot to specify an argument.\n\n             // Display the message sent by the factorial() method:\n\n","name":"main","className":"FactComputer","variables":{"Integer":1,"args":1,"Factorial4":1,"e":4,"x":2},"constants":{"0":1,"\"Bad argument: \"":1,"\"You must specify an argument\"":1,"\"The argument you specify must be an integer\"":1,"\"! = \"":1,"\"Usage: java FactComputer <number>\"":1},"javaDoc":"","comments":"Try to compute a factorial If something goes wrong handle it in the catch clause below The user forgot to specify an argument Thrown if args[0] is undefined The argument is not a number Thrown by Integer parseInt() The argument is < 0 Thrown by Factorial4 factorial() Display the message sent by the factorial() method: ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"UnaryExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Compute and return x!, the factorial of x */\npublic static int factorial(int x) {\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be >= 0\");\n    int fact = 1;\n    for (// loop\n    int i = 2; // loop\n    i <= x; // loop\n    i++) // shorthand for: fact = fact * i;\n    fact *= i;\n    return fact;\n}\n","name":"factorial","className":"Factorial","variables":{"fact":3,"x":2,"i":4},"constants":{"0":1,"1":1,"2":1,"\"x must be >= 0\"":1},"javaDoc":"Compute and return x! the factorial of x","comments":"loop loop loop shorthand for: fact = fact i;  Compute and return x!, the factorial of x ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["double[]"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1,"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":6,"BinaryExpr":3,"NameExpr":28,"FieldAccessExpr":2,"UnaryExpr":2,"AssignExpr":4},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":2,"ExpressionStmt":6},"text":"/**\n     * This is a very simple sorting algorithm that is not very efficient\n     * when sorting large numbers of things\n     **/\npublic static void sort(double[] nums) {\n    // to the first unsorted position in the array.\n    for (int i = 0; i < nums.length; i++) {\n        // holds the index of the smallest element\n        int min = i;\n        // find the smallest one between i and the end of the array\n        for (int j = i; j < nums.length; j++) {\n            if (nums[j] < nums[min])\n                min = j;\n        }\n        // Now swap the smallest one with element i.  \n        // This leaves all elements between 0 and i sorted.\n        double tmp;\n        tmp = nums[i];\n        nums[i] = nums[min];\n        nums[min] = tmp;\n    }\n         // Loop through each element of the array, sorting as we go.\n\n         // Each time through, find the smallest remaining element, and move it\n\n}\n","name":"sort","className":"SortNumbers","variables":{"min":5,"tmp":3,"i":7,"j":5,"nums":6},"constants":{"0":1},"javaDoc":"This is a very simple sorting algorithm that is not very efficient when sorting large numbers of things","comments":"Loop through each element of the array sorting as we go Each time through find the smallest remaining element and move it to the first unsorted position in the array Now swap the smallest one with element i holds the index of the smallest element find the smallest one between i and the end of the array This leaves all elements between 0 and i sorted \n     * This is a very simple sorting algorithm that is not very efficient\n     * when sorting large numbers of things\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"random":1,"sort":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"double[]":1,"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":25,"FieldAccessExpr":3,"ArrayCreationExpr":1,"UnaryExpr":2,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":2,"ExpressionStmt":4},"text":"/** This is a simple test program for the algorithm above */\npublic static void main(String[] args) {\n    // Create an array to hold numbers\n    double[] nums = new double[10];\n    for (// Generate random numbers\n    int i = 0; // Generate random numbers\n    i < nums.length; // Generate random numbers\n    i++) nums[i] = Math.random() * 100;\n    // Sort them\n    sort(nums);\n    for (// Print them out\n    int i = 0; // Print them out\n    i < nums.length; // Print them out\n    i++) System.out.println(nums[i]);\n}\n","name":"main","className":"SortNumbers","variables":{"i":8,"Math":1,"nums":3},"constants":{"0":2,"100":1,"10":1},"javaDoc":"This is a simple test program for the algorithm above","comments":"Create an array to hold numbers Generate random numbers Generate random numbers Generate random numbers Sort them Print them out Print them out Print them out  This is a simple test program for the algorithm above ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":5,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":10,"VariableDeclarationExpr":1,"BinaryExpr":10,"NameExpr":37,"StringLiteralExpr":4,"FieldAccessExpr":6,"EnclosedExpr":6,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":3,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) {\n    // Every program must have main()\n    for (int i = 1; i <= 100; i++) {\n        // count from 1 to 100\n        if (// Is it a multiple of 5 & 7?\n        ((i % 5) == 0) && ((i % 7) == 0))\n            System.out.print(\"fizzbuzz\");\n        else if (// Is it a multiple of 5?\n        (i % 5) == 0)\n            System.out.print(\"fizz\");\n        else if (// Is it a multiple of 7?\n        (i % 7) == 0)\n            System.out.print(\"buzz\");\n        else\n            // Not a multiple of 5 or 7\n            System.out.print(i);\n        System.out.print(\" \");\n    }\n    System.out.println();\n}\n","name":"main","className":"FizzBuzz","variables":{"i":7},"constants":{"0":4,"1":1,"100":1,"\" \"":1,"5":2,"7":2,"\"buzz\"":1,"\"fizzbuzz\"":1,"\"fizz\"":1},"javaDoc":"","comments":"Every program must have main() count from 1 to 100 Is it a multiple of 5 & 7? Is it a multiple of 5? Is it a multiple of 7? Not a multiple of 5 or 7 ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["long"],"returnType":"long","methodCalls":{"factorial":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["Recursion"],"types":{},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"BinaryExpr":4,"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":2,"ThrowStmt":1,"ReturnStmt":2},"text":"public static long factorial(long x) {\n    if (x < 0)\n        throw new IllegalArgumentException(\"x must be >= 0\");\n    if (// Stop recursing here\n    x <= 1)\n        // Stop recursing here\n        return 1;\n    else\n        // Recurse by calling ourselves\n        return x * factorial(x - 1);\n}\n","name":"factorial","className":"Factorial2","variables":{"x":4},"constants":{"0":1,"1":3,"\"x must be >= 0\"":1},"javaDoc":"","comments":"Stop recursing here Stop recursing here Recurse by calling ourselves ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"equals":1,"factorial":1,"readLine":1,"System.out.print":1,"System.out.println":2},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1,"int":1},"expressions":{"ObjectCreationExpr":2,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":34,"StringLiteralExpr":4,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":3,"TryStmt":1,"ForStmt":1,"ExpressionStmt":6},"text":"public static void main(String[] args) throws IOException {\n    // This is how we set things up to read lines of text from the user.\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    // Loop forever\n    for (; ; ) {\n        // Display a prompt to the user\n        System.out.print(\"FactQuoter> \");\n        // Read a line from the user\n        String line = in.readLine();\n        // or if the user types \"quit\", then quit\n        if ((line == null) || line.equals(\"quit\"))\n            break;\n        // Try to parse the line, and compute and print the factorial\n        try {\n            int x = Integer.parseInt(line);\n            System.out.println(x + \"! = \" + Factorial4.factorial(x));\n        }// If anything goes wrong, display a generic error message\n         catch (Exception e) {\n            System.out.println(\"Invalid Input\");\n        }\n    }\n}\n             // If we reach the end-of-file, \n\n","name":"main","className":"FactQuoter","variables":{"Integer":1,"Factorial4":1,"in":2,"e":1,"line":3,"x":2},"constants":{"\"quit\"":1,"null":1,"\"FactQuoter> \"":1,"\"! = \"":1,"\"Invalid Input\"":1},"javaDoc":"","comments":"This is how we set things up to read lines of text from the user Loop forever If we reach the end-of-file Display a prompt to the user Read a line from the user or if the user types \"quit\" then quit Try to parse the line and compute and print the factorial If anything goes wrong display a generic error message ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":17,"StringLiteralExpr":1,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"WhileStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"public static void main(String[] args) {\n    // Initialize the loop variable\n    int i = 0;\n    while (i < args.length) {\n        // Loop until the end of array\n        // Print each argument out\n        System.out.print(args[i] + \" \");\n        // Increment the loop variable\n        i++;\n    }\n    // Terminate the line\n    System.out.println();\n}\n","name":"main","className":"Echo","variables":{"args":1,"i":4},"constants":{"0":1,"\" \"":1},"javaDoc":"","comments":"Initialize the loop variable Loop until the end of array Print each argument out Increment the loop variable Terminate the line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"System.out.print":2,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":27,"StringLiteralExpr":3,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":3,"AssignExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"public static void main(String[] args) {\n    // Initialize variables\n    int n0 = 1, n1 = 1, n2;\n    System.out.print(// Print first and second terms\n    n0 + \" \" + n1 + // of the series\n    \" \");\n    for (int i = 0; i < 18; i++) {\n        // Loop for the next 18 terms\n        // Next term is sum of previous two\n        n2 = n1 + n0;\n        // Print it out\n        System.out.print(n2 + \" \");\n        // First previous becomes 2nd previous\n        n0 = n1;\n        // And current number becomes previous\n        n1 = n2;\n    }\n    // Terminate the line\n    System.out.println();\n}\n","name":"main","className":"Fibonacci","variables":{"n0":4,"n1":5,"n2":4,"i":3},"constants":{"0":1,"1":2,"\" \"":2,"18":1},"javaDoc":"","comments":"Initialize variables Print first and second terms of the series Loop for the next 18 terms Next term is sum of previous two Print it out First previous becomes 2nd previous And current number becomes previous Terminate the line ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"parseInt":1,"sqrt":1,"ceil":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"boolean[]":1,"int":6},"expressions":{"IntegerLiteralExpr":8,"VariableDeclarationExpr":7,"ArrayAccessExpr":7,"BinaryExpr":9,"NameExpr":45,"StringLiteralExpr":2,"UnaryExpr":4,"AssignExpr":7,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"EmptyStmt":1,"ForStmt":4,"ExpressionStmt":9},"text":"public static void main(String[] args) {\n    // We will compute all primes less than the value specified on the\n    // command line, or, if no argument, all primes less than 100.\n    // Assign a default value\n    int max = 100;\n    try // Parse user-supplied arg\n    {\n        max = Integer.parseInt(args[0]);\n    }// Silently ignore exceptions.\n     catch (Exception e) {\n    }\n    // Create an array that specifies whether each number is prime or not.\n    boolean[] isprime = new boolean[max + 1];\n    // Assume that all numbers are primes, until proven otherwise.\n    for (int i = 0; i <= max; i++) isprime[i] = true;\n    // However, we know that 0 and 1 are not primes.  Make a note of it.\n    isprime[0] = isprime[1] = false;\n    // To compute all primes less than max, we need to rule out\n    // multiples of all integers less than the square root of max.\n    // See java.lang.Math class\n    int n = (int) Math.ceil(Math.sqrt(max));\n    //   prime factors of i, so we can skip this case.\n    for (int i = 0; i <= n; i++) {\n        if (// If i is a prime, \n        isprime[i])\n            for (// loop through multiples\n            int j = 2 * i; // loop through multiples\n            j <= max; // loop through multiples\n            j = j + i) // they are not prime.\n            isprime[j] = false;\n    }\n    // Now go look for the largest prime:\n    int largest;\n    // empty loop body\n    for (largest = max; !isprime[largest]; largest--) ;\n    // Output the result\n    System.out.println(\"The largest prime less than or equal to \" + max + \" is \" + largest);\n}\n         // Now, for each integer i from 0 to n:\n\n         //   If i is a prime, then none of its multiples are primes,\n\n         //   so indicate this in the array.  If i is not a prime, then\n\n         //   its multiples have already been ruled out by one of the\n\n","name":"main","className":"Sieve","variables":{"Integer":1,"args":1,"largest":5,"max":7,"e":1,"i":10,"j":5,"Math":2,"isprime":7,"n":2},"constants":{"0":4,"100":1,"1":2,"2":1,"\"The largest prime less than or equal to \"":1,"\" is \"":1,"true":1,"false":2},"javaDoc":"","comments":"We will compute all primes less than the value specified on the command line or if no argument all primes less than 100 To compute all primes less than max we need to rule out multiples of all integers less than the square root of max Now for each integer i from 0 to n: If i is a prime then none of its multiples are primes so indicate this in the array If i is not a prime then its multiples have already been ruled out by one of the Assign a default value Parse user-supplied arg Silently ignore exceptions Create an array that specifies whether each number is prime or not Assume that all numbers are primes until proven otherwise However we know that 0 and 1 are not primes Make a note of it See java lang Math class prime factors of i so we can skip this case If i is a prime loop through multiples loop through multiples loop through multiples they are not prime Now go look for the largest prime: empty loop body Output the result ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","PrintWriter"],"returnType":"MudPerson","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":6,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"public MudPerson(String n, String d, PrintWriter out) throws RemoteException {\n    name = n;\n    description = d;\n    tellStream = out;\n}\n","name":"MudPerson","className":"MudPerson","variables":{"tellStream":1,"d":1,"name":1,"description":1,"n":1,"out":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the person's name.  Not a remote method */\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"MudPerson","variables":{"name":1},"constants":{},"javaDoc":"Return the person's name Not a remote method","comments":" Return the person's name.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the person's name.  Not a remote method */\npublic void setName(String n) {\n    name = n;\n}\n","name":"setName","className":"MudPerson","variables":{"name":1,"n":1},"constants":{},"javaDoc":"Set the person's name Not a remote method","comments":" Set the person's name.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the person's description.  Not a remote method */\npublic void setDescription(String d) {\n    description = d;\n}\n","name":"setDescription","className":"MudPerson","variables":{"d":1,"description":1},"constants":{},"javaDoc":"Set the person's description Not a remote method","comments":" Set the person's description.  Not a remote method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PrintWriter"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the stream that messages to us should be written to. Not remote. */\npublic void setTellStream(PrintWriter out) {\n    tellStream = out;\n}\n","name":"setTellStream","className":"MudPerson","variables":{"tellStream":1,"out":1},"constants":{},"javaDoc":"Set the stream that messages to us should be written to Not remote","comments":" Set the stream that messages to us should be written to. Not remote. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** A remote method that returns this person's description */\npublic String getDescription() throws RemoteException {\n    return description;\n}\n","name":"getDescription","className":"MudPerson","variables":{"description":1},"constants":{},"javaDoc":"A remote method that returns this person's description","comments":" A remote method that returns this person's description ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"println":1,"flush":1},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n     * A remote method that delivers a message to the person.\n     * I.e. it delivers a message to the user controlling the \"person\"\n     **/\npublic void tell(String message) throws RemoteException {\n    tellStream.println(message);\n    tellStream.flush();\n}\n","name":"tell","className":"MudPerson","variables":{"tellStream":2},"constants":{},"javaDoc":"A remote method that delivers a message to the person I e it delivers a message to the user controlling the \"person\"","comments":" \n     * A remote method that delivers a message to the person.\n     * I.e. it delivers a message to the user controlling the \"person\"\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Open a new account, with the specified name and password */\npublic void openAccount(String name, String password) throws RemoteException, BankingException;\n","name":"openAccount","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Open a new account with the specified name and password","comments":" Open a new account, with the specified name and password ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Close the named account */\npublic FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException;\n","name":"closeAccount","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Close the named account","comments":" Close the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Deposit money into the named account */\npublic void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException;\n","name":"deposit","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Deposit money into the named account","comments":" Deposit money into the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Withdraw the specified amount of money from the named account */\npublic FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException;\n","name":"withdraw","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Withdraw the specified amount of money from the named account","comments":" Withdraw the specified amount of money from the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the amount of money in the named account */\npublic int getBalance(String name, String password) throws RemoteException, BankingException;\n","name":"getBalance","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Return the amount of money in the named account","comments":" Return the amount of money in the named account ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"List","methodCalls":{},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Return a List of Strings that list the transaction history \n\t * of the named account \n\t **/\npublic List getTransactionHistory(String name, String password) throws RemoteException, BankingException;\n","name":"getTransactionHistory","className":"RemoteBank","variables":{},"constants":{},"javaDoc":"Return a List of Strings that list the transaction history of the named account","comments":" \n\t * Return a List of Strings that list the transaction history \n\t * of the named account \n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"FunnyMoney","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public FunnyMoney(int amount) {\n    this.amount = amount;\n}\n","name":"FunnyMoney","className":"FunnyMoney","variables":{"amount":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"BankingException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public BankingException(String msg) {\n    super(msg);\n}\n","name":"BankingException","className":"BankingException","variables":{"msg":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookup":1,"getProperty":1,"getTransactionHistory":1,"getMessage":1,"parseInt":2,"closeAccount":1,"getBalance":1,"size":1,"equals":6,"get":1,"deposit":1,"openAccount":1,"System.err.println":5,"System.out.println":8,"withdraw":1},"annotations":[],"exceptions":["BankingException","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"FunnyMoney":3,"RemoteBank":1,"List":1,"String":2,"int":2},"expressions":{"IntegerLiteralExpr":16,"ObjectCreationExpr":1,"VariableDeclarationExpr":9,"ArrayAccessExpr":15,"BinaryExpr":10,"NameExpr":156,"StringLiteralExpr":22,"CastExpr":1,"FieldAccessExpr":16,"UnaryExpr":1,"MethodCallExpr":33},"statements":{"IfStmt":6,"TryStmt":1,"BlockStmt":10,"ForStmt":1,"ExpressionStmt":23},"text":"public static void main(String[] args) {\n    try {\n        // Figure out what RemoteBank to connect to by reading a system\n        // property (specified on the command line with a -D option to\n        // java) or, if it is not defined, use a default URL.  Note\n        // that by default this client tries to connect to a server on\n        // the local machine\n        String url = System.getProperty(\"bank\", \"rmi:///FirstRemote\");\n        // Now look up that RemoteBank server using the Naming object,\n        // which contacts the rmiregistry server.  Given the url, this\n        // call returns a RemoteBank object whose methods may be\n        // invoked remotely\n        RemoteBank bank = (RemoteBank) Naming.lookup(url);\n        // Convert the user's command to lower case\n        String cmd = args[0].toLowerCase();\n        // Now, go test the command against a bunch of possible options\n        if (cmd.equals(\"open\")) {\n            // Open an account\n            bank.openAccount(args[1], args[2]);\n            System.out.println(\"Account opened.\");\n        } else if (cmd.equals(\"close\")) {\n            // Close an account\n            FunnyMoney money = bank.closeAccount(args[1], args[2]);\n            // Note: our currency is denominated in wooden nickels\n            System.out.println(money.amount + \" wooden nickels returned to you.\");\n            System.out.println(\"Thanks for banking with us.\");\n        } else if (cmd.equals(\"deposit\")) {\n            // Deposit money\n            FunnyMoney money = new FunnyMoney(Integer.parseInt(args[3]));\n            bank.deposit(args[1], args[2], money);\n            System.out.println(\"Deposited \" + money.amount + \" wooden nickels.\");\n        } else if (cmd.equals(\"withdraw\")) {\n            // Withdraw money\n            FunnyMoney money = bank.withdraw(args[1], args[2], Integer.parseInt(args[3]));\n            System.out.println(\"Withdrew \" + money.amount + \" wooden nickels.\");\n        } else if (cmd.equals(\"balance\")) {\n            // Check account balance\n            int amt = bank.getBalance(args[1], args[2]);\n            System.out.println(\"You have \" + amt + \" wooden nickels in the bank.\");\n        } else if (cmd.equals(\"history\")) {\n            // Get transaction history\n            List transactions = bank.getTransactionHistory(args[1], args[2]);\n            for (int i = 0; i < transactions.size(); i++) System.out.println(transactions.get(i));\n        } else\n            System.out.println(\"Unknown command\");\n    }// Catch and display RMI exceptions\n     catch (RemoteException e) {\n        System.err.println(e);\n    }// Catch and display Banking related exceptions\n     catch (BankingException e) {\n        System.err.println(e.getMessage());\n    }// Other exceptions are probably user syntax errors, so show usage.\n     catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java [-Dbank=<url>] Bank$Client \" + \"<cmd> <name> <password> [<amount>]\");\n        System.err.println(\"where cmd is: open, close, deposit, \" + \"withdraw, balance, history\");\n    }\n}\n","name":"main","className":"Client","variables":{"args":15,"Integer":2,"bank":7,"money":3,"e":4,"amt":2,"i":3,"cmd":7,"Naming":1,"transactions":3,"url":1,"System":1},"constants":{"\"Unknown command\"":1,"\" wooden nickels.\"":2,"\"You have \"":1,"\"rmi:///FirstRemote\"":1,"\"Thanks for banking with us.\"":1,"\"bank\"":1,"\"withdraw\"":1,"\"Withdrew \"":1,"\"Usage: java [-Dbank=<url>] Bank$Client \"":1,"\"open\"":1,"\"history\"":1,"\"close\"":1,"0":2,"1":6,"2":6,"\"Deposited \"":1,"3":2,"\"deposit\"":1,"\"balance\"":1,"\"where cmd is: open, close, deposit, \"":1,"\" wooden nickels returned to you.\"":1,"\"Account opened.\"":1,"\"withdraw, balance, history\"":1,"\" wooden nickels in the bank.\"":1,"\"<cmd> <name> <password> [<amount>]\"":1},"javaDoc":"","comments":"Figure out what RemoteBank to connect to by reading a system property (specified on the command line with a -D option to java) or if it is not defined use a default URL Note that by default this client tries to connect to a server on Now look up that RemoteBank server using the Naming object which contacts the rmiregistry server Given the url this call returns a RemoteBank object whose methods may be the local machine invoked remotely Convert the user's command to lower case Now go test the command against a bunch of possible options Open an account Close an account Note: our currency is denominated in wooden nickels Deposit money Withdraw money Check account balance Get transaction history Catch and display RMI exceptions Catch and display Banking related exceptions Other exceptions are probably user syntax errors so show usage ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the name of this MUD */\npublic String getMudName() throws RemoteException;\n","name":"getMudName","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Return the name of this MUD","comments":" Return the name of this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return the main entrance place for this MUD */\npublic RemoteMudPlace getEntrance() throws RemoteException;\n","name":"getEntrance","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Return the main entrance place for this MUD","comments":" Return the main entrance place for this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["NoSuchPlace","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Look up and return some other named place in this MUD */\npublic RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace;\n","name":"getNamedPlace","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Look up and return some other named place in this MUD","comments":" Look up and return some other named place in this MUD ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["BadPassword","IOException","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Dump the state of the server to a file so that it can be restored\n\t * later All places, and their exits and things are dumped, but the\n\t * \"people\" in them are not.\n\t **/\npublic void dump(String password, String filename) throws RemoteException, BadPassword, IOException;\n","name":"dump","className":"RemoteMudServer","variables":{},"constants":{},"javaDoc":"Dump the state of the server to a file so that it can be restored later All places and their exits and things are dumped but the \"people\" in them are not","comments":" \n\t * Dump the state of the server to a file so that it can be restored\n\t * later All places, and their exits and things are dumped, but the\n\t * \"people\" in them are not.\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Return a full description of the person */\npublic String getDescription() throws RemoteException;\n","name":"getDescription","className":"RemoteMudPerson","variables":{},"constants":{},"javaDoc":"Return a full description of the person","comments":" Return a full description of the person ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Deliver a message to the person */\npublic void tell(String message) throws RemoteException;\n","name":"tell","className":"RemoteMudPerson","variables":{},"constants":{},"javaDoc":"Deliver a message to the person","comments":" Deliver a message to the person ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Look up the name of this place */\npublic String getPlaceName() throws RemoteException;\n","name":"getPlaceName","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Look up the name of this place","comments":" Look up the name of this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get a description of this place */\npublic String getDescription() throws RemoteException;\n","name":"getDescription","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get a description of this place","comments":" Get a description of this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Find out the names of all people here */\npublic Vector getNames() throws RemoteException;\n","name":"getNames","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Find out the names of all people here","comments":" Find out the names of all people here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the names of all things here */\npublic Vector getThings() throws RemoteException;\n","name":"getThings","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the names of all things here","comments":" Get the names of all things here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the names of all ways out of here */\npublic Vector getExits() throws RemoteException;\n","name":"getExits","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the names of all ways out of here","comments":" Get the names of all ways out of here ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPerson","methodCalls":{},"annotations":[],"exceptions":["NoSuchPerson","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get the RemoteMudPerson object for the named person. */\npublic RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson;\n","name":"getPerson","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get the RemoteMudPerson object for the named person","comments":" Get the RemoteMudPerson object for the named person. ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["NoSuchThing","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Get more details about a named thing */\npublic String examineThing(String name) throws RemoteException, NoSuchThing;\n","name":"examineThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Get more details about a named thing","comments":" Get more details about a named thing ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["LinkFailed","NotThere","NoSuchExit","AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Use the named exit */\npublic RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed;\n","name":"go","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Use the named exit","comments":" Use the named exit ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Send a message of the form \"David: hi everyone\" */\npublic void speak(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere;\n","name":"speak","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Send a message of the form \"David: hi everyone\"","comments":" Send a message of the form \"David: hi everyone\" ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Send a message of the form \"David laughs loudly\" */\npublic void act(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere;\n","name":"act","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Send a message of the form \"David laughs loudly\"","comments":" Send a message of the form \"David laughs loudly\" ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Add a new thing in this place */\npublic void createThing(RemoteMudPerson who, String name, String description) throws RemoteException, NotThere, AlreadyThere;\n","name":"createThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Add a new thing in this place","comments":" Add a new thing in this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchThing","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Remove a thing from this place */\npublic void destroyThing(RemoteMudPerson who, String thing) throws RemoteException, NotThere, NoSuchThing;\n","name":"destroyThing","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove a thing from this place","comments":" Remove a thing from this place ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","PlaceAlreadyExists","ExitAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Create a new place, bi-directionally linked to this one by an exit\n\t **/\npublic void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists;\n","name":"createPlace","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Create a new place bi-directionally linked to this one by an exit","comments":"\n\t * Create a new place, bi-directionally linked to this one by an exit\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchPlace","ExitAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Link this place (unidirectionally) to some existing place.  The\n\t * destination place may even be on another server.\n\t **/\npublic void linkTo(RemoteMudPerson who, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace;\n","name":"linkTo","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Link this place (unidirectionally) to some existing place The destination place may even be on another server","comments":" \n\t * Link this place (unidirectionally) to some existing place.  The\n\t * destination place may even be on another server.\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","NoSuchExit","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Remove an existing exit */\npublic void close(RemoteMudPerson who, String exit) throws RemoteException, NotThere, NoSuchExit;\n","name":"close","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove an existing exit","comments":" Remove an existing exit ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Remove this person from this place, leaving them nowhere.\n\t * Send the specified message to everyone left in the place.\n\t **/\npublic void exit(RemoteMudPerson who, String message) throws RemoteException, NotThere;\n","name":"exit","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Remove this person from this place leaving them nowhere Send the specified message to everyone left in the place","comments":" \n\t * Remove this person from this place, leaving them nowhere.\n\t * Send the specified message to everyone left in the place.\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["AlreadyThere","RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n\t * Put a person in a place, assigning their name, and sending the \n\t * specified message to everyone else in the place.  The client should\n\t * not make this method available to the user.  They should use go()\n\t * instead.\n\t **/\npublic void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere;\n","name":"enter","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Put a person in a place assigning their name and sending the specified message to everyone else in the place The client should not make this method available to the user They should use go() instead","comments":"\n\t * Put a person in a place, assigning their name, and sending the \n\t * specified message to everyone else in the place.  The client should\n\t * not make this method available to the user.  They should use go()\n\t * instead.\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** \n\t * Return the server object of the MUD that \"contains\" this place \n\t * This method should not be directly visible to the player\n\t **/\npublic RemoteMudServer getServer() throws RemoteException;\n","name":"getServer","className":"RemoteMudPlace","variables":{},"constants":{},"javaDoc":"Return the server object of the MUD that \"contains\" this place This method should not be directly visible to the player","comments":" \n\t * Return the server object of the MUD that \"contains\" this place \n\t * This method should not be directly visible to the player\n\t *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"lookup":1,"exit":1,"currentThread":2,"getNamedPlace":1,"getEntrance":1,"getLine":1,"getPriority":1,"setPriority":1,"runMud":1,"getMultiLine":1,"System.out.println":3},"annotations":[],"exceptions":["Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"MudPerson":1,"String":5,"int":1,"PrintWriter":1},"expressions":{"IntegerLiteralExpr":6,"NullLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":10,"ArrayAccessExpr":3,"BinaryExpr":9,"NameExpr":70,"CastExpr":2,"StringLiteralExpr":7,"FieldAccessExpr":6,"AssignExpr":3,"MethodCallExpr":14},"statements":{"IfStmt":2,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":19},"text":"/**\n     * The main program.  It expects two or three arguments:\n     *   0) the name of the host on which the mud server is running\n     *   1) the name of the MUD on that host\n     *   2) the name of a place within that MUD to start at (optional).\n     *\n     * It uses the Naming.lookup() method to obtain a RemoteMudServer object\n     * for the named MUD on the specified host.  Then it uses the getEntrance()\n     * or getNamedPlace() method of RemoteMudServer to obtain the starting\n     * RemoteMudPlace object.  It prompts the user for a their name and \n     * description, and creates a MudPerson object.  Finally, it passes\n     * the person and the place to runMud() to begin interaction with the MUD.\n     **/\npublic static void main(String[] args) {\n    try {\n        // Each MUD is uniquely identified by a \n        String hostname = args[0];\n        //   host and a MUD name.\n        String mudname = args[1];\n        // Each place in a MUD has a unique name\n        String placename = null;\n        if (args.length > 2)\n            placename = args[2];\n        // Look up the RemoteMudServer object for the named MUD using\n        // the default registry on the specified host.  Note the use of\n        // the Mud.mudPrefix constant to help prevent naming conflicts\n        // in the registry.\n        RemoteMudServer server = (RemoteMudServer) Naming.lookup(\"rmi://\" + hostname + \"/\" + Mud.mudPrefix + mudname);\n        // If the user did not specify a place in the mud, use\n        // getEntrance() to get the initial place.  Otherwise, call\n        // getNamedPlace() to find the initial place.\n        RemoteMudPlace location = null;\n        if (placename == null)\n            location = server.getEntrance();\n        else\n            location = (RemoteMudPlace) server.getNamedPlace(placename);\n        // Greet the user and ask for their name and description.\n        // This relies on getLine() and getMultiLine() defined below.\n        System.out.println(\"Welcome to \" + mudname);\n        String name = getLine(\"Enter your name: \");\n        String description = getMultiLine(\"Please describe what \" + \"people see when they look at you:\");\n        // Define an output stream that the MudPerson object will use to\n        // display messages sent to it to the user.  We'll use the console.\n        PrintWriter myout = new PrintWriter(System.out);\n        // Create a MudPerson object to represent the user in the MUD.\n        // Use the specified name and description, and the output stream.\n        MudPerson me = new MudPerson(name, description, myout);\n        // Lower this thread's priority one notch so that broadcast\n        // messages can appear even when we're blocking for I/O.  This is\n        // necessary on the Linux platform, but may not be necessary on all\n        // platforms.\n        int pri = Thread.currentThread().getPriority();\n        Thread.currentThread().setPriority(pri - 1);\n        // Finally, put the MudPerson into the RemoteMudPlace, and start\n        // prompting the user for commands.\n        runMud(location, me);\n    }// If anything goes wrong, print a message and exit.\n     catch (Exception e) {\n        System.out.println(e);\n        System.out.println(\"Usage: java MudClient <host> <mud> [<place>]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"MudClient","variables":{"server":3,"mudname":3,"e":1,"pri":2,"description":2,"placename":3,"Naming":1,"System":1,"Thread":2,"args":3,"hostname":2,"name":2,"me":1,"location":3,"myout":2},"constants":{"0":1,"1":3,"2":2,"\"Welcome to \"":1,"\"Usage: java MudClient <host> <mud> [<place>]\"":1,"null":3,"\"rmi://\"":1,"\"/\"":1,"\"Please describe what \"":1,"\"people see when they look at you:\"":1,"\"Enter your name: \"":1},"javaDoc":"The main program It expects two or three arguments: 0) the name of the host on which the mud server is running 1) the name of the MUD on that host 2) the name of a place within that MUD to start at (optional) It uses the Naming lookup() method to obtain a RemoteMudServer object for the named MUD on the specified host Then it uses the getEntrance() or getNamedPlace() method of RemoteMudServer to obtain the starting RemoteMudPlace object It prompts the user for a their name and description and creates a MudPerson object Finally it passes the person and the place to runMud() to begin interaction with the MUD","comments":"Look up the RemoteMudServer object for the named MUD using the default registry on the specified host Note the use of the Mud mudPrefix constant to help prevent naming conflicts If the user did not specify a place in the mud use getEntrance() to get the initial place Otherwise call Greet the user and ask for their name and description Define an output stream that the MudPerson object will use to Create a MudPerson object to represent the user in the MUD Lower this thread's priority one notch so that broadcast messages can appear even when we're blocking for I/O This is necessary on the Linux platform but may not be necessary on all Finally put the MudPerson into the RemoteMudPlace and start Each MUD is uniquely identified by a host and a MUD name Each place in a MUD has a unique name in the registry getNamedPlace() to find the initial place This relies on getLine() and getMultiLine() defined below display messages sent to it to the user We'll use the console Use the specified name and description and the output stream platforms prompting the user for commands If anything goes wrong print a message and exit \n     * The main program.  It expects two or three arguments:\n     *   0) the name of the host on which the mud server is running\n     *   1) the name of the MUD on that host\n     *   2) the name of a place within that MUD to start at (optional).\n     *\n     * It uses the Naming.lookup() method to obtain a RemoteMudServer object\n     * for the named MUD on the specified host.  Then it uses the getEntrance()\n     * or getNamedPlace() method of RemoteMudServer to obtain the starting\n     * RemoteMudPlace object.  It prompts the user for a their name and \n     * description, and creates a MudPerson object.  Finally, it passes\n     * the person and the place to runMud() to begin interaction with the MUD.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RemoteMudPlace","MudPerson"],"returnType":"void","methodCalls":{"getPlaceName":2,"getName":1,"tell":1,"setDescription":1,"getDescription":1,"substring":2,"getMudName":2,"sleep":1,"act":1,"linkTo":1,"createPlace":1,"destroyThing":1,"speak":1,"enter":1,"dump":1,"indexOf":1,"close":1,"System.out.println":25,"getServer":3,"System.out.flush":1,"createThing":1,"toLowerCase":1,"getLine":8,"go":1,"length":5,"look":3,"getMultiLine":3,"exit":3,"getPerson":2,"equals":16,"examineThing":1},"annotations":[],"exceptions":["MudException","RemoteException","InterruptedException","Exception","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"RemoteMudPerson":2,"RemoteMudPlace":1,"String":14,"int":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":5,"VariableDeclarationExpr":18,"BinaryExpr":31,"NameExpr":387,"StringLiteralExpr":67,"CharLiteralExpr":2,"UnaryExpr":1,"InstanceOfExpr":10,"AssignExpr":10,"NullLiteralExpr":4,"FieldAccessExpr":26,"MethodCallExpr":93},"statements":{"IfStmt":33,"TryStmt":6,"BlockStmt":26,"ForStmt":1,"ThrowStmt":5,"ExpressionStmt":72},"text":"/**\n     * This method is the main loop of the MudClient.  It places the person\n     * into the place (using the enter() method of RemoteMudPlace).  Then it\n     * calls the look() method to describe the place to the user, and enters a\n     * command loop to prompt the user for a command and process the command\n     **/\npublic static void runMud(RemoteMudPlace entrance, MudPerson me) throws RemoteException {\n    // The current place\n    RemoteMudPlace location = entrance;\n    // The person's name\n    String myname = me.getName();\n    // The name of the current place\n    String placename = null;\n    // The name of the mud of that place\n    String mudname = null;\n    try {\n        // Enter the MUD\n        location.enter(me, myname, myname + \" has entered the MUD.\");\n        // Figure out where we are (for the prompt)\n        mudname = location.getServer().getMudName();\n        placename = location.getPlaceName();\n        // Describe the place to the user\n        look(location);\n    } catch (Exception e) {\n        System.out.println(e);\n        System.exit(1);\n    }\n    // could go wrong each time through the loop.\n    for (; ; ) {\n        // Loop until the user types \"quit\"\n        try {\n            // generated indirectly by the last command a chance to appear.\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n            }\n            // Display a prompt, and get the user's input\n            String line = getLine(mudname + '.' + placename + \"> \");\n            // Break the input into a command and an argument that consists\n            // of the rest of the line.  Convert the command to lowercase.\n            String cmd, arg;\n            int i = line.indexOf(' ');\n            if (i == -1) {\n                cmd = line;\n                arg = null;\n            } else {\n                cmd = line.substring(0, i).toLowerCase();\n                arg = line.substring(i + 1);\n            }\n            if (arg == null)\n                arg = \"\";\n            // LOOK: Describe the place and its things, people, and exits\n            if (cmd.equals(\"look\"))\n                look(location);\n            else // EXAMINE: Describe a named thing\n            if (cmd.equals(\"examine\"))\n                System.out.println(location.examineThing(arg));\n            else // DESCRIBE: Describe a named person\n            if (cmd.equals(\"describe\")) {\n                try {\n                    RemoteMudPerson p = location.getPerson(arg);\n                    System.out.println(p.getDescription());\n                } catch (RemoteException e) {\n                    System.out.println(arg + \" is having technical \" + \"difficulties. No description \" + \"is available.\");\n                }\n            } else // GO: Go in a named direction\n            if (cmd.equals(\"go\")) {\n                location = location.go(me, arg);\n                mudname = location.getServer().getMudName();\n                placename = location.getPlaceName();\n                look(location);\n            } else // SAY: Say something to everyone \n            if (cmd.equals(\"say\"))\n                location.speak(me, arg);\n            else // DO: Do something that will be described to everyone\n            if (cmd.equals(\"do\"))\n                location.act(me, arg);\n            else // TALK: Say something to one named person\n            if (cmd.equals(\"talk\")) {\n                try {\n                    RemoteMudPerson p = location.getPerson(arg);\n                    String msg = getLine(\"What do you want to say?: \");\n                    p.tell(myname + \" says \\\"\" + msg + \"\\\"\");\n                } catch (RemoteException e) {\n                    System.out.println(arg + \" is having technical \" + \"difficulties. Can't talk to them.\");\n                }\n            } else // CHANGE: Change my own description \n            if (cmd.equals(\"change\"))\n                me.setDescription(getMultiLine(\"Describe yourself for others: \"));\n            else // CREATE: Create a new thing in this place\n            if (cmd.equals(\"create\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"name expected\");\n                String desc = getMultiLine(\"Please describe the \" + arg + \": \");\n                location.createThing(me, arg, desc);\n            } else // DESTROY: Destroy a named thing\n            if (cmd.equals(\"destroy\"))\n                location.destroyThing(me, arg);\n            else // through the exit specified in the argument.\n            if (cmd.equals(\"open\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                String name = getLine(\"What is the name of place there?: \");\n                String back = getLine(\"What is the direction from \" + \"there back to here?: \");\n                String desc = getMultiLine(\"Please describe \" + name + \":\");\n                location.createPlace(me, arg, back, name, desc);\n            } else // uni-directionally, and does not destroy a place.\n            if (cmd.equals(\"close\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                location.close(me, arg);\n            } else // that may be in another MUD running on another host\n            if (cmd.equals(\"link\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"direction expected\");\n                String host = getLine(\"What host are you linking to?: \");\n                String mud = getLine(\"What is the name of the MUD on that host?: \");\n                String place = getLine(\"What is the place name in that MUD?: \");\n                location.linkTo(me, arg, host, mud, place);\n                System.out.println(\"Don't forget to make a link from \" + \"there back to here!\");\n            } else // if the password is correct\n            if (cmd.equals(\"dump\")) {\n                if (arg.length() == 0)\n                    throw new IllegalArgumentException(\"filename expected\");\n         // Now that we've entered the MUD, begin a command loop to process\n\n         // the user's commands.  Note that there is a huge block of catch\n\n         // statements at the bottom of the loop to handle all the things that\n\n                String password = getLine(\"Password: \");\n                location.getServer().dump(password, arg);\n                      // Catch any exceptions that occur in the loop\n\n                 // Pause just a bit before printing the prompt, to give output\n\n            } else // QUIT: Quit the game\n            if (cmd.equals(\"quit\")) {\n                try {\n                    location.exit(me, myname + \" has quit.\");\n                } catch (Exception e) {\n                }\n                System.out.println(\"Bye.\");\n                System.out.flush();\n                System.exit(0);\n            } else // HELP: Print out a big help message\n            if (cmd.equals(\"help\"))\n                System.out.println(help);\n            else\n                // Otherwise, this is an unrecognized command.\n                System.out.println(\"Unknown command.  Try 'help'.\");\n        }// Handle the many possible types of MudException\n         catch (MudException e) {\n                 // Now go process the command.  What follows is a huge repeated\n\n                 // if/else statement covering each of the commands supported by\n\n                 // this client.  Many of these commands simply invoke one of\n\n                 // the remote methods of the current RemoteMudPlace object.\n\n                 // Some have to do a bit of additional processing.\n\n            if (e instanceof NoSuchThing)\n                System.out.println(\"There isn't any such thing here.\");\n            else if (e instanceof NoSuchPerson)\n                System.out.println(\"There isn't anyone by that name here.\");\n            else if (e instanceof NoSuchExit)\n                System.out.println(\"There isn't an exit in that direction.\");\n            else if (e instanceof NoSuchPlace)\n                System.out.println(\"There isn't any such place.\");\n            else if (e instanceof ExitAlreadyExists)\n                System.out.println(\"There is already an exit \" + \"in that direction.\");\n            else if (e instanceof PlaceAlreadyExists)\n                System.out.println(\"There is already a place \" + \"with that name.\");\n            else if (e instanceof LinkFailed)\n                System.out.println(\"That exit is not functioning.\");\n            else if (e instanceof BadPassword)\n                System.out.println(\"Invalid password.\");\n            else if (e instanceof NotThere)\n                System.out.println(\"You can't do that when \" + \"you're not there.\");\n            else if (e instanceof AlreadyThere)\n                System.out.println(\"You can't go there; \" + \"you're already there.\");\n        }// Handle RMI exceptions\n         catch (RemoteException e) {\n            System.out.println(\"The MUD is having technical difficulties.\");\n            System.out.println(\"Perhaps the server has crashed:\");\n            System.out.println(e);\n        }// Handle everything else that could go wrong.\n         catch (Exception e) {\n            System.out.println(\"Syntax or other error:\");\n            System.out.println(e);\n            System.out.println(\"Try using the 'help' command.\");\n        }\n    }\n}\n                 // OPEN: Create a new place and connect this place to it\n\n                 // CLOSE: Close a named exit.  Note: only closes an exit\n\n                 // LINK: Create a new exit that connects to an existing place\n\n                 // DUMP: Save the state of this MUD into the named file,\n\n                                                      // Shouldn't happen\n\n                                                      // Shouldn't happen\n\n","name":"runMud","className":"MudClient","variables":{"msg":2,"mudname":4,"e":18,"line":5,"i":3,"back":1,"myname":4,"placename":4,"System":2,"Thread":1,"p":4,"password":1,"arg":13,"me":2,"name":2,"host":1,"location":20,"cmd":19,"place":1,"entrance":1,"mud":1,"desc":2},"constants":{"\"talk\"":1,"\"Please describe \"":1,"\"do\"":1,"\"There isn't any such thing here.\"":1,"\"there back to here!\"":1,"\"Try using the 'help' command.\"":1,"\" has quit.\"":1,"\"examine\"":1,"\"Password: \"":1,"\" has entered the MUD.\"":1,"\"There isn't anyone by that name here.\"":1,"'.'":1,"\"Unknown command.  Try 'help'.\"":1,"\"quit\"":1,"\"What is the name of the MUD on that host?: \"":1,"\"you're already there.\"":1,"\"difficulties. No description \"":1,"\"You can't do that when \"":1,"\"\\\"\"":1,"\"look\"":1,"\"say\"":1,"\"there back to here?: \"":1,"\"link\"":1,"\"Syntax or other error:\"":1,"0":7,"\"There is already a place \"":1,"1":3,"200":1,"\"There isn't an exit in that direction.\"":1,"\" says \\\"\"":1,"null":4,"\"What is the place name in that MUD?: \"":1,"\" is having technical \"":2,"\"you're not there.\"":1,"\"Perhaps the server has crashed:\"":1,"\"destroy\"":1,"\"Please describe the \"":1,"\"\"":1,"\"What is the name of place there?: \"":1,"\"What host are you linking to?: \"":1,"\"go\"":1,"\"direction expected\"":3,"\": \"":1,"\":\"":1,"\"What do you want to say?: \"":1,"\"There is already an exit \"":1,"\"> \"":1,"\"in that direction.\"":1,"\"Don't forget to make a link from \"":1,"\"What is the direction from \"":1,"\"name expected\"":1,"\"with that name.\"":1,"\"is available.\"":1,"\"difficulties. Can't talk to them.\"":1,"\"change\"":1,"\"open\"":1,"\"close\"":1,"\"The MUD is having technical difficulties.\"":1,"' '":1,"\"dump\"":1,"\"You can't go there; \"":1,"\"describe\"":1,"\"create\"":1,"\"help\"":1,"\"There isn't any such place.\"":1,"\"That exit is not functioning.\"":1,"\"Describe yourself for others: \"":1,"\"filename expected\"":1,"\"Invalid password.\"":1,"\"Bye.\"":1},"javaDoc":"This method is the main loop of the MudClient It places the person into the place (using the enter() method of RemoteMudPlace) Then it calls the look() method to describe the place to the user and enters a command loop to prompt the user for a command and process the command","comments":"Now that we've entered the MUD begin a command loop to process the user's commands Note that there is a huge block of catch statements at the bottom of the loop to handle all the things that The current place The person's name The name of the current place The name of the mud of that place Enter the MUD Figure out where we are (for the prompt) Describe the place to the user could go wrong each time through the loop Loop until the user types \"quit\" Catch any exceptions that occur in the loop Pause just a bit before printing the prompt to give output Break the input into a command and an argument that consists Now go process the command What follows is a huge repeated if/else statement covering each of the commands supported by this client Many of these commands simply invoke one of the remote methods of the current RemoteMudPlace object Some have to do a bit of additional processing generated indirectly by the last command a chance to appear Display a prompt and get the user's input of the rest of the line Convert the command to lowercase LOOK: Describe the place and its things people and exits EXAMINE: Describe a named thing DESCRIBE: Describe a named person GO: Go in a named direction SAY: Say something to everyone DO: Do something that will be described to everyone TALK: Say something to one named person CHANGE: Change my own description CREATE: Create a new thing in this place DESTROY: Destroy a named thing OPEN: Create a new place and connect this place to it through the exit specified in the argument CLOSE: Close a named exit Note: only closes an exit uni-directionally and does not destroy a place LINK: Create a new exit that connects to an existing place that may be in another MUD running on another host DUMP: Save the state of this MUD into the named file if the password is correct QUIT: Quit the game HELP: Print out a big help message Otherwise this is an unrecognized command Handle the many possible types of MudException Shouldn't happen Shouldn't happen Handle RMI exceptions Handle everything else that could go wrong \n     * This method is the main loop of the MudClient.  It places the person\n     * into the place (using the enter() method of RemoteMudPlace).  Then it\n     * calls the look() method to describe the place to the user, and enters a\n     * command loop to prompt the user for a command and process the command\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["RemoteMudPlace"],"returnType":"void","methodCalls":{"getMudName":1,"getServer":1,"getPlaceName":1,"size":3,"System.out.flush":1,"elementAt":3,"getExits":1,"getNames":1,"getDescription":1,"System.out.print":9,"getThings":1,"System.out.println":3},"annotations":[],"exceptions":["MudException","RemoteException"],"concepts":[],"types":{"String":3,"Vector":3,"int":3},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":9,"BinaryExpr":9,"NameExpr":118,"StringLiteralExpr":8,"FieldAccessExpr":13,"UnaryExpr":3,"MethodCallExpr":26},"statements":{"IfStmt":3,"BlockStmt":3,"ForStmt":3,"ExpressionStmt":19},"text":"/** \n     * This convenience method is used in several places in the\n     * runMud() method above.  It displays the name and description of\n     * the current place (including the name of the mud the place is in), \n     * and also displays the list of things, people, and exits in\n     * the current place.\n     **/\npublic static void look(RemoteMudPlace p) throws RemoteException, MudException {\n    // Mud name\n    String mudname = p.getServer().getMudName();\n    // Place name\n    String placename = p.getPlaceName();\n    // Place description\n    String description = p.getDescription();\n    // List of things here\n    Vector things = p.getThings();\n    // List of people here\n    Vector names = p.getNames();\n    // List of exits from here\n    Vector exits = p.getExits();\n    // Print it all out\n    System.out.println(\"You are in: \" + placename + \" of the Mud: \" + mudname);\n    System.out.println(description);\n    System.out.print(\"Things here: \");\n    for (int i = 0; i < things.size(); i++) {\n        // Display list of things\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(things.elementAt(i));\n    }\n    System.out.print(\"\\nPeople here: \");\n    for (int i = 0; i < names.size(); i++) {\n        // Display list of people\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(names.elementAt(i));\n    }\n    System.out.print(\"\\nExits are: \");\n    for (int i = 0; i < exits.size(); i++) {\n        // Display list of exits\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(exits.elementAt(i));\n    }\n    // Blank line\n    System.out.println();\n    // Make it appear now!\n    System.out.flush();\n}\n","name":"look","className":"MudClient","variables":{"p":6,"exits":3,"names":3,"mudname":2,"things":3,"description":1,"i":12,"placename":2},"constants":{"0":6,"\"\\nExits are: \"":1,"\"You are in: \"":1,"\" of the Mud: \"":1,"\", \"":3,"\"Things here: \"":1,"\"\\nPeople here: \"":1},"javaDoc":"This convenience method is used in several places in the runMud() method above It displays the name and description of the current place (including the name of the mud the place is in) and also displays the list of things people and exits in the current place","comments":"Mud name Place name Place description List of things here List of people here List of exits from here Print it all out Display list of things Display list of people Display list of exits Blank line Make it appear now!  \n     * This convenience method is used in several places in the\n     * runMud() method above.  It displays the name and description of\n     * the current place (including the name of the mud the place is in), \n     * and also displays the list of things, people, and exits in\n     * the current place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":1,"System.out.flush":1,"length":1,"readLine":1,"System.out.print":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"NullLiteralExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":25,"FieldAccessExpr":2,"EnclosedExpr":2,"MethodCallExpr":5,"AssignExpr":2},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ReturnStmt":1,"ExpressionStmt":5,"DoStmt":1},"text":"/** \n     * A convenience method for prompting the user and getting a line of \n     * input.  It guarantees that the line is not empty and strips off \n     * whitespace at the beginning and end of the line.\n     **/\npublic static String getLine(String prompt) {\n    String line = null;\n    do {\n        // Loop until a non-empty line is entered\n        try {\n            // Display prompt\n            System.out.print(prompt);\n            // Display it right away\n            System.out.flush();\n            // Get a line of input\n            line = in.readLine();\n            // Strip off whitespace\n            if (line != null)\n                line = line.trim();\n        }// Ignore any errors\n         catch (Exception e) {\n        }\n    } while ((line == null) || (line.length() == 0));\n    return line;\n}\n","name":"getLine","className":"MudClient","variables":{"in":1,"e":1,"line":8},"constants":{"0":1,"null":3},"javaDoc":"A convenience method for prompting the user and getting a line of input It guarantees that the line is not empty and strips off whitespace at the beginning and end of the line","comments":"Loop until a non-empty line is entered Display prompt Display it right away Get a line of input Strip off whitespace Ignore any errors  \n     * A convenience method for prompting the user and getting a line of \n     * input.  It guarantees that the line is not empty and strips off \n     * whitespace at the beginning and end of the line.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"trim":3,"System.out.flush":1,"equals":1,"length":1,"readLine":1,"substring":1,"System.out.println":4,"startsWith":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":3},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":5,"StringLiteralExpr":8,"NameExpr":55,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":13,"AssignExpr":3},"statements":{"ContinueStmt":1,"IfStmt":3,"WhileStmt":1,"BreakStmt":1,"BlockStmt":5,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"/**\n     * A convenience method for getting multi-line input from the user.\n     * It prompts for the input, displays instructions, and guarantees that\n     * the input is not empty.  It also allows the user to enter the name of\n     * a file from which text will be read.\n     **/\npublic static String getMultiLine(String prompt) {\n    String text = \"\";\n    for (; ; ) {\n        // We'll break out of this loop when we get non-empty input\n        try {\n            // The stream to read from \n            BufferedReader br = in;\n            // Display the prompt\n            System.out.println(prompt);\n            // Display some instructions\n            System.out.println(\"You can enter multiple lines.  \" + \"End with a '.' on a line by itself.\\n\" + \"Or enter a '<<' followed by a filename\");\n            // Make the prompt and instructions appear now.\n            System.out.flush();\n            // Read lines\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Or until a dot by itself\n                if (line.equals(\".\"))\n                    break;\n                // instead of from the console.\n                if (line.trim().startsWith(\"<<\")) {\n                    String filename = line.trim().substring(2).trim();\n                    br = new BufferedReader(new FileReader(filename));\n                    // Don't count the << as part of the input\n                    continue;\n                } else\n                    // Add the line to the collected input\n                    text += line + \"\\n\";\n            }\n            // the user and go back to the prompt and the instructions.\n            if (text.length() > 0)\n                return text;\n            else\n                System.out.println(\"Please enter at least one line.\");\n        }// instructions\n         catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n}\n             // If there were errors, for example an IO error reading a file,\n\n             // display the error and loop again, displaying prompt and\n\n                 // If we got at least one line, return it.  Otherwise, chastise\n\n                                                            // Until EOF\n\n                     // Or, if a file is specified, start reading from it \n\n","name":"getMultiLine","className":"MudClient","variables":{"br":3,"filename":2,"in":1,"e":1,"line":6,"text":4},"constants":{"\"\"":1,"\"<<\"":1,"0":1,"\"Or enter a '<<' followed by a filename\"":1,"2":1,"\"You can enter multiple lines.  \"":1,"null":1,"\"End with a '.' on a line by itself.\\n\"":1,"\".\"":1,"\"Please enter at least one line.\"":1,"\"\\n\"":1},"javaDoc":"A convenience method for getting multi-line input from the user It prompts for the input displays instructions and guarantees that the input is not empty It also allows the user to enter the name of a file from which text will be read","comments":"We'll break out of this loop when we get non-empty input If there were errors for example an IO error reading a file display the error and loop again displaying prompt and If we got at least one line return it Otherwise chastise The stream to read from Display the prompt Display some instructions Make the prompt and instructions appear now Read lines Until EOF Or if a file is specified start reading from it Or until a dot by itself instead of from the console Don't count the << as part of the input Add the line to the collected input the user and go back to the prompt and the instructions instructions \n     * A convenience method for getting multi-line input from the user.\n     * It prompts for the input, displays instructions, and guarantees that\n     * the input is not empty.  It also allows the user to enter the name of\n     * a file from which text will be read.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String","String"],"returnType":"MudServer","methodCalls":{},"annotations":[],"exceptions":["PlaceAlreadyExists","RemoteException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":5,"AssignExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/**\n     * Start a MUD from scratch, with the given name and password.  Create\n     * an initial MudPlace object as the entrance, giving it the specified\n     * name and description.\n     **/\npublic MudServer(String mudname, String password, String placename, String description) throws RemoteException {\n    this.mudname = mudname;\n    this.password = password;\n    this.places = new Hashtable();\n    // Create the entrance place\n    try {\n        this.entrance = new MudPlace(this, placename, description);\n    }// Should never happen\n     catch (PlaceAlreadyExists e) {\n    }\n}\n","name":"MudServer","className":"MudServer","variables":{"password":1,"mudname":1,"e":1,"description":1,"placename":1},"constants":{},"javaDoc":"Start a MUD from scratch with the given name and password Create an initial MudPlace object as the entrance giving it the specified name and description","comments":"Create the entrance place Should never happen \n     * Start a MUD from scratch, with the given name and password.  Create\n     * an initial MudPlace object as the entrance, giving it the specified\n     * name and description.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** For serialization only.  Never call this constructor. */\npublic MudServer() throws RemoteException {\n}\n","name":"MudServer","className":"MudServer","variables":{},"constants":{},"javaDoc":"For serialization only Never call this constructor","comments":" For serialization only.  Never call this constructor. ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the name of the MUD */\npublic String getMudName() throws RemoteException {\n    return mudname;\n}\n","name":"getMudName","className":"MudServer","variables":{"mudname":1},"constants":{},"javaDoc":"This remote method returns the name of the MUD","comments":" This remote method returns the name of the MUD ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the entrance place of the MUD */\npublic RemoteMudPlace getEntrance() throws RemoteException {\n    return entrance;\n}\n","name":"getEntrance","className":"MudServer","variables":{"entrance":1},"constants":{},"javaDoc":"This remote method returns the entrance place of the MUD","comments":" This remote method returns the entrance place of the MUD ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPlace","methodCalls":{"get":1},"annotations":[],"exceptions":["NoSuchPlace","RemoteException"],"concepts":["Casting"],"types":{"RemoteMudPlace":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"CastExpr":1,"NameExpr":6,"MethodCallExpr":1},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This remote method returns a RemoteMudPlace object for the named place.\n     * In this sense, a MudServer acts as like an RMI Registry object,\n     * returning remote objects looked up by name.  It is simpler to do it this\n     * way than to use an actual Registry object.  If the named place does not\n     * exist, it throws a NoSuchPlace exception\n     **/\npublic RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace {\n    RemoteMudPlace p = (RemoteMudPlace) places.get(name);\n    if (p == null)\n        throw new NoSuchPlace();\n    return p;\n}\n","name":"getNamedPlace","className":"MudServer","variables":{"p":3,"places":1},"constants":{"null":1},"javaDoc":"This remote method returns a RemoteMudPlace object for the named place In this sense a MudServer acts as like an RMI Registry object returning remote objects looked up by name It is simpler to do it this way than to use an actual Registry object If the named place does not exist it throws a NoSuchPlace exception","comments":"\n     * This remote method returns a RemoteMudPlace object for the named place.\n     * In this sense, a MudServer acts as like an RMI Registry object,\n     * returning remote objects looked up by name.  It is simpler to do it this\n     * way than to use an actual Registry object.  If the named place does not\n     * exist, it throws a NoSuchPlace exception\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPlace","String"],"returnType":"void","methodCalls":{"containsKey":1,"put":1},"annotations":[],"exceptions":["PlaceAlreadyExists"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/**\n     * Define a new placename to place mapping in our hashtable.  \n     * This is not a remote method.  The MudPlace() constructor calls it\n     * to register the new place it is creating.\n     **/\npublic void setPlaceName(RemoteMudPlace place, String name) throws PlaceAlreadyExists {\n    if (places.containsKey(name))\n        throw new PlaceAlreadyExists();\n    places.put(name, place);\n}\n","name":"setPlaceName","className":"MudServer","variables":{"places":2},"constants":{},"javaDoc":"Define a new placename to place mapping in our hashtable This is not a remote method The MudPlace() constructor calls it to register the new place it is creating","comments":"\n     * Define a new placename to place mapping in our hashtable.  \n     * This is not a remote method.  The MudPlace() constructor calls it\n     * to register the new place it is creating.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"writeObject":1,"this.password.equals":1,"close":1},"annotations":[],"exceptions":["BadPassword","IOException","RemoteException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":14,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":3},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"/**\n     * This remote method serializes and compresses the state of the MUD\n     * to a named file, if the specified password matches the one specified\n     * when the MUD was initially created.  Note that the state of a MUD\n     * consists of all places in the MUD, with all things and exits in those\n     * places.  The people in the MUD are not part of the state that is saved.\n     **/\npublic void dump(String password, String f) throws RemoteException, BadPassword, IOException {\n    if ((this.password != null) && !this.password.equals(password))\n        throw new BadPassword();\n    ObjectOutputStream out = new ObjectOutputStream(new GZIPOutputStream(new FileOutputStream(f)));\n    out.writeObject(this);\n    out.close();\n}\n","name":"dump","className":"MudServer","variables":{"f":1,"out":3},"constants":{"null":1},"javaDoc":"This remote method serializes and compresses the state of the MUD to a named file if the specified password matches the one specified when the MUD was initially created Note that the state of a MUD consists of all places in the MUD with all things and exits in those places The people in the MUD are not part of the state that is saved","comments":"\n     * This remote method serializes and compresses the state of the MUD\n     * to a named file, if the specified password matches the one specified\n     * when the MUD was initially created.  Note that the state of a MUD\n     * consists of all places in the MUD, with all things and exits in those\n     * places.  The people in the MUD are not part of the state that is saved.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"rebind":1,"readObject":1,"System.out.println":2},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"MudServer":1,"FileInputStream":1,"ObjectInputStream":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":5,"BinaryExpr":4,"NameExpr":38,"CastExpr":1,"StringLiteralExpr":3,"FieldAccessExpr":5,"AssignExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ExpressionStmt":9},"text":"/**\n     * This main() method defines the standalone program that starts up a MUD\n     * server.  If invoked with a single argument, it treats that argument as\n     * the name of a file containing the serialized and compressed state of an\n     * existing MUD, and recreates it.  Otherwise, it expects four command-line\n     * arguments: the name of the MUD, the password, the name of the entrance\n     * place for the MUD, and a description of that entrance place.\n     * Besides creating the MudServer object, this program sets an appropriate\n     * security manager, and uses the default rmiregistry to register the\n     * the MudServer under its given name.\n     **/\npublic static void main(String[] args) {\n    try {\n        MudServer server;\n        if (args.length == 1) {\n            // Read the MUD state in from a file\n            FileInputStream f = new FileInputStream(args[0]);\n            ObjectInputStream in = new ObjectInputStream(new GZIPInputStream(f));\n            server = (MudServer) in.readObject();\n        } else\n            // Otherwise, create an initial MUD from scratch\n            server = new MudServer(args[0], args[1], args[2], args[3]);\n        Naming.rebind(Mud.mudPrefix + server.mudname, server);\n    }// Display an error message if anything goes wrong.\n     catch (Exception e) {\n        System.out.println(e);\n        System.out.println(\"Usage: java MudServer <savefile>\\n\" + \"   or: java MudServer <mudname> <password> \" + \"<placename> <description>\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"MudServer","variables":{"args":5,"server":3,"in":2,"e":1,"f":2,"Naming":1,"System":1},"constants":{"0":2,"1":3,"2":1,"3":1,"\"   or: java MudServer <mudname> <password> \"":1,"\"Usage: java MudServer <savefile>\\n\"":1,"\"<placename> <description>\"":1},"javaDoc":"This main() method defines the standalone program that starts up a MUD server If invoked with a single argument it treats that argument as the name of a file containing the serialized and compressed state of an existing MUD and recreates it Otherwise it expects four command-line arguments: the name of the MUD the password the name of the entrance place for the MUD and a description of that entrance place Besides creating the MudServer object this program sets an appropriate security manager and uses the default rmiregistry to register the the MudServer under its given name","comments":"Read the MUD state in from a file Otherwise create an initial MUD from scratch Display an error message if anything goes wrong \n     * This main() method defines the standalone program that starts up a MUD\n     * server.  If invoked with a single argument, it treats that argument as\n     * the name of a file containing the serialized and compressed state of an\n     * existing MUD, and recreates it.  Otherwise, it expects four command-line\n     * arguments: the name of the MUD, the password, the name of the entrance\n     * place for the MUD, and a description of that entrance place.\n     * Besides creating the MudServer object, this program sets an appropriate\n     * security manager, and uses the default rmiregistry to register the\n     * the MudServer under its given name.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"MudPlace","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** A no-arg constructor for de-serialization only.  Do not call it */\npublic MudPlace() throws RemoteException {\n    super();\n}\n","name":"MudPlace","className":"MudPlace","variables":{},"constants":{},"javaDoc":"A no-arg constructor for de-serialization only Do not call it","comments":" A no-arg constructor for de-serialization only.  Do not call it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MudServer","String","String"],"returnType":"MudPlace","methodCalls":{"setPlaceName":1},"annotations":[],"exceptions":["PlaceAlreadyExists","RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":13,"FieldAccessExpr":3,"ThisExpr":4,"AssignExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":4},"text":"/**\n     * This constructor creates a place, and calls a server method\n     * to register the object so that it will be accessible by name\n     **/\npublic MudPlace(MudServer server, String placename, String description) throws RemoteException, PlaceAlreadyExists {\n    this.server = server;\n    this.placename = placename;\n    this.description = description;\n    // Register the place\n    server.setPlaceName(this, placename);\n}\n","name":"MudPlace","className":"MudPlace","variables":{"server":2,"description":1,"placename":1},"constants":{},"javaDoc":"This constructor creates a place and calls a server method to register the object so that it will be accessible by name","comments":"Register the place \n     * This constructor creates a place, and calls a server method\n     * to register the object so that it will be accessible by name\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the name of this place */\npublic String getPlaceName() throws RemoteException {\n    return placename;\n}\n","name":"getPlaceName","className":"MudPlace","variables":{"placename":1},"constants":{},"javaDoc":"This remote method returns the name of this place","comments":" This remote method returns the name of this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns the description of this place */\npublic String getDescription() throws RemoteException {\n    return description;\n}\n","name":"getDescription","className":"MudPlace","variables":{"description":1},"constants":{},"javaDoc":"This remote method returns the description of this place","comments":" This remote method returns the description of this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of people in this place */\npublic Vector getNames() throws RemoteException {\n    return names;\n}\n","name":"getNames","className":"MudPlace","variables":{"names":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of people in this place","comments":" This remote method returns a Vector of names of people in this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of things in this place */\npublic Vector getThings() throws RemoteException {\n    return things;\n}\n","name":"getThings","className":"MudPlace","variables":{"things":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of things in this place","comments":" This remote method returns a Vector of names of things in this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Vector","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This remote method returns a Vector of names of exits from this place*/\npublic Vector getExits() throws RemoteException {\n    return exits;\n}\n","name":"getExits","className":"MudPlace","variables":{"exits":1},"constants":{},"javaDoc":"This remote method returns a Vector of names of exits from this place","comments":" This remote method returns a Vector of names of exits from this place","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"RemoteMudPerson","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NoSuchPerson","RemoteException"],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n     * This remote method returns a RemoteMudPerson object corresponding to\n     * the specified name, or throws an exception if no such person is here \n     **/\npublic RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson {\n    synchronized (names) {\n        // What about when there are 2 of the same name?\n        int i = names.indexOf(name);\n        if (i == -1)\n            throw new NoSuchPerson();\n        return (RemoteMudPerson) people.elementAt(i);\n    }\n}\n","name":"getPerson","className":"MudPlace","variables":{"names":2,"i":2,"people":1},"constants":{"1":1},"javaDoc":"This remote method returns a RemoteMudPerson object corresponding to the specified name or throws an exception if no such person is here","comments":"What about when there are 2 of the same name?  \n     * This remote method returns a RemoteMudPerson object corresponding to\n     * the specified name, or throws an exception if no such person is here \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NoSuchThing","RemoteException"],"concepts":["Synchronization"],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n     * This remote method returns a description of the named thing, or\n     * throws an exception if no such thing is in this place.\n     **/\npublic String examineThing(String name) throws RemoteException, NoSuchThing {\n    synchronized (things) {\n        int i = things.indexOf(name);\n        if (i == -1)\n            throw new NoSuchThing();\n        return (String) descriptions.elementAt(i);\n    }\n}\n","name":"examineThing","className":"MudPlace","variables":{"things":2,"i":2,"descriptions":1},"constants":{"1":1},"javaDoc":"This remote method returns a description of the named thing or throws an exception if no such thing is in this place","comments":" \n     * This remote method returns a description of the named thing, or\n     * throws an exception if no such thing is in this place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"RemoteMudPlace","methodCalls":{"getMudName":1,"lookup":1,"getNamedPlace":1,"verifyPresence":1,"elementAt":1,"enter":1,"indexOf":2,"substring":2},"annotations":[],"exceptions":["LinkFailed","NotThere","NoSuchExit","AlreadyThere","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"Object":1,"String":5,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":2,"VariableDeclarationExpr":10,"BinaryExpr":8,"NameExpr":59,"StringLiteralExpr":3,"CharLiteralExpr":1,"UnaryExpr":1,"InstanceOfExpr":2,"AssignExpr":5,"CastExpr":3,"ThisExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":3,"BlockStmt":4,"TryStmt":1,"SynchronizedStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":17},"text":"/** \n     * This remote method moves the specified RemoteMudPerson from this place\n     * in the named direction (i.e. through the named exit) to whatever place\n     * is there.  It throws exceptions if the specified person isn't in this\n     * place to begin with, or if they are already in the place through the \n     * exit or if the exit doesn't exist, or if the exit links to another MUD \n     * server and the server is not functioning.\n     **/\npublic RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed {\n    // Make sure the direction is valid, and get destination if it is\n    Object destination;\n    synchronized (exits) {\n        int i = exits.indexOf(direction);\n        if (i == -1)\n            throw new NoSuchExit();\n        destination = destinations.elementAt(i);\n    }\n    // If destination is a string, it is a place on another server, so\n    // connect to that server.  Otherwise, it is a place already on this\n    // server.  Throw an exception if we can't connect to the server.\n    RemoteMudPlace newplace;\n    if (destination instanceof String) {\n        try {\n            String t = (String) destination;\n            int pos = t.indexOf('@');\n            String url = t.substring(0, pos);\n            String placename = t.substring(pos + 1);\n            RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);\n            newplace = s.getNamedPlace(placename);\n        } catch (Exception e) {\n            throw new LinkFailed();\n        }\n    } else\n        // If the destination is not a string, then it is a Place\n        newplace = (RemoteMudPlace) destination;\n    // Make sure the person is here and get their name.  \n    // Throw an exception if they are not here\n    String name = verifyPresence(who);\n    // Move the person out of here, and tell everyone who remains about it.\n    this.exit(who, name + \" has gone \" + direction);\n    // Put the person into the new place.  \n    // Send a message to everyone already in that new place\n    String fromwhere;\n    if (// going to a local place\n    newplace instanceof MudPlace)\n        fromwhere = placename;\n    else\n        fromwhere = server.getMudName() + \".\" + placename;\n    newplace.enter(who, name, name + \" has arrived from: \" + fromwhere);\n    // know where they are now at.\n    return newplace;\n}\n         // Return the new RemoteMudPlace object to the client so they\n\n","name":"go","className":"MudPlace","variables":{"server":1,"newplace":6,"e":1,"fromwhere":4,"destinations":1,"destination":5,"i":2,"placename":3,"Naming":1,"url":1,"exits":2,"s":2,"t":4,"pos":2,"name":3,"direction":1},"constants":{"0":1,"1":2,"\" has arrived from: \"":1,"\" has gone \"":1,"\".\"":1,"'@'":1},"javaDoc":"This remote method moves the specified RemoteMudPerson from this place in the named direction (i e through the named exit) to whatever place is there It throws exceptions if the specified person isn't in this place to begin with or if they are already in the place through the exit or if the exit doesn't exist or if the exit links to another MUD server and the server is not functioning","comments":"If destination is a string it is a place on another server so connect to that server Otherwise it is a place already on this Make sure the person is here and get their name Put the person into the new place Return the new RemoteMudPlace object to the client so they Make sure the direction is valid and get destination if it is server Throw an exception if we can't connect to the server If the destination is not a string then it is a Place Throw an exception if they are not here Move the person out of here and tell everyone who remains about it Send a message to everyone already in that new place going to a local place know where they are now at  \n     * This remote method moves the specified RemoteMudPerson from this place\n     * in the named direction (i.e. through the named exit) to whatever place\n     * is there.  It throws exceptions if the specified person isn't in this\n     * place to begin with, or if they are already in the place through the \n     * exit or if the exit doesn't exist, or if the exit links to another MUD \n     * server and the server is not functioning.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n     * This remote method sends a message to everyone in the room.  Used to\n     * say things to everyone.  Requires that the speaker be in this place.\n     **/\npublic void speak(RemoteMudPerson speaker, String msg) throws RemoteException, NotThere {\n    String name = verifyPresence(speaker);\n    tellEveryone(name + \":\" + msg);\n}\n","name":"speak","className":"MudPlace","variables":{"msg":1,"name":2},"constants":{"\":\"":1},"javaDoc":"This remote method sends a message to everyone in the room Used to say things to everyone Requires that the speaker be in this place","comments":" \n     * This remote method sends a message to everyone in the room.  Used to\n     * say things to everyone.  Requires that the speaker be in this place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1},"annotations":[],"exceptions":["NotThere","RemoteException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n     * This remote method sends a message to everyone in the room.  Used to\n     * do things that people can see. Requires that the actor be in this place.\n     **/\npublic void act(RemoteMudPerson actor, String msg) throws RemoteException, NotThere {\n    String name = verifyPresence(actor);\n    tellEveryone(name + \" \" + msg);\n}\n","name":"act","className":"MudPlace","variables":{"msg":1,"name":2},"constants":{"\" \"":1},"javaDoc":"This remote method sends a message to everyone in the room Used to do things that people can see Requires that the actor be in this place","comments":" \n     * This remote method sends a message to everyone in the room.  Used to\n     * do things that people can see. Requires that the actor be in this place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","AlreadyThere","RemoteException"],"concepts":["Synchronization"],"types":{"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":20,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":4},"text":"/** \n     * This remote method creates a new thing in this room.\n     * It requires that the creator be in this room.\n     **/\npublic void createThing(RemoteMudPerson creator, String name, String description) throws RemoteException, NotThere, AlreadyThere {\n    // Make sure the creator is here\n    String creatorname = verifyPresence(creator);\n    synchronized (things) {\n        // Make sure there isn't already something with this name.  \n        if (things.indexOf(name) != -1)\n            throw new AlreadyThere();\n        // Add the thing name and descriptions to the appropriate lists\n        things.addElement(name);\n        descriptions.addElement(description);\n    }\n    // Tell everyone about the new thing and its creator\n    tellEveryone(creatorname + \" has created a \" + name);\n}\n","name":"createThing","className":"MudPlace","variables":{"things":3,"name":1,"creatorname":2,"descriptions":1},"constants":{"1":1,"\" has created a \"":1},"javaDoc":"This remote method creates a new thing in this room It requires that the creator be in this room","comments":"Make sure the creator is here Make sure there isn't already something with this name Add the thing name and descriptions to the appropriate lists Tell everyone about the new thing and its creator  \n     * This remote method creates a new thing in this room.\n     * It requires that the creator be in this room.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchThing","RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n     * Remove a thing from this room.  Throws exceptions if the person\n     * who removes it isn't themselves in the room, or if there is no\n     * such thing here.\n     **/\npublic void destroyThing(RemoteMudPerson destroyer, String thing) throws RemoteException, NotThere, NoSuchThing {\n    // Verify that the destroyer is here\n    String name = verifyPresence(destroyer);\n    synchronized (things) {\n        // Verify that there is a thing by that name in this room\n        int i = things.indexOf(thing);\n        if (i == -1)\n            throw new NoSuchThing();\n        // And remove its name and description from the lists\n        things.removeElementAt(i);\n        descriptions.removeElementAt(i);\n    }\n    // Let everyone know of the demise of this thing.\n    tellEveryone(name + \" had destroyed the \" + thing);\n}\n","name":"destroyThing","className":"MudPlace","variables":{"name":2,"things":3,"i":2,"descriptions":1,"thing":1},"constants":{"1":1,"\" had destroyed the \"":1},"javaDoc":"Remove a thing from this room Throws exceptions if the person who removes it isn't themselves in the room or if there is no such thing here","comments":"Verify that the destroyer is here Verify that there is a thing by that name in this room And remove its name and description from the lists Let everyone know of the demise of this thing \n     * Remove a thing from this room.  Throws exceptions if the person\n     * who removes it isn't themselves in the room, or if there is no\n     * such thing here.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"destination.destinations.addElement":1,"verifyPresence":1,"destination.exits.addElement":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","PlaceAlreadyExists","ExitAlreadyExists","RemoteException"],"concepts":["Synchronization"],"types":{"MudPlace":1,"String":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":34,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":7},"text":"/**\n     * Create a new place in this MUD, with the specified name an description. \n     * The new place is accessible from this place through\n     * the specified exit, and this place is accessible from the new place \n     * through the specified entrance.  The creator must be in this place\n     * in order to create a exit from this place.\n     **/\npublic void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists {\n    // Verify that the creator is actually here in this place\n    String creatorname = verifyPresence(creator);\n    synchronized (exits) {\n        // Check that the exit doesn't already exist.\n        if (exits.indexOf(exit) != -1)\n            throw new ExitAlreadyExists();\n        // Create the new place, registering its name with the server\n        MudPlace destination = new MudPlace(server, name, description);\n        // Link from there back to here\n        destination.exits.addElement(entrance);\n        destination.destinations.addElement(this);\n        // And link from here to there\n        exits.addElement(exit);\n        destinations.addElement(destination);\n    }\n    // Let everyone know about the new exit, and the new place beyond\n    tellEveryone(creatorname + \" has created a new place: \" + exit);\n}\n                                // Only one client may change exits at a time\n\n","name":"createPlace","className":"MudPlace","variables":{"server":1,"exit":1,"exits":3,"destinations":1,"destination":1,"name":1,"creatorname":2,"description":1},"constants":{"1":1,"\" has created a new place: \"":1},"javaDoc":"Create a new place in this MUD with the specified name an description The new place is accessible from this place through the specified exit and this place is accessible from the new place through the specified entrance The creator must be in this place in order to create a exit from this place","comments":"Verify that the creator is actually here in this place Only one client may change exits at a time Check that the exit doesn't already exist Create the new place registering its name with the server Link from there back to here And link from here to there Let everyone know about the new exit and the new place beyond \n     * Create a new place in this MUD, with the specified name an description. \n     * The new place is accessible from this place through\n     * the specified exit, and this place is accessible from the new place \n     * through the specified entrance.  The creator must be in this place\n     * in order to create a exit from this place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String","String","String"],"returnType":"void","methodCalls":{"lookup":1,"tellEveryone":1,"getNamedPlace":1,"verifyPresence":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchPlace","ExitAlreadyExists","RemoteException","Exception"],"concepts":["Casting","ExceptionHandling","Synchronization"],"types":{"RemoteMudServer":1,"RemoteMudPlace":1,"String":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":16,"NameExpr":37,"StringLiteralExpr":6,"CastExpr":1,"CharLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"SynchronizedStmt":1,"ThrowStmt":2,"ExpressionStmt":7},"text":"/**\n     * Create a new exit from this mud, linked to a named place in a named\n     * MUD on a named host (this can also be used to link to a named place in \n     * the current MUD, of course).  Because of the possibilities of deadlock,\n     * this method only links from here to there; it does not create a return\n     * exit from there to here.  That must be done with a separate call.\n     **/\npublic void linkTo(RemoteMudPerson linker, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace {\n    // Verify that the linker is actually here \n    String name = verifyPresence(linker);\n    // Check that the link target actually exists.  Throw NoSuchPlace if\n    // not.  Note that NoSuchPlace may also mean \"NoSuchMud\" or\n    // \"MudNotResponding\".\n    String url = \"rmi://\" + hostname + '/' + Mud.mudPrefix + mudname;\n    try {\n        RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);\n        RemoteMudPlace destination = s.getNamedPlace(placename);\n    } catch (Exception e) {\n        throw new NoSuchPlace();\n    }\n    synchronized (exits) {\n        // Check that the exit doesn't already exist.\n        if (exits.indexOf(exit) != -1)\n            throw new ExitAlreadyExists();\n        // Add the exit, to the list of exit names\n        exits.addElement(exit);\n        // And add the destination to the list of destinations.  Note that\n        // the destination is stored as a string rather than as a\n        // RemoteMudPlace.  This is because if the remote server goes down\n        // then comes back up again, a RemoteMudPlace is not valid, but the\n        // string still is.\n        destinations.addElement(url + '@' + placename);\n    }\n    // Let everyone know about the new exit and where it leads\n    tellEveryone(name + \" has linked \" + exit + \" to \" + \"'\" + placename + \"' in MUD '\" + mudname + \"' on host \" + hostname);\n}\n","name":"linkTo","className":"MudPlace","variables":{"exit":1,"hostname":2,"exits":3,"s":2,"mudname":2,"e":1,"destinations":1,"name":2,"destination":1,"Naming":1,"placename":2,"url":2},"constants":{"1":1,"\"rmi://\"":1,"\" to \"":1,"\" has linked \"":1,"\"' in MUD '\"":1,"\"' on host \"":1,"\"'\"":1,"'@'":1,"'/'":1},"javaDoc":"Create a new exit from this mud linked to a named place in a named MUD on a named host (this can also be used to link to a named place in the current MUD of course) Because of the possibilities of deadlock this method only links from here to there; it does not create a return exit from there to here That must be done with a separate call","comments":"Check that the link target actually exists Throw NoSuchPlace if not Note that NoSuchPlace may also mean \"NoSuchMud\" or Verify that the linker is actually here \"MudNotResponding\" And add the destination to the list of destinations Note that the destination is stored as a string rather than as a RemoteMudPlace This is because if the remote server goes down then comes back up again a RemoteMudPlace is not valid but the Check that the exit doesn't already exist Add the exit to the list of exit names string still is Let everyone know about the new exit and where it leads \n     * Create a new exit from this mud, linked to a named place in a named\n     * MUD on a named host (this can also be used to link to a named place in \n     * the current MUD, of course).  Because of the possibilities of deadlock,\n     * this method only links from here to there; it does not create a return\n     * exit from there to here.  That must be done with a separate call.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"verifyPresence":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["NotThere","NoSuchExit","RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"StringLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n     * Close an exit that leads out of this place.\n     * It does not close the return exit from there back to here.\n     * Note that this method does not destroy the place that the exit leads to.\n     * In the current implementation, there is no way to destroy a place.\n     **/\npublic void close(RemoteMudPerson who, String exit) throws RemoteException, NotThere, NoSuchExit {\n    // check that the person closing the exit is actually here\n    String name = verifyPresence(who);\n    synchronized (exits) {\n        // Check that the exit exists\n        int i = exits.indexOf(exit);\n        if (i == -1)\n            throw new NoSuchExit();\n        // Remove it and its destination from the lists\n        exits.removeElementAt(i);\n        destinations.removeElementAt(i);\n    }\n    // Let everyone know that the exit doesn't exist anymore\n    tellEveryone(name + \" has closed exit \" + exit);\n}\n","name":"close","className":"MudPlace","variables":{"exit":1,"exits":3,"destinations":1,"name":2,"i":2},"constants":{"1":1,"\" has closed exit \"":1},"javaDoc":"Close an exit that leads out of this place It does not close the return exit from there back to here Note that this method does not destroy the place that the exit leads to In the current implementation there is no way to destroy a place","comments":"check that the person closing the exit is actually here Check that the exit exists Remove it and its destination from the lists Let everyone know that the exit doesn't exist anymore \n     * Close an exit that leads out of this place.\n     * It does not close the return exit from there back to here.\n     * Note that this method does not destroy the place that the exit leads to.\n     * In the current implementation, there is no way to destroy a place.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"removeElementAt":2,"indexOf":1},"annotations":[],"exceptions":["RemoteException"],"concepts":["Synchronization"],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":18,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n     * Remove a person from this place.  If there is a message, send it to \n     * everyone who is left in this place.  If the specified person is not here\n     * this method does nothing and does not throw an exception.  This method\n     * is called by go(), and the client should call it when the user quits.\n     * The client should not allow the user to invoke it directly, however.\n     **/\npublic void exit(RemoteMudPerson who, String message) throws RemoteException {\n    String name;\n    synchronized (names) {\n        int i = people.indexOf(who);\n        if (i == -1)\n            return;\n        names.removeElementAt(i);\n        people.removeElementAt(i);\n    }\n    if (message != null)\n        tellEveryone(message);\n}\n","name":"exit","className":"MudPlace","variables":{"names":2,"name":1,"i":2,"message":1,"people":2},"constants":{"1":1,"null":1},"javaDoc":"Remove a person from this place If there is a message send it to everyone who is left in this place If the specified person is not here this method does nothing and does not throw an exception This method is called by go() and the client should call it when the user quits The client should not allow the user to invoke it directly however","comments":" \n     * Remove a person from this place.  If there is a message, send it to \n     * everyone who is left in this place.  If the specified person is not here\n     * this method does nothing and does not throw an exception.  This method\n     * is called by go(), and the client should call it when the user quits.\n     * The client should not allow the user to invoke it directly, however.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["RemoteMudPerson","String","String"],"returnType":"void","methodCalls":{"tellEveryone":1,"addElement":2,"indexOf":1},"annotations":[],"exceptions":["AlreadyThere","RemoteException"],"concepts":["Synchronization"],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"BinaryExpr":2,"NameExpr":17,"UnaryExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ExpressionStmt":3},"text":"/** \n     * This method puts a person into this place, assigning them the\n     * specified name, and displaying a message to anyone else who is in\n     * that place.  This method is called by go(), and the client should\n     * call it to initially place a person into the MUD.  Once the person\n     * is in the MUD, however, the client should restrict them to using go()\n     * and should not allow them to call this method directly.\n     * If there have been networking problems, a client might call this method\n     * to restore a person to this place, in case they've been bumped out.\n     * (A person will be bumped out of a place if the server tries to send\n     * a message to them and gets a RemoteException.)\n     **/\npublic void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere {\n    // Send the message to everyone who is already here.\n    if (message != null)\n        tellEveryone(message);\n    // Add the person to this place.\n    synchronized (names) {\n        if (people.indexOf(who) != -1)\n            throw new AlreadyThere();\n        names.addElement(name);\n        people.addElement(who);\n    }\n}\n","name":"enter","className":"MudPlace","variables":{"names":2,"message":1,"people":2},"constants":{"1":1,"null":1},"javaDoc":"This method puts a person into this place assigning them the specified name and displaying a message to anyone else who is in that place This method is called by go() and the client should call it to initially place a person into the MUD Once the person is in the MUD however the client should restrict them to using go() and should not allow them to call this method directly If there have been networking problems a client might call this method to restore a person to this place in case they've been bumped out (A person will be bumped out of a place if the server tries to send a message to them and gets a RemoteException )","comments":"Send the message to everyone who is already here Add the person to this place  \n     * This method puts a person into this place, assigning them the\n     * specified name, and displaying a message to anyone else who is in\n     * that place.  This method is called by go(), and the client should\n     * call it to initially place a person into the MUD.  Once the person\n     * is in the MUD, however, the client should restrict them to using go()\n     * and should not allow them to call this method directly.\n     * If there have been networking problems, a client might call this method\n     * to restore a person to this place, in case they've been bumped out.\n     * (A person will be bumped out of a place if the server tries to send\n     * a message to them and gets a RemoteException.)\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"RemoteMudServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * This final remote method returns the server object for the MUD in which\n     * this place exists.  The client should not allow the user to invoke this\n     * method.\n     **/\npublic RemoteMudServer getServer() throws RemoteException {\n    return server;\n}\n","name":"getServer","className":"MudPlace","variables":{"server":1},"constants":{},"javaDoc":"This final remote method returns the server object for the MUD in which this place exists The client should not allow the user to invoke this method","comments":"\n     * This final remote method returns the server object for the MUD in which\n     * this place exists.  The client should not allow the user to invoke this\n     * method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"size":1,"tell":1,"elementAt":1},"annotations":[],"exceptions":["RemoteException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"RemoteMudPerson":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":17,"CastExpr":1,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":5,"TryStmt":2,"ForStmt":1,"ExpressionStmt":3},"text":"public void run() {\n    // Loop through the recipients\n    for (int i = 0; i < recipients.size(); i++) {\n        RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);\n        // Try to send the message to each one.\n        try {\n            person.tell(message);\n        }// this place.\n         catch (RemoteException e) {\n            try {\n                MudPlace.this.exit(person, null);\n            } catch (Exception ex) {\n            }\n        }\n    }\n}\n             // If it fails, assume that that person's client or\n\n             // network has failed, and silently remove them from\n\n","name":"run","className":"","variables":{"ex":1,"e":1,"recipients":2,"person":2,"i":3,"MudPlace":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Loop through the recipients Try to send the message to each one If it fails assume that that person's client or network has failed and silently remove them from this place ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":2,"tell":1,"clone":1,"elementAt":1},"annotations":[],"exceptions":["RemoteException","Exception"],"concepts":["Casting","InnerMethod","FinalVariables","ExceptionHandling"],"types":{"RemoteMudPerson":1,"Vector":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":27,"CastExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** \n     * Create and start a thread that sends out a message everyone in this\n     * place.  If it gets a RemoteException talking to a person, it silently\n     * removes that person from this place.  This is not a remote method, but\n     * is used internally by a number of remote methods.\n     **/\nprotected void tellEveryone(final String message) {\n    // If there is no-one here, don't bother sending the message!\n    if (people.size() == 0)\n        return;\n    // Make a copy of the people here now.  The message is sent\n    // asynchronously and the list of people in the room may change before\n    // the message is sent to everyone.\n    final Vector recipients = (Vector) people.clone();\n    // Create and start a thread to send the message, using an anonymous\n    // class.  We do this because sending the message to everyone in this\n    // place might take some time, (particularly on a slow or flaky\n    // network) and we don't want to wait.\n    new Thread() {\n\n        public void run() {\n            // Loop through the recipients\n            for (int i = 0; i < recipients.size(); i++) {\n                RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);\n                // Try to send the message to each one.\n                try {\n                    person.tell(message);\n                }// this place.\n                 catch (RemoteException e) {\n                    try {\n                        MudPlace.this.exit(person, null);\n                    } catch (Exception ex) {\n                    }\n                }\n            }\n        }\n    }.start();\n}\n             // If it fails, assume that that person's client or\n\n             // network has failed, and silently remove them from\n\n","name":"tellEveryone","className":"MudPlace","variables":{"ex":1,"e":1,"recipients":3,"person":2,"i":3,"MudPlace":1,"run":1,"people":2},"constants":{"0":2,"null":1},"javaDoc":"Create and start a thread that sends out a message everyone in this place If it gets a RemoteException talking to a person it silently removes that person from this place This is not a remote method but is used internally by a number of remote methods","comments":"Make a copy of the people here now The message is sent asynchronously and the list of people in the room may change before Create and start a thread to send the message using an anonymous class We do this because sending the message to everyone in this place might take some time (particularly on a slow or flaky If there is no-one here don't bother sending the message! the message is sent to everyone network) and we don't want to wait Loop through the recipients Try to send the message to each one If it fails assume that that person's client or network has failed and silently remove them from this place  \n     * Create and start a thread that sends out a message everyone in this\n     * place.  If it gets a RemoteException talking to a person, it silently\n     * removes that person from this place.  This is not a remote method, but\n     * is used internally by a number of remote methods.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["RemoteMudPerson"],"returnType":"String","methodCalls":{"elementAt":1,"indexOf":1},"annotations":[],"exceptions":["NotThere"],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":9,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This convenience method checks whether the specified person is here.\n     * If so, it returns their name.  If not it throws a NotThere exception\n     **/\nprotected String verifyPresence(RemoteMudPerson who) throws NotThere {\n    int i = people.indexOf(who);\n    if (i == -1)\n        throw new NotThere();\n    else\n        return (String) names.elementAt(i);\n}\n","name":"verifyPresence","className":"MudPlace","variables":{"names":1,"i":2,"people":1},"constants":{"1":1},"javaDoc":"This convenience method checks whether the specified person is here If so it returns their name If not it throws a NotThere exception","comments":"\n     * This convenience method checks whether the specified person is here.\n     * If so, it returns their name.  If not it throws a NotThere exception\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ObjectInputStream"],"returnType":"void","methodCalls":{"defaultReadObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":5,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * This method is used for custom de-serialization.  Since the vectors of\n     * people and of their names are transient, they are not serialized with\n     * the rest of this place.  Therefore, when the place is de-serialized,\n     * those vectors have to be recreated (empty).\n     **/\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Read most of the object as normal\n    in.defaultReadObject();\n    // Then recreate the names vector\n    names = new Vector();\n    // and recreate the people vector\n    people = new Vector();\n}\n","name":"readObject","className":"MudPlace","variables":{"names":1,"in":1,"people":1},"constants":{},"javaDoc":"This method is used for custom de-serialization Since the vectors of people and of their names are transient they are not serialized with the rest of this place Therefore when the place is de-serialized those vectors have to be recreated (empty)","comments":"Read most of the object as normal Then recreate the names vector and recreate the people vector \n     * This method is used for custom de-serialization.  Since the vectors of\n     * people and of their names are transient, they are not serialized with\n     * the rest of this place.  Therefore, when the place is de-serialized,\n     * those vectors have to be recreated (empty).\n     *","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"Account","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":6,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"Account(String password) {\n    this.password = password;\n    transactions.add(\"Account opened at \" + new Date());\n}\n","name":"Account","className":"Account","variables":{"password":1,"transactions":1},"constants":{"\"Account opened at \"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"RemoteBankServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * This constructor doesn't do anything, but because the superclass \n     * constructor throws an exception, the exception must be declared here\n     **/\npublic RemoteBankServer() throws RemoteException {\n    super();\n}\n","name":"RemoteBankServer","className":"RemoteBankServer","variables":{},"constants":{},"javaDoc":"This constructor doesn't do anything but because the superclass constructor throws an exception the exception must be declared here","comments":"\n     * This constructor doesn't do anything, but because the superclass \n     * constructor throws an exception, the exception must be declared here\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"get":1,"put":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":10,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ExpressionStmt":2},"text":"/** \n     * Open a bank account with the specified name and password \n     * This method is synchronized to make it thread safe, since it \n     * manipulates the accounts hashtable.\n     **/\npublic synchronized void openAccount(String name, String password) throws RemoteException, BankingException {\n    // Check if there is already an account under that name\n    if (accounts.get(name) != null)\n        throw new BankingException(\"Account already exists.\");\n    // Otherwise, it doesn't exist, so create it.\n    Account acct = new Account(password);\n    // And register it\n    accounts.put(name, acct);\n}\n","name":"openAccount","className":"RemoteBankServer","variables":{"password":1,"accounts":2,"acct":1},"constants":{"null":1,"\"Account already exists.\"":1},"javaDoc":"Open a bank account with the specified name and password This method is synchronized to make it thread safe since it manipulates the accounts hashtable","comments":"Check if there is already an account under that name Otherwise it doesn't exist so create it And register it  \n     * Open a bank account with the specified name and password \n     * This method is synchronized to make it thread safe, since it \n     * manipulates the accounts hashtable.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"Account","methodCalls":{"get":1,"equals":1},"annotations":[],"exceptions":["BankingException"],"concepts":["Casting","Synchronization"],"types":{"Account":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":13,"CastExpr":1,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":2,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This internal method is not a remote method.  Given a name and password\n     * it checks to see if an account with that name and password exists.  If\n     * so, it returns the Account object.  Otherwise, it throws an exception.\n     **/\nAccount verify(String name, String password) throws BankingException {\n    synchronized (accounts) {\n        Account acct = (Account) accounts.get(name);\n        if (acct == null)\n            throw new BankingException(\"No such account\");\n        if (!password.equals(acct.password))\n            throw new BankingException(\"Invalid password\");\n        return acct;\n    }\n}\n","name":"verify","className":"RemoteBankServer","variables":{"password":1,"accounts":2,"acct":3},"constants":{"\"Invalid password\"":1,"null":1,"\"No such account\"":1},"javaDoc":"This internal method is not a remote method Given a name and password it checks to see if an account with that name and password exists If so it returns the Account object Otherwise it throws an exception","comments":"\n     * This internal method is not a remote method.  Given a name and password\n     * it checks to see if an account with that name and password exists.  If\n     * so, it returns the Account object.  Otherwise, it throws an exception.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{"verify":1,"remove":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":17,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n     * Close the named account.  This method is synchronized to make it \n     * thread safe, since it manipulates the accounts hashtable.\n     **/\npublic synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {\n    Account acct;\n    acct = verify(name, password);\n    accounts.remove(name);\n    // have to obtain a lock on that account to be thread safe.\n    synchronized (acct) {\n        int balance = acct.balance;\n        acct.balance = 0;\n        return new FunnyMoney(balance);\n    }\n}\n         // Before changing the balance or transactions of any account, we first\n\n","name":"closeAccount","className":"RemoteBankServer","variables":{"balance":2,"accounts":1,"acct":3},"constants":{"0":1},"javaDoc":"Close the named account This method is synchronized to make it thread safe since it manipulates the accounts hashtable","comments":"Before changing the balance or transactions of any account we first have to obtain a lock on that account to be thread safe  \n     * Close the named account.  This method is synchronized to make it \n     * thread safe, since it manipulates the accounts hashtable.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{"acct.transactions.add":1,"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":4,"MethodCallExpr":2,"AssignExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":3},"text":"/** Deposit the specified FunnyMoney to the named account */\npublic void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        acct.balance += money.amount;\n        acct.transactions.add(\"Deposited \" + money.amount + \" on \" + new Date());\n    }\n}\n","name":"deposit","className":"RemoteBankServer","variables":{"acct":2},"constants":{"\"Deposited \"":1,"\" on \"":1},"javaDoc":"Deposit the specified FunnyMoney to the named account","comments":" Deposit the specified FunnyMoney to the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{"acct.transactions.add":1,"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"ObjectCreationExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":20,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":2,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** Withdraw the specified amount from the named account */\npublic FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        if (acct.balance < amount)\n            throw new BankingException(\"Insufficient Funds\");\n        acct.balance -= amount;\n        acct.transactions.add(\"Withdrew \" + amount + \" on \" + new Date());\n        return new FunnyMoney(amount);\n    }\n}\n","name":"withdraw","className":"RemoteBankServer","variables":{"amount":4,"acct":2},"constants":{"\"Insufficient Funds\"":1,"\" on \"":1,"\"Withdrew \"":1},"javaDoc":"Withdraw the specified amount from the named account","comments":" Withdraw the specified amount from the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** Return the current balance in the named account */\npublic int getBalance(String name, String password) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        return acct.balance;\n    }\n}\n","name":"getBalance","className":"RemoteBankServer","variables":{"acct":2},"constants":{},"javaDoc":"Return the current balance in the named account","comments":" Return the current balance in the named account ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"List","methodCalls":{"verify":1},"annotations":[],"exceptions":["BankingException","RemoteException"],"concepts":["Synchronization"],"types":{"Account":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"BlockStmt":1,"SynchronizedStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/** \n     * Return a Vector of strings containing the transaction history\n     * for the named account\n     **/\npublic List getTransactionHistory(String name, String password) throws RemoteException, BankingException {\n    Account acct = verify(name, password);\n    synchronized (acct) {\n        return acct.transactions;\n    }\n}\n","name":"getTransactionHistory","className":"RemoteBankServer","variables":{"acct":2},"constants":{},"javaDoc":"Return a Vector of strings containing the transaction history for the named account","comments":" \n     * Return a Vector of strings containing the transaction history\n     * for the named account\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getProperty":1,"rebind":1,"System.err.println":2,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"RemoteBankServer":1,"String":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":28,"StringLiteralExpr":5,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":7},"text":"/**\n     * The main program that runs this RemoteBankServer.\n     * Create a RemoteBankServer object and give it a name in the registry.\n     * Read a system property to determine the name, but use \"FirstRemote\"\n     * as the default name.  This is all that is necessary to set up the\n     * service.  RMI takes care of the rest.\n     **/\npublic static void main(String[] args) {\n    try {\n        // Create a bank server object\n        RemoteBankServer bank = new RemoteBankServer();\n        // Figure out what to name it\n        String name = System.getProperty(\"bankname\", \"FirstRemote\");\n        // Name it that\n        Naming.rebind(name, bank);\n        // Tell the world we're up and running\n        System.out.println(name + \" is open and ready for customers.\");\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java [-Dbankname=<name>] \" + \"com.davidflanagan.examples.rmi.RemoteBankServer\");\n        System.exit(1);\n    }\n}\n                             // Force exit because there may be RMI threads\n\n","name":"main","className":"RemoteBankServer","variables":{"bank":1,"e":1,"name":2,"Naming":1,"System":2},"constants":{"\"FirstRemote\"":1,"\"Usage: java [-Dbankname=<name>] \"":1,"1":1,"\" is open and ready for customers.\"":1,"\"com.davidflanagan.examples.rmi.RemoteBankServer\"":1,"\"bankname\"":1},"javaDoc":"The main program that runs this RemoteBankServer Create a RemoteBankServer object and give it a name in the registry Read a system property to determine the name but use \"FirstRemote\" as the default name This is all that is necessary to set up the service RMI takes care of the rest","comments":"Create a bank server object Figure out what to name it Name it that Tell the world we're up and running Force exit because there may be RMI threads \n     * The main program that runs this RemoteBankServer.\n     * Create a RemoteBankServer object and give it a name in the registry.\n     * Read a system property to determine the name, but use \"FirstRemote\"\n     * as the default name.  This is all that is necessary to set up the\n     * service.  RMI takes care of the rest.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{"getCancelLabel":1,"add":3,"setSize":1,"getYesLabel":1,"getMessageText":1,"setLayout":2,"getNoLabel":1,"addTextListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Panel":2,"String[]":2,"int":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":9,"VariableDeclarationExpr":5,"ArrayAccessExpr":5,"BinaryExpr":1,"NameExpr":62,"StringLiteralExpr":9,"UnaryExpr":1,"AssignExpr":4,"ArrayInitializerExpr":2,"CastExpr":1,"ArrayCreationExpr":3,"ThisExpr":6,"MethodCallExpr":16},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":20},"text":"// The bean box calls this method to tell us what object to customize.\n// This method will always be called before the customizer is displayed,\n// so it is safe to create the customizer GUI here.\npublic void setObject(Object o) {\n    // save the object we're customizing\n    bean = (YesNoPanel) o;\n    // Put a label at the top of the panel.\n    this.setLayout(new BorderLayout());\n    this.add(new Label(\"Enter the message to appear in the panel:\"), \"North\");\n    // And a big text area below it for entering the message.\n    message = new TextArea(bean.getMessageText());\n    message.addTextListener(this);\n    // TextAreas don't know how big they want to be.  You must tell them.\n    message.setSize(400, 200);\n    this.add(message, \"Center\");\n    // Then add a row of textfields for entering the button labels.\n    // The row container\n    Panel buttonbox = new Panel();\n    // Equally spaced\n    buttonbox.setLayout(new GridLayout(1, 0, 25, 10));\n    // Put row on bottom\n    this.add(buttonbox, \"South\");\n    // Now go create three TextFields to put in this row.  But actually\n    // position a Label above each, so create an container for each\n    // TextField+Label combination.\n    // Array of TextFields.\n    fields = new TextField[3];\n    String[] labels = new String[] { // Labels for each.\n    \"Yes Button Label\", \"No Button Label\", \"Cancel Button Label\" };\n    String[] values = new String[] { // Initial values of each.\n    bean.getYesLabel(), bean.getNoLabel(), bean.getCancelLabel() };\n    for (int i = 0; i < 3; i++) {\n        // Create a container.\n        Panel p = new Panel();\n        // Give it a BorderLayout.\n        p.setLayout(new BorderLayout());\n        // Put a label on the top.\n        p.add(new Label(labels[i]), \"North\");\n        // Create the text field.\n        fields[i] = new TextField(values[i]);\n        // Put it below the label.\n        p.add(fields[i], \"Center\");\n        // Set the event listener.\n        fields[i].addTextListener(this);\n        // Add container to row.\n        buttonbox.add(p);\n    }\n}\n","name":"setObject","className":"YesNoPanelCustomizer","variables":{"p":4,"values":2,"buttonbox":3,"i":8,"message":3,"fields":4,"bean":5,"o":1,"labels":2},"constants":{"\"North\"":2,"25":1,"\"Cancel Button Label\"":1,"\"Center\"":2,"0":2,"1":1,"200":1,"3":2,"400":1,"\"No Button Label\"":1,"\"Enter the message to appear in the panel:\"":1,"\"South\"":1,"10":1},"javaDoc":"","comments":"Then add a row of textfields for entering the button labels Now go create three TextFields to put in this row But actually position a Label above each so create an container for each TextField+Label combination save the object we're customizing Put a label at the top of the panel And a big text area below it for entering the message TextAreas don't know how big they want to be You must tell them The row container Equally spaced Put row on bottom Array of TextFields Labels for each Initial values of each Create a container Give it a BorderLayout Put a label on the top Create the text field Put it below the label Set the event listener Add container to row  so it is safe to create the customizer GUI here.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Insets","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4},"statements":{"ReturnStmt":1},"text":"// Add some space around the outside of the panel.\npublic Insets getInsets() {\n    return new Insets(10, 10, 10, 10);\n}\n","name":"getInsets","className":"YesNoPanelCustomizer","variables":{},"constants":{"10":4},"javaDoc":"","comments":" Add some space around the outside of the panel.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TextEvent"],"returnType":"void","methodCalls":{"setCancelLabel":1,"setMessageText":1,"setNoLabel":1,"firePropertyChange":1,"getSource":1,"getText":1,"setYesLabel":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"TextComponent":1,"String":1},"expressions":{"IntegerLiteralExpr":3,"NullLiteralExpr":3,"VariableDeclarationExpr":2,"ArrayAccessExpr":3,"BinaryExpr":4,"CastExpr":1,"NameExpr":33,"MethodCallExpr":7},"statements":{"IfStmt":4,"ExpressionStmt":7},"text":"// This is the method defined by the TextListener interface.  Whenever the\n// user types a character in the TextArea or TextFields, this will get\n// called.  It updates the appropriate property of the bean and fires a\n// property changed event, as all customizers are required to do.\n// Note that we are not required to fire an event for every keystroke.\n// Instead we could include an \"Apply\" button that would make all the\n// changes at once, with a single property changed event.\npublic void textValueChanged(TextEvent e) {\n    TextComponent t = (TextComponent) e.getSource();\n    String s = t.getText();\n    if (t == message)\n        bean.setMessageText(s);\n    else if (t == fields[0])\n        bean.setYesLabel(s);\n    else if (t == fields[1])\n        bean.setNoLabel(s);\n    else if (t == fields[2])\n        bean.setCancelLabel(s);\n    listeners.firePropertyChange(null, null, null);\n}\n","name":"textValueChanged","className":"YesNoPanelCustomizer","variables":{"s":1,"t":6,"listeners":1,"e":1,"message":1,"fields":3,"bean":4},"constants":{"0":1,"1":1,"2":1,"null":3},"javaDoc":"","comments":" changes at once, with a single property changed event.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"addPropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addPropertyChangeListener(PropertyChangeListener l) {\n    listeners.addPropertyChangeListener(l);\n}\n","name":"addPropertyChangeListener","className":"YesNoPanelCustomizer","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"removePropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void removePropertyChangeListener(PropertyChangeListener l) {\n    listeners.removePropertyChangeListener(l);\n}\n","name":"removePropertyChangeListener","className":"YesNoPanelCustomizer","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void yes(AnswerEvent e);\n","name":"yes","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void no(AnswerEvent e);\n","name":"no","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void cancel(AnswerEvent e);\n","name":"cancel","className":"AnswerListener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayInitializerExpr":1,"StringLiteralExpr":3,"ArrayCreationExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the list of value names for the enumerated type. */\npublic String[] getTags() {\n    return new String[] { \"left\", \"center\", \"right\" };\n}\n","name":"getTags","className":"AlignmentEditor","variables":{},"constants":{"\"center\"":1,"\"right\"":1,"\"left\"":1},"javaDoc":"Return the list of value names for the enumerated type","comments":" Return the list of value names for the enumerated type. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"equals":3,"setValue":3},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":25,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":6},"statements":{"IfStmt":3,"ThrowStmt":1,"ExpressionStmt":3},"text":"/** Convert each of those value names into the actual value. */\npublic void setAsText(String s) {\n    if (s.equals(\"left\"))\n        setValue(Alignment.LEFT);\n    else if (s.equals(\"center\"))\n        setValue(Alignment.CENTER);\n    else if (s.equals(\"right\"))\n        setValue(Alignment.RIGHT);\n    else\n        throw new IllegalArgumentException(s);\n}\n","name":"setAsText","className":"AlignmentEditor","variables":{"s":4},"constants":{"\"center\"":1,"\"right\"":1,"\"left\"":1},"javaDoc":"Convert each of those value names into the actual value","comments":" Convert each of those value names into the actual value. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Object":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":3,"FieldAccessExpr":3,"MethodCallExpr":1},"statements":{"IfStmt":3,"ReturnStmt":4,"ExpressionStmt":1},"text":"/** This is an important method for code generation. */\npublic String getJavaInitializationString() {\n    Object o = getValue();\n    if (o == Alignment.LEFT)\n        return \"com.davidflanagan.examples.beans.Alignment.LEFT\";\n    if (o == Alignment.CENTER)\n        return \"com.davidflanagan.examples.beans.Alignment.CENTER\";\n    if (o == Alignment.RIGHT)\n        return \"com.davidflanagan.examples.beans.Alignment.RIGHT\";\n    return null;\n}\n","name":"getJavaInitializationString","className":"AlignmentEditor","variables":{"o":4},"constants":{"\"com.davidflanagan.examples.beans.Alignment.LEFT\"":1,"null":1,"\"com.davidflanagan.examples.beans.Alignment.CENTER\"":1,"\"com.davidflanagan.examples.beans.Alignment.RIGHT\"":1},"javaDoc":"This is an important method for code generation","comments":" This is an important method for code generation. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Image","methodCalls":{"loadImage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Return an icon for the bean.  We should really check the kind argument\n     * to see what size icon the beanbox wants, but since we only have one\n     * icon to offer, we just return it and let the beanbox deal with it\n     **/\npublic Image getIcon(int kind) {\n    return loadImage(\"YesNoPanelIcon.gif\");\n}\n","name":"getIcon","className":"YesNoPanelBeanInfo","variables":{},"constants":{"\"YesNoPanelIcon.gif\"":1},"javaDoc":"Return an icon for the bean We should really check the kind argument to see what size icon the beanbox wants but since we only have one icon to offer we just return it and let the beanbox deal with it","comments":"\n     * Return an icon for the bean.  We should really check the kind argument\n     * to see what size icon the beanbox wants, but since we only have one\n     * icon to offer, we just return it and let the beanbox deal with it\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BeanDescriptor","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ClassExpr":2},"statements":{"ReturnStmt":1},"text":"/**\n     * Return a descriptor for the bean itself.  It specifies a customizer\n     * for the bean class.  We could also add a description string here\n     **/\npublic BeanDescriptor getBeanDescriptor() {\n    return new BeanDescriptor(YesNoPanel.class, YesNoPanelCustomizer.class);\n}\n","name":"getBeanDescriptor","className":"YesNoPanelBeanInfo","variables":{},"constants":{},"javaDoc":"Return a descriptor for the bean itself It specifies a customizer for the bean class We could also add a description string here","comments":"\n     * Return a descriptor for the bean itself.  It specifies a customizer\n     * for the bean class.  We could also add a description string here\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"PropertyDescriptor","methodCalls":{"setShortDescription":1},"annotations":[],"exceptions":["IntrospectionException"],"concepts":["ExceptionHandling"],"types":{"PropertyDescriptor":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"ClassExpr":1,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** This is a convenience method for creating PropertyDescriptor objects */\nstatic PropertyDescriptor prop(String name, String description) {\n    try {\n        PropertyDescriptor p = new PropertyDescriptor(name, YesNoPanel.class);\n        p.setShortDescription(description);\n        return p;\n    } catch (IntrospectionException e) {\n        return null;\n    }\n}\n","name":"prop","className":"YesNoPanelBeanInfo","variables":{"p":3,"e":1,"name":1},"constants":{"null":1},"javaDoc":"This is a convenience method for creating PropertyDescriptor objects","comments":" This is a convenience method for creating PropertyDescriptor objects ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"PropertyDescriptor[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the property descriptors for this bean */\npublic PropertyDescriptor[] getPropertyDescriptors() {\n    return props;\n}\n","name":"getPropertyDescriptors","className":"YesNoPanelBeanInfo","variables":{"props":1},"constants":{},"javaDoc":"Return the property descriptors for this bean","comments":" Return the property descriptors for this bean ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** The message property is most often customized; make it the default */\npublic int getDefaultPropertyIndex() {\n    return 0;\n}\n","name":"getDefaultPropertyIndex","className":"YesNoPanelBeanInfo","variables":{},"constants":{"0":1},"javaDoc":"The message property is most often customized; make it the default","comments":" The message property is most often customized; make it the default ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"CastExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setValue(Object o) {\n    value = (String) o;\n}\n","name":"setValue","className":"YesNoPanelMessageEditor","variables":{"value":1,"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Object getValue() {\n    return value;\n}\n","name":"getValue","className":"YesNoPanelMessageEditor","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public void setAsText(String s) {\n    value = s;\n}\n","name":"setAsText","className":"YesNoPanelMessageEditor","variables":{"s":1,"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getAsText() {\n    return value;\n}\n","name":"getAsText","className":"YesNoPanelMessageEditor","variables":{"value":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// not enumerated; no tags\npublic String[] getTags() {\n    return null;\n}\n","name":"getTags","className":"YesNoPanelMessageEditor","variables":{},"constants":{"null":1},"javaDoc":"","comments":" not enumerated; no tags","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Say that we allow custom editing.\npublic boolean supportsCustomEditor() {\n    return true;\n}\n","name":"supportsCustomEditor","className":"YesNoPanelMessageEditor","variables":{},"constants":{"true":1},"javaDoc":"","comments":" Say that we allow custom editing.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TextEvent"],"returnType":"void","methodCalls":{"firePropertyChange":1,"getText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"NameExpr":7,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void textValueChanged(TextEvent e) {\n    value = t.getText();\n    listeners.firePropertyChange(null, null, null);\n}\n","name":"textValueChanged","className":"","variables":{"t":1,"listeners":1,"value":1},"constants":{"null":3},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Component","methodCalls":{"setSize":1,"firePropertyChange":1,"getText":1,"addTextListener":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"TextArea":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":2,"NullLiteralExpr":3,"VariableDeclarationExpr":1,"NameExpr":17,"MethodCallExpr":4,"AssignExpr":1},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"// Return the custom editor.  This just creates and returns a TextArea\n// to edit the multi-line text.  But it also registers a listener on the\n// text area to update the value as the user types and to fire the\n// property change events that property editors are required to fire.\npublic Component getCustomEditor() {\n    final TextArea t = new TextArea(value);\n    // TextArea has no preferred size, so set one\n    t.setSize(300, 150);\n    t.addTextListener(new TextListener() {\n\n        public void textValueChanged(TextEvent e) {\n            value = t.getText();\n            listeners.firePropertyChange(null, null, null);\n        }\n    });\n    return t;\n}\n","name":"getCustomEditor","className":"YesNoPanelMessageEditor","variables":{"textValueChanged":1,"t":5,"listeners":1,"e":1,"value":2},"constants":{"300":1,"null":3,"150":1},"javaDoc":"","comments":"TextArea has no preferred size so set one  property change events that property editors are required to fire.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Visual display of the value, for use with the custom editor.\n// Just print some instructions and hope they fit in the in the box.\n// This could be more sophisticated.\npublic boolean isPaintable() {\n    return true;\n}\n","name":"isPaintable","className":"YesNoPanelMessageEditor","variables":{},"constants":{"true":1},"javaDoc":"","comments":" This could be more sophisticated.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Rectangle"],"returnType":"void","methodCalls":{"setClip":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void paintValue(Graphics g, Rectangle r) {\n    g.setClip(r);\n    g.drawString(\"Click to edit...\", r.x + 5, r.y + 15);\n}\n","name":"paintValue","className":"YesNoPanelMessageEditor","variables":{"g":2},"constants":{"15":1,"\"Click to edit...\"":1,"5":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":2,"StringLiteralExpr":2,"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Important method for code generators.  Note that it really ought to\n// escape any quotes or backslashes in value before returning the string.\npublic String getJavaInitializationString() {\n    return \"\\\"\" + value + \"\\\"\";\n}\n","name":"getJavaInitializationString","className":"YesNoPanelMessageEditor","variables":{"value":1},"constants":{"\"\\\"\"":2},"javaDoc":"","comments":" escape any quotes or backslashes in value before returning the string.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"addPropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void addPropertyChangeListener(PropertyChangeListener l) {\n    listeners.addPropertyChangeListener(l);\n}\n","name":"addPropertyChangeListener","className":"YesNoPanelMessageEditor","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeListener"],"returnType":"void","methodCalls":{"removePropertyChangeListener":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void removePropertyChangeListener(PropertyChangeListener l) {\n    listeners.removePropertyChangeListener(l);\n}\n","name":"removePropertyChangeListener","className":"YesNoPanelMessageEditor","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Alignment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** This private constructor prevents anyone from instantiating us */\nprivate Alignment() {\n}\n","name":"Alignment","className":"Alignment","variables":{},"constants":{},"javaDoc":"This private constructor prevents anyone from instantiating us","comments":" This private constructor prevents anyone from instantiating us ","isEmpty":true,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Object","int"],"returnType":"AnswerEvent","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public AnswerEvent(Object source, int id) {\n    super(source);\n    this.id = id;\n}\n","name":"AnswerEvent","className":"AnswerEvent","variables":{"source":1,"id":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Return the button\npublic int getID() {\n    return id;\n}\n","name":"getID","className":"AnswerEvent","variables":{"id":1},"constants":{},"javaDoc":"","comments":" Return the button","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"YesNoPanel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** The no-argument bean constructor, with default property values */\npublic YesNoPanel() {\n    this(\"Your\\nMessage\\nHere\");\n}\n","name":"YesNoPanel","className":"YesNoPanel","variables":{},"constants":{"\"Your\\nMessage\\nHere\"":1},"javaDoc":"The no-argument bean constructor with default property values","comments":" The no-argument bean constructor, with default property values ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"YesNoPanel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"StringLiteralExpr":3,"FieldAccessExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public YesNoPanel(String messageText) {\n    this(messageText, Alignment.LEFT, \"Yes\", \"No\", \"Cancel\");\n}\n","name":"YesNoPanel","className":"YesNoPanel","variables":{"messageText":1},"constants":{"\"Yes\"":1,"\"Cancel\"":1,"\"No\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"fireEvent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.YES));\n}\n","name":"actionPerformed","className":"","variables":{"YesNoPanel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"fireEvent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.NO));\n}\n","name":"actionPerformed","className":"","variables":{"YesNoPanel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"fireEvent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.CANCEL));\n}\n","name":"actionPerformed","className":"","variables":{"YesNoPanel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Alignment","String","String","String"],"returnType":"YesNoPanel","methodCalls":{"add":5,"setAlignment":1,"setCancelLabel":1,"setMessageText":1,"setNoLabel":1,"fireEvent":3,"addActionListener":3,"setLayout":2,"setYesLabel":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Panel":1},"expressions":{"ObjectCreationExpr":13,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"NameExpr":86,"FieldAccessExpr":6,"ThisExpr":3,"MethodCallExpr":18,"AssignExpr":4},"statements":{"BlockStmt":3,"ExpressionStmt":23},"text":"/** A constructor for programmers using this class \"by hand\" */\npublic YesNoPanel(String messageText, Alignment alignment, String yesLabel, String noLabel, String cancelLabel) {\n    // Create the components for this panel\n    setLayout(new BorderLayout(15, 15));\n    // Put the message label in the middle of the window.\n    message = new MultiLineLabel(messageText, 20, 20, alignment);\n    add(message, BorderLayout.CENTER);\n    // Create a panel for the Panel buttons and put it at the bottom\n    // of the Panel.  Specify a FlowLayout layout manager for it.\n    Panel buttonbox = new Panel();\n    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));\n    add(buttonbox, BorderLayout.SOUTH);\n    // Create each specified button, specifying the action listener\n    // and action command for each, and adding them to the buttonbox\n    // Create buttons\n    yes = new Button();\n    no = new Button();\n    cancel = new Button();\n    // Add the buttons to the button box\n    buttonbox.add(yes);\n    buttonbox.add(no);\n    buttonbox.add(cancel);\n    // Register listeners for each button\n    yes.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.YES));\n        }\n    });\n    no.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.NO));\n        }\n    });\n    cancel.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.CANCEL));\n        }\n    });\n    // Now call property setter methods to set the message and button\n    // components to contain the right text\n    setMessageText(messageText);\n    setAlignment(alignment);\n    setYesLabel(yesLabel);\n    setNoLabel(noLabel);\n    setCancelLabel(cancelLabel);\n}\n","name":"YesNoPanel","className":"YesNoPanel","variables":{"cancel":2,"messageText":1,"no":2,"actionPerformed":3,"e":3,"yes":2,"YesNoPanel":3,"buttonbox":5,"message":1,"alignment":1},"constants":{"25":1,"15":3,"20":2},"javaDoc":"A constructor for programmers using this class \"by hand\"","comments":"Create a panel for the Panel buttons and put it at the bottom Create each specified button specifying the action listener and action command for each and adding them to the buttonbox Now call property setter methods to set the message and button Create the components for this panel Put the message label in the middle of the window of the Panel Specify a FlowLayout layout manager for it Create buttons Add the buttons to the button box Register listeners for each button components to contain the right text  A constructor for programmers using this class \"by hand\" ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Methods to query all of the bean properties.\npublic String getMessageText() {\n    return messageText;\n}\n","name":"getMessageText","className":"YesNoPanel","variables":{"messageText":1},"constants":{},"javaDoc":"","comments":" Methods to query all of the bean properties.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Alignment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Alignment getAlignment() {\n    return alignment;\n}\n","name":"getAlignment","className":"YesNoPanel","variables":{"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getYesLabel() {\n    return yesLabel;\n}\n","name":"getYesLabel","className":"YesNoPanel","variables":{"yesLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getNoLabel() {\n    return noLabel;\n}\n","name":"getNoLabel","className":"YesNoPanel","variables":{"noLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getCancelLabel() {\n    return cancelLabel;\n}\n","name":"getCancelLabel","className":"YesNoPanel","variables":{"cancelLabel":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setLabel":1,"validate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"// Methods to set all of the bean properties.\npublic void setMessageText(String messageText) {\n    this.messageText = messageText;\n    message.setLabel(messageText);\n    validate();\n}\n","name":"setMessageText","className":"YesNoPanel","variables":{"messageText":1,"message":1},"constants":{},"javaDoc":"","comments":" Methods to set all of the bean properties.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Alignment"],"returnType":"void","methodCalls":{"setAlignment":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setAlignment(Alignment alignment) {\n    this.alignment = alignment;\n    message.setAlignment(alignment);\n}\n","name":"setAlignment","className":"YesNoPanel","variables":{"alignment":1,"message":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setVisible":1,"length":1,"setLabel":1,"validate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void setYesLabel(String l) {\n    yesLabel = l;\n    yes.setLabel(l);\n    yes.setVisible((l != null) && (l.length() > 0));\n    validate();\n}\n","name":"setYesLabel","className":"YesNoPanel","variables":{"yesLabel":1,"yes":2,"l":3},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setVisible":1,"length":1,"setLabel":1,"validate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void setNoLabel(String l) {\n    noLabel = l;\n    no.setLabel(l);\n    no.setVisible((l != null) && (l.length() > 0));\n    validate();\n}\n","name":"setNoLabel","className":"YesNoPanel","variables":{"noLabel":1,"no":2,"l":3},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"setVisible":1,"length":1,"setLabel":1,"validate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"BinaryExpr":3,"NameExpr":15,"EnclosedExpr":2,"AssignExpr":1,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"public void setCancelLabel(String l) {\n    cancelLabel = l;\n    cancel.setLabel(l);\n    cancel.setVisible((l != null) && (l.length() > 0));\n    validate();\n}\n","name":"setCancelLabel","className":"YesNoPanel","variables":{"cancel":2,"cancelLabel":1,"l":3},"constants":{"0":1,"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"setFont":4,"validate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":21,"MethodCallExpr":6},"statements":{"ExpressionStmt":6},"text":"public void setFont(Font f) {\n    // Invoke the superclass method\n    super.setFont(f);\n    message.setFont(f);\n    yes.setFont(f);\n    no.setFont(f);\n    cancel.setFont(f);\n    validate();\n}\n","name":"setFont","className":"YesNoPanel","variables":{"cancel":1,"no":1,"yes":1,"message":1},"constants":{},"javaDoc":"","comments":"Invoke the superclass method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerListener"],"returnType":"void","methodCalls":{"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Register an action listener to be notified when a button is pressed */\npublic void addAnswerListener(AnswerListener l) {\n    listeners.addElement(l);\n}\n","name":"addAnswerListener","className":"YesNoPanel","variables":{"listeners":1},"constants":{},"javaDoc":"Register an action listener to be notified when a button is pressed","comments":" Register an action listener to be notified when a button is pressed ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerListener"],"returnType":"void","methodCalls":{"removeElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Remove an Answer listener from our list of interested listeners */\npublic void removeAnswerListener(AnswerListener l) {\n    listeners.removeElement(l);\n}\n","name":"removeAnswerListener","className":"YesNoPanel","variables":{"listeners":1},"constants":{},"javaDoc":"Remove an Answer listener from our list of interested listeners","comments":" Remove an Answer listener from our list of interested listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"cancel":1,"no":1,"size":1,"yes":1,"clone":1,"elementAt":1,"getID":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"AnswerListener":1,"Vector":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"CastExpr":2,"NameExpr":36,"FieldAccessExpr":3,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"SwitchStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":3,"ForStmt":1,"ExpressionStmt":5},"text":"/** Send an event to all registered listeners */\npublic void fireEvent(AnswerEvent e) {\n    // Make a copy of the list and fire the events using that copy.\n    // This means that listeners can be added or removed from the original\n    // list in response to this event.  We ought to be able to just use an\n    // enumeration for the vector, but that doesn't actually copy the list.\n    Vector list = (Vector) listeners.clone();\n    for (int i = 0; i < list.size(); i++) {\n        AnswerListener listener = (AnswerListener) list.elementAt(i);\n        switch(e.getID()) {\n            case AnswerEvent.YES:\n                listener.yes(e);\n                break;\n            case AnswerEvent.NO:\n                listener.no(e);\n                break;\n            case AnswerEvent.CANCEL:\n                listener.cancel(e);\n                break;\n        }\n    }\n}\n","name":"fireEvent","className":"YesNoPanel","variables":{"listeners":1,"e":1,"listener":4,"i":3,"list":3},"constants":{"0":1},"javaDoc":"Send an event to all registered listeners","comments":"Make a copy of the list and fire the events using that copy This means that listeners can be added or removed from the original list in response to this event We ought to be able to just use an enumeration for the vector but that doesn't actually copy the list  Send an event to all registered listeners ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void yes(AnswerEvent e) {\n    System.exit(0);\n}\n","name":"yes","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void no(AnswerEvent e) {\n    System.out.println(\"No\");\n}\n","name":"no","className":"","variables":{},"constants":{"\"No\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["AnswerEvent"],"returnType":"void","methodCalls":{"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void cancel(AnswerEvent e) {\n    System.out.println(\"Cancel\");\n}\n","name":"cancel","className":"","variables":{},"constants":{"\"Cancel\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"exit":1,"addAnswerListener":1,"pack":1,"System.out.println":2},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Frame":1,"YesNoPanel":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BooleanLiteralExpr":1,"StringLiteralExpr":3,"NameExpr":32,"FieldAccessExpr":2,"MethodCallExpr":7},"statements":{"BlockStmt":3,"ExpressionStmt":9},"text":"/** A main method that demonstrates the class */\npublic static void main(String[] args) {\n    // Create an instance of InfoPanel, with title and message specified:\n    YesNoPanel p = new YesNoPanel(\"Do you really want to quit?\");\n    // Register an action listener for the Panel.  This one just prints\n    // the results out to the console.\n    p.addAnswerListener(new AnswerListener() {\n\n        public void yes(AnswerEvent e) {\n            System.exit(0);\n        }\n\n        public void no(AnswerEvent e) {\n            System.out.println(\"No\");\n        }\n\n        public void cancel(AnswerEvent e) {\n            System.out.println(\"Cancel\");\n        }\n    });\n    Frame f = new Frame();\n    f.add(p);\n    f.pack();\n    f.setVisible(true);\n}\n","name":"main","className":"YesNoPanel","variables":{"p":2,"cancel":1,"no":1,"e":3,"yes":1,"f":4,"System":1},"constants":{"0":1,"true":1,"\"Cancel\"":1,"\"Do you really want to quit?\"":1,"\"No\"":1},"javaDoc":"A main method that demonstrates the class","comments":"Register an action listener for the Panel This one just prints Create an instance of InfoPanel with title and message specified: the results out to the console  A main method that demonstrates the class ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","int","int","Alignment"],"returnType":"MultiLineLabel","methodCalls":{"newLabel":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":14,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":5},"text":"// Here are five versions of the constructor.\npublic MultiLineLabel(String label, int margin_width, int margin_height, Alignment alignment) {\n    // Remember all the properties.\n    this.label = label;\n    this.margin_width = margin_width;\n    this.margin_height = margin_height;\n    this.alignment = alignment;\n    // Break the label up into lines.\n    newLabel();\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"label":1,"alignment":1,"margin_width":1},"constants":{},"javaDoc":"","comments":"Remember all the properties Break the label up into lines  Here are five versions of the constructor.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int","int"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, int margin_width, int margin_height) {\n    this(label, margin_width, margin_height, Alignment.LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"margin_height":1,"label":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Alignment"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label, Alignment alignment) {\n    this(label, 10, 10, alignment);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"label":1,"alignment":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":4,"FieldAccessExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel(String label) {\n    this(label, 10, 10, Alignment.LEFT);\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{"label":1},"constants":{"10":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"MultiLineLabel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MultiLineLabel() {\n    this(\"\");\n}\n","name":"MultiLineLabel","className":"MultiLineLabel","variables":{},"constants":{"\"\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"newLabel":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":8,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"// Methods to set and query the various attributes of the component.\n// Note that some query methods are inherited from the superclass.\npublic void setLabel(String label) {\n    this.label = label;\n    // Break the label into lines.\n    newLabel();\n    // Note that we need to measure lines.\n    measured = false;\n    // Request a redraw.\n    repaint();\n}\n","name":"setLabel","className":"MultiLineLabel","variables":{"measured":1,"label":1},"constants":{"false":1},"javaDoc":"","comments":"Break the label into lines Note that we need to measure lines Request a redraw  Note that some query methods are inherited from the superclass.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"public void setFont(Font f) {\n    // Tell our superclass about the new font.\n    super.setFont(f);\n    // Note that we need to remeasure lines.\n    measured = false;\n    // Request a redraw.\n    repaint();\n}\n","name":"setFont","className":"MultiLineLabel","variables":{"measured":1},"constants":{"false":1},"javaDoc":"","comments":"Tell our superclass about the new font Note that we need to remeasure lines Request a redraw ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void setForeground(Color c) {\n    // Tell our superclass about the new color.\n    super.setForeground(c);\n    // Request a redraw (size is unchanged).\n    repaint();\n}\n","name":"setForeground","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"","comments":"Tell our superclass about the new color Request a redraw (size is unchanged) ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Alignment"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setAlignment(Alignment a) {\n    alignment = a;\n    repaint();\n}\n","name":"setAlignment","className":"MultiLineLabel","variables":{"a":1,"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginWidth(int mw) {\n    margin_width = mw;\n    repaint();\n}\n","name":"setMarginWidth","className":"MultiLineLabel","variables":{"mw":1,"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setMarginHeight(int mh) {\n    margin_height = mh;\n    repaint();\n}\n","name":"setMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1,"mh":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Property getter methods.  Note that getFont(), getForeground(), etc.\n// are inherited from the superclass.\npublic String getLabel() {\n    return label;\n}\n","name":"getLabel","className":"MultiLineLabel","variables":{"label":1},"constants":{},"javaDoc":"","comments":" are inherited from the superclass.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Alignment","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Alignment getAlignment() {\n    return alignment;\n}\n","name":"getAlignment","className":"MultiLineLabel","variables":{"alignment":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginWidth() {\n    return margin_width;\n}\n","name":"getMarginWidth","className":"MultiLineLabel","variables":{"margin_width":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getMarginHeight() {\n    return margin_height;\n}\n","name":"getMarginHeight","className":"MultiLineLabel","variables":{"margin_height":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":8,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * This method is called by a layout manager when it wants to\n     * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n     * the preferred version of this method.  We use this deprecated version\n     * so that this component can interoperate with 1.0 components.\n     */\npublic Dimension preferredSize() {\n    if (!measured)\n        measure();\n    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);\n}\n","name":"preferredSize","className":"MultiLineLabel","variables":{"max_width":1,"margin_height":1,"measured":1,"line_height":1,"margin_width":1,"num_lines":1},"constants":{"2":2},"javaDoc":"This method is called by a layout manager when it wants to know how big we'd like to be In Java 1 1 getPreferredSize() is the preferred version of this method We use this deprecated version so that this component can interoperate with 1 0 components","comments":"\n     * This method is called by a layout manager when it wants to\n     * know how big we'd like to be.  In Java 1.1, getPreferredSize() is\n     * the preferred version of this method.  We use this deprecated version\n     * so that this component can interoperate with 1.0 components.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"preferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * This method is called when the layout manager wants to know\n     * the bare minimum amount of space we need to get by.\n     * For Java 1.1, we'd use getMinimumSize().\n     */\npublic Dimension minimumSize() {\n    return preferredSize();\n}\n","name":"minimumSize","className":"MultiLineLabel","variables":{},"constants":{},"javaDoc":"This method is called when the layout manager wants to know the bare minimum amount of space we need to get by For Java 1 1 we'd use getMinimumSize()","comments":"\n     * This method is called when the layout manager wants to know\n     * the bare minimum amount of space we need to get by.\n     * For Java 1.1, we'd use getMinimumSize().\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"measure":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Dimension":1,"int":2},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":11,"NameExpr":47,"FieldAccessExpr":5,"EnclosedExpr":2,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":5},"statements":{"IfStmt":3,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":8},"text":"/**\n     * This method draws the component.\n     * Note that it handles the margins and the alignment, but that\n     * it doesn't have to worry about the color or font--the superclass\n     * takes care of setting those in the Graphics object we're passed.\n     **/\npublic void paint(Graphics g) {\n    int x, y;\n    // use getSize() in Java 1.1\n    Dimension size = this.size();\n    if (!measured)\n        measure();\n    y = line_ascent + (size.height - num_lines * line_height) / 2;\n    for (int i = 0; i < num_lines; i++, y += line_height) {\n        if (alignment == Alignment.LEFT)\n            x = margin_width;\n        else if (alignment == Alignment.CENTER)\n            x = (size.width - line_widths[i]) / 2;\n        else\n            x = size.width - margin_width - line_widths[i];\n        g.drawString(lines[i], x, y);\n    }\n}\n","name":"paint","className":"MultiLineLabel","variables":{"measured":1,"g":1,"line_widths":2,"i":6,"line_height":2,"size":1,"line_ascent":1,"x":4,"y":3,"alignment":2,"lines":1,"num_lines":2,"margin_width":2},"constants":{"0":1,"2":2},"javaDoc":"This method draws the component Note that it handles the margins and the alignment but that it doesn't have to worry about the color or font--the superclass takes care of setting those in the Graphics object we're passed","comments":"use getSize() in Java 1 1 \n     * This method draws the component.\n     * Note that it handles the margins and the alignment, but that\n     * it doesn't have to worry about the color or font--the superclass\n     * takes care of setting those in the Graphics object we're passed.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"countTokens":1,"nextToken":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"StringTokenizer":1,"int":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":17,"StringLiteralExpr":1,"ArrayCreationExpr":2,"UnaryExpr":1,"AssignExpr":4,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":5},"text":"/**\n     * This internal method breaks a specified label up into an array of lines.\n     * It uses the StringTokenizer utility class.\n     **/\nprotected synchronized void newLabel() {\n    StringTokenizer t = new StringTokenizer(label, \"\\n\");\n    num_lines = t.countTokens();\n    lines = new String[num_lines];\n    line_widths = new int[num_lines];\n    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();\n}\n","name":"newLabel","className":"MultiLineLabel","variables":{"t":3,"line_widths":1,"i":4,"label":1,"lines":2,"num_lines":4},"constants":{"0":1,"\"\\n\"":1},"javaDoc":"This internal method breaks a specified label up into an array of lines It uses the StringTokenizer utility class","comments":"\n     * This internal method breaks a specified label up into an array of lines.\n     * It uses the StringTokenizer utility class.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":[],"returnType":"void","methodCalls":{"getFontMetrics":1,"getAscent":1,"stringWidth":1,"getHeight":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{"FontMetrics":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":4,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":32,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":6,"AssignExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n     * This internal method figures out how the font is, and how wide each\n     * line of the label is, and how wide the widest line is.\n     **/\nprotected synchronized void measure() {\n    FontMetrics fm = this.getToolkit().getFontMetrics(this.getFont());\n    line_height = fm.getHeight();\n    line_ascent = fm.getAscent();\n    max_width = 0;\n    for (int i = 0; i < num_lines; i++) {\n        line_widths[i] = fm.stringWidth(lines[i]);\n        if (line_widths[i] > max_width)\n            max_width = line_widths[i];\n    }\n    measured = true;\n}\n","name":"measure","className":"MultiLineLabel","variables":{"max_width":3,"measured":1,"line_height":1,"fm":4,"line_ascent":1,"line_widths":3,"i":7,"lines":1,"num_lines":1},"constants":{"0":2,"true":1},"javaDoc":"This internal method figures out how the font is and how wide each line of the label is and how wide the widest line is","comments":"\n     * This internal method figures out how the font is, and how wide each\n     * line of the label is, and how wide the widest line is.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":36}
{"paramTypes":["int"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":["ArrayIndexOutOfBoundsException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":5},"statements":{"IfStmt":1,"ThrowStmt":1,"ReturnStmt":1},"text":"/** Return an element of the array */\npublic int get(int index) throws ArrayIndexOutOfBoundsException {\n    if (index >= size)\n        throw new ArrayIndexOutOfBoundsException(index);\n    else\n        return data[index];\n}\n","name":"get","className":"IntList","variables":{"size":1,"data":1,"index":3},"constants":{},"javaDoc":"Return an element of the array","comments":" Return an element of the array ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"resize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"ArrayAccessExpr":1,"BinaryExpr":2,"NameExpr":12,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Add an int to the array, growing the array if necessary */\npublic void add(int x) {\n    // Grow array if needed.\n    if (data.length == size)\n        resize(data.length * 2);\n    // Store the int in it.\n    data[size++] = x;\n}\n","name":"add","className":"IntList","variables":{"size":2,"data":1,"x":1},"constants":{"2":1},"javaDoc":"Add an int to the array growing the array if necessary","comments":"Grow array if needed Store the int in it  Add an int to the array, growing the array if necessary ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"arraycopy":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int[]":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"NameExpr":9,"ArrayCreationExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/** An internal method to change the allocated size of the array */\nprotected void resize(int newsize) {\n    // Create a new array\n    int[] newdata = new int[newsize];\n    // Copy array elements.\n    System.arraycopy(data, 0, newdata, 0, size);\n    // Replace old array\n    data = newdata;\n}\n","name":"resize","className":"IntList","variables":{"data":1,"newdata":2,"newsize":1,"System":1},"constants":{"0":2},"javaDoc":"An internal method to change the allocated size of the array","comments":"Create a new array Copy array elements Replace old array  An internal method to change the allocated size of the array ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ObjectOutputStream"],"returnType":"void","methodCalls":{"resize":1,"defaultWriteObject":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":10,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/** Get rid of unused array elements before serializing the array */\nprivate void writeObject(ObjectOutputStream out) throws IOException {\n    // Compact the array.\n    if (data.length > size)\n        resize(size);\n    // Then write it out normally.\n    out.defaultWriteObject();\n}\n","name":"writeObject","className":"IntList","variables":{"size":1,"out":1},"constants":{},"javaDoc":"Get rid of unused array elements before serializing the array","comments":"Compact the array Then write it out normally  Get rid of unused array elements before serializing the array ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["ObjectInputStream"],"returnType":"void","methodCalls":{"defaultReadObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/** Compute the transient size field after deserializing the array */\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Read the array normally.\n    in.defaultReadObject();\n    // Restore the transient field.\n    size = data.length;\n}\n","name":"readObject","className":"IntList","variables":{"size":1,"in":1},"constants":{},"javaDoc":"Compute the transient size field after deserializing the array","comments":"Read the array normally Restore the transient field  Compute the transient size field after deserializing the array ","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":1,"IntList":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BooleanLiteralExpr":4,"BinaryExpr":3,"NameExpr":18,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":1,"UnaryExpr":2,"InstanceOfExpr":1,"ThisExpr":3},"statements":{"IfStmt":3,"ReturnStmt":4,"ForStmt":1,"ExpressionStmt":1},"text":"/**\n     * Does this object contain the same values as the object o?\n     * We override this Object method so we can test the class.\n     **/\npublic boolean equals(Object o) {\n    if (!(o instanceof IntList))\n        return false;\n    IntList that = (IntList) o;\n    if (this.size != that.size)\n        return false;\n    for (int i = 0; i < this.size; i++) if (this.data[i] != that.data[i])\n        return false;\n    return true;\n}\n","name":"equals","className":"IntList","variables":{"that":1,"i":5,"o":2},"constants":{"0":1,"false":3,"true":1},"javaDoc":"Does this object contain the same values as the object o? We override this Object method so we can test the class","comments":"\n     * Does this object contain the same values as the object o?\n     * We override this Object method so we can test the class.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"random":1,"equals":1,"store":1,"deepclone":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"int":1,"IntList":2},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":25,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** A main() method to prove that it works */\npublic static void main(String[] args) throws Exception {\n    IntList list = new IntList();\n    for (int i = 0; i < 100; i++) list.add((int) (Math.random() * 40000));\n    IntList copy = (IntList) Serializer.deepclone(list);\n    if (list.equals(copy))\n        System.out.println(\"equal copies\");\n    Serializer.store(list, new File(\"intlist.ser\"));\n}\n","name":"main","className":"IntList","variables":{"i":3,"copy":1,"list":3,"Math":1,"Serializer":2},"constants":{"0":1,"100":1,"\"intlist.ser\"":1,"40000":1,"\"equal copies\"":1},"javaDoc":"A main() method to prove that it works","comments":" A main() method to prove that it works ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ObjectOutput"],"returnType":"void","methodCalls":{"writeInt":2,"writeByte":1,"resize":1,"writeShort":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":2},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":6,"NameExpr":42,"FieldAccessExpr":4,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n     * This method from the Externalizable interface is responsible for saving\n     * the complete state of the object to the specified stream.  It can write\n     * anything it wants as long as readExternal() can read it.\n     **/\npublic void writeExternal(ObjectOutput out) throws IOException {\n    // Compact the array.\n    if (data.length > size)\n        resize(size);\n    // Start with our version number.\n    out.writeByte(version);\n    // Output the number of array elements\n    out.writeInt(size);\n    for (int i = 0; i < size; i++) {\n        // Now loop through the array\n        // The array element to write\n        int n = data[i];\n        if ((n < Short.MAX_VALUE) && (n > Short.MIN_VALUE + 1)) {\n            // If n fits in a short and is not Short.MIN_VALUE, then write\n            // it out as a short, saving ourselves two bytes\n            out.writeShort(n);\n        } else {\n            // Otherwise write out the special value Short.MIN_VALUE to\n            // signal that the number does not fit in a short, and then\n            // output the number using a full 4 bytes, for 6 bytes total\n            out.writeShort(Short.MIN_VALUE);\n            out.writeInt(n);\n        }\n    }\n}\n","name":"writeExternal","className":"CompactIntList","variables":{"size":2,"data":1,"i":4,"n":3,"out":5},"constants":{"0":1,"1":1},"javaDoc":"This method from the Externalizable interface is responsible for saving the complete state of the object to the specified stream It can write anything it wants as long as readExternal() can read it","comments":"Compact the array Start with our version number Output the number of array elements Now loop through the array The array element to write If n fits in a short and is not Short MIN_VALUE then write it out as a short saving ourselves two bytes Otherwise write out the special value Short MIN_VALUE to signal that the number does not fit in a short and then output the number using a full 4 bytes for 6 bytes total \n     * This method from the Externalizable interface is responsible for saving\n     * the complete state of the object to the specified stream.  It can write\n     * anything it wants as long as readExternal() can read it.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ObjectInput"],"returnType":"void","methodCalls":{"readShort":1,"resize":1,"readByte":1,"readInt":2},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"byte":1,"short":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":32,"StringLiteralExpr":1,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"IfStmt":2,"BlockStmt":1,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":7},"text":"/**\n     * This Externalizable method is responsible for completely restoring the\n     * state of the object.  A no-arg constructor will be called to re-create\n     * the object, and this method must read the state written by \n     * writeExternal() to restore the object's state.\n     **/\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n    // Start by reading and verifying the version number.\n    byte v = in.readByte();\n    if (v != version)\n        throw new IOException(\"CompactIntList: unknown version number\");\n    // Read the number of array elements, and make array that big\n    int newsize = in.readInt();\n    resize(newsize);\n    this.size = newsize;\n    // Now read that many values from the stream\n    for (int i = 0; i < newsize; i++) {\n        short n = in.readShort();\n        if (n != Short.MIN_VALUE)\n            data[i] = n;\n        else\n            data[i] = in.readInt();\n    }\n}\n","name":"readExternal","className":"CompactIntList","variables":{"data":2,"in":4,"v":2,"newsize":3,"i":5,"version":1,"n":3},"constants":{"0":1,"\"CompactIntList: unknown version number\"":1},"javaDoc":"This Externalizable method is responsible for completely restoring the state of the object A no-arg constructor will be called to re-create the object and this method must read the state written by writeExternal() to restore the object's state","comments":"Start by reading and verifying the version number Read the number of array elements and make array that big Now read that many values from the stream \n     * This Externalizable method is responsible for completely restoring the\n     * state of the object.  A no-arg constructor will be called to re-create\n     * the object, and this method must read the state written by \n     * writeExternal() to restore the object's state.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"random":1,"equals":1,"store":1,"deepclone":1,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["Casting"],"types":{"CompactIntList":2,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"VariableDeclarationExpr":3,"BinaryExpr":2,"NameExpr":25,"CastExpr":2,"StringLiteralExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"/** A main() method to prove that it works */\npublic static void main(String[] args) throws Exception {\n    CompactIntList list = new CompactIntList();\n    for (int i = 0; i < 100; i++) list.add((int) (Math.random() * 40000));\n    CompactIntList copy = (CompactIntList) Serializer.deepclone(list);\n    if (list.equals(copy))\n        System.out.println(\"equal copies\");\n    Serializer.store(list, new File(\"compactintlist.ser\"));\n}\n","name":"main","className":"CompactIntList","variables":{"i":3,"copy":1,"list":3,"Math":1,"Serializer":2},"constants":{"0":1,"100":1,"40000":1,"\"compactintlist.ser\"":1,"\"equal copies\"":1},"javaDoc":"A main() method to prove that it works","comments":" A main() method to prove that it works ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Serializable","File"],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"ObjectOutputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":8,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * Serialize the object o (and any Serializable objects it refers to) and\n     * store its serialized state in File f.\n     **/\nstatic void store(Serializable o, File f) throws IOException {\n    ObjectOutputStream // The class for serialization\n    out = new ObjectOutputStream(new FileOutputStream(f));\n    // This method serializes an object graph\n    out.writeObject(o);\n    out.close();\n}\n","name":"store","className":"Serializer","variables":{"f":1,"out":3},"constants":{},"javaDoc":"Serialize the object o (and any Serializable objects it refers to) and store its serialized state in File f","comments":"The class for serialization This method serializes an object graph \n     * Serialize the object o (and any Serializable objects it refers to) and\n     * store its serialized state in File f.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["File"],"returnType":"Object","methodCalls":{"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":[],"types":{"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * Deserialize the contents of File f and return the resulting object\n     **/\nstatic Object load(File f) throws IOException, ClassNotFoundException {\n    ObjectInputStream // The class for de-serialization\n    in = new ObjectInputStream(new FileInputStream(f));\n    // This method deserializes an object graph\n    return in.readObject();\n}\n","name":"load","className":"Serializer","variables":{"in":2,"f":1},"constants":{},"javaDoc":"Deserialize the contents of File f and return the resulting object","comments":"The class for de-serialization This method deserializes an object graph \n     * Deserialize the contents of File f and return the resulting object\n     *","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"void","methodCalls":{"writeObject":1,"close":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["ExceptionHandling"],"types":{"ObjectOutputStream":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"AssignExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":2,"BlockStmt":5,"ExpressionStmt":4},"text":"public void run() {\n    ObjectOutputStream out = null;\n    try {\n        out = new ObjectOutputStream(pipeout);\n        out.writeObject(o);\n    } catch (IOException e) {\n    } finally {\n        try {\n            out.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"run","className":"","variables":{"pipeout":1,"e":2,"out":4},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Serializable"],"returnType":"Object","methodCalls":{"writeObject":1,"start":1,"close":1,"readObject":1},"annotations":[],"exceptions":["IOException","ClassNotFoundException","Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"PipedOutputStream":1,"PipedInputStream":1,"ObjectOutputStream":1,"Thread":1,"ObjectInputStream":1},"expressions":{"ObjectCreationExpr":5,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"NameExpr":19,"AssignExpr":1,"MethodCallExpr":4},"statements":{"BlockStmt":6,"TryStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/**\n     * Use object serialization to make a \"deep clone\" of the object o.\n     * This method serializes o and all objects it refers to, and then\n     * deserializes that graph of objects, which means that everything is\n     * copied.  This differs from the clone() method of an object which is\n     * usually implemented to produce a \"shallow\" clone that copies references\n     * to other objects, instead of copying all referenced objects.\n     **/\nstatic Object deepclone(final Serializable o) throws IOException, ClassNotFoundException {\n    // Create a connected pair of \"piped\" streams.  \n    // We'll write bytes to one, and them from the other one.\n    final PipedOutputStream pipeout = new PipedOutputStream();\n    PipedInputStream pipein = new PipedInputStream(pipeout);\n    // Now define an independent thread to serialize the object and write\n    // its bytes to the PipedOutputStream\n    Thread writer = new Thread() {\n\n        public void run() {\n            ObjectOutputStream out = null;\n            try {\n                out = new ObjectOutputStream(pipeout);\n                out.writeObject(o);\n            } catch (IOException e) {\n            } finally {\n                try {\n                    out.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    };\n    // Make the thread start serializing and writing\n    writer.start();\n    // Meanwhile, in this thread, read and deserialize from the piped\n    // input stream.  The resulting object is a deep clone of the original.\n    ObjectInputStream in = new ObjectInputStream(pipein);\n    return in.readObject();\n}\n","name":"deepclone","className":"Serializer","variables":{"pipeout":3,"e":2,"in":2,"pipein":2,"run":1,"writer":2,"out":4},"constants":{"null":1},"javaDoc":"Use object serialization to make a \"deep clone\" of the object o This method serializes o and all objects it refers to and then deserializes that graph of objects which means that everything is copied This differs from the clone() method of an object which is usually implemented to produce a \"shallow\" clone that copies references to other objects instead of copying all referenced objects","comments":"Create a connected pair of \"piped\" streams Now define an independent thread to serialize the object and write Meanwhile in this thread read and deserialize from the piped We'll write bytes to one and them from the other one its bytes to the PipedOutputStream Make the thread start serializing and writing input stream The resulting object is a deep clone of the original \n     * Use object serialization to make a \"deep clone\" of the object o.\n     * This method serializes o and all objects it refers to, and then\n     * deserializes that graph of objects, which means that everything is\n     * copied.  This differs from the clone() method of an object which is\n     * usually implemented to produce a \"shallow\" clone that copies references\n     * to other objects, instead of copying all referenced objects.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":[],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":15,"StringLiteralExpr":2,"FieldAccessExpr":1,"UnaryExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"public String toString() {\n    String s = message;\n    for (int i = 0; i < data.length; i++) s += \" \" + data[i];\n    if (other != null)\n        s += \"\\n\\t\" + other.toString();\n    return s;\n}\n","name":"toString","className":"DataStructure","variables":{"other":2,"s":4,"data":1,"i":4,"message":1},"constants":{"0":1,"\" \"":1,"null":1,"\"\\n\\t\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"load":1,"store":1,"deepclone":1,"System.out.println":4},"annotations":[],"exceptions":["IOException","ClassNotFoundException"],"concepts":["Casting"],"types":{"DataStructure":2,"File":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":66,"StringLiteralExpr":7,"AssignExpr":8,"NullLiteralExpr":2,"ArrayInitializerExpr":2,"CastExpr":2,"FieldAccessExpr":15,"ArrayCreationExpr":2,"MethodCallExpr":7},"statements":{"ExpressionStmt":16},"text":"public static void main(String[] args) throws IOException, ClassNotFoundException {\n    // Create a simple object graph\n    DataStructure ds = new DataStructure();\n    ds.message = \"hello world\";\n    ds.data = new int[] { 1, 2, 3, 4 };\n    ds.other = new DataStructure();\n    ds.other.message = \"nested structure\";\n    ds.other.data = new int[] { 9, 8, 7 };\n    // Display the original object graph\n    System.out.println(\"Original data structure: \" + ds);\n    // Output it to a file\n    File f = new File(\"datastructure.ser\");\n    System.out.println(\"Storing to a file...\");\n    Serializer.store(ds, f);\n    // Read it back from the file, and display it again\n    ds = (DataStructure) Serializer.load(f);\n    System.out.println(\"Read from the file: \" + ds);\n    // Create a deep clone and display that.  After making the copy\n    // modify the original to prove that the clone is \"deep\".\n    DataStructure ds2 = (DataStructure) Serializer.deepclone(ds);\n    // Change original\n    ds.other.message = null;\n    // Change original\n    ds.other.data = null;\n    System.out.println(\"Deep clone: \" + ds2);\n}\n","name":"main","className":"Test","variables":{"ds2":2,"f":1,"ds":4,"Serializer":3},"constants":{"\"datastructure.ser\"":1,"\"Storing to a file...\"":1,"\"Original data structure: \"":1,"\"Read from the file: \"":1,"\"Deep clone: \"":1,"1":1,"2":1,"\"hello world\"":1,"3":1,"4":1,"null":2,"7":1,"8":1,"\"nested structure\"":1,"9":1},"javaDoc":"","comments":"Create a deep clone and display that After making the copy Create a simple object graph Display the original object graph Output it to a file Read it back from the file and display it again modify the original to prove that the clone is \"deep\" Change original Change original ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":1,"getMessage":1,"System.err.println":2,"delete":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":22,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":4},"text":"/** \n     * This is the main() method of the standalone program.  After checking\n     * it arguments, it invokes the Delete.delete() method to do the deletion\n     **/\npublic static void main(String[] args) {\n    if (args.length != 1) {\n        // Check command-line arguments\n        System.err.println(\"Usage: java Delete <file or directory>\");\n        System.exit(0);\n    }\n    // Call delete() and display any error messages it throws.\n    try {\n        delete(args[0]);\n    } catch (IllegalArgumentException e) {\n        System.err.println(e.getMessage());\n    }\n}\n","name":"main","className":"Delete","variables":{"args":1,"e":2,"System":1},"constants":{"0":2,"1":1,"\"Usage: java Delete <file or directory>\"":1},"javaDoc":"This is the main() method of the standalone program After checking it arguments it invokes the Delete delete() method to do the deletion","comments":"Check command-line arguments Call delete() and display any error messages it throws  \n     * This is the main() method of the standalone program.  After checking\n     * it arguments, it invokes the Delete.delete() method to do the deletion\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"fail":4,"exists":1,"canWrite":1,"list":1,"delete":1,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"boolean":1,"String[]":1,"File":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":31,"StringLiteralExpr":4,"FieldAccessExpr":1,"UnaryExpr":3,"MethodCallExpr":9},"statements":{"IfStmt":5,"BlockStmt":1,"ExpressionStmt":7},"text":"/**\n     * The static method that does the deletion.  Invoked by main(), and\n     * designed for use by other programs as well.  It first makes sure that\n     * the specified file or directory is deleteable before attempting to\n     * delete it.  If there is a problem, it throws an\n     * IllegalArgumentException.\n     **/\npublic static void delete(String filename) {\n    // Create a File object to represent the filename\n    File f = new File(filename);\n    // Make sure the file or directory exists and isn't write protected\n    if (!f.exists())\n        fail(\"Delete: no such file or directory: \" + filename);\n    if (!f.canWrite())\n        fail(\"Delete: write protected: \" + filename);\n    // If it is a directory, make sure it is empty\n    if (f.isDirectory()) {\n        String[] files = f.list();\n        if (files.length > 0)\n            fail(\"Delete: directory not empty: \" + filename);\n    }\n    // If we passed all the tests, then attempt to delete it\n    boolean success = f.delete();\n    // directory deletion always fails \n    if (!success)\n        fail(\"Delete: deletion failed\");\n}\n         // And throw an exception if it didn't work for some (unknown) reason.\n\n         // For example, because of a bug with Java 1.1.1 on Linux, \n\n","name":"delete","className":"Delete","variables":{"filename":4,"f":6,"success":2,"files":1},"constants":{"0":1,"\"Delete: no such file or directory: \"":1,"\"Delete: directory not empty: \"":1,"\"Delete: write protected: \"":1,"\"Delete: deletion failed\"":1},"javaDoc":"The static method that does the deletion Invoked by main() and designed for use by other programs as well It first makes sure that the specified file or directory is deleteable before attempting to delete it If there is a problem it throws an IllegalArgumentException","comments":"And throw an exception if it didn't work for some (unknown) reason For example because of a bug with Java 1 1 1 on Linux Create a File object to represent the filename Make sure the file or directory exists and isn't write protected If it is a directory make sure it is empty If we passed all the tests then attempt to delete it directory deletion always fails \n     * The static method that does the deletion.  Invoked by main(), and\n     * designed for use by other programs as well.  It first makes sure that\n     * the specified file or directory is deleteable before attempting to\n     * delete it.  If there is a problem, it throws an\n     * IllegalArgumentException.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ThrowStmt":1},"text":"/** A convenience method to throw an exception */\nprotected static void fail(String msg) throws IllegalArgumentException {\n    throw new IllegalArgumentException(msg);\n}\n","name":"fail","className":"Delete","variables":{"msg":1},"constants":{},"javaDoc":"A convenience method to throw an exception","comments":" A convenience method to throw an exception ","isEmpty":false,"hasInnerClass":false,"modifier":12}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    dispose();\n}\n","name":"windowClosing","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","FilenameFilter"],"returnType":"FileLister","methodCalls":{"add":2,"addWindowListener":1,"setEditable":1,"listDirectory":1,"addActionListener":3,"addItemListener":1,"dispose":1,"setFont":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":8,"BooleanLiteralExpr":2,"StringLiteralExpr":9,"NameExpr":75,"FieldAccessExpr":5,"ThisExpr":9,"AssignExpr":6,"MethodCallExpr":18},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":24},"text":"/** \n     * Constructor: create the GUI, and list the initial directory. \n     **/\npublic FileLister(String directory, FilenameFilter filter) {\n    // Create the window\n    super(\"File Lister\");\n    // Save the filter, if any\n    this.filter = filter;\n    // Destroy the window when the user requests it\n    addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            dispose();\n        }\n    });\n    // Set up the list\n    list = new List(12, false);\n    list.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 14));\n    list.addActionListener(this);\n    list.addItemListener(this);\n    // Set up the details area\n    details = new TextField();\n    details.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 12));\n    details.setEditable(false);\n    // Set up the button box\n    buttons = new Panel();\n    buttons.setLayout(new FlowLayout(FlowLayout.RIGHT, 15, 5));\n    buttons.setFont(new Font(\"SansSerif\", Font.BOLD, 14));\n    // Set up the two buttons\n    up = new Button(\"Up a Directory\");\n    close = new Button(\"Close\");\n    up.addActionListener(this);\n    close.addActionListener(this);\n    // Add buttons to button box\n    buttons.add(up);\n    buttons.add(close);\n    // Add stuff to the window\n    this.add(list, \"Center\");\n    this.add(details, \"North\");\n    this.add(buttons, \"South\");\n    this.setSize(500, 350);\n    // And now list initial directory.\n    listDirectory(directory);\n}\n","name":"FileLister","className":"FileLister","variables":{"filter":1,"buttons":5,"e":1,"windowClosing":1,"details":3,"up":2,"list":4,"close":2},"constants":{"\"North\"":1,"12":2,"\"Close\"":1,"14":2,"15":1,"false":2,"\"SansSerif\"":1,"\"Up a Directory\"":1,"\"File Lister\"":1,"\"Center\"":1,"350":1,"\"MonoSpaced\"":2,"5":1,"500":1,"\"South\"":1},"javaDoc":"Constructor: create the GUI and list the initial directory","comments":"Create the window Save the filter if any Destroy the window when the user requests it Set up the list Set up the details area Set up the button box Set up the two buttons Add buttons to button box Add stuff to the window And now list initial directory  \n     * Constructor: create the GUI, and list the initial directory. \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"add":2,"removeAll":1,"list":1,"isDirectory":1,"java.util.Arrays.sort":1,"setText":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"File":1,"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":42,"StringLiteralExpr":2,"FieldAccessExpr":3,"UnaryExpr":2,"ThisExpr":1,"MethodCallExpr":8,"AssignExpr":2},"statements":{"IfStmt":1,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":9},"text":"/**\n     * This method uses the list() method to get all entries in a directory\n     * and then displays them in the List component. \n     **/\npublic void listDirectory(String directory) {\n    // Convert the string to a File object, and check that the dir exists\n    File dir = new File(directory);\n    if (!dir.isDirectory())\n        throw new IllegalArgumentException(\"FileLister: no such directory\");\n    // Get the (filtered) directory entries\n    files = dir.list(filter);\n    // Sort the list of filenames.  Prior to Java 1.2, you could use\n    // com.davidflanagan.examples.classes.Sorter.sort() to sort instead.\n    java.util.Arrays.sort(files);\n    // Remove any old entries in the list, and add the new ones\n    list.removeAll();\n    // A special case entry\n    list.add(\"[Up to Parent Directory]\");\n    for (int i = 0; i < files.length; i++) list.add(files[i]);\n    // Display directory name in window titlebar and in the details box\n    this.setTitle(directory);\n    details.setText(directory);\n    // Remember this directory for later.\n    currentDir = dir;\n}\n","name":"listDirectory","className":"FileLister","variables":{"currentDir":1,"files":2,"i":4,"details":1,"dir":4,"list":3,"directory":1},"constants":{"0":1,"\"[Up to Parent Directory]\"":1,"\"FileLister: no such directory\"":1},"javaDoc":"This method uses the list() method to get all entries in a directory and then displays them in the List component","comments":"Sort the list of filenames Prior to Java 1 2 you could use Convert the string to a File object and check that the dir exists Get the (filtered) directory entries com davidflanagan examples classes Sorter sort() to sort instead Remove any old entries in the list and add the new ones A special case entry Display directory name in window titlebar and in the details box Remember this directory for later \n     * This method uses the list() method to get all entries in a directory\n     * and then displays them in the List component. \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"canRead":1,"length":1,"format":1,"getSelectedIndex":1,"exists":1,"canWrite":1,"lastModified":1,"isDirectory":1,"setText":1},"annotations":[],"exceptions":["IllegalArgumentException"],"concepts":[],"types":{"String":2,"File":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":42,"StringLiteralExpr":6,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":9,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":10},"text":"/**\n     * This ItemListener method uses various File methods to obtain information\n     * about a file or directory. Then it displays that info.\n     **/\npublic void itemStateChanged(ItemEvent e) {\n    // minus 1 for Up To Parent entry\n    int i = list.getSelectedIndex() - 1;\n    if (i < 0)\n        return;\n    // Get the selected entry \n    String filename = files[i];\n    // Convert to a File\n    File f = new File(currentDir, filename);\n    if (// Confirm that it exists\n    !f.exists())\n        throw new IllegalArgumentException(\"FileLister: \" + \"no such file or directory\");\n    // Get the details about the file or directory, concatenate to a string\n    String info = filename;\n    if (f.isDirectory())\n        info += File.separator;\n    info += \" \" + f.length() + \" bytes \";\n    info += dateFormatter.format(new java.util.Date(f.lastModified()));\n    if (f.canRead())\n        info += \" Read\";\n    if (f.canWrite())\n        info += \" Write\";\n    // And display the details string\n    details.setText(info);\n}\n","name":"itemStateChanged","className":"FileLister","variables":{"filename":3,"currentDir":1,"f":7,"i":3,"files":1,"dateFormatter":1,"details":1,"list":1,"info":6},"constants":{"0":1,"1":1,"\" \"":1,"\" bytes \"":1,"\"FileLister: \"":1,"\"no such file or directory\"":1,"\" Write\"":1,"\" Read\"":1},"javaDoc":"This ItemListener method uses various File methods to obtain information about a file or directory Then it displays that info","comments":"minus 1 for Up To Parent entry Get the selected entry Convert to a File Confirm that it exists Get the details about the file or directory concatenate to a string And display the details string \n     * This ItemListener method uses various File methods to obtain information\n     * about a file or directory. Then it displays that info.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getAbsolutePath":1,"getSource":3,"listDirectory":1,"getSelectedIndex":1,"up":2,"isDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"File":1,"int":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":2,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":5,"NameExpr":38,"ThisExpr":1,"MethodCallExpr":11},"statements":{"IfStmt":5,"BlockStmt":3,"ExpressionStmt":9},"text":"/**\n     * This ActionListener method is invoked when the user double-clicks on an \n     * entry or clicks on one of the buttons.  If they double-click on a file,\n     * create a FileViewer to display that file.  If they double-click on a\n     * directory, call the listDirectory() method to display that directory\n     **/\npublic void actionPerformed(ActionEvent e) {\n    if (e.getSource() == close)\n        this.dispose();\n    else if (e.getSource() == up) {\n        up();\n    } else if (e.getSource() == list) {\n        // Double click on an item\n        // Check which item\n        int i = list.getSelectedIndex();\n        if (// Handle first Up To Parent item\n        i == 0)\n            // Handle first Up To Parent item\n            up();\n        else {\n            // Otherwise, get filename\n            String name = files[i - 1];\n            // Convert to a File\n            File f = new File(currentDir, name);\n            String fullname = f.getAbsolutePath();\n            if (// List dir\n            f.isDirectory())\n                // List dir\n                listDirectory(fullname);\n            else\n                // display file\n                new FileViewer(fullname).show();\n        }\n    }\n}\n","name":"actionPerformed","className":"FileLister","variables":{"currentDir":1,"e":3,"f":3,"name":2,"i":3,"files":1,"up":1,"fullname":2,"list":2,"close":1},"constants":{"0":1,"1":1},"javaDoc":"This ActionListener method is invoked when the user double-clicks on an entry or clicks on one of the buttons If they double-click on a file create a FileViewer to display that file If they double-click on a directory call the listDirectory() method to display that directory","comments":"Double click on an item Check which item Handle first Up To Parent item Handle first Up To Parent item Otherwise get filename Convert to a File List dir List dir display file \n     * This ActionListener method is invoked when the user double-clicks on an \n     * entry or clicks on one of the buttons.  If they double-click on a file,\n     * create a FileViewer to display that file.  If they double-click on a\n     * directory, call the listDirectory() method to display that directory\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getParent":1,"listDirectory":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"/** A convenience method to display the contents of the parent directory */\nprotected void up() {\n    String parent = currentDir.getParent();\n    if (parent == null)\n        return;\n    listDirectory(parent);\n}\n","name":"up","className":"FileLister","variables":{"parent":2,"currentDir":1},"constants":{"null":1},"javaDoc":"A convenience method to display the contents of the parent directory","comments":" A convenience method to display the contents of the parent directory ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":8,"StringLiteralExpr":2,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** A convenience method used by main() */\npublic static void usage() {\n    System.out.println(\"Usage: java FileLister [directory_name] \" + \"[-e file_extension]\");\n    System.exit(0);\n}\n","name":"usage","className":"FileLister","variables":{"System":1},"constants":{"0":1,"\"Usage: java FileLister [directory_name] \"":1,"\"[-e file_extension]\"":1},"javaDoc":"A convenience method used by main()","comments":" A convenience method used by main() ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["File","String"],"returnType":"boolean","methodCalls":{"endsWith":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"NameExpr":8,"EnclosedExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"public boolean accept(File dir, String name) {\n    if (name.endsWith(suffix))\n        return true;\n    else\n        return (new File(dir, name)).isDirectory();\n}\n","name":"accept","className":"","variables":{"name":2,"dir":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosed(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addWindowListener":1,"exit":1,"getProperty":1,"usage":2,"endsWith":1,"show":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","FinalVariables"],"types":{"FilenameFilter":1,"String":2,"int":1,"FileLister":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":4,"NameExpr":53,"StringLiteralExpr":2,"UnaryExpr":2,"AssignExpr":4,"NullLiteralExpr":4,"BooleanLiteralExpr":1,"FieldAccessExpr":2,"EnclosedExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":5,"BlockStmt":5,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":13},"text":"/**\n     * A main() method so FileLister can be run standalone.\n     * Parse command line arguments and create the FileLister object.\n     * If an extension is specified, create a FilenameFilter for it.\n     * If no directory is specified, use the current directory.\n     **/\npublic static void main(String args[]) throws IOException {\n    FileLister f;\n    // The filter, if any\n    FilenameFilter filter = null;\n    // The specified dir, or the current dir\n    String directory = null;\n    // Loop through args array, parsing arguments\n    for (int i = 0; i < args.length; i++) {\n        if (args[i].equals(\"-e\")) {\n            if (++i >= args.length)\n                usage();\n            // final for anon. class below\n            final String suffix = args[i];\n            // This class is a simple FilenameFilter.  It defines the\n            // accept() method required to determine whether a specified\n            // file should be listed.  A file will be listed if its name\n            // ends with the specified extension, or if it is a directory.\n            filter = new FilenameFilter() {\n\n                public boolean accept(File dir, String name) {\n                    if (name.endsWith(suffix))\n                        return true;\n                    else\n                        return (new File(dir, name)).isDirectory();\n                }\n            };\n        } else {\n            if (// If already specified, fail.\n            directory != null)\n                // If already specified, fail.\n                usage();\n            else\n                directory = args[i];\n        }\n    }\n    // if no directory specified, use the current directory\n    if (directory == null)\n        directory = System.getProperty(\"user.dir\");\n    // Create the FileLister object, with directory and filter specified.\n    f = new FileLister(directory, filter);\n    // Arrange for the application to exit when the window is closed\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosed(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Finally, pop the window up up.\n    f.show();\n}\n","name":"main","className":"FileLister","variables":{"filter":3,"args":3,"windowClosed":1,"e":1,"f":4,"name":3,"i":7,"suffix":1,"dir":2,"directory":6,"System":2,"accept":1},"constants":{"0":2,"\"user.dir\"":1,"null":4,"\"-e\"":1,"true":1},"javaDoc":"A main() method so FileLister can be run standalone Parse command line arguments and create the FileLister object If an extension is specified create a FilenameFilter for it If no directory is specified use the current directory","comments":"The filter if any The specified dir or the current dir Loop through args array parsing arguments This class is a simple FilenameFilter It defines the accept() method required to determine whether a specified file should be listed A file will be listed if its name final for anon class below ends with the specified extension or if it is a directory If already specified fail If already specified fail if no directory specified use the current directory Create the FileLister object with directory and filter specified Arrange for the application to exit when the window is closed Finally pop the window up up \n     * A main() method so FileLister can be run standalone.\n     * Parse command line arguments and create the FileLister object.\n     * If an extension is specified, create a FilenameFilter for it.\n     * If no directory is specified, use the current directory.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getMessage":1,"copy":1,"System.err.println":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":3,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"FieldAccessExpr":3,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"/** The main() method of the standalone program.  Calls copy(). */\npublic static void main(String[] args) {\n    if (// Check arguments \n    args.length != 2)\n        System.err.println(\"Usage: java FileCopy <source> <destination>\");\n    else {\n        // Call copy() to do the copy; display any error messages\n        try {\n            copy(args[0], args[1]);\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}\n","name":"main","className":"FileCopy","variables":{"args":2,"e":2},"constants":{"0":1,"1":1,"2":1,"\"Usage: java FileCopy <source> <destination>\"":1},"javaDoc":"The main() method of the standalone program Calls copy()","comments":"Check arguments Call copy() to do the copy; display any error messages  The main() method of the standalone program.  Calls copy(). ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"getParent":1,"getName":2,"getProperty":1,"read":1,"isFile":2,"canRead":1,"System.out.flush":1,"canWrite":2,"readLine":1,"abort":8,"equals":2,"exists":3,"write":1,"close":2,"isDirectory":1,"System.out.print":1},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"byte[]":1,"FileOutputStream":1,"BufferedReader":1,"String":2,"File":3,"FileInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":3,"VariableDeclarationExpr":10,"BinaryExpr":14,"NameExpr":113,"StringLiteralExpr":13,"UnaryExpr":9,"AssignExpr":5,"NullLiteralExpr":5,"FieldAccessExpr":3,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":30},"statements":{"IfStmt":13,"WhileStmt":1,"BlockStmt":8,"TryStmt":3,"EmptyStmt":2,"ExpressionStmt":27},"text":"/**\n     * The static method that actually performs the file copy.\n     * Before copying the file, however, it performs a lot of tests to make\n     * sure everything is as it should be.\n     */\npublic static void copy(String from_name, String to_name) throws IOException {\n    // Get File objects from Strings\n    File from_file = new File(from_name);\n    File to_file = new File(to_name);\n    // First make sure the source file exists, is a file, and is readable.\n    if (!from_file.exists())\n        abort(\"no such source file: \" + from_name);\n    if (!from_file.isFile())\n        abort(\"can't copy directory: \" + from_name);\n    if (!from_file.canRead())\n        abort(\"source file is unreadable: \" + from_name);\n    // as the destination file name\n    if (to_file.isDirectory())\n        to_file = new File(to_file, from_file.getName());\n    // exist, make sure the directory exists and is writeable.\n    if (to_file.exists()) {\n        if (!to_file.canWrite())\n            abort(\"destination file is unwriteable: \" + to_name);\n        // Ask whether to overwrite it\n        System.out.print(\"Overwrite existing file \" + to_file.getName() + \"? (Y/N): \");\n        System.out.flush();\n        // Get the user's response.\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String response = in.readLine();\n        // Check the response.  If not a Yes, abort the copy.\n        if (!response.equals(\"Y\") && !response.equals(\"y\"))\n            abort(\"existing file was not overwritten.\");\n    } else {\n        // If file doesn't exist, check if directory exists and is\n        // writeable.  If getParent() returns null, then the directory is\n        // the current dir.  so look up the user.dir system property to\n        // find out what that is.\n        // The destination directory\n        String parent = to_file.getParent();\n        if (// If none, use the current directory\n        parent == null)\n            parent = System.getProperty(\"user.dir\");\n        // Convert it to a file.\n        File dir = new File(parent);\n        if (!dir.exists())\n            abort(\"destination directory doesn't exist: \" + parent);\n        if (dir.isFile())\n            abort(\"destination is not a directory: \" + parent);\n         // If the destination is a directory, use the source file name\n\n        if (!dir.canWrite())\n            abort(\"destination directory is unwriteable: \" + parent);\n    }\n    // If we've gotten this far, then everything is okay.\n         // If the destination exists, make sure it is a writeable file\n\n         // and ask before overwriting it.  If the destination doesn't\n\n    // So we copy the file, a buffer of bytes at a time.\n    // Stream to read from source\n    FileInputStream from = null;\n    // Stream to write to destination\n    FileOutputStream to = null;\n    try {\n        // Create input stream\n        from = new FileInputStream(from_file);\n        // Create output stream\n        to = new FileOutputStream(to_file);\n        // To hold file contents\n        byte[] buffer = new byte[4096];\n        // How many bytes in buffer\n        int bytes_read;\n        // while loop.  This is a common I/O programming idiom.\n        while (// Read until EOF\n        (bytes_read = from.read(buffer)) != -1) // write\n        to.write(buffer, 0, bytes_read);\n    } finally // Always close the streams, even if exceptions were thrown\n    {\n        if (from != null)\n            try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n        if (to != null)\n            try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n    }\n}\n             // Read a chunk of bytes into the buffer, then write them out,\n\n             // looping until we reach the end of the file (when read() returns\n\n             // -1).  Note the combination of assignment and comparison in this\n\n","name":"copy","className":"FileCopy","variables":{"parent":7,"to_name":2,"in":2,"e":2,"to_file":9,"bytes_read":2,"from_name":4,"dir":4,"System":1,"response":3,"from_file":6,"from":5,"to":5,"buffer":1},"constants":{"4096":1,"\"destination directory doesn't exist: \"":1,"\"destination is not a directory: \"":1,"\"destination file is unwriteable: \"":1,"\"no such source file: \"":1,"\"? (Y/N): \"":1,"\"existing file was not overwritten.\"":1,"\"Y\"":1,"\"y\"":1,"\"can't copy directory: \"":1,"0":1,"1":1,"\"user.dir\"":1,"null":5,"\"Overwrite existing file \"":1,"\"source file is unreadable: \"":1,"\"destination directory is unwriteable: \"":1},"javaDoc":"The static method that actually performs the file copy Before copying the file however it performs a lot of tests to make sure everything is as it should be","comments":"If the destination is a directory use the source file name If the destination exists make sure it is a writeable file and ask before overwriting it If the destination doesn't If we've gotten this far then everything is okay So we copy the file a buffer of bytes at a time Get File objects from Strings First make sure the source file exists is a file and is readable as the destination file name exist make sure the directory exists and is writeable Ask whether to overwrite it Get the user's response Check the response If not a Yes abort the copy If file doesn't exist check if directory exists and is writeable If getParent() returns null then the directory is the current dir so look up the user dir system property to find out what that is The destination directory If none use the current directory Convert it to a file Stream to read from source Stream to write to destination Read a chunk of bytes into the buffer then write them out looping until we reach the end of the file (when read() returns -1) Note the combination of assignment and comparison in this Create input stream Create output stream To hold file contents How many bytes in buffer while loop This is a common I/O programming idiom Read until EOF write Always close the streams even if exceptions were thrown \n     * The static method that actually performs the file copy.\n     * Before copying the file, however, it performs a lot of tests to make\n     * sure everything is as it should be.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":1},"statements":{"ThrowStmt":1},"text":"/** A convenience method to throw an exception */\nprivate static void abort(String msg) throws IOException {\n    throw new IOException(\"FileCopy: \" + msg);\n}\n","name":"abort","className":"FileCopy","variables":{"msg":1},"constants":{"\"FileCopy: \"":1},"javaDoc":"A convenience method to throw an exception","comments":" A convenience method to throw an exception ","isEmpty":false,"hasInnerClass":false,"modifier":10}
{"paramTypes":["Reader"],"returnType":"RemoveHTMLReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** A trivial constructor.  Just initialize our superclass */\npublic RemoveHTMLReader(Reader in) {\n    super(in);\n}\n","name":"RemoveHTMLReader","className":"RemoveHTMLReader","variables":{"in":1},"constants":{},"javaDoc":"A trivial constructor Just initialize our superclass","comments":" A trivial constructor.  Just initialize our superclass ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"int","methodCalls":{"read":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":4,"BinaryExpr":7,"BooleanLiteralExpr":2,"NameExpr":30,"CharLiteralExpr":2,"UnaryExpr":5,"AssignExpr":5,"MethodCallExpr":1},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":3,"ReturnStmt":2,"ForStmt":1,"ExpressionStmt":7},"text":"/** \n     * This is the implementation of the no-op read() method of FilterReader.\n     * It calls in.read() to get a buffer full of characters, then strips\n     * out the HTML tags.  (in is a protected field of the superclass).\n     **/\npublic int read(char[] buf, int from, int len) throws IOException {\n    // how many characters have been read\n    int numchars = 0;\n    // all out, leaving us with zero characters to return.\n    while (numchars == 0) {\n        // Read characters\n        numchars = in.read(buf, from, len);\n        // Check for EOF and handle it.\n        if (numchars == -1)\n            return -1;\n        // Loop through the characters we read, stripping out HTML tags.\n        // Characters not in tags are copied over previous tags \n        // Index of last non-HTML char\n        int last = from;\n        for (int i = from; i < from + numchars; i++) {\n            if (!intag) {\n                // If not in an HTML tag\n                if (// check for tag start\n                buf[i] == '<')\n                    // check for tag start\n                    intag = true;\n                else\n                    // and copy the character\n                    buf[last++] = buf[i];\n            } else // check for end of tag\n         // Loop, because we might read a bunch of characters, then strip them\n\n            if (buf[i] == '>')\n                intag = false;\n        }\n        // Figure out how many characters remain\n        numchars = last - from;\n    }\n    // Then return that number.\n    return numchars;\n}\n                                     // And if it is more than zero characters\n\n","name":"read","className":"RemoveHTMLReader","variables":{"buf":4,"last":3,"in":1,"numchars":7,"i":6,"from":4,"intag":3},"constants":{"0":2,"'>'":1,"1":2,"'<'":1,"true":1,"false":1},"javaDoc":"This is the implementation of the no-op read() method of FilterReader It calls in read() to get a buffer full of characters then strips out the HTML tags (in is a protected field of the superclass)","comments":"Loop because we might read a bunch of characters then strip them And if it is more than zero characters how many characters have been read all out leaving us with zero characters to return Loop through the characters we read stripping out HTML tags Characters not in tags are copied over previous tags Read characters Check for EOF and handle it Index of last non-HTML char If not in an HTML tag check for tag start check for tag start and copy the character check for end of tag Figure out how many characters remain Then return that number  \n     * This is the implementation of the no-op read() method of FilterReader.\n     * It calls in.read() to get a buffer full of characters, then strips\n     * out the HTML tags.  (in is a protected field of the superclass).\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{"read":1},"annotations":[],"exceptions":["IOException"],"concepts":["Recursion"],"types":{"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":5,"CastExpr":1,"ArrayCreationExpr":1,"UnaryExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** \n     * This is another no-op read() method we have to implement.  We \n     * implement it in terms of the method above.  Our superclass implements\n     * the remaining read() methods in terms of these two.\n     **/\npublic int read() throws IOException {\n    char[] buf = new char[1];\n    int result = read(buf, 0, 1);\n    if (result == -1)\n        return -1;\n    else\n        return (int) buf[0];\n}\n","name":"read","className":"RemoveHTMLReader","variables":{"result":2,"buf":2},"constants":{"0":2,"1":4},"javaDoc":"This is another no-op read() method we have to implement We implement it in terms of the method above Our superclass implements the remaining read() methods in terms of these two","comments":" \n     * This is another no-op read() method we have to implement.  We \n     * implement it in terms of the method above.  Our superclass implements\n     * the remaining read() methods in terms of these two.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.err.println":2,"close":1,"System.out.println":1},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"BufferedReader":1,"String":1},"expressions":{"IntegerLiteralExpr":2,"ObjectCreationExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":28,"StringLiteralExpr":3,"FieldAccessExpr":4,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":6},"text":"/** The test program: read a text file, strip HTML, print to console */\npublic static void main(String[] args) {\n    try {\n        if (args.length != 1)\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        // Create a stream to read from the file and strip tags from it\n        BufferedReader in = new BufferedReader(new RemoveHTMLReader(new FileReader(args[0])));\n        // Read line by line, printing lines to the console\n        String line;\n        while ((line = in.readLine()) != null) System.out.println(line);\n        // Close the stream.\n        in.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java RemoveHTMLReader$Test\" + \" <filename>\");\n    }\n}\n","name":"main","className":"Test","variables":{"args":1,"in":3,"e":1,"line":2},"constants":{"0":1,"1":1,"null":1,"\" <filename>\"":1,"\"Wrong number of args\"":1,"\"Usage: java RemoveHTMLReader$Test\"":1},"javaDoc":"The test program: read a text file strip HTML print to console","comments":"Create a stream to read from the file and strip tags from it Read line by line printing lines to the console Close the stream  The test program: read a text file, strip HTML, print to console ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"FileViewer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Convenience constructor: file viewer starts out blank */\npublic FileViewer() {\n    this(null, null);\n}\n","name":"FileViewer","className":"FileViewer","variables":{},"constants":{"null":2},"javaDoc":"Convenience constructor: file viewer starts out blank","comments":" Convenience constructor: file viewer starts out blank ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"FileViewer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** Convenience constructor: display file from current directory */\npublic FileViewer(String filename) {\n    this(null, filename);\n}\n","name":"FileViewer","className":"FileViewer","variables":{"filename":1},"constants":{"null":1},"javaDoc":"Convenience constructor: display file from current directory","comments":" Convenience constructor: display file from current directory ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"dispose":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    dispose();\n}\n","name":"windowClosing","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FileViewer","methodCalls":{"add":2,"addWindowListener":1,"getParent":1,"setEditable":1,"getName":1,"getProperty":1,"setFile":1,"addActionListener":2,"setActionCommand":2,"dispose":1,"setFont":3,"setLayout":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Panel":1,"Button":2,"File":1,"Font":1},"expressions":{"ObjectCreationExpr":9,"IntegerLiteralExpr":6,"VariableDeclarationExpr":5,"BinaryExpr":3,"NameExpr":86,"StringLiteralExpr":10,"AssignExpr":6,"NullLiteralExpr":2,"BooleanLiteralExpr":1,"FieldAccessExpr":4,"EnclosedExpr":2,"ThisExpr":6,"MethodCallExpr":21},"statements":{"IfStmt":2,"BlockStmt":3,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":27},"text":"/**\n     * The real constructor.  Create a FileViewer object to display the\n     * specified file from the specified directory \n     **/\npublic FileViewer(String directory, String filename) {\n    // Create the frame\n    super();\n    // Destroy the window when the user requests it\n    addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            dispose();\n        }\n    });\n    // Create a TextArea to display the contents of the file in\n    textarea = new TextArea(\"\", 24, 80);\n    textarea.setFont(new Font(\"MonoSpaced\", Font.PLAIN, 12));\n    textarea.setEditable(false);\n    this.add(\"Center\", textarea);\n    // Create a bottom panel to hold a couple of buttons in\n    Panel p = new Panel();\n    p.setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 5));\n    this.add(p, \"South\");\n    // Create the buttons and arrange to handle button clicks\n    Font font = new Font(\"SansSerif\", Font.BOLD, 14);\n    Button openfile = new Button(\"Open File\");\n    Button close = new Button(\"Close\");\n    openfile.addActionListener(this);\n    openfile.setActionCommand(\"open\");\n    openfile.setFont(font);\n    close.addActionListener(this);\n    close.setActionCommand(\"close\");\n    close.setFont(font);\n    p.add(openfile);\n    p.add(close);\n    this.pack();\n    // Figure out the directory, from filename or current dir, if necessary\n    if (directory == null) {\n        File f;\n        if ((filename != null) && (f = new File(filename)).isAbsolute()) {\n            directory = f.getParent();\n            filename = f.getName();\n        } else\n            directory = System.getProperty(\"user.dir\");\n    }\n    // Remember the directory, for FileDialog\n    this.directory = directory;\n    // Now load and display the file\n    setFile(directory, filename);\n}\n","name":"FileViewer","className":"FileViewer","variables":{"p":4,"filename":3,"e":1,"windowClosing":1,"openfile":4,"f":4,"textarea":3,"close":4,"directory":4,"System":1,"font":1},"constants":{"\"\"":1,"12":1,"24":1,"\"Close\"":1,"14":1,"\"open\"":1,"\"close\"":1,"false":1,"\"SansSerif\"":1,"\"Center\"":1,"\"MonoSpaced\"":1,"\"user.dir\"":1,"null":2,"5":1,"\"Open File\"":1,"80":1,"\"South\"":1,"10":1},"javaDoc":"The real constructor Create a FileViewer object to display the specified file from the specified directory","comments":"Create the frame Destroy the window when the user requests it Create a TextArea to display the contents of the file in Create a bottom panel to hold a couple of buttons in Create the buttons and arrange to handle button clicks Figure out the directory from filename or current dir if necessary Remember the directory for FileDialog Now load and display the file \n     * The real constructor.  Create a FileViewer object to display the\n     * specified file from the specified directory \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"getClass":1,"read":1,"getName":1,"length":1,"getMessage":1,"setCaretPosition":1,"close":1,"append":1,"setText":2},"annotations":[],"exceptions":["IOException"],"concepts":["ExceptionHandling"],"types":{"FileReader":1,"String":1,"File":1,"int":1,"char[]":1},"expressions":{"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":5,"BinaryExpr":10,"NameExpr":47,"StringLiteralExpr":5,"UnaryExpr":1,"AssignExpr":3,"NullLiteralExpr":3,"EnclosedExpr":3,"ArrayCreationExpr":1,"ThisExpr":2,"MethodCallExpr":12},"statements":{"IfStmt":2,"WhileStmt":1,"TryStmt":2,"BlockStmt":6,"ReturnStmt":1,"ExpressionStmt":14},"text":"/**\n     * Load and display the specified file from the specified directory\n     **/\npublic void setFile(String directory, String filename) {\n    if ((filename == null) || (filename.length() == 0))\n        return;\n    File f;\n    FileReader in = null;\n    // use a FileReader instead of a FileInputStream.\n    try {\n        // Create a file object\n        f = new File(directory, filename);\n        // And a char stream to read  it\n        in = new FileReader(f);\n        // Read 4K characters at a time\n        char[] buffer = new char[4096];\n        // How many chars read each time\n        int len;\n        // Clear the text area\n        textarea.setText(\"\");\n        while ((len = in.read(buffer)) != -1) {\n            // Read a batch of chars\n            // Convert to a string\n            String s = new String(buffer, 0, len);\n            // And display them\n            textarea.append(s);\n        }\n        // Set the window title\n        this.setTitle(\"FileViewer: \" + filename);\n        // Go to start of file\n        textarea.setCaretPosition(0);\n    }// Display messages if something goes wrong\n     catch (IOException e) {\n        textarea.setText(e.getClass().getName() + \": \" + e.getMessage());\n        this.setTitle(\"FileViewer: \" + filename + \": I/O Exception\");\n    } finally // Always be sure to close the input stream!\n    {\n        try {\n            if (in != null)\n                in.close();\n        } catch (IOException e) {\n        }\n    }\n}\n         // Read and display the file contents.  Since we're reading text, we\n\n","name":"setFile","className":"FileViewer","variables":{"filename":5,"s":1,"len":3,"in":5,"e":4,"f":3,"textarea":4,"buffer":2,"directory":1},"constants":{"0":3,"\"\"":1,"4096":1,"1":1,"\"FileViewer: \"":2,"null":3,"\": I/O Exception\"":1,"\": \"":1},"javaDoc":"Load and display the specified file from the specified directory","comments":"Read and display the file contents Since we're reading text we use a FileReader instead of a FileInputStream Create a file object And a char stream to read it Read 4K characters at a time How many chars read each time Clear the text area Read a batch of chars Convert to a string And display them Set the window title Go to start of file Display messages if something goes wrong Always be sure to close the input stream! \n     * Load and display the specified file from the specified directory\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setFile":1,"equals":2,"show":1,"setDirectory":1,"getDirectory":1,"dispose":1,"getActionCommand":1,"getFile":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"FileDialog":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"NameExpr":34,"StringLiteralExpr":3,"FieldAccessExpr":1,"ThisExpr":2,"MethodCallExpr":10,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":8},"text":"/**\n     * Handle button clicks\n     **/\npublic void actionPerformed(ActionEvent e) {\n    String cmd = e.getActionCommand();\n    if (cmd.equals(\"open\")) {\n        // If user clicked \"Open\" button\n        // Create a file dialog box to prompt for a new file to display\n        FileDialog f = new FileDialog(this, \"Open File\", FileDialog.LOAD);\n        // Set the default directory\n        f.setDirectory(directory);\n        // Display the dialog and wait for the user's response\n        f.show();\n        // Remember new default directory\n        directory = f.getDirectory();\n        // Load and display selection\n        setFile(directory, f.getFile());\n        // Get rid of the dialog box\n        f.dispose();\n    } else if (// If user clicked \"Close\" button\n    cmd.equals(\"close\"))\n        //    then close the window\n        this.dispose();\n}\n","name":"actionPerformed","className":"FileViewer","variables":{"e":1,"f":6,"cmd":3,"directory":1},"constants":{"\"open\"":1,"\"close\"":1,"\"Open File\"":1},"javaDoc":"Handle button clicks","comments":"If user clicked \"Open\" button Create a file dialog box to prompt for a new file to display Set the default directory Display the dialog and wait for the user's response Remember new default directory Load and display selection Get rid of the dialog box If user clicked \"Close\" button then close the window \n     * Handle button clicks\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosed(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosed","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"addWindowListener":1,"exit":1,"show":1},"annotations":[],"exceptions":["IOException"],"concepts":["InnerMethod","PolyMorphism"],"types":{"Frame":1,"FileViewer":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":15,"FieldAccessExpr":1,"ConditionalExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n     * The FileViewer can be used by other classes, or it can be\n     * used standalone with this main() method.\n     **/\npublic static void main(String[] args) throws IOException {\n    // Create a FileViewer object\n    Frame f = new FileViewer((args.length == 1) ? args[0] : null);\n    // Arrange to exit when the FileViewer window closes\n    f.addWindowListener(new WindowAdapter() {\n\n        public void windowClosed(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // And pop the window up\n    f.show();\n}\n","name":"main","className":"FileViewer","variables":{"args":1,"windowClosed":1,"e":1,"f":3,"System":1},"constants":{"0":2,"1":1,"null":1},"javaDoc":"The FileViewer can be used by other classes or it can be used standalone with this main() method","comments":"Create a FileViewer object Arrange to exit when the FileViewer window closes And pop the window up \n     * The FileViewer can be used by other classes, or it can be\n     * used standalone with this main() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Applet","int","int"],"returnType":"HTMLWriter","methodCalls":{"call":1,"eval":1,"forName":1,"getWindow":1,"getMember":1},"annotations":[],"exceptions":["NoClassDefFoundError","ClassNotFoundException"],"concepts":["ExceptionHandling"],"types":{"Class":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":11,"NameExpr":22,"StringLiteralExpr":13,"CastExpr":2,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":5},"text":"/**\n     * When you create a new HTMLWriter, it pops up a new, blank, Web browser\n     * window to display the output in.  You must specify the applet\n     * (this specifies the main browser window) and the desired size\n     * for the new window.\n     **/\npublic HTMLWriter(Applet applet, int width, int height) {\n    // Verify that we can find the JSObject class we need.  Warn if not.\n    try {\n        Class c = Class.forName(\"netscape.javascript.JSObject\");\n    } catch (ClassNotFoundException e) {\n        throw new NoClassDefFoundError(\"HTMLWriter requires \" + \"Netscape Navigator 4.0 or higher \" + \"or a browser that supports LiveConnect technology\");\n    }\n    // Get a reference to the main browser window from the applet.\n    main_window = JSObject.getWindow(applet);\n    // Create a new window to display output in.  This command sends a\n    // string of JavaScript to the web browser\n    window = (JSObject) main_window.eval(\"self.open('',\" + \"'HTMLWriter\" + window_num++ + \"',\" + \"'menubar,status,resizable,scrollbars,\" + \"width=\" + width + \",height=\" + height + \"')\");\n    // Obtain the Document object of this new window, and open it.\n    document = (JSObject) window.getMember(\"document\");\n    document.call(\"open\", null);\n}\n","name":"HTMLWriter","className":"HTMLWriter","variables":{"c":1,"main_window":2,"e":1,"document":2,"width":1,"JSObject":1,"Class":1,"window":2,"window_num":1,"height":1},"constants":{"\"netscape.javascript.JSObject\"":1,"\"'menubar,status,resizable,scrollbars,\"":1,"\"open\"":1,"\"HTMLWriter requires \"":1,"\"'HTMLWriter\"":1,"\"',\"":1,"\",height=\"":1,"\"self.open('',\"":1,"\"')\"":1,"\"Netscape Navigator 4.0 or higher \"":1,"null":1,"\"width=\"":1,"\"document\"":1,"\"or a browser that supports LiveConnect technology\"":1},"javaDoc":"When you create a new HTMLWriter it pops up a new blank Web browser window to display the output in You must specify the applet (this specifies the main browser window) and the desired size for the new window","comments":"Create a new window to display output in This command sends a Verify that we can find the JSObject class we need Warn if not Get a reference to the main browser window from the applet string of JavaScript to the web browser Obtain the Document object of this new window and open it \n     * When you create a new HTMLWriter, it pops up a new, blank, Web browser\n     * window to display the output in.  You must specify the applet\n     * (this specifies the main browser window) and the desired size\n     * for the new window.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["char[]","int","int"],"returnType":"void","methodCalls":{"call":1,"getMember":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":2,"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"ArrayInitializerExpr":1,"BinaryExpr":3,"NameExpr":14,"CastExpr":1,"StringLiteralExpr":2,"EnclosedExpr":3,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":2},"text":"/**\n     * This is the write() method required for all Writer subclasses.\n     * Writer defines all its other write() methods in terms of this one.\n     **/\npublic void write(char[] buf, int offset, int length) {\n    // has been closed, or if the code is not running in Navigator.\n    if ((window == null) || (document == null))\n        return;\n    // If the window has been closed by the user, do nothing\n    if (((Boolean) window.getMember(\"closed\")).booleanValue())\n        return;\n    // Otherwise, create a string from the specified bytes\n    String s = new String(buf, offset, length);\n    // And pass it to the JS document.write() method to output the HTML\n    document.call(\"write\", new String[] { s });\n}\n         // If no window or document, do nothing.   This occurs if the stream\n\n","name":"write","className":"HTMLWriter","variables":{"buf":1,"s":2,"offset":1,"document":2,"length":1,"window":2},"constants":{"null":2,"\"write\"":1,"\"closed\"":1},"javaDoc":"This is the write() method required for all Writer subclasses Writer defines all its other write() methods in terms of this one","comments":"If no window or document do nothing This occurs if the stream has been closed or if the code is not running in Navigator If the window has been closed by the user do nothing Otherwise create a string from the specified bytes And pass it to the JS document write() method to output the HTML \n     * This is the write() method required for all Writer subclasses.\n     * Writer defines all its other write() methods in terms of this one.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * There is no general way to force JavaScript to flush all pending output,\n     * so this method does nothing.  To flush, output a <P> tag or some other\n     * HTML tag that forces a line break in the output.\n     **/\npublic void flush() {\n}\n","name":"flush","className":"HTMLWriter","variables":{},"constants":{},"javaDoc":"There is no general way to force JavaScript to flush all pending output so this method does nothing To flush output a <P> tag or some other HTML tag that forces a line break in the output","comments":"\n     * There is no general way to force JavaScript to flush all pending output,\n     * so this method does nothing.  To flush, output a <P> tag or some other\n     * HTML tag that forces a line break in the output.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"call":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":2,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n     * When the stream is closed, close the JavaScript Document object\n     * (But don't close the window yet.)\n     **/\npublic void close() {\n    document.call(\"close\", null);\n    document = null;\n}\n","name":"close","className":"HTMLWriter","variables":{"document":2},"constants":{"null":2,"\"close\"":1},"javaDoc":"When the stream is closed close the JavaScript Document object (But don't close the window yet )","comments":"\n     * When the stream is closed, close the JavaScript Document object\n     * (But don't close the window yet.)\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"call":1,"getMember":1,"close":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":3,"BinaryExpr":1,"NameExpr":12,"CastExpr":1,"StringLiteralExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":2,"ExpressionStmt":3},"text":"/**\n     * If the browser window is still open, close it.\n     * This method is unique to HTMLWriter.  \n     **/\npublic void closeWindow() {\n    if (document != null)\n        close();\n    if (!((Boolean) window.getMember(\"closed\")).booleanValue())\n        window.call(\"close\", null);\n    window = null;\n}\n","name":"closeWindow","className":"HTMLWriter","variables":{"document":1,"window":3},"constants":{"null":3,"\"close\"":1,"\"closed\"":1},"javaDoc":"If the browser window is still open close it This method is unique to HTMLWriter","comments":"\n     * If the browser window is still open, close it.\n     * This method is unique to HTMLWriter.  \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"closeWindow":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** A finalizer method to close the window in case we forget. */\npublic void finalize() {\n    closeWindow();\n}\n","name":"finalize","className":"HTMLWriter","variables":{},"constants":{},"javaDoc":"A finalizer method to close the window in case we forget","comments":" A finalizer method to close the window in case we forget. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"read":1,"openStream":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"InputStreamReader":1,"Reader":1,"URL":1,"int":1,"char[]":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":5,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":24,"StringLiteralExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":7,"AssignExpr":2},"statements":{"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ExpressionStmt":8},"text":"/** When the applet starts, read and display specified URL */\npublic void init() {\n    try {\n        // Get the URL specified in the <PARAM> tag\n        URL url = new URL(this.getDocumentBase(), this.getParameter(\"url\"));\n        // Get a stream to read its contents\n        Reader in = new InputStreamReader(url.openStream());\n        // Create an HTMLWriter stream for out output\n        out = new HTMLWriter(this, 400, 200);\n        // Read buffers of characters and output them to the HTMLWriter\n        char[] buffer = new char[4096];\n        int numchars;\n        while ((numchars = in.read(buffer)) != -1) out.write(buffer, 0, numchars);\n        // Close the streams\n        in.close();\n        out.close();\n    } catch (IOException e) {\n    }\n}\n","name":"init","className":"Test","variables":{"in":3,"e":1,"numchars":2,"buffer":1,"url":2,"out":3},"constants":{"0":1,"4096":1,"1":1,"200":1,"\"url\"":1,"400":1},"javaDoc":"When the applet starts read and display specified URL","comments":"Get the URL specified in the <PARAM> tag Get a stream to read its contents Create an HTMLWriter stream for out output Read buffers of characters and output them to the HTMLWriter Close the streams  When the applet starts, read and display specified URL ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"closeWindow":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** When the applet terminates, close the window we created */\npublic void destroy() {\n    out.closeWindow();\n}\n","name":"destroy","className":"Test","variables":{"out":1},"constants":{},"javaDoc":"When the applet terminates close the window we created","comments":" When the applet terminates, close the window we created ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Reader","String"],"returnType":"GrepReader","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/** Pass the stream to our superclass, and remember the pattern ourself */\npublic GrepReader(Reader in, String pattern) {\n    super(in);\n    this.pattern = pattern;\n}\n","name":"GrepReader","className":"GrepReader","variables":{"in":1,"pattern":1},"constants":{},"javaDoc":"Pass the stream to our superclass and remember the pattern ourself","comments":" Pass the stream to our superclass, and remember the pattern ourself ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"indexOf":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"SuperExpr":1,"BinaryExpr":3,"NameExpr":9,"EnclosedExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":2,"DoStmt":1},"text":"/**\n     * This is the filter: call our superclass's readLine() to get the\n     * actual lines, but only return lines that contain the pattern.\n     * When the superclass readLine() returns null (EOF), we return null.\n     **/\npublic final String readLine() throws IOException {\n    String line;\n    do {\n        line = super.readLine();\n    } while ((line != null) && line.indexOf(pattern) == -1);\n    return line;\n}\n","name":"readLine","className":"GrepReader","variables":{"line":5},"constants":{"1":1,"null":1},"javaDoc":"This is the filter: call our superclass's readLine() to get the actual lines but only return lines that contain the pattern When the superclass readLine() returns null (EOF) we return null","comments":"\n     * This is the filter: call our superclass's readLine() to get the\n     * actual lines, but only return lines that contain the pattern.\n     * When the superclass readLine() returns null (EOF), we return null.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":17}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"readLine":1,"System.err.println":1,"close":1,"System.out.println":2},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"GrepReader":1,"String":1},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":3,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":2,"BinaryExpr":3,"NameExpr":29,"StringLiteralExpr":3,"FieldAccessExpr":4,"EnclosedExpr":1,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"WhileStmt":1,"TryStmt":1,"BlockStmt":2,"ThrowStmt":1,"ExpressionStmt":6},"text":"public static void main(String args[]) {\n    try {\n        if (args.length != 2)\n            throw new IllegalArgumentException(\"Wrong number of args\");\n        GrepReader in = new GrepReader(new FileReader(args[1]), args[0]);\n        String line;\n        while ((line = in.readLine()) != null) System.out.println(line);\n        in.close();\n    } catch (Exception e) {\n        System.err.println(e);\n        System.out.println(\"Usage: java GrepReader$Test\" + \" <pattern> <file>\");\n    }\n}\n","name":"main","className":"Test","variables":{"args":2,"in":3,"e":1,"line":2},"constants":{"0":1,"1":1,"2":1,"null":1,"\"Wrong number of args\"":1,"\" <pattern> <file>\"":1,"\"Usage: java GrepReader$Test\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"read":1,"write":1,"close":2},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"byte[]":1,"GZIPOutputStream":1,"FileInputStream":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":18,"EnclosedExpr":1,"ArrayCreationExpr":1,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"ExpressionStmt":7},"text":"/** Gzip the contents of the from file and save in the to file. */\npublic static void gzipFile(String from, String to) throws IOException {\n    // Create stream to read from the from file\n    FileInputStream in = new FileInputStream(from);\n    // Create stream to compress data and write it to the to file.\n    GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(to));\n    // Copy bytes from one stream to the other\n    byte[] buffer = new byte[4096];\n    int bytes_read;\n    while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n    // And close the streams\n    in.close();\n    out.close();\n}\n","name":"gzipFile","className":"Compress","variables":{"in":3,"from":1,"bytes_read":2,"to":1,"buffer":1,"out":3},"constants":{"0":1,"4096":1,"1":1},"javaDoc":"Gzip the contents of the from file and save in the to file","comments":"Create stream to read from the from file Create stream to compress data and write it to the to file Copy bytes from one stream to the other And close the streams  Gzip the contents of the from file and save in the to file. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"putNextEntry":1,"read":1,"getPath":1,"list":1,"write":1,"close":2,"isDirectory":2},"annotations":[],"exceptions":["IOException","IllegalArgumentException"],"concepts":[],"types":{"byte[]":1,"ZipOutputStream":1,"ZipEntry":1,"String[]":1,"File":2,"int":2,"FileInputStream":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":4,"VariableDeclarationExpr":9,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":44,"StringLiteralExpr":1,"UnaryExpr":3,"AssignExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":9},"statements":{"ContinueStmt":1,"IfStmt":2,"WhileStmt":1,"BlockStmt":1,"ThrowStmt":1,"ForStmt":1,"ExpressionStmt":12},"text":"/** Zip the contents of the directory, and save it in the zipfile */\npublic static void zipDirectory(String dir, String zipfile) throws IOException, IllegalArgumentException {\n    // Check that the directory is a directory, and get its contents\n    File d = new File(dir);\n    if (!d.isDirectory())\n        throw new IllegalArgumentException(\"Compress: not a directory:  \" + dir);\n    String[] entries = d.list();\n    // Create a buffer for copying \n    byte[] buffer = new byte[4096];\n    int bytes_read;\n    // Create a stream to compress data and write it to the zipfile\n    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile));\n    // Loop through all entries in the directory\n    for (int i = 0; i < entries.length; i++) {\n        File f = new File(d, entries[i]);\n        // Don't zip sub-directories\n        if (f.isDirectory())\n            continue;\n        // Stream to read file\n        FileInputStream in = new FileInputStream(f);\n        // Make a ZipEntry\n        ZipEntry entry = new ZipEntry(f.getPath());\n        // Store entry\n        out.putNextEntry(entry);\n        while (// Copy bytes\n        (bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);\n        // Close input stream\n        in.close();\n    }\n    // When we're done with the whole loop, close the output stream\n    out.close();\n}\n","name":"zipDirectory","className":"Compress","variables":{"entry":1,"entries":2,"zipfile":1,"d":4,"in":3,"f":4,"i":4,"bytes_read":2,"buffer":1,"dir":2,"out":4},"constants":{"0":2,"4096":1,"1":1,"\"Compress: not a directory:  \"":1},"javaDoc":"Zip the contents of the directory and save it in the zipfile","comments":"Check that the directory is a directory and get its contents Create a buffer for copying Create a stream to compress data and write it to the zipfile Loop through all entries in the directory Don't zip sub-directories Stream to read file Make a ZipEntry Store entry Copy bytes Close input stream When we're done with the whole loop close the output stream  Zip the contents of the directory, and save it in the zipfile ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"exit":2,"zipDirectory":1,"System.err.println":2,"isDirectory":1,"gzipFile":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"boolean":1,"String":1,"File":1},"expressions":{"IntegerLiteralExpr":7,"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"ArrayAccessExpr":2,"BinaryExpr":7,"NameExpr":52,"StringLiteralExpr":4,"FieldAccessExpr":5,"EnclosedExpr":3,"MethodCallExpr":8,"AssignExpr":3},"statements":{"IfStmt":5,"BlockStmt":3,"ExpressionStmt":12},"text":"/**\n\t * Compress a specified file or directory.  If no destination name is\n\t * specified, append .gz to a file name or .zip to a directory name\n\t **/\npublic static void main(String args[]) throws IOException {\n    if ((args.length != 1) && (args.length != 2)) {\n        // check arguments\n        System.err.println(\"Usage: java Compress$Test <from> [<to>]\");\n        System.exit(0);\n    }\n    String from = args[0], to;\n    File f = new File(from);\n    // Is it a file or directory?\n    boolean directory = f.isDirectory();\n    if (args.length == 2)\n        to = args[1];\n    else {\n        // If destination not specified\n        if (//   use a .zip suffix\n        directory)\n            //   use a .zip suffix\n            to = from + \".zip\";\n        else\n            //   or a .gz suffix\n            to = from + \".gz\";\n    }\n    if ((new File(to)).exists()) {\n        // Make sure not to overwrite\n        System.err.println(\"Compress: won't overwrite existing file: \" + to);\n        System.exit(0);\n    }\n    // Finally, call one of the methods defined above to do the work.\n    if (directory)\n        Compress.zipDirectory(from, to);\n    else\n        Compress.gzipFile(from, to);\n}\n","name":"main","className":"Test","variables":{"args":2,"Compress":2,"f":2,"from":4,"to":6,"directory":3,"System":2},"constants":{"0":3,"1":2,"2":2,"\"Usage: java Compress$Test <from> [<to>]\"":1,"\"Compress: won't overwrite existing file: \"":1,"\".gz\"":1,"\".zip\"":1},"javaDoc":"Compress a specified file or directory If no destination name is specified append gz to a file name or zip to a directory name","comments":"check arguments Is it a file or directory? If destination not specified use a zip suffix use a zip suffix or a gz suffix Make sure not to overwrite Finally call one of the methods defined above to do the work \n\t * Compress a specified file or directory.  If no destination name is\n\t * specified, append .gz to a file name or .zip to a directory name\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// This method displays the applet.\npublic void paint(Graphics g) {\n    g.drawString(\"Hello World\", 25, 50);\n}\n","name":"paint","className":"FirstApplet","variables":{"g":1},"constants":{"\"Hello World\"":1,"25":1,"50":1},"javaDoc":"","comments":" This method displays the applet.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getRectangleParameter":1,"addElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1,"ImagemapRectangle":1},"expressions":{"ObjectCreationExpr":1,"NullLiteralExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":2,"NameExpr":26,"StringLiteralExpr":3,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":8,"AssignExpr":4,"MethodCallExpr":9},"statements":{"ForStmt":1,"ExpressionStmt":6},"text":"/** Initialize the applet */\npublic void init() {\n    // Look up the name of the image, relative to a base URL, and load it.\n    // Note the use of three Applet methods in this one line.\n    image = this.getImage(this.getDocumentBase(), this.getParameter(\"image\"));\n    // Lookup and parse a list of rectangular areas and their URLs.\n    // The convenience routine getRectangleParameter() is defined below.\n    rects = new Vector();\n    ImagemapRectangle r;\n    for (int i = 0; (r = getRectangleParameter(\"rect\" + i)) != null; i++) rects.addElement(r);\n    // Look up a sound to play when the user clicks one of those areas.\n    sound = this.getAudioClip(this.getDocumentBase(), this.getParameter(\"sound\"));\n    // Specify an \"event listener\" object to respond to mouse button\n    // presses and releases.  Note that this is the Java 1.1 event model.\n    this.addMouseListener(this);\n}\n","name":"init","className":"Soundmap","variables":{"image":1,"r":2,"sound":1,"i":3,"rects":2},"constants":{"0":1,"\"sound\"":1,"null":1,"\"rect\"":1,"\"image\"":1},"javaDoc":"Initialize the applet","comments":"Look up the name of the image relative to a base URL and load it Lookup and parse a list of rectangular areas and their URLs Specify an \"event listener\" object to respond to mouse button Note the use of three Applet methods in this one line The convenience routine getRectangleParameter() is defined below Look up a sound to play when the user clicks one of those areas presses and releases Note that this is the Java 1 1 event model  Initialize the applet ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"flush":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Called when the applet is being unloaded from the system.\n     * We use it here to \"flush\" the image we no longer need. This may\n     * result in memory and other resources being freed more quickly.\n     **/\npublic void destroy() {\n    image.flush();\n}\n","name":"destroy","className":"Soundmap","variables":{"image":1},"constants":{},"javaDoc":"Called when the applet is being unloaded from the system We use it here to \"flush\" the image we no longer need This may result in memory and other resources being freed more quickly","comments":"\n     * Called when the applet is being unloaded from the system.\n     * We use it here to \"flush\" the image we no longer need. This may\n     * result in memory and other resources being freed more quickly.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"drawImage":1,"setColor":1,"drawRect":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":6,"NullLiteralExpr":1,"BinaryExpr":5,"NameExpr":41,"FieldAccessExpr":9,"ThisExpr":1,"MethodCallExpr":4},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":4},"text":"/**\n     * To display the applet, we simply draw the image, and highlight the\n     * current rectangle if any.\n     **/\npublic void paint(Graphics g) {\n    g.drawImage(image, 0, 0, this);\n    if (highlight != null) {\n        g.setColor(Color.red);\n        g.drawRect(highlight.x, highlight.y, highlight.width, highlight.height);\n        g.drawRect(highlight.x + 1, highlight.y + 1, highlight.width - 2, highlight.height - 2);\n    }\n}\n","name":"paint","className":"Soundmap","variables":{"highlight":1,"g":4},"constants":{"0":2,"1":2,"2":2,"null":1},"javaDoc":"To display the applet we simply draw the image and highlight the current rectangle if any","comments":"\n     * To display the applet, we simply draw the image, and highlight the\n     * current rectangle if any.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"paint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * We override this method so that it doesn't clear the background\n     * before calling paint().  No clear is necessary, since paint() overwrites\n     * everything with an image.  Causes less flickering this way.\n     **/\npublic void update(Graphics g) {\n    paint(g);\n}\n","name":"update","className":"Soundmap","variables":{},"constants":{},"javaDoc":"We override this method so that it doesn't clear the background before calling paint() No clear is necessary since paint() overwrites everything with an image Causes less flickering this way","comments":"\n     * We override this method so that it doesn't clear the background\n     * before calling paint().  No clear is necessary, since paint() overwrites\n     * everything with an image.  Causes less flickering this way.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"ImagemapRectangle","methodCalls":{"parseInt":4,"nextToken":5},"annotations":[],"exceptions":["MalformedURLException","NumberFormatException","NoSuchElementException"],"concepts":["ExceptionHandling"],"types":{"StringTokenizer":1,"String":1,"int":1,"URL":1},"expressions":{"NullLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":44,"StringLiteralExpr":1,"ThisExpr":2,"MethodCallExpr":11,"AssignExpr":5},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":4,"ReturnStmt":5,"ExpressionStmt":9},"text":"/**\n     * Parse a comma-separated list of rectangle coordinates and a URL.\n     * Used to read the imagemap rectangle definitions from applet parameters\n     **/\nprotected ImagemapRectangle getRectangleParameter(String name) {\n    int x, y, w, h;\n    URL url;\n    String value = this.getParameter(name);\n    if (value == null)\n        return null;\n    try {\n        StringTokenizer st = new StringTokenizer(value, \",\");\n        x = Integer.parseInt(st.nextToken());\n        y = Integer.parseInt(st.nextToken());\n        w = Integer.parseInt(st.nextToken());\n        h = Integer.parseInt(st.nextToken());\n        url = new URL(this.getDocumentBase(), st.nextToken());\n    } catch (NoSuchElementException e) {\n        return null;\n    } catch (NumberFormatException e) {\n        return null;\n    } catch (MalformedURLException e) {\n        return null;\n    }\n    return new ImagemapRectangle(x, y, w, h, url);\n}\n","name":"getRectangleParameter","className":"Soundmap","variables":{"Integer":4,"st":6,"e":3,"w":3,"x":3,"h":3,"y":3,"value":3,"url":3},"constants":{"null":5,"\",\"":1},"javaDoc":"Parse a comma-separated list of rectangle coordinates and a URL Used to read the imagemap rectangle definitions from applet parameters","comments":"\n     * Parse a comma-separated list of rectangle coordinates and a URL.\n     * Used to read the imagemap rectangle definitions from applet parameters\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"play":1,"showStatus":1,"findrect":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ImagemapRectangle":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":4,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":5},"text":"/** Called when a mouse button is pressed. */\npublic void mousePressed(MouseEvent e) {\n    // On button down, check if we're inside one of the rectangles.\n    // If so, highlight the rectangle, display a message, and play a sound.\n    // The utility routine findrect() is defined below.\n    ImagemapRectangle r = findrect(e);\n    // If a rectangle is found, and is not already highlighted\n    if (r != null && r != highlight) {\n        // Remember which rectangle it is\n        highlight = r;\n        // display its URL in status line\n        showStatus(\"To: \" + r.url);\n        // play the sound\n        sound.play();\n        // request a redraw to highlight it\n        repaint();\n    }\n}\n","name":"mousePressed","className":"Soundmap","variables":{"highlight":2,"r":4,"sound":1},"constants":{"null":1,"\"To: \"":1},"javaDoc":"Called when a mouse button is pressed","comments":"On button down check if we're inside one of the rectangles If so highlight the rectangle display a message and play a sound The utility routine findrect() is defined below If a rectangle is found and is not already highlighted Remember which rectangle it is display its URL in status line play the sound request a redraw to highlight it  Called when a mouse button is pressed. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getAppletContext":1,"showStatus":1,"findrect":1,"showDocument":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"ImagemapRectangle":1},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":18,"StringLiteralExpr":1,"FieldAccessExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":2,"BlockStmt":1,"ExpressionStmt":5},"text":"/** Called when a mouse button is released. */\npublic void mouseReleased(MouseEvent e) {\n    // erase the highlight and clear status\n    if (highlight != null) {\n        ImagemapRectangle r = findrect(e);\n        if (r == highlight)\n            getAppletContext().showDocument(r.url);\n        // clear the message.\n        showStatus(\"\");\n        // forget the highlight\n        highlight = null;\n        // request a redraw\n        repaint();\n    }\n}\n     // If the user releases the mouse button over a highlighted\n\n     // rectangle, tell the browser to display its URL.  Also,\n\n","name":"mouseReleased","className":"Soundmap","variables":{"highlight":3,"r":2},"constants":{"\"\"":1,"null":2},"javaDoc":"Called when a mouse button is released","comments":"If the user releases the mouse button over a highlighted rectangle tell the browser to display its URL Also erase the highlight and clear status clear the message forget the highlight request a redraw  Called when a mouse button is released. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/** Unused methods of the MouseListener interface */\npublic void mouseEntered(MouseEvent e) {\n}\n","name":"mouseEntered","className":"Soundmap","variables":{},"constants":{},"javaDoc":"Unused methods of the MouseListener interface","comments":" Unused methods of the MouseListener interface ","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent e) {\n}\n","name":"mouseExited","className":"Soundmap","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent e) {\n}\n","name":"mouseClicked","className":"Soundmap","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"ImagemapRectangle","methodCalls":{"getX":1,"contains":1,"getY":1,"size":1,"elementAt":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"int":1,"ImagemapRectangle":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":22,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":2,"ExpressionStmt":2},"text":"/** Find the rectangle we're inside. */\nprotected ImagemapRectangle findrect(MouseEvent e) {\n    int i, x = e.getX(), y = e.getY();\n    for (i = 0; i < rects.size(); i++) {\n        ImagemapRectangle r = (ImagemapRectangle) rects.elementAt(i);\n        if (r.contains(x, y))\n            return r;\n    }\n    return null;\n}\n","name":"findrect","className":"Soundmap","variables":{"r":3,"e":2,"x":1,"i":4,"y":1,"rects":2},"constants":{"0":1,"null":1},"javaDoc":"Find the rectangle we're inside","comments":" Find the rectangle we're inside. ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int","int","int","int","URL"],"returnType":"ImagemapRectangle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"public ImagemapRectangle(int x, int y, int w, int h, URL url) {\n    super(x, y, w, h);\n    this.url = url;\n}\n","name":"ImagemapRectangle","className":"ImagemapRectangle","variables":{"w":1,"x":1,"h":1,"y":1,"url":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Handle mouse events\npublic boolean mouseDown(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Down: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseDown","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"Mouse Down: [\"":1,"\"]\"":1,"\",\"":1,"true":1},"javaDoc":"","comments":" Handle mouse events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseUp(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Up: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseUp","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Up: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseDrag(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Drag: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseDrag","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Drag: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"mods":1,"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":9,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseMove(Event e, int x, int y) {\n    showLine(mods(e.modifiers) + \"Mouse Move: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseMove","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Move: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":4,"StringLiteralExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseEnter(Event e, int x, int y) {\n    showLine(\"Mouse Enter: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseEnter","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Enter: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"BooleanLiteralExpr":1,"NameExpr":4,"StringLiteralExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean mouseExit(Event e, int x, int y) {\n    showLine(\"Mouse Exit: [\" + x + \",\" + y + \"]\");\n    return true;\n}\n","name":"mouseExit","className":"EventTester","variables":{"x":1,"y":1},"constants":{"\"]\"":1,"\",\"":1,"true":1,"\"Mouse Exit: [\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"// Handle focus events\npublic boolean gotFocus(Event e, Object what) {\n    showLine(\"Got Focus\");\n    return true;\n}\n","name":"gotFocus","className":"EventTester","variables":{},"constants":{"\"Got Focus\"":1,"true":1},"javaDoc":"","comments":" Handle focus events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"showLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":2,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public boolean lostFocus(Event e, Object what) {\n    showLine(\"Lost Focus\");\n    return true;\n}\n","name":"lostFocus","className":"EventTester","variables":{},"constants":{"\"Lost Focus\"":1,"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"key_name":1,"mods":2,"function_key_name":1,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"IfStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"// Handle key down and key up events\n// This gets more confusing because there are two types of key events\npublic boolean keyDown(Event e, int key) {\n    int flags = e.modifiers;\n    if (// a regular key\n    e.id == Event.KEY_PRESS)\n        showLine(\"Key Down: \" + mods(flags) + key_name(e));\n    else if (// a function key\n    e.id == Event.KEY_ACTION)\n        showLine(\"Function Key Down: \" + mods(flags) + function_key_name(key));\n    return true;\n}\n","name":"keyDown","className":"EventTester","variables":{"flags":1},"constants":{"\"Key Down: \"":1,"true":1,"\"Function Key Down: \"":1},"javaDoc":"","comments":"a regular key a function key  This gets more confusing because there are two types of key events","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"key_name":1,"mods":2,"function_key_name":1,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":6,"BooleanLiteralExpr":1,"NameExpr":31,"StringLiteralExpr":2,"FieldAccessExpr":5,"MethodCallExpr":6},"statements":{"IfStmt":2,"ReturnStmt":1,"ExpressionStmt":3},"text":"public boolean keyUp(Event e, int key) {\n    int flags = e.modifiers;\n    if (// a regular key\n    e.id == Event.KEY_RELEASE)\n        showLine(\"Key Up: \" + mods(flags) + key_name(e));\n    else if (// a function key\n    e.id == Event.KEY_ACTION_RELEASE)\n        showLine(\"Function Key Up: \" + mods(flags) + function_key_name(key));\n    return true;\n}\n","name":"keyUp","className":"EventTester","variables":{"flags":1},"constants":{"true":1,"\"Key Up: \"":1,"\"Function Key Up: \"":1},"javaDoc":"","comments":"a regular key a function key ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":1,"BinaryExpr":9,"StringLiteralExpr":7,"NameExpr":23,"FieldAccessExpr":4,"EnclosedExpr":4,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":2,"ExpressionStmt":6},"text":"// The remaining methods help us sort out the various modifiers and keys\n// Return the current list of modifier keys\nprivate String mods(int flags) {\n    String s = \"[ \";\n    if (flags == 0)\n        return \"\";\n    if ((flags & Event.SHIFT_MASK) != 0)\n        s += \"Shift \";\n    if ((flags & Event.CTRL_MASK) != 0)\n        s += \"Control \";\n    if ((flags & Event.META_MASK) != 0)\n        s += \"Meta \";\n    if ((flags & Event.ALT_MASK) != 0)\n        s += \"Alt \";\n    s += \"] \";\n    return s;\n}\n","name":"mods","className":"EventTester","variables":{"s":7,"flags":5},"constants":{"0":5,"\"\"":1,"\"Alt \"":1,"\"Meta \"":1,"\"[ \"":1,"\"Control \"":1,"\"] \"":1,"\"Shift \"":1},"javaDoc":"","comments":" Return the current list of modifier keys","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["Event"],"returnType":"String","methodCalls":{"controlDown":1,"valueOf":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"char":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":4,"CastExpr":1,"NameExpr":16,"StringLiteralExpr":7,"FieldAccessExpr":1,"CharLiteralExpr":8,"MethodCallExpr":2,"AssignExpr":1},"statements":{"SwitchStmt":1,"IfStmt":4,"BlockStmt":3,"SwitchEntryStmt":4,"ReturnStmt":8,"ExpressionStmt":2},"text":"// Return the name of a regular (non-function) key.\nprivate String key_name(Event e) {\n    char c = (char) e.key;\n    if (e.controlDown()) {\n        // If CTRL flag is set, handle control chars.\n        if (c < ' ') {\n            c += '@';\n            return \"^\" + c;\n        }\n    } else {\n        // If CTRL flag is not set, then certain ASCII\n        switch(// control characters have special meaning.\n        c) {\n            case '\\n':\n                return \"Return\";\n            case '\\t':\n                return \"Tab\";\n            case '\\033':\n                return \"Escape\";\n            case '\\010':\n                return \"Backspace\";\n        }\n    }\n    // Handle the remaining possibilities.\n    if (c == '\\177')\n        return \"Delete\";\n    else if (c == ' ')\n        return \"Space\";\n    else\n        return String.valueOf(c);\n}\n","name":"key_name","className":"EventTester","variables":{"c":7,"e":1,"String":1},"constants":{"\"Backspace\"":1,"\"^\"":1,"\"Return\"":1,"\"Tab\"":1,"\"Escape\"":1,"' '":2,"'@'":1,"\"Space\"":1,"'\\033'":1,"'\\010'":1,"'\\t'":1,"'\\n'":1,"'\\177'":1,"\"Delete\"":1},"javaDoc":"","comments":"If CTRL flag is set handle control chars If CTRL flag is not set then certain ASCII control characters have special meaning Handle the remaining possibilities  Return the name of a regular (non-function) key.","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":61,"StringLiteralExpr":21,"FieldAccessExpr":20},"statements":{"SwitchStmt":1,"SwitchEntryStmt":20,"ReturnStmt":21},"text":"// Return the name of a function key.  Just compare the key to the\n// constants defined in the Event class.\nprivate String function_key_name(int key) {\n    switch(key) {\n        case Event.HOME:\n            return \"Home\";\n        case Event.END:\n            return \"End\";\n        case Event.PGUP:\n            return \"Page Up\";\n        case Event.PGDN:\n            return \"Page Down\";\n        case Event.UP:\n            return \"Up\";\n        case Event.DOWN:\n            return \"Down\";\n        case Event.LEFT:\n            return \"Left\";\n        case Event.RIGHT:\n            return \"Right\";\n        case Event.F1:\n            return \"F1\";\n        case Event.F2:\n            return \"F2\";\n        case Event.F3:\n            return \"F3\";\n        case Event.F4:\n            return \"F4\";\n        case Event.F5:\n            return \"F5\";\n        case Event.F6:\n            return \"F6\";\n        case Event.F7:\n            return \"F7\";\n        case Event.F8:\n            return \"F8\";\n        case Event.F9:\n            return \"F9\";\n        case Event.F10:\n            return \"F10\";\n        case Event.F11:\n            return \"F11\";\n        case Event.F12:\n            return \"F12\";\n    }\n    return \"Unknown Function Key\";\n}\n","name":"function_key_name","className":"EventTester","variables":{"key":1},"constants":{"\"F6\"":1,"\"F10\"":1,"\"F5\"":1,"\"F11\"":1,"\"F4\"":1,"\"F12\"":1,"\"F3\"":1,"\"F2\"":1,"\"F1\"":1,"\"End\"":1,"\"Down\"":1,"\"Page Up\"":1,"\"Page Down\"":1,"\"Home\"":1,"\"Right\"":1,"\"Up\"":1,"\"Left\"":1,"\"Unknown Function Key\"":1,"\"F9\"":1,"\"F8\"":1,"\"F7\"":1},"javaDoc":"","comments":" constants defined in the Event class.","isEmpty":false,"hasInnerClass":false,"modifier":2}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"removeElementAt":1,"addElement":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Add a new line to the list of lines, and redisplay */\nprotected void showLine(String s) {\n    if (lines.size() == 20)\n        lines.removeElementAt(0);\n    lines.addElement(s);\n    repaint();\n}\n","name":"showLine","className":"EventTester","variables":{"lines":3},"constants":{"0":1,"20":1},"javaDoc":"Add a new line to the list of lines and redisplay","comments":" Add a new line to the list of lines, and redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":13,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/** This method repaints the text in the window */\npublic void paint(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) g.drawString((String) lines.elementAt(i), 20, i * 16 + 50);\n}\n","name":"paint","className":"EventTester","variables":{"g":1,"i":4,"lines":2},"constants":{"0":1,"16":1,"50":1,"20":1},"javaDoc":"This method repaints the text in the window","comments":" This method repaints the text in the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getColorParameter":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":2},"expressions":{"NullLiteralExpr":2,"VariableDeclarationExpr":2,"SuperExpr":1,"BinaryExpr":2,"NameExpr":14,"StringLiteralExpr":2,"ThisExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":2,"ExpressionStmt":5},"text":"// Read in two color parameters and set the colors.\npublic void init() {\n    // Let the superclass initialize itself\n    super.init();\n    Color foreground = getColorParameter(\"foreground\");\n    Color background = getColorParameter(\"background\");\n    if (foreground != null)\n        this.setForeground(foreground);\n    if (background != null)\n        this.setBackground(background);\n}\n","name":"init","className":"ColorScribble","variables":{"background":2,"foreground":2},"constants":{"\"foreground\"":1,"null":2,"\"background\"":1},"javaDoc":"","comments":"Let the superclass initialize itself  Read in two color parameters and set the colors.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Color","methodCalls":{"parseInt":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":7,"ThisExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"// Read the specified parameter.  Interpret it as a hexadecimal\n// number of the form RRGGBB and convert it to a color.\nprotected Color getColorParameter(String name) {\n    String value = this.getParameter(name);\n    try {\n        return new Color(Integer.parseInt(value, 16));\n    } catch (Exception e) {\n        return null;\n    }\n}\n","name":"getColorParameter","className":"ColorScribble","variables":{"Integer":1,"e":1,"value":1},"constants":{"null":1,"16":1},"javaDoc":"","comments":" number of the form RRGGBB and convert it to a color.","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Return information suitable for display in an About dialog box.\npublic String getAppletInfo() {\n    return \"ColorScribble v. 0.03.  Written by David Flanagan.\";\n}\n","name":"getAppletInfo","className":"ColorScribble","variables":{},"constants":{"\"ColorScribble v. 0.03.  Written by David Flanagan.\"":1},"javaDoc":"","comments":" Return information suitable for display in an About dialog box.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[][]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Return info about the supported parameters.  Web browsers and applet\n// viewers should display this information, and may also allow users to\n// set the parameter values.\npublic String[][] getParameterInfo() {\n    return info;\n}\n","name":"getParameterInfo","className":"ColorScribble","variables":{"info":1},"constants":{},"javaDoc":"","comments":" set the parameter values.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":3,"AssignExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":4},"text":"/** Initialize the erase button, ask for keyboard focus */\npublic void init() {\n    erase_button = new Button(\"Erase\");\n    this.add(erase_button);\n    // Set background color for scribble\n    this.setBackground(Color.white);\n    // Ask for keyboard focus so we get key events\n    this.requestFocus();\n}\n","name":"init","className":"Scribble","variables":{"erase_button":1},"constants":{"\"Erase\"":1},"javaDoc":"Initialize the erase button ask for keyboard focus","comments":"Set background color for scribble Ask for keyboard focus so we get key events  Initialize the erase button, ask for keyboard focus ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":4,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"/** Respond to mouse clicks */\npublic boolean mouseDown(Event e, int x, int y) {\n    // Remember where the click was\n    lastx = x;\n    // Remember where the click was\n    lasty = y;\n    return true;\n}\n","name":"mouseDown","className":"Scribble","variables":{"x":1,"y":1,"lasty":1,"lastx":1},"constants":{"true":1},"javaDoc":"Respond to mouse clicks","comments":"Remember where the click was Remember where the click was  Respond to mouse clicks ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int","int"],"returnType":"boolean","methodCalls":{"getGraphics":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":13,"MethodCallExpr":2,"AssignExpr":2},"statements":{"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Respond to mouse drags */\npublic boolean mouseDrag(Event e, int x, int y) {\n    Graphics g = getGraphics();\n    // Draw from last position to here\n    g.drawLine(lastx, lasty, x, y);\n    // And remember new last position\n    lastx = x;\n    // And remember new last position\n    lasty = y;\n    return true;\n}\n","name":"mouseDrag","className":"Scribble","variables":{"g":2,"x":1,"y":1,"lasty":1,"lastx":1},"constants":{"true":1},"javaDoc":"Respond to mouse drags","comments":"Draw from last position to here And remember new last position And remember new last position  Respond to mouse drags ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","int"],"returnType":"boolean","methodCalls":{"setColor":1,"bounds":2,"getGraphics":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":25,"FieldAccessExpr":4,"CharLiteralExpr":1,"EnclosedExpr":2,"ThisExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** Respond to key presses: Erase drawing when user types 'e' */\npublic boolean keyDown(Event e, int key) {\n    if ((e.id == Event.KEY_PRESS) && (key == 'e')) {\n        Graphics g = getGraphics();\n        g.setColor(this.getBackground());\n        g.fillRect(0, 0, bounds().width, bounds().height);\n        return true;\n    } else\n        return false;\n}\n","name":"keyDown","className":"Scribble","variables":{"g":3,"key":1},"constants":{"0":2,"true":1,"false":1,"'e'":1},"javaDoc":"Respond to key presses: Erase drawing when user types 'e'","comments":" Respond to key presses: Erase drawing when user types 'e' ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Event","Object"],"returnType":"boolean","methodCalls":{"setColor":1,"bounds":2,"getGraphics":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":22,"FieldAccessExpr":3,"ThisExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":3},"text":"/** Respond to Button clicks: erase drawing when user clicks button */\npublic boolean action(Event e, Object arg) {\n    if (e.target == erase_button) {\n        Graphics g = getGraphics();\n        g.setColor(this.getBackground());\n        g.fillRect(0, 0, bounds().width, bounds().height);\n        return true;\n    } else\n        return false;\n}\n","name":"action","className":"Scribble","variables":{"erase_button":1,"g":3},"constants":{"0":2,"true":1,"false":1},"javaDoc":"Respond to Button clicks: erase drawing when user clicks button","comments":" Respond to Button clicks: erase drawing when user clicks button ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"setAlignment":1,"setFont":1,"setLayout":1,"getTimeInstance":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":1,"NameExpr":28,"StringLiteralExpr":1,"FieldAccessExpr":4,"AssignExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":6},"text":"/**\n     * The init method is called when the browser first starts the applet.\n     * It sets up the Label component and obtains a DateFormat object\n     **/\npublic void init() {\n    time = new Label();\n    time.setFont(new Font(\"helvetica\", Font.BOLD, 12));\n    time.setAlignment(Label.CENTER);\n    setLayout(new BorderLayout());\n    add(time, BorderLayout.CENTER);\n    timeFormat = DateFormat.getTimeInstance(DateFormat.MEDIUM);\n}\n","name":"init","className":"Clock","variables":{"timeFormat":1,"DateFormat":1,"time":3},"constants":{"12":1,"\"helvetica\"":1},"javaDoc":"The init method is called when the browser first starts the applet It sets up the Label component and obtains a DateFormat object","comments":"\n     * The init method is called when the browser first starts the applet.\n     * It sets up the Label component and obtains a DateFormat object\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":6,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"/**\n     * This browser calls this method to tell the applet to start running.\n     * Here, we create and start a thread that will update the time each\n     * second.  Note that we take care never to have more than one thread\n     **/\npublic void start() {\n    // Set the flag \n    running = true;\n    if (timer == null) {\n        // If we don't already have a thread\n        // Then create one\n        timer = new Thread(this);\n        // And start it running\n        timer.start();\n    }\n}\n","name":"start","className":"Clock","variables":{"running":1,"timer":3},"constants":{"null":1,"true":1},"javaDoc":"This browser calls this method to tell the applet to start running Here we create and start a thread that will update the time each second Note that we take care never to have more than one thread","comments":"Set the flag If we don't already have a thread Then create one And start it running \n     * This browser calls this method to tell the applet to start running.\n     * Here, we create and start a thread that will update the time each\n     * second.  Note that we take care never to have more than one thread\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"sleep":1,"format":1,"setText":1},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"NameExpr":11,"MethodCallExpr":3,"AssignExpr":1},"statements":{"WhileStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":3},"text":"/**\n     * This method implements Runnable.  It is the body of the thread.  Once\n     * a second, it updates the text of the Label to display the current time\n     **/\npublic void run() {\n    while (running) {\n        // Loop until we're stopped\n        // Get current time, convert to a String, and display in the Label\n        time.setText(timeFormat.format(new Date()));\n        // Now wait 1000 milliseconds\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n    }\n    // If the thread exits, set it to null so we can create a new one\n    // if start() is called again.\n    timer = null;\n}\n","name":"run","className":"Clock","variables":{"running":1,"timer":1,"e":1,"timeFormat":1,"time":1,"Thread":1},"constants":{"null":1,"1000":1},"javaDoc":"This method implements Runnable It is the body of the thread Once a second it updates the text of the Label to display the current time","comments":"If the thread exits set it to null so we can create a new one Loop until we're stopped Get current time convert to a String and display in the Label Now wait 1000 milliseconds if start() is called again \n     * This method implements Runnable.  It is the body of the thread.  Once\n     * a second, it updates the text of the Label to display the current time\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * The browser calls this method to tell the applet that it is not visible\n     * and should not run.  It sets a flag that tells the run() method to exit\n     **/\npublic void stop() {\n    running = false;\n}\n","name":"stop","className":"Clock","variables":{"running":1},"constants":{"false":1},"javaDoc":"The browser calls this method to tell the applet that it is not visible and should not run It sets a flag that tells the run() method to exit","comments":"\n     * The browser calls this method to tell the applet that it is not visible\n     * and should not run.  It sets a flag that tells the run() method to exit\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Returns information about the applet for display by the applet viewer\n     **/\npublic String getAppletInfo() {\n    return \"Clock applet Copyright (c) 2000 by David Flanagan\";\n}\n","name":"getAppletInfo","className":"Clock","variables":{},"constants":{"\"Clock applet Copyright (c) 2000 by David Flanagan\"":1},"javaDoc":"Returns information about the applet for display by the applet viewer","comments":"\n     * Returns information about the applet for display by the applet viewer\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"requestFocus":1,"getY":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":10,"MethodCallExpr":4},"statements":{"ExpressionStmt":2},"text":"public void mousePressed(MouseEvent e) {\n    // Move to click position\n    moveto(e.getX(), e.getY());\n    // Take keyboard focus\n    requestFocus();\n}\n","name":"mousePressed","className":"","variables":{"e":2},"constants":{},"javaDoc":"","comments":"Move to click position Take keyboard focus ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"lineto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void mouseDragged(MouseEvent e) {\n    // Draw to mouse position\n    lineto(e.getX(), e.getY());\n}\n","name":"mouseDragged","className":"","variables":{"e":2},"constants":{},"javaDoc":"","comments":"Draw to mouse position ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"clear":1,"getKeyCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"FieldAccessExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"public void keyPressed(KeyEvent e) {\n    if (e.getKeyCode() == KeyEvent.VK_C)\n        clear();\n}\n","name":"keyPressed","className":"","variables":{"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribblePane2","methodCalls":{"setPreferredSize":1,"getX":2,"requestFocus":1,"getY":2,"addKeyListener":1,"addMouseMotionListener":1,"clear":1,"lineto":1,"getKeyCode":1,"addMouseListener":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":40,"FieldAccessExpr":1,"MethodCallExpr":13},"statements":{"IfStmt":1,"BlockStmt":3,"ExpressionStmt":8},"text":"public ScribblePane2() {\n    // Give the component a preferred size\n    setPreferredSize(new Dimension(450, 200));\n    // Register a mouse event handler defined as an inner class\n    // Note the call to requestFocus().  This is required in order for\n    // the component to receive key events.\n    addMouseListener(new MouseAdapter() {\n\n        public void mousePressed(MouseEvent e) {\n            // Move to click position\n            moveto(e.getX(), e.getY());\n            // Take keyboard focus\n            requestFocus();\n        }\n    });\n    // Register a mouse motion event handler defined as an inner class\n    // By subclassing MouseMotionAdapter rather than implementing\n    // MouseMotionListener, we only override the method we're interested\n    // in and inherit default (empty) implementations of the other methods.\n    addMouseMotionListener(new MouseMotionAdapter() {\n\n        public void mouseDragged(MouseEvent e) {\n            // Draw to mouse position\n            lineto(e.getX(), e.getY());\n        }\n    });\n    // Add a keyboard event handler to clear the screen on key 'C'\n    addKeyListener(new KeyAdapter() {\n\n        public void keyPressed(KeyEvent e) {\n            if (e.getKeyCode() == KeyEvent.VK_C)\n                clear();\n        }\n    });\n}\n","name":"ScribblePane2","className":"ScribblePane2","variables":{"keyPressed":1,"mouseDragged":1,"e":8,"mousePressed":1},"constants":{"200":1,"450":1},"javaDoc":"","comments":"Register a mouse event handler defined as an inner class Note the call to requestFocus() This is required in order for Register a mouse motion event handler defined as an inner class By subclassing MouseMotionAdapter rather than implementing MouseMotionListener we only override the method we're interested Give the component a preferred size the component to receive key events Move to click position Take keyboard focus in and inherit default (empty) implementations of the other methods Draw to mouse position Add a keyboard event handler to clear the screen on key 'C' ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Remember the specified point */\npublic void moveto(int x, int y) {\n    last_x = x;\n    last_y = y;\n}\n","name":"moveto","className":"ScribblePane2","variables":{"last_x":1,"x":1,"last_y":1,"y":1},"constants":{},"javaDoc":"Remember the specified point","comments":" Remember the specified point ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"setColor":1,"getGraphics":1,"drawLine":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Graphics":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":17,"MethodCallExpr":4},"statements":{"ExpressionStmt":4},"text":"/** Draw from the last point to this point, then remember new point */\npublic void lineto(int x, int y) {\n    // Get the object to draw with\n    Graphics g = getGraphics();\n    // Tell it what color to use\n    g.setColor(color);\n    // Tell it what to draw\n    g.drawLine(last_x, last_y, x, y);\n    // Save the current point\n    moveto(x, y);\n}\n","name":"lineto","className":"ScribblePane2","variables":{"g":3},"constants":{},"javaDoc":"Draw from the last point to this point then remember new point","comments":"Get the object to draw with Tell it what color to use Tell it what to draw Save the current point  Draw from the last point to this point, then remember new point ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Clear the drawing area, using the component background color.  This\n     * method works by requesting that the component be redrawn.  Since this\n     * component does not have a paintComponent() method, nothing will be\n     * drawn.  However, other parts of the component, such as borders or\n     * sub-components will be drawn correctly.\n     **/\npublic void clear() {\n    repaint();\n}\n","name":"clear","className":"ScribblePane2","variables":{},"constants":{},"javaDoc":"Clear the drawing area using the component background color This method works by requesting that the component be redrawn Since this component does not have a paintComponent() method nothing will be drawn However other parts of the component such as borders or sub-components will be drawn correctly","comments":"\n     * Clear the drawing area, using the component background color.  This\n     * method works by requesting that the component be redrawn.  Since this\n     * component does not have a paintComponent() method, nothing will be\n     * drawn.  However, other parts of the component, such as borders or\n     * sub-components will be drawn correctly.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This is the property \"setter\" method for the color property */\npublic void setColor(Color color) {\n    this.color = color;\n}\n","name":"setColor","className":"ScribblePane2","variables":{"color":1},"constants":{},"javaDoc":"This is the property \"setter\" method for the color property","comments":" This is the property \"setter\" method for the color property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is the property \"getter\" method for the color property */\npublic Color getColor() {\n    return color;\n}\n","name":"getColor","className":"ScribblePane2","variables":{"color":1},"constants":{},"javaDoc":"This is the property \"getter\" method for the color property","comments":" This is the property \"getter\" method for the color property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribblePane1","methodCalls":{"setPreferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"NameExpr":6,"ThisExpr":4,"MethodCallExpr":3},"statements":{"ExpressionStmt":3},"text":"public ScribblePane1() {\n    // This component registers itself as an event listener for\n    // mouse events and mouse motion events.\n    this.addMouseListener(this);\n    this.addMouseMotionListener(this);\n    // Give the component a preferred size\n    setPreferredSize(new Dimension(450, 200));\n}\n","name":"ScribblePane1","className":"ScribblePane1","variables":{},"constants":{"200":1,"450":1},"javaDoc":"","comments":"This component registers itself as an event listener for mouse events and mouse motion events Give the component a preferred size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"AssignExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"// A method from the MouseListener interface.  Invoked when the\n// user presses a mouse button.\npublic void mousePressed(MouseEvent e) {\n    // remember the coordinates of the click\n    last_x = e.getX();\n    last_y = e.getY();\n}\n","name":"mousePressed","className":"ScribblePane1","variables":{"e":2,"last_x":1,"last_y":1},"constants":{},"javaDoc":"","comments":"remember the coordinates of the click  user presses a mouse button.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"drawLine":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":2},"expressions":{"VariableDeclarationExpr":2,"NameExpr":18,"ThisExpr":1,"MethodCallExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":5},"text":"// A method from the MouseMotionListener interface.  Invoked when the\n// user drags the mouse with a button pressed.\npublic void mouseDragged(MouseEvent e) {\n    // Get the current mouse position\n    int x = e.getX();\n    int y = e.getY();\n    // Draw a line from the saved coordinates to the current position\n    this.getGraphics().drawLine(last_x, last_y, x, y);\n    // Remember the current position\n    last_x = x;\n    last_y = y;\n}\n","name":"mouseDragged","className":"ScribblePane1","variables":{"e":2,"last_x":1,"x":2,"last_y":1,"y":2},"constants":{},"javaDoc":"","comments":"Get the current mouse position Draw a line from the saved coordinates to the current position Remember the current position  user drags the mouse with a button pressed.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// The other, unused methods of the MouseListener interface.\npublic void mouseReleased(MouseEvent e) {\n}\n","name":"mouseReleased","className":"ScribblePane1","variables":{},"constants":{},"javaDoc":"","comments":" The other, unused methods of the MouseListener interface.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseClicked(MouseEvent e) {\n}\n","name":"mouseClicked","className":"ScribblePane1","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseEntered(MouseEvent e) {\n}\n","name":"mouseEntered","className":"ScribblePane1","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void mouseExited(MouseEvent e) {\n}\n","name":"mouseExited","className":"ScribblePane1","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// The other, unused, method of the MouseMotionListener interface.\npublic void mouseMoved(MouseEvent e) {\n}\n","name":"mouseMoved","className":"ScribblePane1","variables":{},"constants":{},"javaDoc":"","comments":" The other, unused, method of the MouseMotionListener interface.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FlowLayoutPane","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":6,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":14,"StringLiteralExpr":3,"FieldAccessExpr":1,"UnaryExpr":1,"ThisExpr":3,"MethodCallExpr":3,"AssignExpr":1},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public FlowLayoutPane() {\n    // Use a FlowLayout layout manager.  Left justify rows.\n    // Leave 10 pixels of horizontal and vertical space between components.\n    this.setLayout(new FlowLayout(FlowLayout.LEFT, 10, 10));\n    // Add some buttons to demonstrate the layout.\n    // Used to make the buttons different\n    String spaces = \"\";\n    for (int i = 1; i <= 9; i++) {\n        this.add(new JButton(\"Button #\" + i + spaces));\n        spaces += \" \";\n    }\n    // Give ourselves a default size\n    this.setPreferredSize(new Dimension(500, 200));\n}\n","name":"FlowLayoutPane","className":"FlowLayoutPane","variables":{"spaces":3,"i":4},"constants":{"\"\"":1,"1":1,"200":1,"\" \"":1,"500":1,"9":1,"\"Button #\"":1,"10":2},"javaDoc":"","comments":"Use a FlowLayout layout manager Left justify rows Add some buttons to demonstrate the layout Leave 10 pixels of horizontal and vertical space between components Used to make the buttons different Give ourselves a default size ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Class[] getResourceTypes() {\n    return supportedTypes;\n}\n","name":"getResourceTypes","className":"CommandParser","variables":{"supportedTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{"getString":1,"parse":1,"getRoot":1},"annotations":[],"exceptions":["java.util.MissingResourceException","java.io.IOException"],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":11,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"public Object parse(GUIResourceBundle bundle, String key, Class type) throws java.util.MissingResourceException, java.io.IOException {\n    // look up the command text\n    String value = bundle.getString(key);\n    // parse it!\n    return Command.parse(bundle.getRoot(), value);\n}\n","name":"parse","className":"CommandParser","variables":{"Command":1,"value":1,"bundle":2},"constants":{},"javaDoc":"","comments":"look up the command text parse it! ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String[]","Object[]","int","int"],"returnType":"ItemChooser","methodCalls":{"initList":1,"initComboBox":1,"initRadioButtons":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":29,"FieldAccessExpr":6,"ThisExpr":6,"AssignExpr":6,"MethodCallExpr":3},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"SwitchEntryStmt":3,"ExpressionStmt":9},"text":"// The constructor method sets everything up\npublic ItemChooser(String name, String[] labels, Object[] values, int defaultSelection, int presentation) {\n    // Copy the constructor arguments to instance fields\n    this.name = name;\n    this.labels = labels;\n    this.values = values;\n    this.selection = defaultSelection;\n    this.presentation = presentation;\n    // If no values were supplied, use the labels\n    if (values == null)\n        this.values = labels;\n    // Now create content and event handlers based on presentation type\n    switch(presentation) {\n        case LIST:\n            initList();\n            break;\n        case COMBOBOX:\n            initComboBox();\n            break;\n        case RADIOBUTTONS:\n            initRadioButtons();\n            break;\n    }\n}\n","name":"ItemChooser","className":"ItemChooser","variables":{"presentation":2,"defaultSelection":1,"values":2,"name":1,"COMBOBOX":1,"LIST":1,"labels":2,"RADIOBUTTONS":1},"constants":{"null":1},"javaDoc":"","comments":"Copy the constructor arguments to instance fields If no values were supplied use the labels Now create content and event handlers based on presentation type  The constructor method sets everything up","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void valueChanged(ListSelectionEvent e) {\n    ItemChooser.this.select(list.getSelectedIndex());\n}\n","name":"valueChanged","className":"","variables":{"ItemChooser":1,"list":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addListSelectionListener":1,"getSelectedIndex":1,"setSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":5,"NameExpr":28,"FieldAccessExpr":1,"ThisExpr":5,"AssignExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ExpressionStmt":7},"text":"// Initialization for JList presentation\nvoid initList() {\n    // Create the list\n    list = new JList(labels);\n    // Set initial state\n    list.setSelectedIndex(selection);\n    // Handle state changes\n    list.addListSelectionListener(new ListSelectionListener() {\n\n        public void valueChanged(ListSelectionEvent e) {\n            ItemChooser.this.select(list.getSelectedIndex());\n        }\n    });\n    // Lay out list and name label vertically\n    // vertical\n    this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n    // Display choice name\n    this.add(new JLabel(name));\n    // Add the JList\n    this.add(new JScrollPane(list));\n}\n","name":"initList","className":"ItemChooser","variables":{"ItemChooser":1,"valueChanged":1,"e":1,"name":1,"list":5,"labels":1},"constants":{},"javaDoc":"","comments":"Lay out list and name label vertically Create the list Set initial state Handle state changes vertical Display choice name Add the JList  Initialization for JList presentation","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ItemEvent"],"returnType":"void","methodCalls":{"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"ThisExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void itemStateChanged(ItemEvent e) {\n    ItemChooser.this.select(combobox.getSelectedIndex());\n}\n","name":"itemStateChanged","className":"","variables":{"ItemChooser":1,"combobox":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"addItemListener":1,"getSelectedIndex":1,"setSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{},"expressions":{"ObjectCreationExpr":4,"NameExpr":28,"FieldAccessExpr":1,"ThisExpr":5,"AssignExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ExpressionStmt":7},"text":"// Initialization for JComboBox presentation\nvoid initComboBox() {\n    // Create the combo box\n    combobox = new JComboBox(labels);\n    // Set initial state\n    combobox.setSelectedIndex(selection);\n    // Handle changes to the state\n    combobox.addItemListener(new ItemListener() {\n\n        public void itemStateChanged(ItemEvent e) {\n            ItemChooser.this.select(combobox.getSelectedIndex());\n        }\n    });\n    // Lay out combo box and name label horizontally\n    this.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));\n    this.add(new JLabel(name));\n    this.add(combobox);\n}\n","name":"initComboBox","className":"ItemChooser","variables":{"ItemChooser":1,"itemStateChanged":1,"e":1,"name":1,"combobox":4,"labels":1},"constants":{},"javaDoc":"","comments":"Create the combo box Set initial state Handle changes to the state Lay out combo box and name label horizontally  Initialization for JComboBox presentation","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["ChangeEvent"],"returnType":"void","methodCalls":{"getSource":1,"isSelected":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"JRadioButton":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":2,"CastExpr":1,"NameExpr":18,"FieldAccessExpr":1,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":2,"BlockStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":2},"text":"public void stateChanged(ChangeEvent e) {\n    JRadioButton b = (JRadioButton) e.getSource();\n    if (b.isSelected()) {\n        // figure out the index of the selected one.\n        for (int i = 0; i < radiobuttons.length; i++) {\n            if (radiobuttons[i] == b) {\n                ItemChooser.this.select(i);\n                return;\n            }\n        }\n    }\n}\n             // If we received this event because a button was\n\n             // selected, then loop through the list of buttons to\n\n","name":"stateChanged","className":"","variables":{"ItemChooser":1,"b":3,"e":1,"i":4,"radiobuttons":1},"constants":{"0":1},"javaDoc":"","comments":"If we received this event because a button was selected then loop through the list of buttons to figure out the index of the selected one ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":1,"getSource":1,"isSelected":1},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod","PolyMorphism"],"types":{"JRadioButton":1,"ButtonGroup":1,"ChangeListener":2,"int":2},"expressions":{"ObjectCreationExpr":6,"IntegerLiteralExpr":2,"VariableDeclarationExpr":5,"ArrayAccessExpr":7,"BinaryExpr":4,"NameExpr":61,"UnaryExpr":2,"AssignExpr":2,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":4,"ArrayCreationExpr":1,"ThisExpr":5,"MethodCallExpr":9},"statements":{"IfStmt":3,"BlockStmt":5,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":12},"text":"// Initialization for JRadioButton presentation\nvoid initRadioButtons() {\n    // Create an array of mutually exclusive radio buttons\n    // the array\n    radiobuttons = new JRadioButton[labels.length];\n    // used for exclusion\n    ButtonGroup radioButtonGroup = new ButtonGroup();\n    ChangeListener listener = new // A shared listener\n    ChangeListener() {\n\n        public void stateChanged(ChangeEvent e) {\n            JRadioButton b = (JRadioButton) e.getSource();\n            if (b.isSelected()) {\n                // figure out the index of the selected one.\n                for (int i = 0; i < radiobuttons.length; i++) {\n                    if (radiobuttons[i] == b) {\n                        ItemChooser.this.select(i);\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    // Display the choice name in a border around the buttons\n    this.setBorder(new TitledBorder(new EtchedBorder(), name));\n    this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n    // the event listener for each one.\n    for (int i = 0; i < labels.length; i++) {\n        radiobuttons[i] = new JRadioButton(labels[i]);\n        if (i == selection)\n            radiobuttons[i].setSelected(true);\n        radiobuttons[i].addChangeListener(listener);\n        radioButtonGroup.add(radiobuttons[i]);\n        this.add(radiobuttons[i]);\n    }\n}\n     // Create the buttons, add them to the button group, and specify\n\n             // If we received this event because a button was\n\n             // selected, then loop through the list of buttons to\n\n","name":"initRadioButtons","className":"ItemChooser","variables":{"ItemChooser":1,"b":3,"selection":1,"radioButtonGroup":2,"e":2,"listener":1,"name":1,"i":14,"radiobuttons":7,"stateChanged":1,"labels":1},"constants":{"0":2,"true":1},"javaDoc":"","comments":"Create an array of mutually exclusive radio buttons Create the buttons add them to the button group and specify the array used for exclusion A shared listener If we received this event because a button was selected then loop through the list of buttons to figure out the index of the selected one Display the choice name in a border around the buttons the event listener for each one  Initialization for JRadioButton presentation","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These simple property accessor methods just return field values\n// These are read-only properties.  The values are set by the constructor\n// and may not be changed.\npublic String getName() {\n    return name;\n}\n","name":"getName","className":"ItemChooser","variables":{"name":1},"constants":{},"javaDoc":"","comments":" and may not be changed.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getPresentation() {\n    return presentation;\n}\n","name":"getPresentation","className":"ItemChooser","variables":{"presentation":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String[] getLabels() {\n    return labels;\n}\n","name":"getLabels","className":"ItemChooser","variables":{"labels":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Object[] getValues() {\n    return values;\n}\n","name":"getValues","className":"ItemChooser","variables":{"values":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the index of the selected item */\npublic int getSelectedIndex() {\n    return selection;\n}\n","name":"getSelectedIndex","className":"ItemChooser","variables":{"selection":1},"constants":{},"javaDoc":"Return the index of the selected item","comments":" Return the index of the selected item ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"/** Return the object associated with the selected item */\npublic Object getSelectedValue() {\n    return values[selection];\n}\n","name":"getSelectedValue","className":"ItemChooser","variables":{"selection":1,"values":1},"constants":{},"javaDoc":"Return the object associated with the selected item","comments":" Return the object associated with the selected item ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"setSelectedIndex":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"BooleanLiteralExpr":1,"NameExpr":19,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":3,"AssignExpr":1},"statements":{"SwitchStmt":1,"BreakStmt":3,"SwitchEntryStmt":3,"ExpressionStmt":4},"text":"/**\n     * Set the selected item by specifying its index.  Calling this\n     * method changes the on-screen display but does not generate events.\n     **/\npublic void setSelectedIndex(int selection) {\n    switch(presentation) {\n        case LIST:\n            list.setSelectedIndex(selection);\n            break;\n        case COMBOBOX:\n            combobox.setSelectedIndex(selection);\n            break;\n        case RADIOBUTTONS:\n            radiobuttons[selection].setSelected(true);\n            break;\n    }\n    this.selection = selection;\n}\n","name":"setSelectedIndex","className":"ItemChooser","variables":{"presentation":1,"selection":2,"COMBOBOX":1,"list":1,"combobox":1,"radiobuttons":1,"LIST":1,"RADIOBUTTONS":1},"constants":{"true":1},"javaDoc":"Set the selected item by specifying its index Calling this method changes the on-screen display but does not generate events","comments":"\n     * Set the selected item by specifying its index.  Calling this\n     * method changes the on-screen display but does not generate events.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"next":1,"iterator":1,"itemChosen":1,"isEmpty":1,"hasNext":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Iterator":1,"ItemChooser.Event":1,"ItemChooser.Listener":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"NameExpr":22,"CastExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"ThisExpr":2,"AssignExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ExpressionStmt":4},"text":"/**\n     * This internal method is called when the selection changes.  It stores\n     * the new selected index, and fires events to any registered listeners.\n     * The event listeners registered on the JList, JComboBox, or JRadioButtons\n     * all call this method.\n     **/\nprotected void select(int selection) {\n    // Store the new selected index\n    this.selection = selection;\n    if (!listeners.isEmpty()) {\n        // If there are any listeners registered\n        // Create an event object to describe the selection\n        ItemChooser.Event e = new ItemChooser.Event(this, selection, values[selection]);\n        // Loop through the listeners using an Iterator\n        for (Iterator i = listeners.iterator(); i.hasNext(); ) {\n            ItemChooser.Listener l = (ItemChooser.Listener) i.next();\n            // Notify each listener of the selection\n            l.itemChosen(e);\n        }\n    }\n}\n","name":"select","className":"ItemChooser","variables":{"selection":3,"listeners":2,"e":1,"values":1,"i":3,"l":2},"constants":{},"javaDoc":"This internal method is called when the selection changes It stores the new selected index and fires events to any registered listeners The event listeners registered on the JList JComboBox or JRadioButtons all call this method","comments":"Store the new selected index If there are any listeners registered Create an event object to describe the selection Loop through the listeners using an Iterator Notify each listener of the selection \n     * This internal method is called when the selection changes.  It stores\n     * the new selected index, and fires events to any registered listeners.\n     * The event listeners registered on the JList, JComboBox, or JRadioButtons\n     * all call this method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["ItemChooser.Listener"],"returnType":"void","methodCalls":{"add":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"// These methods are for event listener registration and deregistration\npublic void addItemChooserListener(ItemChooser.Listener l) {\n    listeners.add(l);\n}\n","name":"addItemChooserListener","className":"ItemChooser","variables":{"listeners":1},"constants":{},"javaDoc":"","comments":" These methods are for event listener registration and deregistration","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Listener"],"returnType":"void","methodCalls":{"remove":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void removeItemChooserListener(ItemChooser.Listener l) {\n    listeners.remove(l);\n}\n","name":"removeItemChooserListener","className":"ItemChooser","variables":{"listeners":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser","int","Object"],"returnType":"Event","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public Event(ItemChooser source, int selectedIndex, Object selectedValue) {\n    super(source);\n    this.selectedIndex = selectedIndex;\n    this.selectedValue = selectedValue;\n}\n","name":"Event","className":"Event","variables":{"source":1,"selectedValue":1,"selectedIndex":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ItemChooser","methodCalls":{"getSource":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"public ItemChooser getItemChooser() {\n    return (ItemChooser) getSource();\n}\n","name":"getItemChooser","className":"Event","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getSelectedIndex() {\n    return selectedIndex;\n}\n","name":"getSelectedIndex","className":"Event","variables":{"selectedIndex":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Object getSelectedValue() {\n    return selectedValue;\n}\n","name":"getSelectedValue","className":"Event","variables":{"selectedValue":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Event"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void itemChosen(ItemChooser.Event e);\n","name":"itemChosen","className":"Listener","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Event"],"returnType":"void","methodCalls":{"getName":1,"getItemChooser":1,"getSelectedIndex":1,"getSelectedValue":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":4,"NameExpr":14,"StringLiteralExpr":2,"MethodCallExpr":5},"statements":{"ExpressionStmt":1},"text":"public void itemChosen(ItemChooser.Event e) {\n    msgline.setText(e.getItemChooser().getName() + \": \" + e.getSelectedIndex() + \": \" + e.getSelectedValue());\n}\n","name":"itemChosen","className":"","variables":{"e":3,"msgline":1},"constants":{"\": \"":2},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getName":3,"showMessageDialog":1,"getSelectedValue":3},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":12,"StringLiteralExpr":7,"NameExpr":23,"MethodCallExpr":7},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    // Note the use of multi-line italic HTML text\n    // with the JOptionPane message dialog box.\n    String msg = \"<html><i>\" + c1.getName() + \": \" + c1.getSelectedValue() + \"<br>\" + c2.getName() + \": \" + c2.getSelectedValue() + \"<br>\" + c3.getName() + \": \" + c3.getSelectedValue() + \"</i>\";\n    JOptionPane.showMessageDialog(frame, msg);\n}\n","name":"actionPerformed","className":"","variables":{"msg":1,"c3":2,"JOptionPane":1,"c1":2,"c2":2},"constants":{"\"</i>\"":1,"\": \"":3,"\"<html><i>\"":1,"\"<br>\"":2},"javaDoc":"","comments":"Note the use of multi-line italic HTML text with the JOptionPane message dialog box ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":6,"getName":4,"getItemChooser":1,"addActionListener":1,"show":1,"getSelectedValue":4,"getContentPane":1,"addItemChooserListener":3,"pack":1,"addWindowListener":1,"exit":1,"showMessageDialog":1,"getSelectedIndex":1,"setText":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"ItemChooser":3,"JPanel":1,"Container":1,"JFrame":1,"JButton":1,"JLabel":1,"String":1,"ItemChooser.Listener":1},"expressions":{"ObjectCreationExpr":10,"IntegerLiteralExpr":4,"NullLiteralExpr":3,"VariableDeclarationExpr":10,"BinaryExpr":16,"StringLiteralExpr":15,"NameExpr":115,"FieldAccessExpr":5,"MethodCallExpr":27},"statements":{"BlockStmt":3,"ExpressionStmt":26},"text":"public static void main(String[] args) {\n    // Create a window, arrange to handle close requests\n    final JFrame frame = new JFrame(\"ItemChooser Demo\");\n    frame.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // A \"message line\" to display results in\n    final JLabel msgline = new JLabel(\" \");\n    // Create a panel holding three ItemChooser components\n    JPanel chooserPanel = new JPanel();\n    final ItemChooser c1 = new ItemChooser(\"Choice #1\", args, null, 0, ItemChooser.LIST);\n    final ItemChooser c2 = new ItemChooser(\"Choice #2\", args, null, 0, ItemChooser.COMBOBOX);\n    final ItemChooser c3 = new ItemChooser(\"Choice #3\", args, null, 0, ItemChooser.RADIOBUTTONS);\n    // An event listener that displays changes on the message line\n    ItemChooser.Listener l = new ItemChooser.Listener() {\n\n        public void itemChosen(ItemChooser.Event e) {\n            msgline.setText(e.getItemChooser().getName() + \": \" + e.getSelectedIndex() + \": \" + e.getSelectedValue());\n        }\n    };\n    c1.addItemChooserListener(l);\n    c2.addItemChooserListener(l);\n    c3.addItemChooserListener(l);\n    // Instead of tracking every change with a ItemChooser.Listener,\n    // applications can also just query the current state when\n    // they need it.  Here's a button that does that.\n    JButton report = new JButton(\"Report\");\n    report.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // Note the use of multi-line italic HTML text\n            // with the JOptionPane message dialog box.\n            String msg = \"<html><i>\" + c1.getName() + \": \" + c1.getSelectedValue() + \"<br>\" + c2.getName() + \": \" + c2.getSelectedValue() + \"<br>\" + c3.getName() + \": \" + c3.getSelectedValue() + \"</i>\";\n            JOptionPane.showMessageDialog(frame, msg);\n        }\n    });\n    // Add the 3 ItemChooser objects, and the Button to the panel\n    chooserPanel.add(c1);\n    chooserPanel.add(c2);\n    chooserPanel.add(c3);\n    chooserPanel.add(report);\n    // Add the panel and the message line to the window\n    Container contentPane = frame.getContentPane();\n    contentPane.add(chooserPanel, BorderLayout.CENTER);\n    contentPane.add(msgline, BorderLayout.SOUTH);\n    // Set the window size and pop it up.\n    frame.pack();\n    frame.show();\n}\n","name":"main","className":"Demo","variables":{"msg":1,"e":6,"itemChosen":1,"l":1,"JOptionPane":1,"contentPane":3,"System":1,"c1":4,"c2":4,"chooserPanel":5,"args":3,"c3":4,"actionPerformed":1,"windowClosing":1,"msgline":2,"report":2,"frame":5},"constants":{"0":4,"\"Choice #3\"":1,"\"</i>\"":1,"\"Choice #2\"":1,"\"Report\"":1,"\"Choice #1\"":1,"\" \"":1,"null":3,"\"ItemChooser Demo\"":1,"\": \"":5,"\"<html><i>\"":1,"\"<br>\"":2},"javaDoc":"","comments":"Instead of tracking every change with a ItemChooser Listener applications can also just query the current state when Create a window arrange to handle close requests A \"message line\" to display results in Create a panel holding three ItemChooser components An event listener that displays changes on the message line they need it Here's a button that does that Note the use of multi-line italic HTML text with the JOptionPane message dialog box Add the 3 ItemChooser objects and the Button to the panel Add the panel and the message line to the window Set the window size and pop it up ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["JTextComponent"],"returnType":"PrintableDocument","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * This constructor allows printing the contents of any JTextComponent\n     * using a default PageFormat\n     */\npublic PrintableDocument(JTextComponent textComponent) {\n    this(textComponent, new PageFormat());\n}\n","name":"PrintableDocument","className":"PrintableDocument","variables":{"textComponent":1},"constants":{},"javaDoc":"This constructor allows printing the contents of any JTextComponent using a default PageFormat","comments":"\n     * This constructor allows printing the contents of any JTextComponent\n     * using a default PageFormat\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JTextComponent","PageFormat"],"returnType":"PrintableDocument","methodCalls":{"getViewFactory":1,"getDefaultRootElement":1,"getImageableHeight":1,"getDocument":1,"getEditorKit":1,"paginate":1,"getWidth":1,"getImageableX":1,"getImageableY":1,"getPreferredSpan":1,"getUI":1,"setSize":1,"size":1,"create":1,"getImageableWidth":1,"setParent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"EditorKit":1,"double":2,"Element":1,"ViewFactory":1,"Document":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":6,"BinaryExpr":2,"NameExpr":78,"CastExpr":6,"FieldAccessExpr":6,"ThisExpr":5,"AssignExpr":8,"MethodCallExpr":16},"statements":{"IfStmt":1,"ExpressionStmt":17},"text":"/** \n     * This constructor allows the contents of any JTextComponent to be\n     * printed, using any specified PageFormat object\n     **/\npublic PrintableDocument(JTextComponent textComponent, PageFormat format) {\n    // Remember the page format, and ask it for the printable area\n    this.format = format;\n    this.printX = format.getImageableX();\n    this.printY = format.getImageableY();\n    this.printWidth = format.getImageableWidth();\n    this.printHeight = format.getImageableHeight();\n    double paperWidth = format.getWidth();\n    // Get the document and its root Element from the text component\n    Document document = textComponent.getDocument();\n    Element rootElement = document.getDefaultRootElement();\n    // Get the EditorKit and its ViewFactory from the text component\n    EditorKit editorKit = textComponent.getUI().getEditorKit(textComponent);\n    ViewFactory viewFactory = editorKit.getViewFactory();\n    // Use the ViewFactory to create a root View object for the document\n    // This is the object we'll print.  \n    root = viewFactory.create(rootElement);\n    // The Swing text architecture requires us to call setParent() on\n    // our root View before we use it for anything.  In order to do this,\n    // we need a View object that can serve as the parent.  We use a \n    // custom implementation defined below.\n    root.setParent(new ParentView(root, viewFactory, textComponent));\n    // Tell the view how wide the page is; it has to format itself\n    // to fit within this width.  The height doesn't really matter here\n    root.setSize((float) printWidth, (float) printHeight);\n    // Now that the view has formatted itself for the specified width,\n    // Ask it how tall it is.  \n    double documentHeight = root.getPreferredSpan(View.Y_AXIS);\n    // Set up the rectangle that tells the view where to draw itself\n    // We'll use it in other methods of this class.\n    drawRect = new Rectangle((int) printX, (int) printY, (int) printWidth, (int) documentHeight);\n    // figure out where the page breaks are.\n    if (documentHeight > printHeight)\n        paginate(root, drawRect);\n    // Once we've broken it into pages, figure out how man pages.\n    numPages = pageLengths.size() + 1;\n}\n     // Now if the document is taller than one page, we have to \n\n","name":"PrintableDocument","className":"PrintableDocument","variables":{"textComponent":3,"documentHeight":3,"rootElement":1,"document":2,"format":6,"printWidth":2,"pageLengths":1,"editorKit":2,"printHeight":2,"numPages":1,"paperWidth":1,"root":5,"printY":1,"viewFactory":3,"drawRect":1,"printX":1},"constants":{"1":1},"javaDoc":"This constructor allows the contents of any JTextComponent to be printed using any specified PageFormat object","comments":"Use the ViewFactory to create a root View object for the document The Swing text architecture requires us to call setParent() on our root View before we use it for anything In order to do this we need a View object that can serve as the parent We use a Tell the view how wide the page is; it has to format itself Now that the view has formatted itself for the specified width Set up the rectangle that tells the view where to draw itself Now if the document is taller than one page we have to Remember the page format and ask it for the printable area Get the document and its root Element from the text component Get the EditorKit and its ViewFactory from the text component This is the object we'll print custom implementation defined below to fit within this width The height doesn't really matter here Ask it how tall it is We'll use it in other methods of this class figure out where the page breaks are Once we've broken it into pages figure out how man pages  \n     * This constructor allows the contents of any JTextComponent to be\n     * printed, using any specified PageFormat object\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["View","Rectangle2D"],"returnType":"void","methodCalls":{"getHeight":2,"setSize":1,"getY":4,"breakPage":3,"getBounds2D":1,"getChildAllocation":1,"paginate":1,"getViewCount":2,"getView":1,"getPreferredSpan":1},"annotations":[],"exceptions":[],"concepts":["Recursion"],"types":{"Shape":1,"double":2,"Rectangle2D":1,"View":1,"int":2},"expressions":{"IntegerLiteralExpr":6,"NullLiteralExpr":1,"VariableDeclarationExpr":7,"BinaryExpr":23,"NameExpr":81,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":4,"UnaryExpr":1,"MethodCallExpr":17},"statements":{"ContinueStmt":7,"IfStmt":8,"BlockStmt":5,"ForStmt":1,"ExpressionStmt":11},"text":"/**\n     * This method loops through the children of the specified view,\n     * recursing as necessary, and inserts pages breaks when needed.\n     * It makes a rudimentary attempt to avoid \"widows\" and \"orphans\".\n     **/\nprotected void paginate(View v, Rectangle2D allocation) {\n    // Figure out how tall this view is, and tell it to allocate\n    // that space among its children\n    double myheight = v.getPreferredSpan(View.Y_AXIS);\n    v.setSize((float) printWidth, (float) myheight);\n    // Now loop through each of the children\n    int numkids = v.getViewCount();\n    for (int i = 0; i < numkids; i++) {\n        // this is the child we're working with\n        View kid = v.getView(i);\n        // Figure out its size and location\n        Shape kidshape = v.getChildAllocation(i, allocation);\n        if (kidshape == null)\n            continue;\n        Rectangle2D kidbox = kidshape.getBounds2D();\n        // This is the Y coordinate of the bottom of the child\n        double kidpos = kidbox.getY() + kidbox.getHeight() - pageStart;\n        // I.e. we want to prevent \"widows\"\n        if ((numkids > 1) && (i == 0)) {\n            // on to the next child\n            if (kidpos < printY + printHeight * MARGIN_ADJUST)\n                continue;\n            // Otherwise, the child is near the bottom of the page, so\n            // break the page before this child and place this child on\n            // the new page.\n            breakPage(kidbox.getY());\n            continue;\n        }\n        // prevent \"orphans\"\n        if ((numkids > 1) && (i == numkids - 1)) {\n            // If it fits normally, just move on to the next one\n            if (kidpos < printY + printHeight)\n                continue;\n            // at the end of the group\n            if (kidpos < printY + printHeight / MARGIN_ADJUST) {\n                breakPage(allocation.getY() + allocation.getHeight());\n                continue;\n            }\n        }\n        // then move on to the next child.\n        if (kidpos < printY + printHeight)\n            continue;\n        // no children, then break the page before this child and continue.\n        if (kid.getViewCount() == 0) {\n            breakPage(kidbox.getY());\n            continue;\n        }\n        // If we get here, then the child did not fit on the page, but it\n        // has kids of its own, so recurse to see if any of those kids\n        // will fit on the page.\n        paginate(kid, kidbox);\n    }\n}\n         // If this is the first child of a group, then we want to ensure\n\n         // that it doesn't get left by itself at the bottom of a page.\n\n         // If this is the last child of a group, we don't want it to\n\n         // appear by itself at the top of a new page, so allow it to\n\n         // squeeze past the bottom margin if necessary.  This helps to\n\n         // If the child is not the first or last of a group, then we use\n\n         // the bottom margin strictly.  If the child fits on the page,\n\n         // If we get here, the child doesn't fit on this page.  If it has\n\n         // If it is not near the end of the page, then just move\n\n         // Otherwise, if it fits with extra space, then break the\n\n","name":"paginate","className":"PrintableDocument","variables":{"allocation":2,"kidpos":5,"kid":2,"printWidth":1,"kidbox":5,"i":5,"kidshape":3,"printHeight":4,"numkids":5,"v":5,"pageStart":1,"myheight":2,"printY":4,"MARGIN_ADJUST":2},"constants":{"0":3,"1":3,"null":1},"javaDoc":"This method loops through the children of the specified view recursing as necessary and inserts pages breaks when needed It makes a rudimentary attempt to avoid \"widows\" and \"orphans\"","comments":"Figure out how tall this view is and tell it to allocate that space among its children Now loop through each of the children If this is the first child of a group then we want to ensure that it doesn't get left by itself at the bottom of a page If this is the last child of a group we don't want it to appear by itself at the top of a new page so allow it to squeeze past the bottom margin if necessary This helps to If the child is not the first or last of a group then we use the bottom margin strictly If the child fits on the page If we get here the child doesn't fit on this page If it has If we get here then the child did not fit on the page but it has kids of its own so recurse to see if any of those kids this is the child we're working with Figure out its size and location This is the Y coordinate of the bottom of the child I e we want to prevent \"widows\" If it is not near the end of the page then just move Otherwise the child is near the bottom of the page so break the page before this child and place this child on on to the next child the new page prevent \"orphans\" Otherwise if it fits with extra space then break the If it fits normally just move on to the next one at the end of the group then move on to the next child no children then break the page before this child and continue will fit on the page \n     * This method loops through the children of the specified view,\n     * recursing as necessary, and inserts pages breaks when needed.\n     * It makes a rudimentary attempt to avoid \"widows\" and \"orphans\".\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["double"],"returnType":"void","methodCalls":{"add":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"double":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":14,"AssignExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":4},"text":"/** \n     * Break a page at the specified Y coordinate.  Store the necessary\n     * information into the pageLengths and pageOffsets lists\n     **/\nvoid breakPage(double y) {\n    double pageLength = y - pageStart - printY;\n    pageStart = y - printY;\n    pageLengths.add(new Double(pageLength));\n    pageOffsets.add(new Double(pageStart));\n}\n","name":"breakPage","className":"PrintableDocument","variables":{"pageLength":2,"pageStart":3,"y":2,"printY":2,"pageLengths":1,"pageOffsets":1},"constants":{},"javaDoc":"Break a page at the specified Y coordinate Store the necessary information into the pageLengths and pageOffsets lists","comments":" \n     * Break a page at the specified Y coordinate.  Store the necessary\n     * information into the pageLengths and pageOffsets lists\n     *","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Return the number of pages. This is a Pageable method.   */\npublic int getNumberOfPages() {\n    return numPages;\n}\n","name":"getNumberOfPages","className":"PrintableDocument","variables":{"numPages":1},"constants":{},"javaDoc":"Return the number of pages This is a Pageable method","comments":" Return the number of pages. This is a Pageable method.   ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"PageFormat","methodCalls":{"getPaper":1,"getOrientation":1,"get":1,"clone":1,"setImageableArea":2,"setPaper":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"PageFormat":1,"double":1,"Paper":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":3,"NameExpr":40,"CastExpr":2,"FieldAccessExpr":1,"EnclosedExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":6},"text":"/** \n     * Return the PageFormat object for the specified page.  This\n     * implementation uses the computed length of the page in the returned\n     * PageFormat object.  The PrinterJob will use this as a clipping region,\n     * which will prevent extraneous parts of the document from being drawn\n     * in the top and bottom margins.\n     **/\npublic PageFormat getPageFormat(int pagenum) {\n    // On the last page, just return the user-specified page format\n    if (pagenum == numPages - 1)\n        return format;\n    // Otherwise, look up the height of this page and return an\n    // appropriate PageFormat.\n    double pageLength = ((Double) pageLengths.get(pagenum)).doubleValue();\n    PageFormat f = (PageFormat) format.clone();\n    Paper p = f.getPaper();\n    if (f.getOrientation() == PageFormat.PORTRAIT)\n        p.setImageableArea(printX, printY, printWidth, pageLength);\n    else\n        p.setImageableArea(printY, printX, pageLength, printWidth);\n    f.setPaper(p);\n    return f;\n}\n","name":"getPageFormat","className":"PrintableDocument","variables":{"p":3,"numPages":1,"pageLength":1,"f":5,"format":2,"pagenum":1,"pageLengths":1},"constants":{"1":1},"javaDoc":"Return the PageFormat object for the specified page This implementation uses the computed length of the page in the returned PageFormat object The PrinterJob will use this as a clipping region which will prevent extraneous parts of the document from being drawn in the top and bottom margins","comments":"Otherwise look up the height of this page and return an On the last page just return the user-specified page format appropriate PageFormat  \n     * Return the PageFormat object for the specified page.  This\n     * implementation uses the computed length of the page in the returned\n     * PageFormat object.  The PrinterJob will use this as a clipping region,\n     * which will prevent extraneous parts of the document from being drawn\n     * in the top and bottom margins.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Printable","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * This Printable method returns the Printable object for the specified\n     * page.  Since this class implements both Pageable and Printable, it just\n     * returns this.\n     **/\npublic Printable getPrintable(int pagenum) {\n    return this;\n}\n","name":"getPrintable","className":"PrintableDocument","variables":{},"constants":{},"javaDoc":"This Printable method returns the Printable object for the specified page Since this class implements both Pageable and Printable it just returns this","comments":"\n     * This Printable method returns the Printable object for the specified\n     * page.  Since this class implements both Pageable and Printable, it just\n     * returns this.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","PageFormat","int"],"returnType":"int","methodCalls":{"getStringBounds":1,"paint":1,"getWidth":1,"drawString":1,"translate":1,"getAscent":1,"getHeight":1,"setColor":1,"getFontRenderContext":2,"get":1,"getClip":1,"getLineMetrics":1,"setClip":2,"setFont":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Shape":1,"double":1,"Rectangle2D":1,"String":1,"LineMetrics":1,"Graphics2D":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":7,"VariableDeclarationExpr":6,"BinaryExpr":12,"NameExpr":75,"StringLiteralExpr":2,"UnaryExpr":1,"AssignExpr":1,"DoubleLiteralExpr":2,"CastExpr":6,"FieldAccessExpr":1,"EnclosedExpr":6,"MethodCallExpr":17},"statements":{"IfStmt":2,"ReturnStmt":2,"ExpressionStmt":14},"text":"/**\n     * This is the basic Printable method that prints a specified page\n     **/\npublic int print(Graphics g, PageFormat format, int pageIndex) {\n    // Return an error code on attempts to print past the end of the doc\n    if (pageIndex >= numPages)\n        return NO_SUCH_PAGE;\n    // Cast the Graphics object so we can use Java2D operations\n    Graphics2D g2 = (Graphics2D) g;\n    // Display a page number centered in the area of the top margin.\n    // Set a new clipping region so we can draw into the top margin\n    // But remember the original clipping region so we can restore it\n    Shape originalClip = g.getClip();\n    g.setClip(new Rectangle(0, 0, (int) printWidth, (int) printY));\n    // Compute the header to display, measure it, then display it\n    String numString = \"- \" + (pageIndex + 1) + \" -\";\n    Rectangle2D // Get the width and height of the string\n    numBounds = headerFont.getStringBounds(numString, g2.getFontRenderContext());\n    LineMetrics // Get the ascent and descent of the font\n    metrics = headerFont.getLineMetrics(numString, g2.getFontRenderContext());\n    // Set the font\n    g.setFont(headerFont);\n    // Print with black ink\n    g.setColor(Color.black);\n    // Display the string\n    g.drawString(// Display the string\n    numString, (int) (printX + (printWidth - numBounds.getWidth()) / 2), (int) ((printY - numBounds.getHeight()) / 2 + metrics.getAscent()));\n    // Restore the clipping region\n    g.setClip(originalClip);\n    // Figure out the staring position of the page within the document\n    double pageStart = 0.0;\n    if (pageIndex > 0)\n        pageStart = ((Double) pageOffsets.get(pageIndex - 1)).doubleValue();\n    // Scroll so that the appropriate part of the document is lined up\n    // with the upper-left corner of the page\n    g2.translate(0.0, -pageStart);\n    // Now paint the entire document.  The PrinterJob will have\n    // established a clipping region, so that only the desired portion\n    // of the document will actually be drawn on this sheet of paper.\n    root.paint(g, drawRect);\n    // Finally return a success code\n    return PAGE_EXISTS;\n}\n","name":"print","className":"PrintableDocument","variables":{"headerFont":2,"numString":1,"originalClip":1,"g":7,"printWidth":2,"g2":4,"NO_SUCH_PAGE":1,"numBounds":3,"numPages":1,"pageIndex":4,"pageStart":3,"root":1,"printY":2,"metrics":2,"printX":1,"pageOffsets":1,"PAGE_EXISTS":1},"constants":{"0":3,"1":2,"2":2,"0.0":2,"\" -\"":1,"\"- \"":1},"javaDoc":"This is the basic Printable method that prints a specified page","comments":"Display a page number centered in the area of the top margin Set a new clipping region so we can draw into the top margin Scroll so that the appropriate part of the document is lined up Now paint the entire document The PrinterJob will have established a clipping region so that only the desired portion Return an error code on attempts to print past the end of the doc Cast the Graphics object so we can use Java2D operations But remember the original clipping region so we can restore it Compute the header to display measure it then display it Get the width and height of the string Get the ascent and descent of the font Set the font Print with black ink Display the string Display the string Display the string Restore the clipping region Figure out the staring position of the page within the document with the upper-left corner of the page of the document will actually be drawn on this sheet of paper Finally return a success code \n     * This is the basic Printable method that prints a specified page\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["View","ViewFactory","Container"],"returnType":"ParentView","methodCalls":{"getElement":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":2,"ThisExpr":2,"MethodCallExpr":1,"AssignExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":2},"text":"public ParentView(View v, ViewFactory viewFactory, Container container) {\n    super(v.getElement());\n    this.viewFactory = viewFactory;\n    this.container = container;\n}\n","name":"ParentView","className":"ParentView","variables":{"container":1,"v":1,"viewFactory":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ViewFactory","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These methods return key pieces of information required by\n// the View hierarchy.\npublic ViewFactory getViewFactory() {\n    return viewFactory;\n}\n","name":"getViewFactory","className":"ParentView","variables":{"viewFactory":1},"constants":{},"javaDoc":"","comments":" the View hierarchy.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Container","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Container getContainer() {\n    return container;\n}\n","name":"getContainer","className":"ParentView","variables":{"container":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics","Shape"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// These methods are abstract in View, so we've got to provide\n// dummy implementations of them here, even though they're never used.\npublic void paint(Graphics g, Shape allocation) {\n}\n","name":"paint","className":"ParentView","variables":{},"constants":{},"javaDoc":"","comments":" dummy implementations of them here, even though they're never used.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getPreferredSpan(int axis) {\n    return 0.0f;\n}\n","name":"getPreferredSpan","className":"ParentView","variables":{},"constants":{"0.0f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["float","float","Shape","Position.Bias[]"],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {\n    return 0;\n}\n","name":"viewToModel","className":"ParentView","variables":{},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","Shape","Position.Bias"],"returnType":"Shape","methodCalls":{},"annotations":[],"exceptions":["BadLocationException"],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {\n    return a;\n}\n","name":"modelToView","className":"ParentView","variables":{"a":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame","GUIResourceBundle"],"returnType":"ThemeManager","methodCalls":{"setTheme":1,"getDefaultThemeName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":4},"text":"/** \n     * Build a ThemeManager for the frame and resource bundle.  If there\n     * is a default theme specified, apply it to the frame\n     **/\npublic ThemeManager(JFrame frame, GUIResourceBundle resources) {\n    this.frame = frame;\n    this.resources = resources;\n    String defaultName = getDefaultThemeName();\n    if (defaultName != null)\n        setTheme(defaultName);\n}\n","name":"ThemeManager","className":"ThemeManager","variables":{"resources":1,"defaultName":2,"frame":1},"constants":{"null":1},"javaDoc":"Build a ThemeManager for the frame and resource bundle If there is a default theme specified apply it to the frame","comments":" \n     * Build a ThemeManager for the frame and resource bundle.  If there\n     * is a default theme specified, apply it to the frame\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"updateComponentTreeUI":1,"setLookAndFeel":1,"setCurrentTheme":1},"annotations":[],"exceptions":["UnsupportedLookAndFeelException"],"concepts":["ExceptionHandling"],"types":{"Theme":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":1,"NameExpr":13,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"/** Look up the named theme, and apply it to the frame */\npublic void setTheme(String themeName) {\n    // Look up the theme in the resource bundle\n    Theme theme = new Theme(resources, themeName);\n    // Make it the current theme\n    MetalLookAndFeel.setCurrentTheme(theme);\n    // Re-apply the Metal look-and-feel to install new theme\n    try {\n        UIManager.setLookAndFeel(new MetalLookAndFeel());\n    } catch (UnsupportedLookAndFeelException e) {\n    }\n    // Propagate the new l&f across the entire component tree of the frame\n    SwingUtilities.updateComponentTreeUI(frame);\n}\n","name":"setTheme","className":"ThemeManager","variables":{"themeName":1,"e":1,"resources":1,"UIManager":1,"theme":1,"SwingUtilities":1,"MetalLookAndFeel":1},"constants":{},"javaDoc":"Look up the named theme and apply it to the frame","comments":"Look up the theme in the resource bundle Make it the current theme Re-apply the Metal look-and-feel to install new theme Propagate the new l&f across the entire component tree of the frame  Look up the named theme, and apply it to the frame ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"String","methodCalls":{"getString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the \"display name\" or label of the named theme */\npublic String getDisplayName(String themeName) {\n    return resources.getString(themeName + \".name\", null);\n}\n","name":"getDisplayName","className":"ThemeManager","variables":{"themeName":1,"resources":1},"constants":{"null":1,"\".name\"":1},"javaDoc":"Get the \"display name\" or label of the named theme","comments":" Get the \"display name\" or label of the named theme ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{"getString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":3,"StringLiteralExpr":1,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Get the name of the default theme, or null */\npublic String getDefaultThemeName() {\n    return resources.getString(\"defaultTheme\", null);\n}\n","name":"getDefaultThemeName","className":"ThemeManager","variables":{"resources":1},"constants":{"null":1,"\"defaultTheme\"":1},"javaDoc":"Get the name of the default theme or null","comments":" Get the name of the default theme, or null ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String[]","methodCalls":{"size":1,"toArray":1,"getStringList":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.util.List":1},"expressions":{"VariableDeclarationExpr":1,"NameExpr":9,"StringLiteralExpr":1,"CastExpr":1,"ArrayCreationExpr":1,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":1},"text":"/**\n     * Get the list of all known theme names.  The returned values are\n     * theme property names, not theme display names.\n     **/\npublic String[] getAllThemeNames() {\n    java.util.List names = resources.getStringList(\"themelist\");\n    return (String[]) names.toArray(new String[names.size()]);\n}\n","name":"getAllThemeNames","className":"ThemeManager","variables":{"names":3,"resources":1},"constants":{"\"themelist\"":1},"javaDoc":"Get the list of all known theme names The returned values are theme property names not theme display names","comments":"\n     * Get the list of all known theme names.  The returned values are\n     * theme property names, not theme display names.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setTheme":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent event) {\n    setTheme(themeName);\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"JMenu","methodCalls":{"add":2,"getAllThemeNames":1,"getDisplayName":1,"setSelected":1,"equals":1,"addActionListener":1,"setTheme":1,"getDefaultThemeName":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"ButtonGroup":1,"String[]":1,"String":3,"JMenuItem":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":38,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":1,"BlockStmt":2,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":11},"text":"/**\n     * Get a JMenu that lists all known themes by display name and\n     * installs any selected theme.\n     **/\npublic JMenu getThemeMenu() {\n    String[] names = getAllThemeNames();\n    String defaultName = getDefaultThemeName();\n    JMenu menu = new JMenu(\"Themes\");\n    ButtonGroup buttongroup = new ButtonGroup();\n    for (int i = 0; i < names.length; i++) {\n        final String themeName = names[i];\n        String displayName = getDisplayName(themeName);\n        JMenuItem item = menu.add(new JRadioButtonMenuItem(displayName));\n        buttongroup.add(item);\n        if (themeName.equals(defaultName))\n            item.setSelected(true);\n        item.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent event) {\n                setTheme(themeName);\n            }\n        });\n    }\n    return menu;\n}\n","name":"getThemeMenu","className":"ThemeManager","variables":{"actionPerformed":1,"themeName":2,"item":3,"names":2,"displayName":2,"i":4,"menu":3,"buttongroup":2,"event":1,"defaultName":1},"constants":{"0":1,"true":1,"\"Themes\"":1},"javaDoc":"Get a JMenu that lists all known themes by display name and installs any selected theme","comments":"\n     * Get a JMenu that lists all known themes by display name and\n     * installs any selected theme.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String"],"returnType":"Theme","methodCalls":{"getControlTextFont":1,"getSubTextFont":1,"getWindowTitleFont":1,"getSystemTextFont":1,"brighter":4,"getMenuTextFont":1,"getUserTextFont":1,"getColor":2,"getFont":6,"getString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":2,"DefaultMetalTheme":1,"Font":6},"expressions":{"ObjectCreationExpr":15,"NullLiteralExpr":17,"IntegerLiteralExpr":6,"VariableDeclarationExpr":9,"BinaryExpr":17,"NameExpr":103,"StringLiteralExpr":9,"AssignExpr":21,"MethodCallExpr":19},"statements":{"IfStmt":8,"ExpressionStmt":30},"text":"/**\n\t * This constructor reads all the values it needs from the\n\t * GUIResourceBundle.  It uses intelligent defaults if properties\n\t * are not specified.\n\t **/\npublic Theme(GUIResourceBundle resources, String name) {\n    // Use this theme object to get default font values from\n    DefaultMetalTheme defaultTheme = new DefaultMetalTheme();\n    // Look up the display name of the theme\n    displayName = resources.getString(name + \".name\", null);\n    // Look up the fonts for the theme\n    Font control = resources.getFont(name + \".controlFont\", null);\n    Font menu = resources.getFont(name + \".menuFont\", null);\n    Font small = resources.getFont(name + \".smallFont\", null);\n    Font system = resources.getFont(name + \".systemFont\", null);\n    Font user = resources.getFont(name + \".userFont\", null);\n    Font title = resources.getFont(name + \".titleFont\", null);\n    // Convert fonts to FontUIResource, or get defaults\n    if (control != null)\n        controlFont = new FontUIResource(control);\n    else\n        controlFont = defaultTheme.getControlTextFont();\n    if (menu != null)\n        menuFont = new FontUIResource(menu);\n    else\n        menuFont = defaultTheme.getMenuTextFont();\n    if (small != null)\n        smallFont = new FontUIResource(small);\n    else\n        smallFont = defaultTheme.getSubTextFont();\n    if (system != null)\n        systemFont = new FontUIResource(system);\n    else\n        systemFont = defaultTheme.getSystemTextFont();\n    if (user != null)\n        userFont = new FontUIResource(user);\n    else\n        userFont = defaultTheme.getUserTextFont();\n    if (title != null)\n        titleFont = new FontUIResource(title);\n    else\n        titleFont = defaultTheme.getWindowTitleFont();\n    // Look up primary and secondary colors\n    Color primary = resources.getColor(name + \".primary\", null);\n    Color secondary = resources.getColor(name + \".secondary\", null);\n    // Derive all six colors from these two, using defaults if needed\n    if (primary != null)\n        primary1 = new ColorUIResource(primary);\n    else\n        primary1 = new ColorUIResource(102, 102, 153);\n    primary2 = new ColorUIResource(primary1.brighter());\n    primary3 = new ColorUIResource(primary2.brighter());\n    if (secondary != null)\n        secondary1 = new ColorUIResource(secondary);\n    else\n        secondary1 = new ColorUIResource(102, 102, 102);\n    secondary2 = new ColorUIResource(secondary1.brighter());\n    secondary3 = new ColorUIResource(secondary2.brighter());\n}\n","name":"Theme","className":"Theme","variables":{"small":3,"displayName":1,"resources":9,"control":3,"titleFont":2,"primary1":3,"menu":3,"title":3,"userFont":2,"smallFont":2,"controlFont":2,"secondary":3,"menuFont":2,"system":3,"primary2":2,"secondary1":3,"defaultTheme":7,"systemFont":2,"primary3":1,"secondary3":1,"secondary2":2,"name":9,"user":3,"primary":3},"constants":{"\".userFont\"":1,"\".controlFont\"":1,"\".secondary\"":1,"102":5,"null":17,"\".name\"":1,"\".smallFont\"":1,"\".menuFont\"":1,"\".systemFont\"":1,"\".titleFont\"":1,"\".primary\"":1,"153":1},"javaDoc":"This constructor reads all the values it needs from the GUIResourceBundle It uses intelligent defaults if properties are not specified","comments":"Use this theme object to get default font values from Look up the display name of the theme Look up the fonts for the theme Convert fonts to FontUIResource or get defaults Look up primary and secondary colors Derive all six colors from these two using defaults if needed \n\t * This constructor reads all the values it needs from the\n\t * GUIResourceBundle.  It uses intelligent defaults if properties\n\t * are not specified.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These methods override DefaultMetalTheme and return the property\n// values we looked up and computed for this theme\npublic String getName() {\n    return displayName;\n}\n","name":"getName","className":"Theme","variables":{"displayName":1},"constants":{},"javaDoc":"","comments":" values we looked up and computed for this theme","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getControlTextFont() {\n    return controlFont;\n}\n","name":"getControlTextFont","className":"Theme","variables":{"controlFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getSystemTextFont() {\n    return systemFont;\n}\n","name":"getSystemTextFont","className":"Theme","variables":{"systemFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getUserTextFont() {\n    return userFont;\n}\n","name":"getUserTextFont","className":"Theme","variables":{"userFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getMenuTextFont() {\n    return menuFont;\n}\n","name":"getMenuTextFont","className":"Theme","variables":{"menuFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getWindowTitleFont() {\n    return titleFont;\n}\n","name":"getWindowTitleFont","className":"Theme","variables":{"titleFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"FontUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public FontUIResource getSubTextFont() {\n    return smallFont;\n}\n","name":"getSubTextFont","className":"Theme","variables":{"smallFont":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getPrimary1() {\n    return primary1;\n}\n","name":"getPrimary1","className":"Theme","variables":{"primary1":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getPrimary2() {\n    return primary2;\n}\n","name":"getPrimary2","className":"Theme","variables":{"primary2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getPrimary3() {\n    return primary3;\n}\n","name":"getPrimary3","className":"Theme","variables":{"primary3":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getSecondary1() {\n    return secondary1;\n}\n","name":"getSecondary1","className":"Theme","variables":{"secondary1":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getSecondary2() {\n    return secondary2;\n}\n","name":"getSecondary2","className":"Theme","variables":{"secondary2":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"ColorUIResource","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"protected ColorUIResource getSecondary3() {\n    return secondary3;\n}\n","name":"getSecondary3","className":"Theme","variables":{"secondary3":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int","int","int","int"],"returnType":"ColumnLayout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"FieldAccessExpr":4,"ThisExpr":4,"AssignExpr":4},"statements":{"ExpressionStmt":4},"text":"/** The constructor.  See comment above for meanings of these arguments */\npublic ColumnLayout(int margin_height, int margin_width, int spacing, int alignment) {\n    this.margin_height = margin_height;\n    this.margin_width = margin_width;\n    this.spacing = spacing;\n    this.alignment = alignment;\n}\n","name":"ColumnLayout","className":"ColumnLayout","variables":{"margin_height":1,"spacing":1,"alignment":1,"margin_width":1},"constants":{},"javaDoc":"The constructor See comment above for meanings of these arguments","comments":" The constructor.  See comment above for meanings of these arguments ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ColumnLayout","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"NameExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * A default constructor that creates a ColumnLayout using 5-pixel\n     * margin width and height, 5-pixel spacing, and left alignment\n     **/\npublic ColumnLayout() {\n    this(5, 5, 5, LEFT);\n}\n","name":"ColumnLayout","className":"ColumnLayout","variables":{"LEFT":1},"constants":{"5":3},"javaDoc":"A default constructor that creates a ColumnLayout using 5-pixel margin width and height 5-pixel spacing and left alignment","comments":"\n     * A default constructor that creates a ColumnLayout using 5-pixel\n     * margin width and height, 5-pixel spacing, and left alignment\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"void","methodCalls":{"getComponentCount":1,"getSize":1,"getPreferredSize":1,"getInsets":1,"getComponent":1,"isVisible":1,"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Insets":1,"Dimension":2,"Component":1,"int":5},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":9,"BinaryExpr":9,"NameExpr":71,"FieldAccessExpr":10,"EnclosedExpr":1,"UnaryExpr":2,"MethodCallExpr":7,"AssignExpr":5},"statements":{"ContinueStmt":1,"SwitchStmt":1,"IfStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":4,"ForStmt":1,"ExpressionStmt":14},"text":"/**\n     * The method that actually performs the layout.\n     * Called by the Container\n     **/\npublic void layoutContainer(Container parent) {\n    Insets insets = parent.getInsets();\n    Dimension parent_size = parent.getSize();\n    Component kid;\n    int nkids = parent.getComponentCount();\n    // The base X position\n    int x0 = insets.left + margin_width;\n    int x;\n    // Start at the top of the column\n    int y = insets.top + margin_height;\n    for (int i = 0; i < nkids; i++) {\n        // Loop through the kids\n        // Get the kid\n        kid = parent.getComponent(i);\n        // Skip hidden ones\n        if (!kid.isVisible())\n            continue;\n        // How big is it?\n        Dimension pref = kid.getPreferredSize();\n        switch(// Compute X coordinate\n        alignment) {\n            default:\n            case LEFT:\n                x = x0;\n                break;\n            case CENTER:\n                x = (parent_size.width - pref.width) / 2;\n                break;\n            case RIGHT:\n                x = parent_size.width - insets.right - margin_width - pref.width;\n                break;\n        }\n        // Set the size and position of this kid\n        kid.setBounds(x, y, pref.width, pref.height);\n        // Get Y position of the next one\n        y += pref.height + spacing;\n    }\n}\n","name":"layoutContainer","className":"ColumnLayout","variables":{"margin_height":1,"parent":4,"LEFT":1,"insets":1,"kid":5,"i":3,"CENTER":1,"spacing":1,"parent_size":1,"pref":1,"x0":2,"x":4,"y":2,"RIGHT":1,"nkids":2,"alignment":1,"margin_width":2},"constants":{"0":1,"2":1},"javaDoc":"The method that actually performs the layout Called by the Container","comments":"The base X position Start at the top of the column Loop through the kids Get the kid Skip hidden ones How big is it? Compute X coordinate Set the size and position of this kid Get Y position of the next one \n     * The method that actually performs the layout.\n     * Called by the Container\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout should to be */\npublic Dimension preferredLayoutSize(Container parent) {\n    return layoutSize(parent, 1);\n}\n","name":"preferredLayoutSize","className":"ColumnLayout","variables":{},"constants":{"1":1},"javaDoc":"The Container calls this to find out how big the layout should to be","comments":" The Container calls this to find out how big the layout should to be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout must be */\npublic Dimension minimumLayoutSize(Container parent) {\n    return layoutSize(parent, 2);\n}\n","name":"minimumLayoutSize","className":"ColumnLayout","variables":{},"constants":{"2":1},"javaDoc":"The Container calls this to find out how big the layout must be","comments":" The Container calls this to find out how big the layout must be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"Dimension","methodCalls":{"layoutSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** The Container calls this to find out how big the layout can be */\npublic Dimension maximumLayoutSize(Container parent) {\n    return layoutSize(parent, 3);\n}\n","name":"maximumLayoutSize","className":"ColumnLayout","variables":{},"constants":{"3":1},"javaDoc":"The Container calls this to find out how big the layout can be","comments":" The Container calls this to find out how big the layout can be ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container","int"],"returnType":"Dimension","methodCalls":{"getComponentCount":1,"getMaximumSize":1,"getPreferredSize":1,"getMinimumSize":1,"getInsets":1,"getComponent":1,"isVisible":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Insets":1,"Dimension":2,"Component":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":10,"VariableDeclarationExpr":7,"BinaryExpr":13,"NameExpr":76,"FieldAccessExpr":13,"EnclosedExpr":1,"UnaryExpr":3,"MethodCallExpr":7,"AssignExpr":8},"statements":{"ContinueStmt":1,"IfStmt":5,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":15},"text":"// Compute min, max, or preferred size of all the visible children\nprotected Dimension layoutSize(Container parent, int sizetype) {\n    int nkids = parent.getComponentCount();\n    Dimension size = new Dimension(0, 0);\n    Insets insets = parent.getInsets();\n    int num_visible_kids = 0;\n    // Compute maximum width and total height of all visible kids\n    for (int i = 0; i < nkids; i++) {\n        Component kid = parent.getComponent(i);\n        Dimension d;\n        if (!kid.isVisible())\n            continue;\n        num_visible_kids++;\n        if (sizetype == 1)\n            d = kid.getPreferredSize();\n        else if (sizetype == 2)\n            d = kid.getMinimumSize();\n        else\n            d = kid.getMaximumSize();\n        if (d.width > size.width)\n            size.width = d.width;\n        size.height += d.height;\n    }\n    // Now add in margins and stuff\n    size.width += insets.left + insets.right + 2 * margin_width;\n    size.height += insets.top + insets.bottom + 2 * margin_height;\n    if (num_visible_kids > 1)\n        size.height += (num_visible_kids - 1) * spacing;\n    return size;\n}\n","name":"layoutSize","className":"ColumnLayout","variables":{"margin_height":1,"parent":3,"sizetype":2,"spacing":1,"size":2,"d":4,"insets":1,"kid":5,"i":3,"nkids":2,"margin_width":1,"num_visible_kids":4},"constants":{"0":4,"1":3,"2":3},"javaDoc":"","comments":"Compute maximum width and total height of all visible kids Now add in margins and stuff  Compute min, max, or preferred size of all the visible children","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["String","Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// Other LayoutManager(2) methods that are unused by this class\npublic void addLayoutComponent(String constraint, Component comp) {\n}\n","name":"addLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","comments":" Other LayoutManager(2) methods that are unused by this class","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void addLayoutComponent(Component comp, Object constraint) {\n}\n","name":"addLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void removeLayoutComponent(Component comp) {\n}\n","name":"removeLayoutComponent","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void invalidateLayout(Container parent) {\n}\n","name":"invalidateLayout","className":"ColumnLayout","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getLayoutAlignmentX(Container parent) {\n    return 0.5f;\n}\n","name":"getLayoutAlignmentX","className":"ColumnLayout","variables":{},"constants":{"0.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Container"],"returnType":"float","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"DoubleLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public float getLayoutAlignmentY(Container parent) {\n    return 0.5f;\n}\n","name":"getLayoutAlignmentY","className":"ColumnLayout","variables":{},"constants":{"0.5f":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setJMenuBar":1,"add":2,"setVisible":1,"getClass":1,"addTab":1,"getName":1,"getContentPane":1,"pack":1,"substring":1,"addWindowListener":1,"exit":1,"lastIndexOf":1,"getComponentsFromArgs":1,"size":1,"createPlafMenu":1,"elementAt":1},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"JFrame":1,"JTabbedPane":1,"String":2,"Component":1,"Vector":1,"JMenuBar":1,"JMenu":1,"int":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":3,"VariableDeclarationExpr":9,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":59,"StringLiteralExpr":1,"CastExpr":1,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":17},"statements":{"BlockStmt":2,"ForStmt":1,"ExpressionStmt":16},"text":"// The main program\npublic static void main(String[] args) {\n    // Process the command line to get the components to display\n    Vector components = getComponentsFromArgs(args);\n    // Create a frame (a window) to display them in\n    JFrame frame = new JFrame(\"ShowComponent\");\n    // Handle window close requests by exiting the VM\n    frame.addWindowListener(new // Anonymous inner class\n    WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Set up a menu system that allows the user to select the \n    // look-and-feel of the component from a list of installed PLAFs\n    // Create a menubar\n    JMenuBar menubar = new JMenuBar();\n    // Tell the frame to display it\n    frame.setJMenuBar(menubar);\n    // Create a menu\n    JMenu plafmenu = createPlafMenu(frame);\n    // Add the menu to the menubar\n    menubar.add(plafmenu);\n    // Create a JTabbedPane to display each of the components\n    JTabbedPane pane = new JTabbedPane();\n    // Use the unqualified component classname as the tab text\n    for (int i = 0; i < components.size(); i++) {\n        Component c = (Component) components.elementAt(i);\n        String classname = c.getClass().getName();\n        String tabname = classname.substring(classname.lastIndexOf('.') + 1);\n        pane.addTab(tabname, c);\n    }\n    // Add the tabbed pane to the frame.  Note the call to getContentPane()\n    // This is required for JFrame, but not for most Swing components\n    frame.getContentPane().add(pane);\n    // Set the frame size and pop it up\n    // Make frame as big as its kids need \n    frame.pack();\n    // Make the frame visible on the screen\n    frame.setVisible(true);\n// The main() method exits now but the Java VM keeps running because\n// all AWT programs automatically start an event-handling thread.\n}\n     // Now add each component as a tab of the tabbed pane\n\n","name":"main","className":"ShowComponent","variables":{"menubar":2,"tabname":1,"components":3,"c":2,"classname":3,"e":1,"windowClosing":1,"i":3,"plafmenu":1,"pane":2,"System":1,"frame":6},"constants":{"0":2,"'.'":1,"1":1,"\"ShowComponent\"":1,"true":1},"javaDoc":"","comments":"Set up a menu system that allows the user to select the look-and-feel of the component from a list of installed PLAFs Now add each component as a tab of the tabbed pane Add the tabbed pane to the frame Note the call to getContentPane() Set the frame size and pop it up The main() method exits now but the Java VM keeps running because all AWT programs automatically start an event-handling thread Process the command line to get the components to display Create a frame (a window) to display them in Handle window close requests by exiting the VM Anonymous inner class Create a menubar Tell the frame to display it Create a menu Add the menu to the menubar Create a JTabbedPane to display each of the components Use the unqualified component classname as the tab text This is required for JFrame but not for most Swing components Make frame as big as its kids need Make the frame visible on the screen  The main program","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"updateComponentTreeUI":1,"setLookAndFeel":1,"System.err.println":1,"pack":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":4},"text":"public void actionPerformed(ActionEvent e) {\n    try {\n        // Set the new look and feel\n        UIManager.setLookAndFeel(plafClassName);\n        // Tell each component to change its look-and-feel\n        SwingUtilities.updateComponentTreeUI(frame);\n        // Tell the frame to resize itself to the its\n        // children's new desired sizes\n        frame.pack();\n    } catch (Exception ex) {\n        System.err.println(ex);\n    }\n}\n","name":"actionPerformed","className":"","variables":{"ex":1,"UIManager":1,"SwingUtilities":1,"frame":1},"constants":{},"javaDoc":"","comments":"Tell the frame to resize itself to the its Set the new look and feel Tell each component to change its look-and-feel children's new desired sizes ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JFrame"],"returnType":"JMenu","methodCalls":{"add":2,"updateComponentTreeUI":1,"getInstalledLookAndFeels":1,"addActionListener":1,"setLookAndFeel":1,"System.err.println":1,"pack":1},"annotations":[],"exceptions":["Exception"],"concepts":["InnerMethod","FinalVariables","ExceptionHandling"],"types":{"ButtonGroup":1,"String":2,"JMenuItem":1,"JMenu":1,"int":1,"UIManager.LookAndFeelInfo[]":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":1,"VariableDeclarationExpr":7,"ArrayAccessExpr":2,"BinaryExpr":1,"StringLiteralExpr":1,"NameExpr":47,"FieldAccessExpr":2,"UnaryExpr":1,"MethodCallExpr":10},"statements":{"BlockStmt":4,"TryStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":12},"text":"/**\n     * This static method queries the system to find out what Pluggable\n     * Look-and-Feel (PLAF) implementations are available.  Then it creates a\n     * JMenu component that lists each of the implementations by name and\n     * allows the user to select one of them using JRadioButtonMenuItem\n     * components.  When the user selects one, the selected menu item\n     * traverses the component hierarchy and tells all components to use the\n     * new PLAF.\n     **/\npublic static JMenu createPlafMenu(final JFrame frame) {\n    // Create the menu\n    JMenu plafmenu = new JMenu(\"Look and Feel\");\n    // Create an object used for radio button mutual exclusion\n    ButtonGroup radiogroup = new ButtonGroup();\n    // Look up the available look and feels\n    UIManager.LookAndFeelInfo[] plafs = UIManager.getInstalledLookAndFeels();\n    // Loop through the plafs, and add a menu item for each one\n    for (int i = 0; i < plafs.length; i++) {\n        String plafName = plafs[i].getName();\n        final String plafClassName = plafs[i].getClassName();\n        // Create the menu item\n        JMenuItem item = plafmenu.add(new JRadioButtonMenuItem(plafName));\n        // Tell the menu item what to do when it is selected\n        item.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    // Set the new look and feel\n                    UIManager.setLookAndFeel(plafClassName);\n                    // Tell each component to change its look-and-feel\n                    SwingUtilities.updateComponentTreeUI(frame);\n                    // Tell the frame to resize itself to the its\n                    // children's new desired sizes\n                    frame.pack();\n                } catch (Exception ex) {\n                    System.err.println(ex);\n                }\n            }\n        });\n        // Only allow one menu item to be selected at once\n        radiogroup.add(item);\n    }\n    return plafmenu;\n}\n","name":"createPlafMenu","className":"ShowComponent","variables":{"plafName":2,"item":2,"e":1,"plafClassName":1,"UIManager":2,"i":5,"plafs":3,"actionPerformed":1,"ex":1,"radiogroup":2,"plafmenu":3,"SwingUtilities":1,"frame":1},"constants":{"0":1,"\"Look and Feel\"":1},"javaDoc":"This static method queries the system to find out what Pluggable Look-and-Feel (PLAF) implementations are available Then it creates a JMenu component that lists each of the implementations by name and allows the user to select one of them using JRadioButtonMenuItem components When the user selects one the selected menu item traverses the component hierarchy and tells all components to use the new PLAF","comments":"Create the menu Create an object used for radio button mutual exclusion Look up the available look and feels Loop through the plafs and add a menu item for each one Create the menu item Tell the menu item what to do when it is selected Tell the frame to resize itself to the its Set the new look and feel Tell each component to change its look-and-feel children's new desired sizes Only allow one menu item to be selected at once \n     * This static method queries the system to find out what Pluggable\n     * Look-and-Feel (PLAF) implementations are available.  Then it creates a\n     * JMenu component that lists each of the implementations by name and\n     * allows the user to select one of them using JRadioButtonMenuItem\n     * components.  When the user selects one, the selected menu item\n     * traverses the component hierarchy and tells all components to use the\n     * new PLAF.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"Vector","methodCalls":{"getName":2,"forName":1,"valueOf":2,"newInstance":1,"getPropertyDescriptors":1,"invoke":1,"decode":2,"getBeanInfo":1,"exit":1,"equals":1,"addElement":1,"System.err.println":5,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"BeanInfo":1,"Class":2,"PropertyDescriptor[]":1,"String":2,"Method":1,"Component":1,"Vector":1,"Object[]":1,"int":3},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":12,"VariableDeclarationExpr":13,"ArrayAccessExpr":13,"BinaryExpr":25,"NameExpr":143,"StringLiteralExpr":11,"CharLiteralExpr":1,"UnaryExpr":3,"AssignExpr":7,"NullLiteralExpr":4,"CastExpr":1,"FieldAccessExpr":8,"ClassExpr":5,"ArrayCreationExpr":1,"MethodCallExpr":26},"statements":{"ContinueStmt":5,"IfStmt":9,"BlockStmt":18,"TryStmt":3,"ForStmt":2,"ReturnStmt":1,"ExpressionStmt":27,"LabeledStmt":1},"text":"/**\n     * This method loops through the command line arguments looking for\n     * class names of components to create and property settings for those\n     * components in the form name=value.  This method demonstrates \n     * reflection and JavaBeans introspection as they can be applied to\n     * dynamically created GUIs\n     **/\npublic static Vector getComponentsFromArgs(String[] args) {\n    // List of components to return\n    Vector components = new Vector();\n    // The current component \n    Component component = null;\n    // Properties of the component\n    PropertyDescriptor[] properties = null;\n    // We'll use this below\n    Object[] methodArgs = new Object[1];\n    nextarg: // This is a labeled loop\n    for (int i = 0; i < args.length; i++) {\n        // Loop through all arguments\n        // If the argument does not contain an equal sign, then it is\n        // a component class name.  Otherwise it is a property setting\n        int equalsPos = args[i].indexOf('=');\n        if (equalsPos == -1) {\n            // Its the name of a component\n            try {\n                // Load the named component class\n                Class componentClass = Class.forName(args[i]);\n                // Instantiate it to create the component instance\n                component = (Component) componentClass.newInstance();\n                // Use JavaBeans to introspect the component\n                // And get the list of properties it supports\n                BeanInfo componentBeanInfo = Introspector.getBeanInfo(componentClass);\n                properties = componentBeanInfo.getPropertyDescriptors();\n            } catch (Exception e) {\n                System.out.println(\"Can't load, instantiate, \" + \"or introspect: \" + args[i]);\n                System.exit(1);\n            }\n            // If we succeeded, store the component in the vector\n            components.addElement(component);\n        } else {\n            // The arg is a name=value property specification \n            // property name\n            String name = args[i].substring(0, equalsPos);\n            // property value\n            String value = args[i].substring(equalsPos + 1);\n            // If we don't have a component to set this property on, skip!\n            if (component == null)\n                continue nextarg;\n            // component to find one with the same name.\n            for (int p = 0; p < properties.length; p++) {\n                if (properties[p].getName().equals(name)) {\n                    // Okay, we found a property of the right name.\n                    // Now get its type, and the setter method\n                    Class type = properties[p].getPropertyType();\n                    Method setter = properties[p].getWriteMethod();\n                    // Check if property is read-only!\n                    if (setter == null) {\n                        System.err.println(\"Property \" + name + \" is read-only\");\n                        // continue with next argument\n                        continue nextarg;\n                    }\n                    // be easily passed when we invoke the property setter\n                    try {\n                        if (type == String.class) {\n                            // no conversion needed\n                            methodArgs[0] = value;\n                        } else if (type == int.class) {\n                            // String to int\n                            methodArgs[0] = Integer.valueOf(value);\n                        } else if (type == boolean.class) {\n                            // to boolean\n                            methodArgs[0] = Boolean.valueOf(value);\n                        } else if (type == Color.class) {\n                            // to Color\n                            methodArgs[0] = Color.decode(value);\n                        } else if (type == Font.class) {\n                            // String to Font\n                            methodArgs[0] = Font.decode(value);\n                        } else {\n                            // If we can't convert, ignore the property\n                            System.err.println(\"Property \" + name + \" is of unsupported type \" + type.getName());\n                            continue nextarg;\n                        }\n                    } catch (Exception e) {\n                        System.err.println(\"Can't convert  '\" + value + \"' to type \" + type.getName() + \" for property \" + name);\n                        continue nextarg;\n                    }\n                    // in the converted property value.\n                    try {\n                        setter.invoke(component, methodArgs);\n                    } catch (Exception e) {\n                        System.err.println(\"Can't set property: \" + name);\n                    }\n                    // Now go on to next command-line arg\n                    continue nextarg;\n                }\n            }\n            // If we get here, we didn't find the named property\n            System.err.println(\"Warning: No such property: \" + name);\n        }\n    }\n    return components;\n}\n             // If any step failed, print an error and exit\n\n         // Now look through the properties descriptors for this\n\n             // Try to convert the property value to the right type\n\n             // We support a small set of common property types here\n\n             // Store the converted value in an Object[] so it can\n\n             // Finally, use reflection to invoke the property\n\n             // setter method of the component we created, and pass\n\n                 // If conversion failed, continue with the next arg\n\n","name":"getComponentsFromArgs","className":"ShowComponent","variables":{"methodArgs":6,"components":3,"componentClass":2,"e":3,"Color":1,"i":8,"Introspector":1,"type":8,"System":1,"Font":1,"args":5,"p":6,"Integer":1,"component":3,"componentBeanInfo":2,"name":6,"Class":1,"setter":3,"Boolean":1,"value":3,"properties":5,"equalsPos":3},"constants":{"\"or introspect: \"":1,"\"Can't convert  '\"":1,"\"Can't load, instantiate, \"":1,"\"Property \"":2,"0":8,"\" is of unsupported type \"":1,"\"Warning: No such property: \"":1,"1":4,"'='":1,"null":4,"\"Can't set property: \"":1,"\" for property \"":1,"\" is read-only\"":1,"\"' to type \"":1},"javaDoc":"This method loops through the command line arguments looking for class names of components to create and property settings for those components in the form name=value This method demonstrates reflection and JavaBeans introspection as they can be applied to dynamically created GUIs","comments":"List of components to return The current component Properties of the component We'll use this below This is a labeled loop Loop through all arguments If the argument does not contain an equal sign then it is a component class name Otherwise it is a property setting Its the name of a component Use JavaBeans to introspect the component Load the named component class Instantiate it to create the component instance And get the list of properties it supports If any step failed print an error and exit If we succeeded store the component in the vector The arg is a name=value property specification Now look through the properties descriptors for this property name property value If we don't have a component to set this property on skip! component to find one with the same name Okay we found a property of the right name Try to convert the property value to the right type We support a small set of common property types here Store the converted value in an Object[] so it can Finally use reflection to invoke the property setter method of the component we created and pass Now get its type and the setter method Check if property is read-only! continue with next argument be easily passed when we invoke the property setter no conversion needed String to int to boolean to Color String to Font If we can't convert ignore the property If conversion failed continue with the next arg in the converted property value Now go on to next command-line arg If we get here we didn't find the named property \n     * This method loops through the command line arguments looking for\n     * class names of components to create and property settings for those\n     * components in the form name=value.  This method demonstrates \n     * reflection and JavaBeans introspection as they can be applied to\n     * dynamically created GUIs\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Class[] getResourceTypes() {\n    return supportedTypes;\n}\n","name":"getResourceTypes","className":"ActionParser","variables":{"supportedTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{"getInt":1,"getResource":3,"get":2,"getBoolean":1,"getString":2,"put":2},"annotations":[],"exceptions":["java.util.MissingResourceException"],"concepts":["Casting"],"types":{"Action":1,"boolean":1,"HashMap":1,"Command":1,"KeyStroke":1,"String":2,"Icon":1,"int":1},"expressions":{"NullLiteralExpr":6,"ObjectCreationExpr":2,"VariableDeclarationExpr":9,"BinaryExpr":8,"BooleanLiteralExpr":1,"CastExpr":5,"NameExpr":62,"StringLiteralExpr":6,"ClassExpr":3,"FieldAccessExpr":1,"MethodCallExpr":11,"AssignExpr":2},"statements":{"IfStmt":2,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":13},"text":"public Object parse(GUIResourceBundle bundle, String key, Class type) throws java.util.MissingResourceException {\n    // Look up the Action cache associated with this bundle\n    HashMap cache = (HashMap) bundleToCacheMap.get(bundle);\n    if (cache == null) {\n        // If there isn't one, create one and save it\n        cache = new HashMap();\n        bundleToCacheMap.put(bundle, cache);\n    }\n    // Now look up the Action associated with the key in the cache.\n    Action action = (Action) cache.get(key);\n    // If we found a cached action, return it.\n    if (action != null)\n        return action;\n    // If there was no cached action create one.  The command is\n    // the only required resource.  It will throw an exception if\n    // missing or malformed.\n    Command command = (Command) bundle.getResource(key, Command.class);\n    // The remaining calls all supply default values, so they will not\n    // throw exceptions, even if ResourceParsers haven't been registered\n    // for types like Icon and KeyStroke\n    String label = bundle.getString(key + \".label\", null);\n    Icon icon = (Icon) bundle.getResource(key + \".icon\", Icon.class, null);\n    String tooltip = bundle.getString(key + \".description\", null);\n    KeyStroke accelerator = (KeyStroke) bundle.getResource(key + \".accelerator\", KeyStroke.class, null);\n    int mnemonic = bundle.getInt(key + \".mnemonic\", KeyEvent.VK_UNDEFINED);\n    boolean enabled = bundle.getBoolean(key + \".enabled\", true);\n    // Create a CommandAction object with these values\n    action = new CommandAction(command, label, icon, tooltip, accelerator, mnemonic, enabled);\n    // Save it in the cache, then return it\n    cache.put(key, action);\n    return action;\n}\n","name":"parse","className":"ActionParser","variables":{"accelerator":2,"cache":5,"icon":2,"tooltip":2,"bundleToCacheMap":2,"action":5,"mnemonic":2,"label":2,"bundle":7,"command":2,"key":6,"enabled":2},"constants":{"\".accelerator\"":1,"\".enabled\"":1,"null":6,"\".icon\"":1,"\".description\"":1,"\".mnemonic\"":1,"true":1,"\".label\"":1},"javaDoc":"","comments":"If there was no cached action create one The command is the only required resource It will throw an exception if The remaining calls all supply default values so they will not throw exceptions even if ResourceParsers haven't been registered Look up the Action cache associated with this bundle If there isn't one create one and save it Now look up the Action associated with the key in the cache If we found a cached action return it missing or malformed for types like Icon and KeyStroke Create a CommandAction object with these values Save it in the cache then return it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"add":6,"addMenu":2,"setForeground":1,"setFont":1,"setHighlightColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"AppletMenuBar":1,"PopupMenu":2},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"NameExpr":52,"StringLiteralExpr":9,"FieldAccessExpr":4,"ThisExpr":2,"MethodCallExpr":13},"statements":{"ExpressionStmt":16},"text":"public void init() {\n    AppletMenuBar menubar = new AppletMenuBar();\n    menubar.setForeground(Color.black);\n    menubar.setHighlightColor(Color.red);\n    menubar.setFont(new Font(\"helvetica\", Font.BOLD, 12));\n    this.setLayout(new BorderLayout());\n    this.add(menubar, BorderLayout.NORTH);\n    PopupMenu file = new PopupMenu();\n    file.add(\"New...\");\n    file.add(\"Open...\");\n    file.add(\"Save As...\");\n    PopupMenu edit = new PopupMenu();\n    edit.add(\"Cut\");\n    edit.add(\"Copy\");\n    edit.add(\"Paste\");\n    menubar.addMenu(\"File\", file);\n    menubar.addMenu(\"Edit\", edit);\n}\n","name":"init","className":"AppletMenuBarDemo","variables":{"menubar":6,"file":4,"edit":4},"constants":{"12":1,"\"helvetica\"":1,"\"Copy\"":1,"\"File\"":1,"\"Paste\"":1,"\"Edit\"":1,"\"Save As...\"":1,"\"New...\"":1,"\"Open...\"":1,"\"Cut\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Class[] getResourceTypes() {\n    return supportedTypes;\n}\n","name":"getResourceTypes","className":"ToolBarParser","variables":{"supportedTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{"add":1,"getValue":1,"getResource":1,"size":1,"setToolTipText":1,"get":1,"getStringList":1},"annotations":[],"exceptions":["java.util.MissingResourceException"],"concepts":["Casting"],"types":{"Action":1,"JButton":1,"List":1,"JToolBar":1,"String":2,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":8,"BinaryExpr":2,"NameExpr":34,"CastExpr":3,"ClassExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":8},"text":"public Object parse(GUIResourceBundle bundle, String key, Class type) throws java.util.MissingResourceException {\n    // Get the value of the key as a list of strings\n    List toolList = bundle.getStringList(key);\n    // Create a ToolBar\n    JToolBar toolbar = new JToolBar();\n    // Create a JTool for each of the tool property names, \n    // and add it to the bar\n    int numtools = toolList.size();\n    for (int i = 0; i < numtools; i++) {\n        // Get the action name\n        String tool = (String) toolList.get(i);\n        // Get the Action object associated with that name\n        Action action = (Action) bundle.getResource(tool, Action.class);\n        // Add the action to the toolbar, and get the JButton it creates\n        JButton button = toolbar.add(action);\n        // If the action contains a description, use it as the tooltip\n        String tooltip = (String) action.getValue(Action.SHORT_DESCRIPTION);\n        if (tooltip != null)\n            button.setToolTipText(tooltip);\n    }\n    return toolbar;\n}\n","name":"parse","className":"ToolBarParser","variables":{"toolbar":3,"button":2,"numtools":2,"tooltip":2,"i":3,"action":2,"toolList":3,"bundle":2,"tool":1},"constants":{"0":1,"null":1},"javaDoc":"","comments":"Create a JTool for each of the tool property names Get the value of the key as a list of strings Create a ToolBar and add it to the bar Get the action name Get the Action object associated with that name Add the action to the toolbar and get the JButton it creates If the action contains a description use it as the tooltip ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Command","String","Icon","String","KeyStroke","int","boolean"],"returnType":"CommandAction","methodCalls":{"setEnabled":1,"putValue":5},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":4,"ObjectCreationExpr":1,"BinaryExpr":5,"NameExpr":34,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":5,"ExpressionStmt":7},"text":"/**\n     * Create an Action object that has the various specified attributes, \n     * and invokes the specified Command object in response to ActionEvents\n     **/\npublic CommandAction(Command command, String label, Icon icon, String tooltip, KeyStroke accelerator, int mnemonic, boolean enabled) {\n    // Remember the command to invoke\n    this.command = command;\n    // Set the various action attributes with putValue()\n    if (label != null)\n        putValue(NAME, label);\n    if (icon != null)\n        putValue(SMALL_ICON, icon);\n    if (tooltip != null)\n        putValue(SHORT_DESCRIPTION, tooltip);\n    if (accelerator != null)\n        putValue(ACCELERATOR_KEY, accelerator);\n    if (mnemonic != KeyEvent.VK_UNDEFINED)\n        putValue(MNEMONIC_KEY, new Integer(mnemonic));\n    // Tell the action whether it is currently enabled or not\n    setEnabled(enabled);\n}\n","name":"CommandAction","className":"CommandAction","variables":{"accelerator":1,"icon":1,"tooltip":1,"mnemonic":2,"label":1,"command":1},"constants":{"null":4},"javaDoc":"Create an Action object that has the various specified attributes and invokes the specified Command object in response to ActionEvents","comments":"Remember the command to invoke Set the various action attributes with putValue() Tell the action whether it is currently enabled or not \n     * Create an Action object that has the various specified attributes, \n     * and invokes the specified Command object in response to ActionEvents\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"actionPerformed":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * This method implements ActionListener, which is a super-interface of\n     * Action.  When a component generates an ActionEvent, it is passed to\n     * this method.  This method simply passes it on to the Command object\n     * which is also an ActionListener object\n     **/\npublic void actionPerformed(ActionEvent e) {\n    command.actionPerformed(e);\n}\n","name":"actionPerformed","className":"CommandAction","variables":{"command":1},"constants":{},"javaDoc":"This method implements ActionListener which is a super-interface of Action When a component generates an ActionEvent it is passed to this method This method simply passes it on to the Command object which is also an ActionListener object","comments":"\n     * This method implements ActionListener, which is a super-interface of\n     * Action.  When a component generates an ActionEvent, it is passed to\n     * this method.  This method simply passes it on to the Command object\n     * which is also an ActionListener object\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"BoxLayoutPane","methodCalls":{"add":15,"createVerticalStrut":2,"createVerticalBox":1,"setBorder":1,"createHorizontalStrut":2,"createHorizontalGlue":4,"createHorizontalBox":3,"setFont":2,"setLayout":1,"setLineWrap":1,"setWrapStyleWord":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":1,"JTextArea":1,"JButton":2,"Box":4,"int":2},"expressions":{"ObjectCreationExpr":14,"IntegerLiteralExpr":16,"VariableDeclarationExpr":10,"BinaryExpr":9,"BooleanLiteralExpr":2,"NameExpr":152,"StringLiteralExpr":10,"FieldAccessExpr":7,"UnaryExpr":2,"ThisExpr":6,"MethodCallExpr":40},"statements":{"BlockStmt":2,"ForStmt":2,"ExpressionStmt":36},"text":"public BoxLayoutPane() {\n    // Use a BorderLayout layout manager to arrange various Box components\n    this.setLayout(new BorderLayout());\n    // Give the entire panel a margin by adding an empty border\n    // We could also do this by overriding getInsets()\n    this.setBorder(new EmptyBorder(10, 10, 10, 10));\n    // Add a plain row of buttons along the top of the pane\n    Box row = Box.createHorizontalBox();\n    for (int i = 0; i < 4; i++) {\n        JButton b = new JButton(\"B\" + i);\n        b.setFont(new Font(\"serif\", Font.BOLD, 12 + i * 2));\n        row.add(b);\n    }\n    this.add(row, BorderLayout.NORTH);\n    // Add a plain column of buttons along the right edge\n    // Use BoxLayout with a different kind of Swing container\n    // Give the column a border: can't do this with the Box class\n    JPanel col = new JPanel();\n    col.setLayout(new BoxLayout(col, BoxLayout.Y_AXIS));\n    col.setBorder(new TitledBorder(new EtchedBorder(), \"Column\"));\n    for (int i = 0; i < 4; i++) {\n        JButton b = new JButton(\"Button \" + i);\n        b.setFont(new Font(\"sanserif\", Font.BOLD, 10 + i * 2));\n        col.add(b);\n    }\n    // Add column to right of panel\n    this.add(col, BorderLayout.EAST);\n    // Add a button box along the bottom of the panel.  \n    // Use \"Glue\" to space the buttons evenly \n    Box buttonbox = Box.createHorizontalBox();\n    // stretchy space\n    buttonbox.add(Box.createHorizontalGlue());\n    buttonbox.add(new JButton(\"Okay\"));\n    // stretchy space\n    buttonbox.add(Box.createHorizontalGlue());\n    buttonbox.add(new JButton(\"Cancel\"));\n    // stretchy space\n    buttonbox.add(Box.createHorizontalGlue());\n    buttonbox.add(new JButton(\"Help\"));\n    // stretchy space\n    buttonbox.add(Box.createHorizontalGlue());\n    this.add(buttonbox, BorderLayout.SOUTH);\n    // Create a component to display in the center of the panel\n    JTextArea textarea = new JTextArea();\n    textarea.setText(\"This component has 12-pixel margins on left and top\" + \" and has 72-pixel margins on right and bottom.\");\n    textarea.setLineWrap(true);\n    textarea.setWrapStyleWord(true);\n    // Use Box objects to give the JTextArea an unusual spacing\n    // First, create a column with 3 kids.  The first and last kids\n    // are rigid spaces.  The middle kid is the text area\n    Box fixedcol = Box.createVerticalBox();\n    // 12 rigid pixels\n    fixedcol.add(Box.createVerticalStrut(12));\n    // Component fills in the rest\n    fixedcol.add(textarea);\n    // 72 rigid pixels\n    fixedcol.add(Box.createVerticalStrut(72));\n    // Now create a row.  Give it rigid spaces on the left and right,\n    // and put the column from above in the middle.\n    Box fixedrow = Box.createHorizontalBox();\n    fixedrow.add(Box.createHorizontalStrut(12));\n    fixedrow.add(fixedcol);\n    fixedrow.add(Box.createHorizontalStrut(72));\n    // Now add the JTextArea in the column in the row to the panel\n    this.add(fixedrow, BorderLayout.CENTER);\n}\n","name":"BoxLayoutPane","className":"BoxLayoutPane","variables":{"col":5,"b":4,"fixedcol":4,"i":10,"buttonbox":8,"textarea":4,"Box":12,"row":2,"fixedrow":4},"constants":{"12":3,"\"B\"":1,"\"sanserif\"":1,"\"This component has 12-pixel margins on left and top\"":1,"\"Cancel\"":1,"0":2,"\"Button \"":1,"\"serif\"":1,"2":2,"4":2,"\"Help\"":1,"\"Column\"":1,"\" and has 72-pixel margins on right and bottom.\"":1,"true":2,"72":2,"\"Okay\"":1,"10":5},"javaDoc":"","comments":"Give the entire panel a margin by adding an empty border Add a plain column of buttons along the right edge Use BoxLayout with a different kind of Swing container Add a button box along the bottom of the panel Use Box objects to give the JTextArea an unusual spacing First create a column with 3 kids The first and last kids Now create a row Give it rigid spaces on the left and right Use a BorderLayout layout manager to arrange various Box components We could also do this by overriding getInsets() Add a plain row of buttons along the top of the pane Give the column a border: can't do this with the Box class Add column to right of panel Use \"Glue\" to space the buttons evenly stretchy space stretchy space stretchy space stretchy space Create a component to display in the center of the panel are rigid spaces The middle kid is the text area 12 rigid pixels Component fills in the rest 72 rigid pixels and put the column from above in the middle Now add the JTextArea in the column in the row to the panel ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setExitWhenLastWindowClosed":1,"setSize":1,"getHome":1,"displayPage":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"WebBrowser":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BooleanLiteralExpr":2,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":1,"ConditionalExpr":1,"EnclosedExpr":1,"MethodCallExpr":5},"statements":{"ExpressionStmt":5},"text":"/**\n     * A simple main() method that allows the WebBrowser class to be used\n     * as a stand-alone application.\n     **/\npublic static void main(String[] args) throws IOException {\n    // End the program when there are no more open browser windows\n    WebBrowser.setExitWhenLastWindowClosed(true);\n    // Create a browser window\n    WebBrowser browser = new WebBrowser();\n    // Set its size\n    browser.setSize(800, 600);\n    // Make it visible.\n    browser.setVisible(true);\n    // Tell the browser what to display.  This method is defined below.\n    browser.displayPage((args.length > 0) ? args[0] : browser.getHome());\n}\n","name":"main","className":"WebBrowser","variables":{"args":1,"WebBrowser":1,"browser":5},"constants":{"0":2,"600":1,"true":2,"800":1},"javaDoc":"A simple main() method that allows the WebBrowser class to be used as a stand-alone application","comments":"End the program when there are no more open browser windows Create a browser window Set its size Make it visible Tell the browser what to display This method is defined below \n     * A simple main() method that allows the WebBrowser class to be used\n     * as a stand-alone application.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getText":1,"displayPage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    displayPage(urlField.getText());\n}\n","name":"actionPerformed","className":"","variables":{"urlField":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"WebBrowser","methodCalls":{"add":6,"setEnabled":2,"getThemeMenu":1,"getResource":4,"setEditable":1,"addHyperlinkListener":1,"getText":1,"addActionListener":1,"addPropertyChangeListener":1,"displayPage":1},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod"],"types":{"JToolBar":1,"GUIResourceBundle":1,"ThemeManager":1,"JMenuBar":1},"expressions":{"ObjectCreationExpr":8,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":86,"StringLiteralExpr":8,"UnaryExpr":1,"AssignExpr":5,"BooleanLiteralExpr":3,"CastExpr":4,"FieldAccessExpr":4,"ClassExpr":4,"ThisExpr":8,"MethodCallExpr":23},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":24},"text":"/** Create and initialize a new WebBrowser window */\npublic WebBrowser() {\n    // Chain to JFrame constructor\n    super();\n    // Create HTML window\n    textPane = new JEditorPane();\n    // Don't allow the user to edit it\n    textPane.setEditable(false);\n    // Register action listeners.  The first is to handle hyperlinks.\n    // The second is to receive property change notifications, which tell\n    // us when a document is done loading.  This class implements these\n    // EventListener interfaces, and the methods are defined below\n    textPane.addHyperlinkListener(this);\n    textPane.addPropertyChangeListener(this);\n    // Put the text pane in a JScrollPane in the center of the window\n    this.getContentPane().add(new JScrollPane(textPane), BorderLayout.CENTER);\n    // Now create a message line and place it at the bottom of the window\n    messageLine = new JLabel(\" \");\n    this.getContentPane().add(messageLine, BorderLayout.SOUTH);\n    // Read the file WebBrowserResources.properties (and any localized\n    // variants appropriate for the current Locale) to create a\n    // GUIResourceBundle from which we'll get our menubar and toolbar.\n    GUIResourceBundle resources = new GUIResourceBundle(this, \"com.davidflanagan.examples.gui.\" + \"WebBrowserResources\");\n    // Read a menubar from the resource bundle and display it\n    JMenuBar menubar = (JMenuBar) resources.getResource(\"menubar\", JMenuBar.class);\n    this.setJMenuBar(menubar);\n    // Read a toolbar from the resource bundle.  Don't display it yet.\n    JToolBar toolbar = (JToolBar) resources.getResource(\"toolbar\", JToolBar.class);\n    // Create a text field that the user can enter a URL in.\n    // Set up an action listener to respond to the ENTER key in that field\n    urlField = new JTextField();\n    urlField.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            displayPage(urlField.getText());\n        }\n    });\n    // Add the URL field and a label for it to the end of the toolbar\n    toolbar.add(new JLabel(\"         URL:\"));\n    toolbar.add(urlField);\n    // And add the toolbar to the top of the window\n    this.getContentPane().add(toolbar, BorderLayout.NORTH);\n    // Read cached copies of two Action objects from the resource bundle\n    // These actions are used by the menubar and toolbar, and enabling and\n    // disabling them enables and disables the menu and toolbar items.\n    backAction = (Action) resources.getResource(\"action.back\", Action.class);\n    forwardAction = (Action) resources.getResource(\"action.forward\", Action.class);\n    // Start off with both actions disabled\n    backAction.setEnabled(false);\n    forwardAction.setEnabled(false);\n    // Create a ThemeManager for this frame, \n    // and add a Theme menu to the menubar\n    ThemeManager themes = new ThemeManager(this, resources);\n    menubar.add(themes.getThemeMenu());\n    // Keep track of how many web browser windows are open\n    WebBrowser.numBrowserWindows++;\n}\n","name":"WebBrowser","className":"WebBrowser","variables":{"toolbar":3,"menubar":2,"actionPerformed":1,"themes":2,"backAction":2,"e":1,"forwardAction":2,"resources":6,"messageLine":1,"urlField":3,"textPane":5},"constants":{"\"menubar\"":1,"\" \"":1,"\"action.back\"":1,"\"toolbar\"":1,"\"action.forward\"":1,"\"com.davidflanagan.examples.gui.\"":1,"\"WebBrowserResources\"":1,"false":3,"\"         URL:\"":1},"javaDoc":"Create and initialize a new WebBrowser window","comments":"Register action listeners The first is to handle hyperlinks The second is to receive property change notifications which tell us when a document is done loading This class implements these Read the file WebBrowserResources properties (and any localized variants appropriate for the current Locale) to create a Create a text field that the user can enter a URL in Read cached copies of two Action objects from the resource bundle These actions are used by the menubar and toolbar and enabling and Create a ThemeManager for this frame Chain to JFrame constructor Create HTML window Don't allow the user to edit it EventListener interfaces and the methods are defined below Put the text pane in a JScrollPane in the center of the window Now create a message line and place it at the bottom of the window GUIResourceBundle from which we'll get our menubar and toolbar Read a menubar from the resource bundle and display it Read a toolbar from the resource bundle Don't display it yet Set up an action listener to respond to the ENTER key in that field Add the URL field and a label for it to the end of the toolbar And add the toolbar to the top of the window disabling them enables and disables the menu and toolbar items Start off with both actions disabled and add a Theme menu to the menubar Keep track of how many web browser windows are open  Create and initialize a new WebBrowser window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Set the static property that controls the behavior of close() */\npublic static void setExitWhenLastWindowClosed(boolean b) {\n    exitWhenLastWindowClosed = b;\n}\n","name":"setExitWhenLastWindowClosed","className":"WebBrowser","variables":{"b":1,"exitWhenLastWindowClosed":1},"constants":{},"javaDoc":"Set the static property that controls the behavior of close()","comments":" Set the static property that controls the behavior of close() ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** These are accessor methods for the home property. */\npublic void setHome(String home) {\n    this.home = home;\n}\n","name":"setHome","className":"WebBrowser","variables":{"home":1},"constants":{},"javaDoc":"These are accessor methods for the home property","comments":" These are accessor methods for the home property. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public String getHome() {\n    return home;\n}\n","name":"getHome","className":"WebBrowser","variables":{"home":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["URL"],"returnType":"boolean","methodCalls":{"stopAnimation":1,"getMessage":1,"toString":1,"startAnimation":1,"setPage":1,"setText":2},"annotations":[],"exceptions":["// If page loading fails\nIOException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"BooleanLiteralExpr":2,"NameExpr":25,"StringLiteralExpr":3,"ThisExpr":1,"MethodCallExpr":8},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":7},"text":"/**\n     * This internal method attempts to load and display the specified URL.\n     * It is called from various places throughout the class.\n     **/\nboolean visit(URL url) {\n    try {\n        String href = url.toString();\n        // Start animating.  Animation is stopped in propertyChanged()\n        startAnimation(\"Loading \" + href + \"...\");\n        // Load and display the URL \n        textPane.setPage(url);\n        // Display URL in window titlebar\n        this.setTitle(href);\n        // Display URL in text input field\n        urlField.setText(href);\n        // Return success\n        return true;\n    } catch (// If page loading fails\n    IOException // If page loading fails\n    ex) {\n        stopAnimation();\n        messageLine.setText(\"Can't load page: \" + ex.getMessage());\n        return false;\n    }\n}\n                                  // Return failure\n\n","name":"visit","className":"WebBrowser","variables":{"ex":2,"messageLine":1,"href":2,"urlField":1,"url":1,"textPane":1},"constants":{"\"...\"":1,"true":1,"false":1,"\"Can't load page: \"":1,"\"Loading \"":1},"javaDoc":"This internal method attempts to load and display the specified URL It is called from various places throughout the class","comments":"Start animating Animation is stopped in propertyChanged() Load and display the URL Display URL in window titlebar Display URL in text input field Return success Return failure If page loading fails If page loading fails \n     * This internal method attempts to load and display the specified URL.\n     * It is called from various places throughout the class.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["URL"],"returnType":"void","methodCalls":{"add":1,"setEnabled":1,"subList":1,"size":1,"visit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":1,"BinaryExpr":5,"BooleanLiteralExpr":1,"NameExpr":27,"MethodCallExpr":5,"AssignExpr":3},"statements":{"IfStmt":3,"BlockStmt":2,"ExpressionStmt":6},"text":"/**\n     * Ask the browser to display the specified URL, and put it in the\n     * history list.\n     **/\npublic void displayPage(URL url) {\n    if (visit(url)) {\n        // go to the specified url, and if we succeed:\n        // Add the url to the history list\n        history.add(url);\n        int numentries = history.size();\n        if (numentries > MAX_HISTORY + 10) {\n            // Trim history when too large\n            history = history.subList(numentries - MAX_HISTORY, numentries);\n            numentries = MAX_HISTORY;\n        }\n        // Set current history page\n        currentHistoryPage = numentries - 1;\n        // If we can go back, then enable the Back action\n        if (currentHistoryPage > 0)\n            backAction.setEnabled(true);\n    }\n}\n","name":"displayPage","className":"WebBrowser","variables":{"backAction":1,"MAX_HISTORY":3,"history":4,"currentHistoryPage":2,"numentries":5},"constants":{"0":1,"1":1,"true":1,"10":1},"javaDoc":"Ask the browser to display the specified URL and put it in the history list","comments":"go to the specified url and if we succeed: Add the url to the history list Trim history when too large Set current history page If we can go back then enable the Back action \n     * Ask the browser to display the specified URL, and put it in the\n     * history list.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"displayPage":1,"setText":1},"annotations":[],"exceptions":["MalformedURLException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"ObjectCreationExpr":1,"BinaryExpr":1,"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":2},"text":"/** Like displayPage(URL), but takes a string instead */\npublic void displayPage(String href) {\n    try {\n        displayPage(new URL(href));\n    } catch (MalformedURLException ex) {\n        messageLine.setText(\"Bad URL: \" + href);\n    }\n}\n","name":"displayPage","className":"WebBrowser","variables":{"ex":1,"messageLine":1,"href":2},"constants":{"\"Bad URL: \"":1},"javaDoc":"Like displayPage(URL) but takes a string instead","comments":" Like displayPage(URL), but takes a string instead ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["File"],"returnType":"boolean","methodCalls":{"getName":1,"endsWith":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":1,"BooleanLiteralExpr":2,"NameExpr":9,"StringLiteralExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"public boolean accept(File f) {\n    String fn = f.getName();\n    if (fn.endsWith(\".html\") || fn.endsWith(\".htm\"))\n        return true;\n    else\n        return false;\n}\n","name":"accept","className":"","variables":{"f":1,"fn":3},"constants":{"\".htm\"":1,"true":1,"false":1,"\".html\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public String getDescription() {\n    return \"HTML Files\";\n}\n","name":"getDescription","className":"","variables":{},"constants":{"\"HTML Files\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"showOpenDialog":1,"getName":1,"getSelectedFile":1,"getAbsolutePath":1,"addChoosableFileFilter":1,"endsWith":2,"setFileFilter":1,"displayPage":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"String":2,"FileFilter":1,"File":1,"int":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":5,"BinaryExpr":4,"BooleanLiteralExpr":2,"NameExpr":39,"StringLiteralExpr":4,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":9},"statements":{"IfStmt":3,"BlockStmt":4,"ReturnStmt":3,"ExpressionStmt":9},"text":"/** Allow the user to choose a local file, and display it */\npublic void openPage() {\n    // Lazy creation: don't create the JFileChooser until it is needed\n    if (fileChooser == null) {\n        fileChooser = new JFileChooser();\n        // This javax.swing.filechooser.FileFilter displays only HTML files\n        FileFilter filter = new FileFilter() {\n\n            public boolean accept(File f) {\n                String fn = f.getName();\n                if (fn.endsWith(\".html\") || fn.endsWith(\".htm\"))\n                    return true;\n                else\n                    return false;\n            }\n\n            public String getDescription() {\n                return \"HTML Files\";\n            }\n        };\n        fileChooser.setFileFilter(filter);\n        fileChooser.addChoosableFileFilter(filter);\n    }\n    // Ask the user to choose a file.\n    int result = fileChooser.showOpenDialog(this);\n    if (result == JFileChooser.APPROVE_OPTION) {\n        // If they didn't click \"Cancel\", then try to display the file.\n        File selectedFile = fileChooser.getSelectedFile();\n        String url = \"file://\" + selectedFile.getAbsolutePath();\n        displayPage(url);\n    }\n}\n","name":"openPage","className":"WebBrowser","variables":{"filter":1,"result":2,"fileChooser":6,"selectedFile":2,"f":2,"fn":3,"getDescription":1,"url":1,"accept":1},"constants":{"\".htm\"":1,"null":1,"\"file://\"":1,"true":1,"false":1,"\"HTML Files\"":1,"\".html\"":1},"javaDoc":"Allow the user to choose a local file and display it","comments":"Lazy creation: don't create the JFileChooser until it is needed This javax swing filechooser FileFilter displays only HTML files Ask the user to choose a file If they didn't click \"Cancel\" then try to display the file  Allow the user to choose a local file, and display it ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setEnabled":2,"size":1,"get":1,"visit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":4,"NameExpr":18,"CastExpr":1,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Go back to the previously displayed page. */\npublic void back() {\n    if (// go back, if we can\n    currentHistoryPage > 0)\n        visit((URL) history.get(--currentHistoryPage));\n    // Enable or disable actions as appropriate\n    backAction.setEnabled((currentHistoryPage > 0));\n    forwardAction.setEnabled((currentHistoryPage < history.size() - 1));\n}\n","name":"back","className":"WebBrowser","variables":{"backAction":1,"forwardAction":1,"history":2,"currentHistoryPage":4},"constants":{"0":2,"1":1},"javaDoc":"Go back to the previously displayed page","comments":"go back if we can Enable or disable actions as appropriate  Go back to the previously displayed page. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setEnabled":2,"size":2,"get":1,"visit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":3,"BinaryExpr":5,"NameExpr":21,"CastExpr":1,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Go forward to the next page in the history list */\npublic void forward() {\n    if (// go forward, if we can\n    currentHistoryPage < history.size() - 1)\n        visit((URL) history.get(++currentHistoryPage));\n    // Enable or disable actions as appropriate\n    backAction.setEnabled((currentHistoryPage > 0));\n    forwardAction.setEnabled((currentHistoryPage < history.size() - 1));\n}\n","name":"forward","className":"WebBrowser","variables":{"backAction":1,"forwardAction":1,"history":3,"currentHistoryPage":4},"constants":{"0":1,"1":2},"javaDoc":"Go forward to the next page in the history list","comments":"go forward if we can Enable or disable actions as appropriate  Go forward to the next page in the history list ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"get":1,"visit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":1,"NameExpr":7,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"/** Reload the current page in the history list */\npublic void reload() {\n    if (currentHistoryPage != -1)\n        visit((URL) history.get(currentHistoryPage));\n}\n","name":"reload","className":"WebBrowser","variables":{"history":1,"currentHistoryPage":1},"constants":{"1":1},"javaDoc":"Reload the current page in the history list","comments":" Reload the current page in the history list ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"getHome":1,"displayPage":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"/** Display the page specified by the \"home\" property */\npublic void home() {\n    displayPage(getHome());\n}\n","name":"home","className":"WebBrowser","variables":{},"constants":{},"javaDoc":"Display the page specified by the \"home\" property","comments":" Display the page specified by the \"home\" property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"WebBrowser":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":10,"ThisExpr":2,"MethodCallExpr":4},"statements":{"ExpressionStmt":3},"text":"/** Open a new browser window */\npublic void newBrowser() {\n    WebBrowser b = new WebBrowser();\n    b.setSize(this.getWidth(), this.getHeight());\n    b.setVisible(true);\n}\n","name":"newBrowser","className":"WebBrowser","variables":{"b":3},"constants":{"true":1},"javaDoc":"Open a new browser window","comments":" Open a new browser window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":["Synchronization"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BooleanLiteralExpr":1,"BinaryExpr":2,"NameExpr":12,"ClassExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":3},"statements":{"IfStmt":1,"BlockStmt":1,"SynchronizedStmt":1,"ExpressionStmt":4},"text":"/**\n     * Close this browser window.  If this was the only open window,\n     * and exitWhenLastBrowserClosed is true, then exit the VM\n     **/\npublic void close() {\n    // Hide the window\n    this.setVisible(false);\n    // Destroy the window\n    this.dispose();\n    synchronized (WebBrowser.class) {\n        // Synchronize for thread-safety\n        // There is one window fewer now\n        WebBrowser.numBrowserWindows--;\n        if ((numBrowserWindows == 0) && exitWhenLastWindowClosed)\n            // Exit if it was the last one\n            System.exit(0);\n    }\n}\n","name":"close","className":"WebBrowser","variables":{"numBrowserWindows":1,"exitWhenLastWindowClosed":1,"System":1},"constants":{"0":2,"false":1},"javaDoc":"Close this browser window If this was the only open window and exitWhenLastBrowserClosed is true then exit the VM","comments":"Hide the window Destroy the window Synchronize for thread-safety There is one window fewer now Exit if it was the last one \n     * Close this browser window.  If this was the only open window,\n     * and exitWhenLastBrowserClosed is true, then exit the VM\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["boolean"],"returnType":"void","methodCalls":{"exit":1,"showConfirmDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":13,"StringLiteralExpr":2,"FieldAccessExpr":2,"EnclosedExpr":1,"UnaryExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"/**\n     * Exit the VM.  If confirm is true, ask the user if they are sure.\n     * Note that showConfirmDialog() displays a dialog, waits for the user,\n     * and returns the user's response (i.e. the button the user selected).\n     **/\npublic void exit(boolean confirm) {\n    if (!confirm || (// dialog parent\n    JOptionPane.showConfirmDialog(// dialog parent\n    this, /* message to display */\n    \"Are you sure you want to quit?\", /* dialog title */\n    \"Really Quit?\", /* dialog buttons */\n    JOptionPane.YES_NO_OPTION) == // If Yes button was clicked\n    JOptionPane.YES_OPTION))\n        System.exit(0);\n}\n","name":"exit","className":"WebBrowser","variables":{"confirm":1,"JOptionPane":1,"System":1},"constants":{"0":1,"/* message to display */\n\"Are you sure you want to quit?\"":1,"/* dialog title */\n\"Really Quit?\"":1},"javaDoc":"Exit the VM If confirm is true ask the user if they are sure Note that showConfirmDialog() displays a dialog waits for the user and returns the user's response (i e the button the user selected)","comments":"dialog parent dialog parent dialog parent message to display dialog title dialog buttons If Yes button was clicked \n     * Exit the VM.  If confirm is true, ask the user if they are sure.\n     * Note that showConfirmDialog() displays a dialog, waits for the user,\n     * and returns the user's response (i.e. the button the user selected).\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"printDialog":1,"print":1,"getPrinterJob":1,"setPageable":1,"getMessage":1,"setText":1},"annotations":[],"exceptions":["// display errors nicely\nPrinterException"],"concepts":["ExceptionHandling"],"types":{"PrintableDocument":1,"PrinterJob":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":1,"NameExpr":20,"StringLiteralExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":3,"TryStmt":1,"ExpressionStmt":5},"text":"/**\n     * Print the contents of the text pane using the java.awt.print API\n     * Note that this API does not work efficiently in Java 1.2\n     * All the hard work is done by the PrintableDocument class.\n     **/\npublic void print() {\n    // Get a PrinterJob object from the system\n    PrinterJob job = PrinterJob.getPrinterJob();\n    // This is the object that we are going to print\n    PrintableDocument pd = new PrintableDocument(textPane);\n    // Tell the PrinterJob what we want to print\n    job.setPageable(pd);\n    // printer to print to, and giving the user a chance to cancel.\n    if (job.printDialog()) {\n        // If the user did not cancel\n        try // Start printing!\n        {\n            job.print();\n        } catch (// display errors nicely\n        PrinterException // display errors nicely\n        ex) {\n            messageLine.setText(\"Couldn't print: \" + ex.getMessage());\n        }\n    }\n}\n     // Display a print dialog, asking the user what pages to print, what\n\n","name":"print","className":"WebBrowser","variables":{"ex":2,"pd":1,"messageLine":1,"job":4,"textPane":1,"PrinterJob":1},"constants":{"\"Couldn't print: \"":1},"javaDoc":"Print the contents of the text pane using the java awt print API Note that this API does not work efficiently in Java 1 2 All the hard work is done by the PrintableDocument class","comments":"Display a print dialog asking the user what pages to print what Get a PrinterJob object from the system This is the object that we are going to print Tell the PrinterJob what we want to print printer to print to and giving the user a chance to cancel If the user did not cancel Start printing! display errors nicely display errors nicely \n     * Print the contents of the text pane using the java.awt.print API\n     * Note that this API does not work efficiently in Java 1.2\n     * All the hard work is done by the PrintableDocument class.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["HyperlinkEvent"],"returnType":"void","methodCalls":{"getURL":2,"getEventType":1,"toString":1,"displayPage":1,"setText":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"HyperlinkEvent.EventType":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":37,"StringLiteralExpr":1,"FieldAccessExpr":6,"MethodCallExpr":7},"statements":{"IfStmt":3,"BlockStmt":3,"ExpressionStmt":4},"text":"/** \n     * This method implements HyperlinkListener.  It is invoked when the user\n     * clicks on a hyperlink, or move the mouse onto or off of a link\n     **/\npublic void hyperlinkUpdate(HyperlinkEvent e) {\n    // what happened?\n    HyperlinkEvent.EventType type = e.getEventType();\n    if (type == HyperlinkEvent.EventType.ACTIVATED) {\n        // Click!\n        // Follow the link; display new page\n        displayPage(e.getURL());\n    } else if (type == HyperlinkEvent.EventType.ENTERED) {\n        // Mouse over!\n        // When mouse goes over a link, display it in the message line\n        messageLine.setText(e.getURL().toString());\n    } else if (type == HyperlinkEvent.EventType.EXITED) {\n        // Mouse out!\n        // Clear the message line\n        messageLine.setText(\" \");\n    }\n}\n","name":"hyperlinkUpdate","className":"WebBrowser","variables":{"e":3,"messageLine":2,"type":4},"constants":{"\" \"":1},"javaDoc":"This method implements HyperlinkListener It is invoked when the user clicks on a hyperlink or move the mouse onto or off of a link","comments":"what happened? Click! Follow the link; display new page Mouse over! When mouse goes over a link display it in the message line Mouse out! Clear the message line  \n     * This method implements HyperlinkListener.  It is invoked when the user\n     * clicks on a hyperlink, or move the mouse onto or off of a link\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyChangeEvent"],"returnType":"void","methodCalls":{"stopAnimation":1,"equals":1,"getPropertyName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":1},"text":"/**\n     * This method implements java.beans.PropertyChangeListener.  It is \n     * invoked whenever a bound property changes in the JEditorPane object.\n     * The property we are interested in is the \"page\" property, because it\n     * tells us when a page has finished loading.\n     **/\npublic void propertyChange(PropertyChangeEvent e) {\n    if (// If the page property changed\n    e.getPropertyName().equals(\"page\"))\n        // Then stop the loading... animation\n        stopAnimation();\n}\n","name":"propertyChange","className":"WebBrowser","variables":{"e":1},"constants":{"\"page\"":1},"javaDoc":"This method implements java beans PropertyChangeListener It is invoked whenever a bound property changes in the JEditorPane object The property we are interested in is the \"page\" property because it tells us when a page has finished loading","comments":"If the page property changed Then stop the loading animation \n     * This method implements java.beans.PropertyChangeListener.  It is \n     * invoked whenever a bound property changes in the JEditorPane object.\n     * The property we are interested in is the \"page\" property, because it\n     * tells us when a page has finished loading.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"animate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    animate();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":12,"StringLiteralExpr":1,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Display the next frame. Called by the animator timer */\nvoid animate() {\n    // Get next frame\n    String frame = animationFrames[animationFrame++];\n    // Update msgline\n    messageLine.setText(animationMessage + \" \" + frame);\n    animationFrame = animationFrame % animationFrames.length;\n}\n","name":"animate","className":"WebBrowser","variables":{"animationFrames":1,"animationFrame":3,"messageLine":1,"animationMessage":1,"frame":2},"constants":{"\" \"":1},"javaDoc":"Display the next frame Called by the animator timer","comments":"Get next frame Update msgline  Display the next frame. Called by the animator timer ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"start":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":6,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"/** Start the animation.  Called by the visit() method. */\nvoid startAnimation(String msg) {\n    // Save the message to display\n    animationMessage = msg;\n    // Start with frame 0 of the animation\n    animationFrame = 0;\n    // Tell the timer to start firing.\n    animator.start();\n}\n","name":"startAnimation","className":"WebBrowser","variables":{"msg":1,"animationFrame":1,"animationMessage":1,"animator":1},"constants":{"0":1},"javaDoc":"Start the animation Called by the visit() method","comments":"Save the message to display Start with frame 0 of the animation Tell the timer to start firing  Start the animation.  Called by the visit() method. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"void","methodCalls":{"stop":1,"setText":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Stop the animation.  Called by propertyChanged() method. */\nvoid stopAnimation() {\n    // Tell the timer to stop firing events\n    animator.stop();\n    // Clear the message line\n    messageLine.setText(\" \");\n}\n","name":"stopAnimation","className":"WebBrowser","variables":{"messageLine":1,"animator":1},"constants":{"\" \"":1},"javaDoc":"Stop the animation Called by propertyChanged() method","comments":"Tell the timer to stop firing events Clear the message line  Stop the animation.  Called by propertyChanged() method. ","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Class[] getResourceTypes() {\n    return supportedTypes;\n}\n","name":"getResourceTypes","className":"MenuBarParser","variables":{"supportedTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{"add":1,"getResource":1,"size":1,"get":1,"getStringList":1},"annotations":[],"exceptions":["java.util.MissingResourceException"],"concepts":[],"types":{"List":1,"JMenuBar":1,"int":2},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":4,"BinaryExpr":1,"NameExpr":21,"CastExpr":2,"ClassExpr":1,"UnaryExpr":1,"MethodCallExpr":5},"statements":{"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"public Object parse(GUIResourceBundle bundle, String key, Class type) throws java.util.MissingResourceException {\n    // Get the value of the key as a list of strings\n    List menuList = bundle.getStringList(key);\n    // Create a MenuBar\n    JMenuBar menubar = new JMenuBar();\n    // Create a JMenu for each of the menu property names, \n    // and add it to the bar\n    int nummenus = menuList.size();\n    for (int i = 0; i < nummenus; i++) {\n        menubar.add((JMenu) bundle.getResource((String) menuList.get(i), JMenu.class));\n    }\n    return menubar;\n}\n","name":"parse","className":"MenuBarParser","variables":{"menubar":3,"menuList":3,"nummenus":2,"i":3,"bundle":2},"constants":{"0":1},"javaDoc":"","comments":"Create a JMenu for each of the menu property names Get the value of the key as a list of strings Create a MenuBar and add it to the bar ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"NullLayoutPane","methodCalls":{"setBounds":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JButton":1,"int":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":6,"ObjectCreationExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":4,"NameExpr":13,"StringLiteralExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"public NullLayoutPane() {\n    // Get rid of the default layout manager.\n    // We'll arrange the components ourselves.\n    this.setLayout(null);\n    // Create some buttons and set their sizes and positions explicitly\n    for (int i = 1; i <= 9; i++) {\n        JButton b = new JButton(\"Button #\" + i);\n        // use reshape() in Java 1.0\n        b.setBounds(i * 30, i * 20, 125, 30);\n        this.add(b);\n    }\n}\n","name":"NullLayoutPane","className":"NullLayoutPane","variables":{"b":2,"i":6},"constants":{"1":1,"null":1,"125":1,"9":1,"\"Button #\"":1,"30":2,"20":1},"javaDoc":"","comments":"Get rid of the default layout manager We'll arrange the components ourselves Create some buttons and set their sizes and positions explicitly use reshape() in Java 1 0 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2},"statements":{"ReturnStmt":1},"text":"// Specify how big the panel should be.\npublic Dimension getPreferredSize() {\n    return new Dimension(425, 250);\n}\n","name":"getPreferredSize","className":"NullLayoutPane","variables":{},"constants":{"425":1,"250":1},"javaDoc":"","comments":" Specify how big the panel should be.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public Class[] getResourceTypes() {\n    return supportedTypes;\n}\n","name":"getResourceTypes","className":"MenuParser","variables":{"supportedTypes":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{"add":4,"getResource":1,"hasMoreTokens":1,"addSeparator":2,"nextToken":2,"getString":1,"parse":1,"charAt":1,"substring":2},"annotations":[],"exceptions":["java.util.MissingResourceException"],"concepts":["Casting","Recursion"],"types":{"StringTokenizer":1,"Action":1,"char":1,"String":3,"JMenu":2,"JPopupMenu":1},"expressions":{"ObjectCreationExpr":3,"NullLiteralExpr":6,"IntegerLiteralExpr":3,"VariableDeclarationExpr":9,"BinaryExpr":5,"NameExpr":67,"StringLiteralExpr":1,"CastExpr":2,"ClassExpr":3,"CharLiteralExpr":3,"MethodCallExpr":15,"AssignExpr":4},"statements":{"SwitchStmt":1,"IfStmt":5,"WhileStmt":1,"BreakStmt":3,"BlockStmt":1,"SwitchEntryStmt":4,"ReturnStmt":2,"ExpressionStmt":19},"text":"public Object parse(GUIResourceBundle bundle, String key, Class type) throws java.util.MissingResourceException {\n    // Get the string value of the key\n    String menudef = bundle.getString(key);\n    // Break it up into words, ignoring whitespace, colons and commas\n    StringTokenizer st = new StringTokenizer(menudef, \" \\t:,\");\n    // The first word is the label of the menu\n    String menuLabel = st.nextToken();\n    // Create either a JMenu or JPopupMenu\n    JMenu menu = null;\n    JPopupMenu popup = null;\n    if (type == JMenu.class)\n        menu = new JMenu(menuLabel);\n    else\n        popup = new JPopupMenu(menuLabel);\n    // for each one.  Accumulate these items in a list\n    while (st.hasMoreTokens()) {\n        // the next word\n        String item = st.nextToken();\n        // determines type of menu item\n        char firstchar = item.charAt(0);\n        switch(firstchar) {\n            case // words beginning with - add a separator to the menu\n            '-':\n                if (menu != null)\n                    menu.addSeparator();\n                else\n                    popup.addSeparator();\n                break;\n            case // words beginning with > are submenu names\n            '>':\n                // strip off the > character, and recurse to parse the submenu\n                item = item.substring(1);\n                // Parse a submenu and add it to the list of items\n                JMenu submenu = (JMenu) parse(bundle, item, JMenu.class);\n                if (menu != null)\n                    menu.add(submenu);\n                else\n                    popup.add(submenu);\n                break;\n            case // words beginning with ! are action names\n            '!':\n                // strip off the ! character\n                item = item.substring(1);\n            // fall through to the next case\n            default:\n                // By default all other words are taken as action names\n                // Look up the named action and add it to the menu\n                Action action = (Action) bundle.getResource(item, Action.class);\n     // Then loop through the rest of the words, creating a JMenuItem\n\n                if (menu != null)\n                    menu.add(action);\n                else\n                    popup.add(action);\n                break;\n        }\n    }\n    // Finally, return the menu or the popup menu\n    if (menu != null)\n        return menu;\n    else\n        return popup;\n}\n         /* falls through */\n\n","name":"parse","className":"MenuParser","variables":{"st":4,"popup":6,"item":6,"firstchar":2,"menudef":2,"submenu":1,"action":1,"menu":10,"type":1,"bundle":2,"menuLabel":3},"constants":{"0":1,"1":2,"null":6,"\" \\t:,\"":1},"javaDoc":"","comments":"Then loop through the rest of the words creating a JMenuItem Get the string value of the key Break it up into words ignoring whitespace colons and commas The first word is the label of the menu Create either a JMenu or JPopupMenu for each one Accumulate these items in a list the next word determines type of menu item falls through words beginning with - add a separator to the menu words beginning with > are submenu names strip off the > character and recurse to parse the submenu Parse a submenu and add it to the list of items words beginning with ! are action names strip off the ! character fall through to the next case By default all other words are taken as action names Look up the named action and add it to the menu Finally return the menu or the popup menu ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GridLayoutPane","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":1,"BinaryExpr":2,"NameExpr":7,"StringLiteralExpr":1,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"public GridLayoutPane() {\n    // Layout components into a grid three columns wide, with the number\n    // of rows depending on the number of components.  Leave 10 pixels\n    // of horizontal and vertical space between components\n    this.setLayout(new GridLayout(0, 3, 10, 10));\n    // Add some components\n    for (int i = 1; i <= 12; i++) this.add(new JButton(\"Button #\" + i));\n}\n","name":"GridLayoutPane","className":"GridLayoutPane","variables":{"i":4},"constants":{"0":1,"12":1,"1":1,"3":1,"\"Button #\"":1,"10":2},"javaDoc":"","comments":"Layout components into a grid three columns wide with the number of rows depending on the number of components Leave 10 pixels of horizontal and vertical space between components Add some components ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Containers","methodCalls":{"add":8,"setBackground":4},"annotations":[],"exceptions":[],"concepts":[],"types":{"JPanel":4},"expressions":{"ObjectCreationExpr":15,"IntegerLiteralExpr":13,"VariableDeclarationExpr":4,"NameExpr":54,"StringLiteralExpr":7,"FieldAccessExpr":2,"ThisExpr":4,"MethodCallExpr":16},"statements":{"ExpressionStmt":20},"text":"public Containers() {\n    // This component is white\n    this.setBackground(Color.white);\n    this.setFont(new Font(\"Dialog\", Font.BOLD, 24));\n    JPanel p1 = new JPanel();\n    // Panel1 is darker\n    p1.setBackground(new Color(200, 200, 200));\n    // p1 is contained by this component\n    this.add(p1);\n    // Button 1 is contained in p1\n    p1.add(new JButton(\"#1\"));\n    JPanel p2 = new JPanel();\n    // p2 is darker than p2\n    p2.setBackground(new Color(150, 150, 150));\n    // p2 is contained in p1\n    p1.add(p2);\n    // Button 2 is contained in p2\n    p2.add(new JButton(\"#2\"));\n    JPanel p3 = new JPanel();\n    // p3 is darker than p2\n    p3.setBackground(new Color(100, 100, 100));\n    // p3 is contained in p2\n    p2.add(p3);\n    // Button 3 is contained in p3\n    p3.add(new JButton(\"#3\"));\n    JPanel p4 = new JPanel();\n    // p4 is darker than p1\n    p4.setBackground(new Color(150, 150, 150));\n    // p4 is contained in p1\n    p1.add(p4);\n    // Button4 is contained in p4\n    p4.add(new JButton(\"#4\"));\n    // Button5 is also contained in p4\n    p4.add(new JButton(\"#5\"));\n    // Button6 is contained in this component\n    this.add(new JButton(\"#6\"));\n}\n","name":"Containers","className":"Containers","variables":{"p1":5,"p2":4,"p3":3,"p4":4},"constants":{"\"#4\"":1,"100":3,"\"#5\"":1,"24":1,"200":3,"\"#6\"":1,"150":6,"\"#1\"":1,"\"Dialog\"":1,"\"#2\"":1,"\"#3\"":1},"javaDoc":"","comments":"This component is white Panel1 is darker p1 is contained by this component Button 1 is contained in p1 p2 is darker than p2 p2 is contained in p1 Button 2 is contained in p2 p3 is darker than p2 p3 is contained in p2 Button 3 is contained in p3 p4 is darker than p1 p4 is contained in p1 Button4 is contained in p4 Button5 is also contained in p4 Button6 is contained in this component ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribblePane4","methodCalls":{"setPreferredSize":1,"enableEvents":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":2,"NameExpr":13,"FieldAccessExpr":3,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public ScribblePane4() {\n    // Give the component a preferred size\n    setPreferredSize(new Dimension(450, 200));\n    // Tell the system what kind of events the component is interested in\n    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);\n}\n","name":"ScribblePane4","className":"ScribblePane4","variables":{},"constants":{"200":1,"450":1},"javaDoc":"","comments":"Give the component a preferred size Tell the system what kind of events the component is interested in ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"requestFocus":1,"getY":1,"getID":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":19,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void processMouseEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_PRESSED) {\n        moveto(e.getX(), e.getY());\n        requestFocus();\n    } else\n        // pass unhandled events to superclass\n        super.processMouseEvent(e);\n}\n","name":"processMouseEvent","className":"ScribblePane4","variables":{"e":3},"constants":{},"javaDoc":"","comments":"pass unhandled events to superclass ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"lineto":1,"getID":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":1,"NameExpr":17,"FieldAccessExpr":1,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void processMouseMotionEvent(MouseEvent e) {\n    if (e.getID() == MouseEvent.MOUSE_DRAGGED)\n        lineto(e.getX(), e.getY());\n    else\n        super.processMouseMotionEvent(e);\n}\n","name":"processMouseMotionEvent","className":"ScribblePane4","variables":{"e":3},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"clear":1,"getID":1,"getKeyCode":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BinaryExpr":3,"NameExpr":17,"FieldAccessExpr":2,"EnclosedExpr":2,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void processKeyEvent(KeyEvent e) {\n    if ((e.getID() == KeyEvent.KEY_PRESSED) && (e.getKeyCode() == KeyEvent.VK_C))\n        clear();\n    else\n        // Give superclass a chance to handle\n        super.processKeyEvent(e);\n}\n","name":"processKeyEvent","className":"ScribblePane4","variables":{"e":2},"constants":{},"javaDoc":"","comments":"Give superclass a chance to handle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Remember the specified point */\npublic void moveto(int x, int y) {\n    last_x = x;\n    last_y = y;\n}\n","name":"moveto","className":"ScribblePane4","variables":{"last_x":1,"x":1,"last_y":1,"y":1},"constants":{},"javaDoc":"Remember the specified point","comments":" Remember the specified point ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"void","methodCalls":{"drawLine":1,"getGraphics":1,"moveto":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":12,"MethodCallExpr":3},"statements":{"ExpressionStmt":2},"text":"/** Draw from the last point to this point, then remember new point */\npublic void lineto(int x, int y) {\n    getGraphics().drawLine(last_x, last_y, x, y);\n    moveto(x, y);\n}\n","name":"lineto","className":"ScribblePane4","variables":{},"constants":{},"javaDoc":"Draw from the last point to this point then remember new point","comments":" Draw from the last point to this point, then remember new point ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Clear the drawing area, using the component background color */\npublic void clear() {\n    repaint();\n}\n","name":"clear","className":"ScribblePane4","variables":{},"constants":{},"javaDoc":"Clear the drawing area using the component background color","comments":" Clear the drawing area, using the component background color ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"AppletMenuBar","methodCalls":{"enableEvents":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":8,"FieldAccessExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Create a new component that simulates a menubar by displaying\n     * the specified labels.  Whenever the user clicks the specified label,\n     * popup up the PopupMenu specified in the menus array.\n     * Elements of the menus arra may be a static PopupMenu object, or\n     * a PopupMenuFactory object for dynamically creating menus.\n     * Perhaps we'll also provide some other kind of constructor or factory\n     * method that reads popup menus out of a config file.\n     */\npublic AppletMenuBar() {\n    // We'd like these kinds of events to be delivered\n    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);\n}\n","name":"AppletMenuBar","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"Create a new component that simulates a menubar by displaying the specified labels Whenever the user clicks the specified label popup up the PopupMenu specified in the menus array Elements of the menus arra may be a static PopupMenu object or a PopupMenuFactory object for dynamically creating menus Perhaps we'll also provide some other kind of constructor or factory method that reads popup menus out of a config file","comments":"We'd like these kinds of events to be delivered \n     * Create a new component that simulates a menubar by displaying\n     * the specified labels.  Whenever the user clicks the specified label,\n     * popup up the PopupMenu specified in the menus array.\n     * Elements of the menus arra may be a static PopupMenu object, or\n     * a PopupMenuFactory object for dynamically creating menus.\n     * Perhaps we'll also provide some other kind of constructor or factory\n     * method that reads popup menus out of a config file.\n     ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","PopupMenu"],"returnType":"void","methodCalls":{"insertMenu":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":4,"UnaryExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** Add a popup menu to the menubar */\npublic void addMenu(String label, PopupMenu menu) {\n    insertMenu(label, menu, -1);\n}\n","name":"addMenu","className":"AppletMenuBar","variables":{},"constants":{"1":1},"javaDoc":"Add a popup menu to the menubar","comments":" Add a popup menu to the menubar ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","PopupMenu","int"],"returnType":"void","methodCalls":{"insertElementAt":2,"size":1,"invalidate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":21,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":6},"text":"/** Insert a popup menu into the menubar */\npublic void insertMenu(String label, PopupMenu menu, int index) {\n    // Position to put it at\n    if (index < 0)\n        index += labels.size() + 1;\n    // Popup belongs to us\n    this.add(menu);\n    // Remember the label\n    labels.insertElementAt(label, index);\n    // Remember the menu\n    menus.insertElementAt(menu, index);\n    // Remeasure everything\n    remeasure = true;\n    // Container must relayout\n    invalidate();\n}\n","name":"insertMenu","className":"AppletMenuBar","variables":{"remeasure":1,"index":2,"menus":1,"labels":2},"constants":{"0":1,"1":1,"true":1},"javaDoc":"Insert a popup menu into the menubar","comments":"Position to put it at Popup belongs to us Remember the label Remember the menu Remeasure everything Container must relayout  Insert a popup menu into the menubar ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Insets","methodCalls":{"clone":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Property accessor methods for margins property */\npublic Insets getMargins() {\n    return (Insets) margins.clone();\n}\n","name":"getMargins","className":"AppletMenuBar","variables":{"margins":1},"constants":{},"javaDoc":"Property accessor methods for margins property","comments":" Property accessor methods for margins property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Insets"],"returnType":"void","methodCalls":{"invalidate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1,"NameExpr":6,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":3},"text":"public void setMargins(Insets margins) {\n    this.margins = margins;\n    remeasure = true;\n    invalidate();\n}\n","name":"setMargins","className":"AppletMenuBar","variables":{"margins":1,"remeasure":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** Property accessor methods for spacing property */\npublic int getSpacing() {\n    return spacing;\n}\n","name":"getSpacing","className":"AppletMenuBar","variables":{"spacing":1},"constants":{},"javaDoc":"Property accessor methods for spacing property","comments":" Property accessor methods for spacing property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"invalidate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"BooleanLiteralExpr":1,"NameExpr":9,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":3},"text":"public void setSpacing(int spacing) {\n    if (this.spacing != spacing) {\n        this.spacing = spacing;\n        remeasure = true;\n        invalidate();\n    }\n}\n","name":"setSpacing","className":"AppletMenuBar","variables":{"spacing":2,"remeasure":1},"constants":{"true":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Color","methodCalls":{"getForeground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"BinaryExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"/** Accessor methods for highlightColor property */\npublic Color getHighlightColor() {\n    if (highlightColor == null)\n        return getForeground();\n    else\n        return highlightColor;\n}\n","name":"getHighlightColor","className":"AppletMenuBar","variables":{"highlightColor":2},"constants":{"null":1},"javaDoc":"Accessor methods for highlightColor property","comments":" Accessor methods for highlightColor property ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":6,"AssignExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":2},"text":"public void setHighlightColor(Color c) {\n    if (highlightColor != c) {\n        highlightColor = c;\n        repaint();\n    }\n}\n","name":"setHighlightColor","className":"AppletMenuBar","variables":{"highlightColor":2,"c":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"invalidate":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2,"AssignExpr":1},"statements":{"ExpressionStmt":3},"text":"/** We override the setFont() method so we can remeasure */\npublic void setFont(Font f) {\n    super.setFont(f);\n    remeasure = true;\n    invalidate();\n}\n","name":"setFont","className":"AppletMenuBar","variables":{"remeasure":1},"constants":{"true":1},"javaDoc":"We override the setFont() method so we can remeasure","comments":" We override the setFont() method so we can remeasure ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Override these color property setter method so we can repaint */\npublic void setForeground(Color c) {\n    super.setForeground(c);\n    repaint();\n}\n","name":"setForeground","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"Override these color property setter method so we can repaint","comments":" Override these color property setter method so we can repaint ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"void","methodCalls":{"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"public void setBackground(Color c) {\n    super.setBackground(c);\n    repaint();\n}\n","name":"setBackground","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"brighter":1,"drawLine":2,"drawString":1,"getForeground":1,"getSize":1,"measure":1,"setColor":4,"getHighlightColor":1,"darker":1,"size":1,"elementAt":1,"getFont":1,"setFont":1,"getBackground":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":1,"Dimension":1,"int":3},"expressions":{"IntegerLiteralExpr":7,"NullLiteralExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":1,"BinaryExpr":10,"NameExpr":84,"CastExpr":1,"FieldAccessExpr":8,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":18},"statements":{"IfStmt":2,"BlockStmt":1,"ForStmt":1,"ExpressionStmt":13},"text":"/**\n     * This method is called to draw tell the component to redraw itself.\n     * If we were implementing a Swing component, we'd override \n     * paintComponent() instead\n     **/\npublic void paint(Graphics g) {\n    // Remeasure everything first, if needed\n    if (remeasure)\n        measure();\n    // Figure out Y coordinate to draw at\n    Dimension size = getSize();\n    int baseline = size.height - margins.bottom - descent;\n    // Set the font to draw with\n    g.setFont(getFont());\n    // Loop through the labels\n    int nummenus = labels.size();\n    for (int i = 0; i < nummenus; i++) {\n        // Set the drawing color.  Highlight the current item\n        if ((i == highlightedItem) && (highlightColor != null))\n            g.setColor(getHighlightColor());\n        else\n            g.setColor(getForeground());\n        // Draw the menu label at the position computed in measure()\n        g.drawString((String) labels.elementAt(i), startPositions[i], baseline);\n    }\n    // Now draw a groove at the bottom of the menubar.\n    Color bg = getBackground();\n    g.setColor(bg.darker());\n    g.drawLine(0, size.height - 2, size.width, size.height - 2);\n    g.setColor(bg.brighter());\n    g.drawLine(0, size.height - 1, size.width, size.height - 1);\n}\n","name":"paint","className":"AppletMenuBar","variables":{"descent":1,"highlightColor":1,"size":1,"nummenus":2,"bg":3,"remeasure":1,"g":8,"i":5,"startPositions":1,"baseline":1,"highlightedItem":1,"labels":2},"constants":{"0":3,"1":2,"2":2,"null":1},"javaDoc":"This method is called to draw tell the component to redraw itself If we were implementing a Swing component we'd override paintComponent() instead","comments":"Remeasure everything first if needed Figure out Y coordinate to draw at Set the font to draw with Loop through the labels Set the drawing color Highlight the current item Draw the menu label at the position computed in measure() Now draw a groove at the bottom of the menubar \n     * This method is called to draw tell the component to redraw itself.\n     * If we were implementing a Swing component, we'd override \n     * paintComponent() instead\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getSize":1,"findItemAt":1,"elementAt":1,"show":1,"getID":1,"repaint":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Dimension":1,"int":2,"PopupMenu":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"BinaryExpr":12,"NameExpr":52,"UnaryExpr":3,"AssignExpr":2,"NullLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":2,"ThisExpr":1,"MethodCallExpr":8},"statements":{"IfStmt":9,"BlockStmt":5,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Called when a mouse event happens over the menubar */\nprotected void processMouseEvent(MouseEvent e) {\n    // What type of event?\n    int type = e.getID();\n    // Over which menu label?\n    int item = findItemAt(e.getX());\n    if (type == MouseEvent.MOUSE_PRESSED) {\n        // If it was a mouse down event, then pop up the menu\n        if (item == -1)\n            return;\n        Dimension size = getSize();\n        PopupMenu pm = (PopupMenu) menus.elementAt(item);\n        if (pm != null)\n            pm.show(this, startPositions[item] - 3, size.height);\n    } else if (type == MouseEvent.MOUSE_EXITED) {\n        // If the mouse left the menubar, then unhighlight\n        if (highlightedItem != -1) {\n            highlightedItem = -1;\n            if (highlightColor != null)\n                repaint();\n        }\n    } else if ((type == MouseEvent.MOUSE_MOVED) || (type == MouseEvent.MOUSE_ENTERED)) {\n        // If the mouse moved, change the highlighted item, if necessary\n        if (item != highlightedItem) {\n            highlightedItem = item;\n            if (highlightColor != null)\n                repaint();\n        }\n    }\n}\n","name":"processMouseEvent","className":"AppletMenuBar","variables":{"highlightColor":2,"item":5,"size":1,"e":2,"startPositions":1,"menus":1,"type":5,"pm":3,"highlightedItem":4},"constants":{"1":3,"3":1,"null":3},"javaDoc":"Called when a mouse event happens over the menubar","comments":"What type of event? Over which menu label? If it was a mouse down event then pop up the menu If the mouse left the menubar then unhighlight If the mouse moved change the highlighted item if necessary  Called when a mouse event happens over the menubar ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"processMouseEvent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/** This method is called when the mouse moves */\nprotected void processMouseMotionEvent(MouseEvent e) {\n    processMouseEvent(e);\n}\n","name":"processMouseMotionEvent","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"This method is called when the mouse moves","comments":" This method is called when the mouse moves ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["int"],"returnType":"int","methodCalls":{"size":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":3,"ArrayAccessExpr":3,"BinaryExpr":10,"NameExpr":19,"EnclosedExpr":2,"UnaryExpr":1,"MethodCallExpr":1,"AssignExpr":1},"statements":{"IfStmt":1,"BreakStmt":1,"BlockStmt":1,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"/** This utility method converts an X coordinate to a menu label index */\nprotected int findItemAt(int x) {\n    // This could be a more efficient search...\n    int nummenus = labels.size();\n    int halfspace = spacing / 2 - 1;\n    int i;\n    for (i = nummenus - 1; i >= 0; i--) {\n        if ((x >= startPositions[i] - halfspace) && (x <= startPositions[i] + widths[i] + halfspace))\n            break;\n    }\n    return i;\n}\n","name":"findItemAt","className":"AppletMenuBar","variables":{"spacing":1,"nummenus":2,"halfspace":3,"x":2,"i":8,"startPositions":2,"widths":1,"labels":1},"constants":{"0":1,"1":2,"2":1},"javaDoc":"This utility method converts an X coordinate to a menu label index","comments":"This could be a more efficient search  This utility method converts an X coordinate to a menu label index ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"void","methodCalls":{"getAscent":1,"stringWidth":1,"size":1,"elementAt":1,"getFont":1,"getDescent":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"FontMetrics":1,"String":1,"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":5,"ArrayAccessExpr":3,"BinaryExpr":7,"NameExpr":62,"UnaryExpr":1,"AssignExpr":10,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":6,"ArrayCreationExpr":2,"ThisExpr":1,"MethodCallExpr":7},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":14},"text":"/**\n     * Measure the menu labels, and figure out their positions, so we\n     * can determine when a click happens, and so we can redraw efficiently.\n     **/\nprotected void measure() {\n    // Get information about the font\n    FontMetrics fm = this.getFontMetrics(getFont());\n    // Remember the basic font size\n    ascent = fm.getAscent();\n    descent = fm.getDescent();\n    // Create arrays to hold the measurements and positions\n    int nummenus = labels.size();\n    widths = new int[nummenus];\n    startPositions = new int[nummenus];\n    // Measure the label strings and\n    // figure out the starting position of each label\n    int pos = margins.left;\n    for (int i = 0; i < nummenus; i++) {\n        startPositions[i] = pos;\n        String label = (String) labels.elementAt(i);\n        widths[i] = fm.stringWidth(label);\n        pos += widths[i] + spacing;\n    }\n    // Compute our preferred size from this data\n    prefsize.width = pos - spacing + margins.right;\n    prefsize.height = ascent + descent + margins.top + margins.bottom;\n    // We've don't need to be remeasured anymore.\n    remeasure = false;\n}\n","name":"measure","className":"AppletMenuBar","variables":{"descent":2,"ascent":2,"spacing":2,"nummenus":4,"pos":4,"remeasure":1,"fm":4,"startPositions":2,"i":6,"widths":3,"label":1,"labels":2},"constants":{"0":1,"false":1},"javaDoc":"Measure the menu labels and figure out their positions so we can determine when a click happens and so we can redraw efficiently","comments":"Measure the label strings and Get information about the font Remember the basic font size Create arrays to hold the measurements and positions figure out the starting position of each label Compute our preferred size from this data We've don't need to be remeasured anymore \n     * Measure the menu labels, and figure out their positions, so we\n     * can determine when a click happens, and so we can redraw efficiently.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getPreferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * These methods tell the container how big the menubar wants to be.\n     * \n     **/\npublic Dimension getMinimumSize() {\n    return getPreferredSize();\n}\n","name":"getMinimumSize","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"These methods tell the container how big the menubar wants to be","comments":"\n     * These methods tell the container how big the menubar wants to be.\n     * \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":1},"text":"public Dimension getPreferredSize() {\n    if (remeasure)\n        measure();\n    return prefsize;\n}\n","name":"getPreferredSize","className":"AppletMenuBar","variables":{"prefsize":1,"remeasure":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getPreferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** @deprecated Here for compatibility with Java 1.0 */\npublic Dimension minimumSize() {\n    return getPreferredSize();\n}\n","name":"minimumSize","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"@deprecated Here for compatibility with Java 1 0","comments":" @deprecated Here for compatibility with Java 1.0 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Dimension","methodCalls":{"getPreferredSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** @deprecated Here for compatibility with Java 1.0 */\npublic Dimension preferredSize() {\n    return getPreferredSize();\n}\n","name":"preferredSize","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"@deprecated Here for compatibility with Java 1 0","comments":" @deprecated Here for compatibility with Java 1.0 ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"measure":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"SuperExpr":1,"NameExpr":4,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** \n     * This method is called when the underlying AWT component is created.\n     * We can't measure ourselves (no font metrics) until this is called.\n     **/\npublic void addNotify() {\n    super.addNotify();\n    measure();\n}\n","name":"addNotify","className":"AppletMenuBar","variables":{},"constants":{},"javaDoc":"This method is called when the underlying AWT component is created We can't measure ourselves (no font metrics) until this is called","comments":" \n     * This method is called when the underlying AWT component is created.\n     * We can't measure ourselves (no font metrics) until this is called.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"/** This method tells the container not to give us keyboard focus */\npublic boolean isFocusTraversable() {\n    return false;\n}\n","name":"isFocusTraversable","className":"AppletMenuBar","variables":{},"constants":{"false":1},"javaDoc":"This method tells the container not to give us keyboard focus","comments":" This method tells the container not to give us keyboard focus ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"EventTestPane","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"BinaryExpr":5,"NameExpr":22,"FieldAccessExpr":6,"ThisExpr":2,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** The constructor: register the event types we are interested in */\npublic EventTestPane() {\n    // We're interested in all types of events\n    this.enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK | AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK | AWTEvent.COMPONENT_EVENT_MASK | AWTEvent.WINDOW_EVENT_MASK);\n    this.setPreferredSize(new Dimension(500, 400));\n}\n","name":"EventTestPane","className":"EventTestPane","variables":{},"constants":{"400":1,"500":1},"javaDoc":"The constructor: register the event types we are interested in","comments":"We're interested in all types of events  The constructor: register the event types we are interested in ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"requestFocus":1,"getY":1,"mousemods":1,"getClickCount":1,"getID":2,"showLine":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":10,"NameExpr":49,"StringLiteralExpr":11,"FieldAccessExpr":6,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":9,"AssignExpr":5},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":5,"SwitchEntryStmt":5,"ExpressionStmt":8},"text":"/**\n     * Display mouse events that don't involve mouse motion.  The mousemods()\n     * method prints modifiers, and is defined below.  The other methods\n     * return additional information about the mouse event.  showLine()\n     * displays a line of text in the window.  It is defined at the end of\n     * this class, along with the paintComponent() method.\n     **/\npublic void processMouseEvent(MouseEvent e) {\n    String type = null;\n    switch(e.getID()) {\n        case MouseEvent.MOUSE_PRESSED:\n            type = \"MOUSE_PRESSED\";\n            break;\n        case MouseEvent.MOUSE_RELEASED:\n            type = \"MOUSE_RELEASED\";\n            break;\n        case MouseEvent.MOUSE_CLICKED:\n            type = \"MOUSE_CLICKED\";\n            break;\n        case MouseEvent.MOUSE_ENTERED:\n            type = \"MOUSE_ENTERED\";\n            break;\n        case MouseEvent.MOUSE_EXITED:\n            type = \"MOUSE_EXITED\";\n            break;\n    }\n    showLine(mousemods(e) + type + \": [\" + e.getX() + \",\" + e.getY() + \"] \" + \"num clicks = \" + e.getClickCount() + (e.isPopupTrigger() ? \"; is popup trigger\" : \"\"));\n    // we can receive and respond to keyboard events\n    if (e.getID() == MouseEvent.MOUSE_ENTERED)\n        requestFocus();\n}\n     // When the mouse enters the component, request keyboard focus so\n\n","name":"processMouseEvent","className":"EventTestPane","variables":{"e":6,"type":7},"constants":{"\"\"":1,"\"; is popup trigger\"":1,"\"MOUSE_PRESSED\"":1,"null":1,"\"MOUSE_RELEASED\"":1,"\": [\"":1,"\"num clicks = \"":1,"\",\"":1,"\"MOUSE_ENTERED\"":1,"\"MOUSE_EXITED\"":1,"\"] \"":1,"\"MOUSE_CLICKED\"":1},"javaDoc":"Display mouse events that don't involve mouse motion The mousemods() method prints modifiers and is defined below The other methods return additional information about the mouse event showLine() displays a line of text in the window It is defined at the end of this class along with the paintComponent() method","comments":"When the mouse enters the component request keyboard focus so we can receive and respond to keyboard events \n     * Display mouse events that don't involve mouse motion.  The mousemods()\n     * method prints modifiers, and is defined below.  The other methods\n     * return additional information about the mouse event.  showLine()\n     * displays a line of text in the window.  It is defined at the end of\n     * this class, along with the paintComponent() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"void","methodCalls":{"getX":1,"getY":1,"mousemods":1,"getClickCount":1,"getID":1,"showLine":1,"isPopupTrigger":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":9,"NameExpr":29,"StringLiteralExpr":8,"FieldAccessExpr":2,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":7,"AssignExpr":2},"statements":{"SwitchStmt":1,"BreakStmt":2,"SwitchEntryStmt":2,"ExpressionStmt":4},"text":"/**\n     * Display mouse moved and dragged mouse event.  Note that MouseEvent is\n     * the only event type that has two methods, two EventListener interfaces\n     * and two adapter classes to handle two distinct categories of events.\n     * Also, as seen in init(), mouse motion events must be requested\n     * separately from other mouse event types.\n     **/\npublic void processMouseMotionEvent(MouseEvent e) {\n    String type = null;\n    switch(e.getID()) {\n        case MouseEvent.MOUSE_MOVED:\n            type = \"MOUSE_MOVED\";\n            break;\n        case MouseEvent.MOUSE_DRAGGED:\n            type = \"MOUSE_DRAGGED\";\n            break;\n    }\n    showLine(mousemods(e) + type + \": [\" + e.getX() + \",\" + e.getY() + \"] \" + \"num clicks = \" + e.getClickCount() + (e.isPopupTrigger() ? \"; is popup trigger\" : \"\"));\n}\n","name":"processMouseMotionEvent","className":"EventTestPane","variables":{"e":5,"type":4},"constants":{"\"\"":1,"\"; is popup trigger\"":1,"\"MOUSE_DRAGGED\"":1,"null":1,"\": [\"":1,"\"num clicks = \"":1,"\",\"":1,"\"MOUSE_MOVED\"":1,"\"] \"":1},"javaDoc":"Display mouse moved and dragged mouse event Note that MouseEvent is the only event type that has two methods two EventListener interfaces and two adapter classes to handle two distinct categories of events Also as seen in init() mouse motion events must be requested separately from other mouse event types","comments":"\n     * Display mouse moved and dragged mouse event.  Note that MouseEvent is\n     * the only event type that has two methods, two EventListener interfaces\n     * and two adapter classes to handle two distinct categories of events.\n     * Also, as seen in init(), mouse motion events must be requested\n     * separately from other mouse event types.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["MouseEvent"],"returnType":"String","methodCalls":{"isControlDown":1,"getModifiers":1,"isShiftDown":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1,"int":1},"expressions":{"IntegerLiteralExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":27,"StringLiteralExpr":6,"FieldAccessExpr":3,"EnclosedExpr":3,"MethodCallExpr":3,"AssignExpr":5},"statements":{"IfStmt":5,"ReturnStmt":1,"ExpressionStmt":7},"text":"/**\n     * Return a string representation of the modifiers for a MouseEvent.\n     * Note that the methods called here are inherited from InputEvent.\n     **/\nprotected String mousemods(MouseEvent e) {\n    int mods = e.getModifiers();\n    String s = \"\";\n    if (e.isShiftDown())\n        s += \"Shift \";\n    if (e.isControlDown())\n        s += \"Ctrl \";\n    if ((mods & InputEvent.BUTTON1_MASK) != 0)\n        s += \"Button 1 \";\n    if ((mods & InputEvent.BUTTON2_MASK) != 0)\n        s += \"Button 2 \";\n    if ((mods & InputEvent.BUTTON3_MASK) != 0)\n        s += \"Button 3 \";\n    return s;\n}\n","name":"mousemods","className":"EventTestPane","variables":{"mods":4,"s":7,"e":3},"constants":{"\"\"":1,"0":3,"\"Button 2 \"":1,"\"Button 3 \"":1,"\"Shift \"":1,"\"Ctrl \"":1,"\"Button 1 \"":1},"javaDoc":"Return a string representation of the modifiers for a MouseEvent Note that the methods called here are inherited from InputEvent","comments":"\n     * Return a string representation of the modifiers for a MouseEvent.\n     * Note that the methods called here are inherited from InputEvent.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["KeyEvent"],"returnType":"void","methodCalls":{"isActionKey":1,"getKeyModifiersText":1,"getKeyText":1,"getKeyChar":2,"getID":2,"getModifiers":1,"showLine":1,"getKeyCode":2},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":1},"expressions":{"VariableDeclarationExpr":1,"BinaryExpr":15,"NameExpr":57,"StringLiteralExpr":15,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":11,"AssignExpr":9},"statements":{"SwitchStmt":1,"IfStmt":2,"BreakStmt":3,"SwitchEntryStmt":4,"ExpressionStmt":11},"text":"/**\n     * Display keyboard events.\n     *\n     * Note that there are three distinct types of key events, and that key\n     * events are reported by key code and/or Unicode character.  KEY_PRESSED\n     * and KEY_RELEASED events are generated for all key strokes.  KEY_TYPED\n     * events are only generated when a key stroke produces a Unicode\n     * character; these events do not report a key code.  If isActionKey()\n     * returns true, then the key event reports only a key code, because the\n     * key that was pressed or released (such as a function key) has no\n     * corresponding Unicode character.  Key codes can be interpreted by using\n     * the many VK_ constants defined by the KeyEvent class, or they can be\n     * converted to strings using the static getKeyText() method as we do\n     * here.\n     **/\npublic void processKeyEvent(KeyEvent e) {\n    String eventtype, modifiers, code, character;\n    switch(e.getID()) {\n        case KeyEvent.KEY_PRESSED:\n            eventtype = \"KEY_PRESSED\";\n            break;\n        case KeyEvent.KEY_RELEASED:\n            eventtype = \"KEY_RELEASED\";\n            break;\n        case KeyEvent.KEY_TYPED:\n            eventtype = \"KEY_TYPED\";\n            break;\n        default:\n            eventtype = \"UNKNOWN\";\n    }\n    // Convert the list of modifier keys to a string\n    modifiers = KeyEvent.getKeyModifiersText(e.getModifiers());\n    // Get string and numeric versions of the key code, if any.\n    if (e.getID() == KeyEvent.KEY_TYPED)\n        code = \"\";\n    else\n        code = \"Code=\" + KeyEvent.getKeyText(e.getKeyCode()) + \" (\" + e.getKeyCode() + \")\";\n    // Get string and numeric versions of the Unicode character, if any.\n    if (e.isActionKey())\n        character = \"\";\n    else\n        character = \"Character=\" + e.getKeyChar() + \" (Unicode=\" + ((int) e.getKeyChar()) + \")\";\n    // Display it all.\n    showLine(eventtype + \": \" + modifiers + \" \" + code + \" \" + character);\n}\n","name":"processKeyEvent","className":"EventTestPane","variables":{"KeyEvent":2,"character":4,"code":4,"e":8,"eventtype":6,"modifiers":3},"constants":{"\"\"":2,"\" (Unicode=\"":1,"\" \"":2,"\"KEY_PRESSED\"":1,"\"UNKNOWN\"":1,"\"Code=\"":1,"\" (\"":1,"\"Character=\"":1,"\"KEY_RELEASED\"":1,"\": \"":1,"\"KEY_TYPED\"":1,"\")\"":2},"javaDoc":"Display keyboard events Note that there are three distinct types of key events and that key events are reported by key code and/or Unicode character KEY_PRESSED and KEY_RELEASED events are generated for all key strokes KEY_TYPED events are only generated when a key stroke produces a Unicode character; these events do not report a key code If isActionKey() returns true then the key event reports only a key code because the key that was pressed or released (such as a function key) has no corresponding Unicode character Key codes can be interpreted by using the many VK_ constants defined by the KeyEvent class or they can be converted to strings using the static getKeyText() method as we do here","comments":"Convert the list of modifier keys to a string Get string and numeric versions of the key code if any Get string and numeric versions of the Unicode character if any Display it all \n     * Display keyboard events.\n     *\n     * Note that there are three distinct types of key events, and that key\n     * events are reported by key code and/or Unicode character.  KEY_PRESSED\n     * and KEY_RELEASED events are generated for all key strokes.  KEY_TYPED\n     * events are only generated when a key stroke produces a Unicode\n     * character; these events do not report a key code.  If isActionKey()\n     * returns true, then the key event reports only a key code, because the\n     * key that was pressed or released (such as a function key) has no\n     * corresponding Unicode character.  Key codes can be interpreted by using\n     * the many VK_ constants defined by the KeyEvent class, or they can be\n     * converted to strings using the static getKeyText() method as we do\n     * here.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["FocusEvent"],"returnType":"void","methodCalls":{"getID":1,"isTemporary":2,"showLine":2},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"NameExpr":16,"StringLiteralExpr":6,"FieldAccessExpr":1,"EnclosedExpr":2,"ConditionalExpr":2,"MethodCallExpr":5},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"/**\n     * Display keyboard focus events.  Focus can be permanently gained or\n     * lost, or temporarily transferred to or from a component.\n     **/\npublic void processFocusEvent(FocusEvent e) {\n    if (e.getID() == FocusEvent.FOCUS_GAINED)\n        showLine(\"FOCUS_GAINED\" + (e.isTemporary() ? \" (temporary)\" : \"\"));\n    else\n        showLine(\"FOCUS_LOST\" + (e.isTemporary() ? \" (temporary)\" : \"\"));\n}\n","name":"processFocusEvent","className":"EventTestPane","variables":{"e":3},"constants":{"\"\"":2,"\" (temporary)\"":2,"\"FOCUS_LOST\"":1,"\"FOCUS_GAINED\"":1},"javaDoc":"Display keyboard focus events Focus can be permanently gained or lost or temporarily transferred to or from a component","comments":"\n     * Display keyboard focus events.  Focus can be permanently gained or\n     * lost, or temporarily transferred to or from a component.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ComponentEvent"],"returnType":"void","methodCalls":{"getID":1,"showLine":4},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":23,"StringLiteralExpr":4,"FieldAccessExpr":4,"MethodCallExpr":5},"statements":{"SwitchStmt":1,"BreakStmt":4,"SwitchEntryStmt":4,"ExpressionStmt":4},"text":"/** Display Component events.  */\npublic void processComponentEvent(ComponentEvent e) {\n    switch(e.getID()) {\n        case ComponentEvent.COMPONENT_MOVED:\n            showLine(\"COMPONENT_MOVED\");\n            break;\n        case ComponentEvent.COMPONENT_RESIZED:\n            showLine(\"COMPONENT_RESIZED\");\n            break;\n        case ComponentEvent.COMPONENT_HIDDEN:\n            showLine(\"COMPONENT_HIDDEN\");\n            break;\n        case ComponentEvent.COMPONENT_SHOWN:\n            showLine(\"COMPONENT_SHOWN\");\n            break;\n    }\n}\n","name":"processComponentEvent","className":"EventTestPane","variables":{"e":1},"constants":{"\"COMPONENT_RESIZED\"":1,"\"COMPONENT_SHOWN\"":1,"\"COMPONENT_MOVED\"":1,"\"COMPONENT_HIDDEN\"":1},"javaDoc":"Display Component events","comments":" Display Component events.  ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"sleep":1,"exit":1,"update":1,"getID":2,"showLine":9},"annotations":[],"exceptions":["InterruptedException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":58,"StringLiteralExpr":9,"FieldAccessExpr":8,"ThisExpr":1,"MethodCallExpr":15},"statements":{"SwitchStmt":1,"IfStmt":1,"BreakStmt":7,"BlockStmt":3,"TryStmt":1,"SwitchEntryStmt":7,"EmptyStmt":1,"ExpressionStmt":12},"text":"/** Display Window events.  Note the special handling of WINDOW_CLOSING */\npublic void processWindowEvent(WindowEvent e) {\n    switch(e.getID()) {\n        case WindowEvent.WINDOW_OPENED:\n            showLine(\"WINDOW_OPENED\");\n            break;\n        case WindowEvent.WINDOW_CLOSED:\n            showLine(\"WINDOW_CLOSED\");\n            break;\n        case WindowEvent.WINDOW_CLOSING:\n            showLine(\"WINDOW_CLOSING\");\n            break;\n        case WindowEvent.WINDOW_ICONIFIED:\n            showLine(\"WINDOW_ICONIFIED\");\n            break;\n        case WindowEvent.WINDOW_DEICONIFIED:\n            showLine(\"WINDOW_DEICONIFIED\");\n            break;\n        case WindowEvent.WINDOW_ACTIVATED:\n            showLine(\"WINDOW_ACTIVATED\");\n            break;\n        case WindowEvent.WINDOW_DEACTIVATED:\n            showLine(\"WINDOW_DEACTIVATED\");\n            break;\n    }\n    // sure the user has time to read it.\n    if (e.getID() == WindowEvent.WINDOW_CLOSING) {\n        showLine(\"WINDOW_CLOSING event received.\");\n        showLine(\"Application will exit in 5 seconds\");\n        // Force the updates to appear now.\n        update(this.getGraphics());\n        // Wait five seconds\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException ie) {\n            ;\n        }\n        // Exit now\n        System.exit(0);\n    }\n}\n     // If the user requested a window close, quit the program.\n\n     // But first display a message, force it to be visible, and make\n\n","name":"processWindowEvent","className":"EventTestPane","variables":{"e":2,"ie":1,"System":1,"Thread":1},"constants":{"\"WINDOW_OPENED\"":1,"0":1,"\"WINDOW_ICONIFIED\"":1,"\"WINDOW_DEACTIVATED\"":1,"5000":1,"\"WINDOW_CLOSED\"":1,"\"WINDOW_CLOSING event received.\"":1,"\"WINDOW_CLOSING\"":1,"\"WINDOW_ACTIVATED\"":1,"\"WINDOW_DEICONIFIED\"":1,"\"Application will exit in 5 seconds\"":1},"javaDoc":"Display Window events Note the special handling of WINDOW_CLOSING","comments":"If the user requested a window close quit the program But first display a message force it to be visible and make sure the user has time to read it Force the updates to appear now Wait five seconds Exit now  Display Window events.  Note the special handling of WINDOW_CLOSING ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"size":1,"removeElementAt":1,"addElement":1,"repaint":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"BinaryExpr":1,"NameExpr":12,"MethodCallExpr":4},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"/** Add a new line to the list of lines, and request redisplay */\nprotected void showLine(String s) {\n    if (lines.size() == 20)\n        lines.removeElementAt(0);\n    lines.addElement(s);\n    repaint();\n}\n","name":"showLine","className":"EventTestPane","variables":{"lines":3},"constants":{"0":1,"20":1},"javaDoc":"Add a new line to the list of lines and request redisplay","comments":" Add a new line to the list of lines, and request redisplay ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":["Graphics"],"returnType":"void","methodCalls":{"size":1,"elementAt":1,"drawString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":13,"CastExpr":1,"UnaryExpr":1,"MethodCallExpr":3},"statements":{"ForStmt":1,"ExpressionStmt":1},"text":"/** This method repaints the text in the window */\npublic void paintComponent(Graphics g) {\n    for (int i = 0; i < lines.size(); i++) g.drawString((String) lines.elementAt(i), 20, i * 16 + 50);\n}\n","name":"paintComponent","className":"EventTestPane","variables":{"g":1,"i":4,"lines":2},"constants":{"0":1,"16":1,"50":1,"20":1},"javaDoc":"This method repaints the text in the window","comments":" This method repaints the text in the window ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean isOpaque() {\n    return false;\n}\n","name":"isOpaque","className":"EventTestPane","variables":{},"constants":{"false":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component"],"returnType":"ComponentTree","methodCalls":{"setCellRenderer":1,"getCellRenderer":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":2,"NameExpr":5,"MethodCallExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":1},"text":"/**\n     * All this constructor method has to do is set the TreeModel and\n     * TreeCellRenderer objects for the tree.  It is these classes (defined\n     * below) that do all the real work.\n     **/\npublic ComponentTree(Component c) {\n    super(new ComponentTreeModel(c));\n    setCellRenderer(new ComponentCellRenderer(getCellRenderer()));\n}\n","name":"ComponentTree","className":"ComponentTree","variables":{"c":1},"constants":{},"javaDoc":"All this constructor method has to do is set the TreeModel and TreeCellRenderer objects for the tree It is these classes (defined below) that do all the real work","comments":"\n     * All this constructor method has to do is set the TreeModel and\n     * TreeCellRenderer objects for the tree.  It is these classes (defined\n     * below) that do all the real work.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component"],"returnType":"ComponentTreeModel","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Constructor: just remember the root object\npublic ComponentTreeModel(Component root) {\n    this.root = root;\n}\n","name":"ComponentTreeModel","className":"ComponentTreeModel","variables":{"root":1},"constants":{},"javaDoc":"","comments":" Constructor: just remember the root object","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// Return the root of the tree\npublic Object getRoot() {\n    return root;\n}\n","name":"getRoot","className":"ComponentTreeModel","variables":{"root":1},"constants":{},"javaDoc":"","comments":" Return the root of the tree","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{"getComponentCount":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Container":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"BinaryExpr":1,"NameExpr":5,"CastExpr":1,"EnclosedExpr":1,"UnaryExpr":1,"InstanceOfExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"// Is this node a leaf? (Leaf nodes are displayed differently by JTree)\n// Any node that isn't a container is a leaf, since they cannot have\n// children.  We also define containers with no children as leaves.\npublic boolean isLeaf(Object node) {\n    if (!(node instanceof Container))\n        return true;\n    Container c = (Container) node;\n    return c.getComponentCount() == 0;\n}\n","name":"isLeaf","className":"ComponentTreeModel","variables":{"node":2,"c":2},"constants":{"0":1,"true":1},"javaDoc":"","comments":" children.  We also define containers with no children as leaves.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"int","methodCalls":{"getComponentCount":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Container":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":5,"CastExpr":1,"InstanceOfExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"// How many children does this node have?\npublic int getChildCount(Object node) {\n    if (node instanceof Container) {\n        Container c = (Container) node;\n        return c.getComponentCount();\n    }\n    return 0;\n}\n","name":"getChildCount","className":"ComponentTreeModel","variables":{"node":2,"c":2},"constants":{"0":1},"javaDoc":"","comments":" How many children does this node have?","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","int"],"returnType":"Object","methodCalls":{"getComponent":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Container":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"NameExpr":6,"CastExpr":1,"InstanceOfExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":1,"BlockStmt":1,"ReturnStmt":2,"ExpressionStmt":1},"text":"// Return the specified child of a parent node.\npublic Object getChild(Object parent, int index) {\n    if (parent instanceof Container) {\n        Container c = (Container) parent;\n        return c.getComponent(index);\n    }\n    return null;\n}\n","name":"getChild","className":"ComponentTreeModel","variables":{"parent":2,"c":2},"constants":{"null":1},"javaDoc":"","comments":" Return the specified child of a parent node.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"getComponents":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Container":1,"Component[]":1,"int":1},"expressions":{"IntegerLiteralExpr":4,"NullLiteralExpr":1,"VariableDeclarationExpr":3,"ArrayAccessExpr":1,"BinaryExpr":3,"NameExpr":15,"CastExpr":1,"FieldAccessExpr":1,"EnclosedExpr":1,"UnaryExpr":5,"InstanceOfExpr":1,"MethodCallExpr":1},"statements":{"IfStmt":3,"BlockStmt":1,"ReturnStmt":4,"ForStmt":1,"ExpressionStmt":2},"text":"// Return the index of the child node in the parent node\npublic int getIndexOfChild(Object parent, Object child) {\n    if (!(parent instanceof Container))\n        return -1;\n    Container c = (Container) parent;\n    Component[] children = c.getComponents();\n    if (children == null)\n        return -1;\n    for (int i = 0; i < children.length; i++) {\n        if (children[i] == child)\n            return i;\n    }\n    return -1;\n}\n","name":"getIndexOfChild","className":"ComponentTreeModel","variables":{"parent":2,"c":2,"children":3,"i":5,"child":1},"constants":{"0":1,"1":3,"null":1},"javaDoc":"","comments":" Return the index of the child node in the parent node","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreePath","Object"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// This method is only required for editable trees, so it is not\n// implemented here.\npublic void valueForPathChanged(TreePath path, Object newvalue) {\n}\n","name":"valueForPathChanged","className":"ComponentTreeModel","variables":{},"constants":{},"javaDoc":"","comments":" implemented here.","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeModelListener"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"// This TreeModel never fires any events (since it is not editable)\n// so event listener registration methods are left unimplemented\npublic void addTreeModelListener(TreeModelListener l) {\n}\n","name":"addTreeModelListener","className":"ComponentTreeModel","variables":{},"constants":{},"javaDoc":"","comments":" so event listener registration methods are left unimplemented","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeModelListener"],"returnType":"void","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"public void removeTreeModelListener(TreeModelListener l) {\n}\n","name":"removeTreeModelListener","className":"ComponentTreeModel","variables":{},"constants":{},"javaDoc":"","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeCellRenderer"],"returnType":"ComponentCellRenderer","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"// Constructor: just remember the renderer\npublic ComponentCellRenderer(TreeCellRenderer renderer) {\n    this.renderer = renderer;\n}\n","name":"ComponentCellRenderer","className":"ComponentCellRenderer","variables":{"renderer":1},"constants":{},"javaDoc":"","comments":" Constructor: just remember the renderer","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["JTree","Object","boolean","boolean","boolean","int","boolean"],"returnType":"Component","methodCalls":{"getClass":1,"getName":1,"getTreeCellRendererComponent":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":3,"NameExpr":21,"CastExpr":1,"StringLiteralExpr":2,"EnclosedExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"ReturnStmt":1,"ExpressionStmt":3},"text":"// This is the only TreeCellRenderer method.\n// Compute the string to display, and pass it to the wrapped renderer\npublic Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {\n    // Component type\n    String newvalue = value.getClass().getName();\n    // Component name\n    String name = ((Component) value).getName();\n    // unless null\n    if (name != null)\n        newvalue += \" (\" + name + \")\";\n    // Use the wrapped renderer object to do the real work\n    return renderer.getTreeCellRendererComponent(tree, newvalue, selected, expanded, leaf, row, hasFocus);\n}\n","name":"getTreeCellRendererComponent","className":"ComponentCellRenderer","variables":{"newvalue":2,"renderer":1,"name":3,"value":2},"constants":{"null":1,"\" (\"":1,"\")\"":1},"javaDoc":"","comments":"Component type Component name unless null Use the wrapped renderer object to do the real work  Compute the string to display, and pass it to the wrapped renderer","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["TreeSelectionEvent"],"returnType":"void","methodCalls":{"getLastPathComponent":1,"isShowing":1,"getHeight":1,"getLocationOnScreen":1,"getPath":1,"getWidth":1,"setText":2},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"TreePath":1,"Point":1,"Component":1},"expressions":{"VariableDeclarationExpr":3,"BinaryExpr":7,"NameExpr":30,"CastExpr":1,"StringLiteralExpr":5,"FieldAccessExpr":2,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":2,"ExpressionStmt":5},"text":"public void valueChanged(TreeSelectionEvent e) {\n    // Tree selections are referred to by \"path\"\n    // We only care about the last node in the path\n    TreePath path = e.getPath();\n    Component c = (Component) path.getLastPathComponent();\n    // display some information about it in the message line\n    if (c.isShowing()) {\n        Point p = c.getLocationOnScreen();\n        msgline.setText(\"x: \" + p.x + \"  y: \" + p.y + \"  width: \" + c.getWidth() + \"  height: \" + c.getHeight());\n    } else {\n        msgline.setText(\"component is not showing\");\n    }\n}\n             // Now we know what component was selected, so\n\n","name":"valueChanged","className":"","variables":{"p":1,"path":2,"c":5,"e":1,"msgline":2},"constants":{"\"x: \"":1,"\"  height: \"":1,"\"  width: \"":1,"\"component is not showing\"":1,"\"  y: \"":1},"javaDoc":"","comments":"Tree selections are referred to by \"path\" Now we know what component was selected so We only care about the last node in the path display some information about it in the message line ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":2,"setVisible":1,"getLastPathComponent":1,"getSelectionModel":1,"getLocationOnScreen":1,"getContentPane":2,"setSelectionMode":1,"getWidth":1,"addWindowListener":1,"exit":1,"isShowing":1,"getHeight":1,"setViewportView":1,"setSize":1,"getPath":1,"setFont":1,"addTreeSelectionListener":1,"setText":2},"annotations":[],"exceptions":[],"concepts":["Casting","InnerMethod","FinalVariables","PolyMorphism"],"types":{"JScrollPane":1,"JTree":1,"TreePath":1,"JFrame":1,"JLabel":1,"Point":1,"Component":1,"ComponentTree":1},"expressions":{"ObjectCreationExpr":7,"IntegerLiteralExpr":4,"VariableDeclarationExpr":7,"BinaryExpr":7,"BooleanLiteralExpr":1,"StringLiteralExpr":8,"NameExpr":86,"CastExpr":1,"FieldAccessExpr":6,"MethodCallExpr":21},"statements":{"IfStmt":1,"BlockStmt":4,"ExpressionStmt":19},"text":"/**\n     * This main() method demonstrates the use of the ComponentTree class: it\n     * puts a ComponentTree component in a Frame, and uses the ComponentTree\n     * to display its own GUI hierarchy.  It also adds a TreeSelectionListener\n     * to display additional information about each component as it is selected\n     **/\npublic static void main(String[] args) {\n    // Create a frame for the demo, and handle window close requests\n    JFrame frame = new JFrame(\"ComponentTree Demo\");\n    frame.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // Create a scroll pane and a \"message line\" and add them to the\n    // center and bottom of the frame.\n    JScrollPane scrollpane = new JScrollPane();\n    final JLabel msgline = new JLabel(\" \");\n    frame.getContentPane().add(scrollpane, BorderLayout.CENTER);\n    frame.getContentPane().add(msgline, BorderLayout.SOUTH);\n    // Now create the ComponentTree object, specifying the frame as the\n    // component whose tree is to be displayed.  Also set the tree's font.\n    JTree tree = new ComponentTree(frame);\n    tree.setFont(new Font(\"SansSerif\", Font.BOLD, 12));\n    // Only allow a single item in the tree to be selected at once\n    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);\n    // Add an event listener for notifications when\n    // the tree selection state changes. \n    tree.addTreeSelectionListener(new TreeSelectionListener() {\n\n        public void valueChanged(TreeSelectionEvent e) {\n            // Tree selections are referred to by \"path\"\n            // We only care about the last node in the path\n            TreePath path = e.getPath();\n            Component c = (Component) path.getLastPathComponent();\n            // display some information about it in the message line\n            if (c.isShowing()) {\n                Point p = c.getLocationOnScreen();\n                msgline.setText(\"x: \" + p.x + \"  y: \" + p.y + \"  width: \" + c.getWidth() + \"  height: \" + c.getHeight());\n            } else {\n                msgline.setText(\"component is not showing\");\n            }\n        }\n    });\n    // Now that we've set up the tree, add it to the scrollpane\n    scrollpane.setViewportView(tree);\n    // Finally, set the size of the main window, and pop it up.\n    frame.setSize(600, 400);\n    frame.setVisible(true);\n}\n             // Now we know what component was selected, so\n\n","name":"main","className":"ComponentTree","variables":{"p":1,"path":2,"c":5,"valueChanged":1,"e":3,"windowClosing":1,"scrollpane":2,"msgline":3,"tree":4,"System":1,"frame":7},"constants":{"12":1,"\"ComponentTree Demo\"":1,"\" \"":1,"\"component is not showing\"":1,"\"SansSerif\"":1,"\"  y: \"":1,"0":1,"\"x: \"":1,"\"  height: \"":1,"400":1,"\"  width: \"":1,"600":1,"true":1},"javaDoc":"This main() method demonstrates the use of the ComponentTree class: it puts a ComponentTree component in a Frame and uses the ComponentTree to display its own GUI hierarchy It also adds a TreeSelectionListener to display additional information about each component as it is selected","comments":"Create a scroll pane and a \"message line\" and add them to the Now create the ComponentTree object specifying the frame as the Add an event listener for notifications when Create a frame for the demo and handle window close requests center and bottom of the frame component whose tree is to be displayed Also set the tree's font Only allow a single item in the tree to be selected at once the tree selection state changes Tree selections are referred to by \"path\" Now we know what component was selected so We only care about the last node in the path display some information about it in the message line Now that we've set up the tree add it to the scrollpane Finally set the size of the main window and pop it up \n     * This main() method demonstrates the use of the ComponentTree class: it\n     * puts a ComponentTree component in a Frame, and uses the ComponentTree\n     * to display its own GUI hierarchy.  It also adds a TreeSelectionListener\n     * to display additional information about each component as it is selected\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":[],"returnType":"ColumnLayoutPane","methodCalls":{"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"JButton":1,"int":2},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":7,"VariableDeclarationExpr":3,"BinaryExpr":4,"NameExpr":19,"StringLiteralExpr":2,"FieldAccessExpr":2,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":3},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":5},"text":"public ColumnLayoutPane() {\n    // Get rid of the default layout manager.\n    // We'll arrange the components ourselves.\n    this.setLayout(new ColumnLayout(5, 5, 10, ColumnLayout.RIGHT));\n    // Create some buttons and set their sizes and positions explicitly\n    for (int i = 0; i < 6; i++) {\n        int pointsize = 8 + i * 2;\n        JButton b = new JButton(\"Point size \" + pointsize);\n        b.setFont(new Font(\"helvetica\", Font.BOLD, pointsize));\n        this.add(b);\n    }\n}\n","name":"ColumnLayoutPane","className":"ColumnLayoutPane","variables":{"b":2,"i":4,"pointsize":3},"constants":{"0":1,"2":1,"\"helvetica\"":1,"5":2,"6":1,"8":1,"\"Point size \"":1,"10":1},"javaDoc":"","comments":"Get rid of the default layout manager We'll arrange the components ourselves Create some buttons and set their sizes and positions explicitly ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    clear();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ListSelectionEvent"],"returnType":"void","methodCalls":{"setColor":1,"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void valueChanged(ListSelectionEvent e) {\n    setColor(colors[colorList.getSelectedIndex()]);\n}\n","name":"valueChanged","className":"","variables":{"colors":1,"colorList":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ScribblePane3","methodCalls":{"addListSelectionListener":1,"setColor":1,"addActionListener":1,"clear":1,"getSelectedIndex":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JButton":1,"JList":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"StringLiteralExpr":1,"NameExpr":25,"ThisExpr":2,"MethodCallExpr":7},"statements":{"BlockStmt":2,"ExpressionStmt":8},"text":"// Add JButton and JList components to the panel.\npublic ScribblePane3() {\n    // Implicit super() call here invokes the superclass constructor\n    // Add a \"Clear\" button to the panel.\n    // Handle button events with an action listener\n    JButton clear = new JButton(\"Clear\");\n    clear.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            clear();\n        }\n    });\n    this.add(clear);\n    // Add a JList to allow color choices.\n    // Handle list selection events with a ListSelectionListener.\n    final JList colorList = new JList(colorNames);\n    colorList.addListSelectionListener(new ListSelectionListener() {\n\n        public void valueChanged(ListSelectionEvent e) {\n            setColor(colors[colorList.getSelectedIndex()]);\n        }\n    });\n    this.add(colorList);\n}\n","name":"ScribblePane3","className":"ScribblePane3","variables":{"actionPerformed":1,"colorNames":1,"valueChanged":1,"e":2,"clear":2,"colors":1,"colorList":3},"constants":{"\"Clear\"":1},"javaDoc":"","comments":"Implicit super() call here invokes the superclass constructor Add a \"Clear\" button to the panel Add a JList to allow color choices Handle button events with an action listener Handle list selection events with a ListSelectionListener  Add JButton and JList components to the panel.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"GridBagLayoutPane","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"GridBagConstraints":1},"expressions":{"ObjectCreationExpr":12,"IntegerLiteralExpr":40,"VariableDeclarationExpr":1,"DoubleLiteralExpr":2,"NameExpr":158,"StringLiteralExpr":9,"FieldAccessExpr":43,"ThisExpr":10,"MethodCallExpr":10,"AssignExpr":42},"statements":{"ExpressionStmt":51},"text":"public GridBagLayoutPane() {\n    // Create and specify a layout manager\n    this.setLayout(new GridBagLayout());\n    // Create a constraints object, and specify some default values\n    GridBagConstraints c = new GridBagConstraints();\n    // components grow in both dimensions\n    c.fill = GridBagConstraints.BOTH;\n    // 5-pixel margins on all sides\n    c.insets = new Insets(5, 5, 5, 5);\n    // Create and add a bunch of buttons, specifying different grid\n    // position, and size for each.\n    // Give the first button a resize weight of 1.0 and all others\n    // a weight of 0.0.  The first button will get all extra space.\n    c.gridx = 0;\n    c.gridy = 0;\n    c.gridwidth = 4;\n    c.gridheight = 4;\n    c.weightx = c.weighty = 1.0;\n    this.add(new JButton(\"Button #1\"), c);\n    c.gridx = 4;\n    c.gridy = 0;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    c.weightx = c.weighty = 0.0;\n    this.add(new JButton(\"Button #2\"), c);\n    c.gridx = 4;\n    c.gridy = 1;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #3\"), c);\n    c.gridx = 4;\n    c.gridy = 2;\n    c.gridwidth = 1;\n    c.gridheight = 2;\n    this.add(new JButton(\"Button #4\"), c);\n    c.gridx = 0;\n    c.gridy = 4;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #5\"), c);\n    c.gridx = 2;\n    c.gridy = 4;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #6\"), c);\n    c.gridx = 3;\n    c.gridy = 4;\n    c.gridwidth = 2;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #7\"), c);\n    c.gridx = 1;\n    c.gridy = 5;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #8\"), c);\n    c.gridx = 3;\n    c.gridy = 5;\n    c.gridwidth = 1;\n    c.gridheight = 1;\n    this.add(new JButton(\"Button #9\"), c);\n}\n","name":"GridBagLayoutPane","className":"GridBagLayoutPane","variables":{"c":1},"constants":{"0":4,"\"Button #2\"":1,"1":16,"\"Button #3\"":1,"0.0":1,"2":4,"\"Button #4\"":1,"1.0":1,"\"Button #5\"":1,"3":2,"4":8,"\"Button #6\"":1,"5":6,"\"Button #7\"":1,"\"Button #8\"":1,"\"Button #9\"":1,"\"Button #1\"":1},"javaDoc":"","comments":"Create and add a bunch of buttons specifying different grid position and size for each Give the first button a resize weight of 1 0 and all others Create and specify a layout manager Create a constraints object and specify some default values components grow in both dimensions 5-pixel margins on all sides a weight of 0 0 The first button will get all extra space ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setVisible":1,"exit":1,"setSize":1,"forName":1,"getMessage":1,"getContentPane":1,"System.out.println":2},"annotations":[],"exceptions":["// Report errors\nException"],"concepts":["PolyMorphism","ExceptionHandling"],"types":{"JScrollPane":1,"PropertyTable":1,"JFrame":1,"JTable":1,"Class":1},"expressions":{"NullLiteralExpr":1,"IntegerLiteralExpr":5,"ObjectCreationExpr":3,"VariableDeclarationExpr":4,"ArrayAccessExpr":2,"BinaryExpr":2,"BooleanLiteralExpr":1,"NameExpr":36,"StringLiteralExpr":3,"FieldAccessExpr":2,"AssignExpr":1,"MethodCallExpr":9},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"/** This main method allows the class to be demonstrated  standalone */\npublic static void main(String[] args) {\n    // Specify the name of the class as a command-line argument\n    Class beanClass = null;\n    try {\n        // Use reflection to get the Class from the classname\n        beanClass = Class.forName(args[0]);\n    } catch (// Report errors\n    Exception // Report errors\n    e) {\n        System.out.println(\"Can't find specified class: \" + e.getMessage());\n        System.out.println(\"Usage: java TableDemo <JavaBean class name>\");\n        System.exit(0);\n    }\n    // Create a table to display the properties of the specified class\n    JTable table = new PropertyTable(beanClass);\n    // Then put the table in a scrolling window, put the scrolling \n    // window into a frame, and pop it all up on to the screen\n    JScrollPane scrollpane = new JScrollPane(table);\n    JFrame frame = new JFrame(\"Properties of JavaBean: \" + args[0]);\n    frame.getContentPane().add(scrollpane);\n    frame.setSize(500, 400);\n    frame.setVisible(true);\n}\n","name":"main","className":"PropertyTable","variables":{"args":2,"beanClass":3,"e":2,"scrollpane":1,"Class":1,"System":1,"table":2,"frame":4},"constants":{"0":3,"null":1,"\"Can't find specified class: \"":1,"400":1,"500":1,"true":1,"\"Properties of JavaBean: \"":1,"\"Usage: java TableDemo <JavaBean class name>\"":1},"javaDoc":"This main method allows the class to be demonstrated standalone","comments":"Then put the table in a scrolling window put the scrolling Specify the name of the class as a command-line argument Use reflection to get the Class from the classname Report errors Report errors Create a table to display the properties of the specified class window into a frame and pop it all up on to the screen  This main method allows the class to be demonstrated  standalone ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"PropertyTable","methodCalls":{"setPreferredWidth":4,"setModel":1,"getColumnModel":1,"setCellRenderer":1,"getColumn":5,"System.err.println":1,"setHorizontalAlignment":1},"annotations":[],"exceptions":["IntrospectionException"],"concepts":["ExceptionHandling"],"types":{"TableColumnModel":1,"TableColumn":1,"DefaultTableCellRenderer":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":9,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":44,"StringLiteralExpr":1,"FieldAccessExpr":2,"MethodCallExpr":14},"statements":{"TryStmt":1,"BlockStmt":2,"ExpressionStmt":11},"text":"/**\n     * This constructor method specifies what data the table will display\n     * (the table model) and uses the TableColumnModel to customize the\n     * way that the table displays it.  The hard work is done by the\n     * TableModel implementation below.\n     **/\npublic PropertyTable(Class beanClass) {\n    // Set the data model for this table\n    try {\n        setModel(new JavaBeanPropertyTableModel(beanClass));\n    } catch (IntrospectionException e) {\n        System.err.println(\"WARNING: can't introspect: \" + beanClass);\n    }\n    // Tweak the appearance of the table by manipulating its column model\n    TableColumnModel colmodel = getColumnModel();\n    // Set column widths\n    colmodel.getColumn(0).setPreferredWidth(125);\n    colmodel.getColumn(1).setPreferredWidth(200);\n    colmodel.getColumn(2).setPreferredWidth(75);\n    colmodel.getColumn(3).setPreferredWidth(50);\n    // Right justify the text in the first column\n    TableColumn namecol = colmodel.getColumn(0);\n    DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();\n    renderer.setHorizontalAlignment(SwingConstants.RIGHT);\n    namecol.setCellRenderer(renderer);\n}\n","name":"PropertyTable","className":"PropertyTable","variables":{"renderer":2,"beanClass":2,"e":1,"namecol":2,"colmodel":6},"constants":{"0":2,"1":1,"200":1,"2":1,"3":1,"125":1,"\"WARNING: can't introspect: \"":1,"50":1,"75":1},"javaDoc":"This constructor method specifies what data the table will display (the table model) and uses the TableColumnModel to customize the way that the table displays it The hard work is done by the TableModel implementation below","comments":"Set the data model for this table Tweak the appearance of the table by manipulating its column model Set column widths Right justify the text in the first column \n     * This constructor method specifies what data the table will display\n     * (the table model) and uses the TableColumnModel to customize the\n     * way that the table displays it.  The hard work is done by the\n     * TableModel implementation below.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Object"],"returnType":"int","methodCalls":{"getName":2,"compareToIgnoreCase":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"PropertyDescriptor":2},"expressions":{"VariableDeclarationExpr":2,"CastExpr":2,"NameExpr":10,"MethodCallExpr":3},"statements":{"ReturnStmt":1,"ExpressionStmt":2},"text":"public int compare(Object p, Object q) {\n    PropertyDescriptor a = (PropertyDescriptor) p;\n    PropertyDescriptor b = (PropertyDescriptor) q;\n    return a.getName().compareToIgnoreCase(b.getName());\n}\n","name":"compare","className":"","variables":{"p":1,"a":2,"q":1,"b":2},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object"],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":1,"ThisExpr":1},"statements":{"ReturnStmt":1},"text":"public boolean equals(Object o) {\n    return o == this;\n}\n","name":"equals","className":"","variables":{"o":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Class"],"returnType":"JavaBeanPropertyTableModel","methodCalls":{"getName":2,"getPropertyDescriptors":1,"sort":1,"getBeanInfo":1,"compareToIgnoreCase":1},"annotations":[],"exceptions":["java.beans.IntrospectionException"],"concepts":["Casting","InnerMethod"],"types":{"PropertyDescriptor":2,"BeanInfo":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":1,"NameExpr":27,"CastExpr":2,"ThisExpr":1,"MethodCallExpr":6,"AssignExpr":1},"statements":{"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":5},"text":"/**\n\t * The constructor: use the JavaBeans introspector mechanism to get \n\t * information about all the properties of a bean.  Once we've got\n\t * this information, the other methods will interpret it for JTable.\n\t **/\npublic JavaBeanPropertyTableModel(Class beanClass) throws java.beans.IntrospectionException {\n    // Use the introspector class to get \"bean info\" about the class.\n    BeanInfo beaninfo = Introspector.getBeanInfo(beanClass);\n    // Get the property descriptors from that BeanInfo class\n    properties = beaninfo.getPropertyDescriptors();\n    // Now do a case-insensitive sort by property name\n    // The anonymous Comparator implementation specifies how to \n    // sort PropertyDescriptor objects by name\n    Arrays.sort(properties, new Comparator() {\n\n        public int compare(Object p, Object q) {\n            PropertyDescriptor a = (PropertyDescriptor) p;\n            PropertyDescriptor b = (PropertyDescriptor) q;\n            return a.getName().compareToIgnoreCase(b.getName());\n        }\n\n        public boolean equals(Object o) {\n            return o == this;\n        }\n    });\n}\n","name":"JavaBeanPropertyTableModel","className":"JavaBeanPropertyTableModel","variables":{"beaninfo":2,"p":2,"q":2,"a":2,"b":2,"compare":1,"equals":1,"Introspector":1,"Arrays":1,"properties":1,"o":2},"constants":{},"javaDoc":"The constructor: use the JavaBeans introspector mechanism to get information about all the properties of a bean Once we've got this information the other methods will interpret it for JTable","comments":"Now do a case-insensitive sort by property name The anonymous Comparator implementation specifies how to Use the introspector class to get \"bean info\" about the class Get the property descriptors from that BeanInfo class sort PropertyDescriptor objects by name \n\t * The constructor: use the JavaBeans introspector mechanism to get \n\t * information about all the properties of a bean.  Once we've got\n\t * this information, the other methods will interpret it for JTable.\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"// These simple methods return basic information about the table\npublic int getColumnCount() {\n    return columnNames.length;\n}\n","name":"getColumnCount","className":"JavaBeanPropertyTableModel","variables":{},"constants":{},"javaDoc":"","comments":" These simple methods return basic information about the table","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1},"statements":{"ReturnStmt":1},"text":"public int getRowCount() {\n    return properties.length;\n}\n","name":"getRowCount","className":"JavaBeanPropertyTableModel","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public String getColumnName(int column) {\n    return columnNames[column];\n}\n","name":"getColumnName","className":"JavaBeanPropertyTableModel","variables":{"columnNames":1,"column":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"Class","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ArrayAccessExpr":1,"NameExpr":2},"statements":{"ReturnStmt":1},"text":"public Class getColumnClass(int column) {\n    return columnTypes[column];\n}\n","name":"getColumnClass","className":"JavaBeanPropertyTableModel","variables":{"columnTypes":1,"column":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int","int"],"returnType":"Object","methodCalls":{"getName":1,"isBound":1,"getAccessType":1,"getPropertyType":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"PropertyDescriptor":1},"expressions":{"IntegerLiteralExpr":4,"ObjectCreationExpr":1,"NullLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":15,"MethodCallExpr":4},"statements":{"SwitchStmt":1,"SwitchEntryStmt":5,"ReturnStmt":5,"ExpressionStmt":1},"text":"/**\n\t * This method returns the value that appears at the specified row and\n\t * column of the table\n\t **/\npublic Object getValueAt(int row, int column) {\n    PropertyDescriptor prop = properties[row];\n    switch(column) {\n        case 0:\n            return prop.getName();\n        case 1:\n            return prop.getPropertyType();\n        case 2:\n            return getAccessType(prop);\n        case 3:\n            return new Boolean(prop.isBound());\n        default:\n            return null;\n    }\n}\n","name":"getValueAt","className":"JavaBeanPropertyTableModel","variables":{"prop":4,"column":1,"row":1,"properties":1},"constants":{"0":1,"1":1,"2":1,"3":1,"null":1},"javaDoc":"This method returns the value that appears at the specified row and column of the table","comments":"\n\t * This method returns the value that appears at the specified row and\n\t * column of the table\n\t *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["PropertyDescriptor"],"returnType":"String","methodCalls":{"getWriteMethod":1,"getReadMethod":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"java.lang.reflect.Method":2},"expressions":{"NullLiteralExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":5,"NameExpr":10,"StringLiteralExpr":4,"EnclosedExpr":2,"MethodCallExpr":2},"statements":{"IfStmt":3,"ReturnStmt":4,"ExpressionStmt":2},"text":"// A helper method called from getValueAt() above\nString getAccessType(PropertyDescriptor prop) {\n    java.lang.reflect.Method reader = prop.getReadMethod();\n    java.lang.reflect.Method writer = prop.getWriteMethod();\n    if ((reader != null) && (writer != null))\n        return \"Read/Write\";\n    else if (reader != null)\n        return \"Read-Only\";\n    else if (writer != null)\n        return \"Write-Only\";\n    else\n        // should never happen\n        return \"No Access\";\n}\n","name":"getAccessType","className":"JavaBeanPropertyTableModel","variables":{"reader":3,"prop":2,"writer":3},"constants":{"\"Read/Write\"":1,"null":4,"\"No Access\"":1,"\"Read-Only\"":1,"\"Write-Only\"":1},"javaDoc":"","comments":"should never happen  A helper method called from getValueAt() above","isEmpty":false,"hasInnerClass":false,"modifier":0}
{"paramTypes":[],"returnType":"BorderLayoutPane","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"ObjectCreationExpr":2,"IntegerLiteralExpr":4,"VariableDeclarationExpr":1,"ArrayAccessExpr":2,"BinaryExpr":1,"NameExpr":10,"UnaryExpr":1,"ThisExpr":2,"MethodCallExpr":2},"statements":{"BlockStmt":1,"ForStmt":1,"ExpressionStmt":2},"text":"public BorderLayoutPane() {\n    // Use a BorderLayout with 10-pixel margins between components\n    this.setLayout(new BorderLayout(10, 10));\n    for (int i = 0; i < 5; i++) {\n        // Add children to the pane\n        // Add this component\n        this.add(// Add this component\n        new JButton(borders[i]), // Using this constraint\n        borders[i]);\n    }\n}\n","name":"BorderLayoutPane","className":"BorderLayoutPane","variables":{"borders":2,"i":5},"constants":{"0":1,"5":1,"10":2},"javaDoc":"","comments":"Use a BorderLayout with 10-pixel margins between components Add children to the pane Add this component Add this component Add this component Using this constraint ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","ResourceBundle"],"returnType":"GUIResourceBundle","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/** Create a GUIResourceBundle wrapper around a specified bundle */\npublic GUIResourceBundle(Object root, ResourceBundle bundle) {\n    this.root = root;\n    this.bundle = bundle;\n}\n","name":"GUIResourceBundle","className":"GUIResourceBundle","variables":{"root":1,"bundle":1},"constants":{},"javaDoc":"Create a GUIResourceBundle wrapper around a specified bundle","comments":" Create a GUIResourceBundle wrapper around a specified bundle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","String"],"returnType":"GUIResourceBundle","methodCalls":{"getBundle":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"/**\n     * Load a named bundle and create a GUIResourceBundle around it.  This \n     * constructor takes advantage of the internationalization features of\n     * the ResourceBundle.getBundle() method.\n     **/\npublic GUIResourceBundle(Object root, String bundleName) throws MissingResourceException {\n    this.root = root;\n    this.bundle = ResourceBundle.getBundle(bundleName);\n}\n","name":"GUIResourceBundle","className":"GUIResourceBundle","variables":{"root":1,"ResourceBundle":1},"constants":{},"javaDoc":"Load a named bundle and create a GUIResourceBundle around it This constructor takes advantage of the internationalization features of the ResourceBundle getBundle() method","comments":"\n     * Load a named bundle and create a GUIResourceBundle around it.  This \n     * constructor takes advantage of the internationalization features of\n     * the ResourceBundle.getBundle() method.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","InputStream"],"returnType":"GUIResourceBundle","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":6,"FieldAccessExpr":2,"ThisExpr":2,"AssignExpr":2},"statements":{"ExpressionStmt":2},"text":"/**\n     * Create a PropertyResourceBundle from the specified stream and then\n     * create a GUIResourceBundle wrapper for it\n     **/\npublic GUIResourceBundle(Object root, InputStream propertiesStream) throws IOException {\n    this.root = root;\n    this.bundle = new PropertyResourceBundle(propertiesStream);\n}\n","name":"GUIResourceBundle","className":"GUIResourceBundle","variables":{"propertiesStream":1,"root":1},"constants":{},"javaDoc":"Create a PropertyResourceBundle from the specified stream and then create a GUIResourceBundle wrapper for it","comments":"\n     * Create a PropertyResourceBundle from the specified stream and then\n     * create a GUIResourceBundle wrapper for it\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","File"],"returnType":"GUIResourceBundle","methodCalls":{},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":2},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/**\n     * Create a PropertyResourceBundle from the specified properties file and\n     * then create a GUIResourceBundle wrapper for it.\n     **/\npublic GUIResourceBundle(Object root, File propertiesFile) throws IOException {\n    this(root, new FileInputStream(propertiesFile));\n}\n","name":"GUIResourceBundle","className":"GUIResourceBundle","variables":{"propertiesFile":1,"root":1},"constants":{},"javaDoc":"Create a PropertyResourceBundle from the specified properties file and then create a GUIResourceBundle wrapper for it","comments":"\n     * Create a PropertyResourceBundle from the specified properties file and\n     * then create a GUIResourceBundle wrapper for it.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Enumeration","methodCalls":{"getKeys":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is one of the abstract methods of ResourceBundle */\npublic Enumeration getKeys() {\n    return bundle.getKeys();\n}\n","name":"getKeys","className":"GUIResourceBundle","variables":{"bundle":1},"constants":{},"javaDoc":"This is one of the abstract methods of ResourceBundle","comments":" This is one of the abstract methods of ResourceBundle ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Object","methodCalls":{"getObject":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is the other abstract method of ResourceBundle */\nprotected Object handleGetObject(String key) throws MissingResourceException {\n    // simply defer to the wrapped bundle\n    return bundle.getObject(key);\n}\n","name":"handleGetObject","className":"GUIResourceBundle","variables":{"bundle":1},"constants":{},"javaDoc":"This is the other abstract method of ResourceBundle","comments":"simply defer to the wrapped bundle  This is the other abstract method of ResourceBundle ","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/** This is a property accessor method for our root object */\npublic Object getRoot() {\n    return root;\n}\n","name":"getRoot","className":"GUIResourceBundle","variables":{"root":1},"constants":{},"javaDoc":"This is a property accessor method for our root object","comments":" This is a property accessor method for our root object ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"String","methodCalls":{"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/** \n     * This method is like the inherited getString() method, except that \n     * when the named resource is not found, it returns the specified default \n     * instead of throwing an exception \n     **/\npublic String getString(String key, String defaultValue) {\n    try {\n        return bundle.getString(key);\n    } catch (MissingResourceException e) {\n        return defaultValue;\n    }\n}\n","name":"getString","className":"GUIResourceBundle","variables":{"e":1,"defaultValue":1,"bundle":1},"constants":{},"javaDoc":"This method is like the inherited getString() method except that when the named resource is not found it returns the specified default instead of throwing an exception","comments":" \n     * This method is like the inherited getString() method, except that \n     * when the named resource is not found, it returns the specified default \n     * instead of throwing an exception \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"java.util.List","methodCalls":{"add":1,"hasMoreTokens":1,"nextToken":1,"getString":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":[],"types":{"StringTokenizer":1,"ArrayList":1,"String":1},"expressions":{"ObjectCreationExpr":2,"VariableDeclarationExpr":3,"BooleanLiteralExpr":1,"NameExpr":14,"StringLiteralExpr":1,"MethodCallExpr":4},"statements":{"WhileStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/**\n     * Look up the named resource and parse it as a list of strings separated\n     * by spaces, tabs, or commas.\n     **/\npublic java.util.List getStringList(String key) throws MissingResourceException {\n    String s = getString(key);\n    StringTokenizer t = new StringTokenizer(s, \", \\t\", false);\n    ArrayList list = new ArrayList();\n    while (t.hasMoreTokens()) list.add(t.nextToken());\n    return list;\n}\n","name":"getStringList","className":"GUIResourceBundle","variables":{"s":2,"t":3,"list":3},"constants":{"\", \\t\"":1,"false":1},"javaDoc":"Look up the named resource and parse it as a list of strings separated by spaces tabs or commas","comments":"\n     * Look up the named resource and parse it as a list of strings separated\n     * by spaces, tabs, or commas.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","java.util.List"],"returnType":"java.util.List","methodCalls":{"getStringList":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/** Like above, but return a default instead of throwing an exception */\npublic java.util.List getStringList(String key, java.util.List defaultValue) {\n    try {\n        return getStringList(key);\n    } catch (MissingResourceException e) {\n        return defaultValue;\n    }\n}\n","name":"getStringList","className":"GUIResourceBundle","variables":{"e":1,"defaultValue":1},"constants":{},"javaDoc":"Like above but return a default instead of throwing an exception","comments":" Like above, but return a default instead of throwing an exception ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"boolean","methodCalls":{"toLowerCase":1,"equals":6,"getString":1},"annotations":[],"exceptions":["MissingResourceException","MalformedResourceException"],"concepts":[],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BooleanLiteralExpr":6,"NameExpr":27,"StringLiteralExpr":7,"MethodCallExpr":8,"AssignExpr":1},"statements":{"IfStmt":6,"BlockStmt":1,"ReturnStmt":6,"ThrowStmt":1,"ExpressionStmt":2},"text":"/** Look up the named resource and try to interpret it as a boolean. */\npublic boolean getBoolean(String key) throws MissingResourceException {\n    String s = bundle.getString(key);\n    s = s.toLowerCase();\n    if (s.equals(\"true\"))\n        return true;\n    else if (s.equals(\"false\"))\n        return false;\n    else if (s.equals(\"yes\"))\n        return true;\n    else if (s.equals(\"no\"))\n        return false;\n    else if (s.equals(\"on\"))\n        return true;\n    else if (s.equals(\"off\"))\n        return false;\n    else {\n        throw new MalformedResourceException(\"boolean\", key);\n    }\n}\n","name":"getBoolean","className":"GUIResourceBundle","variables":{"s":9,"bundle":1,"key":1},"constants":{"\"on\"":1,"\"boolean\"":1,"\"off\"":1,"true":3,"false":3,"\"false\"":1,"\"yes\"":1,"\"no\"":1,"\"true\"":1},"javaDoc":"Look up the named resource and try to interpret it as a boolean","comments":" Look up the named resource and try to interpret it as a boolean. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","boolean"],"returnType":"boolean","methodCalls":{"getMessage":1,"getBoolean":1,"System.err.println":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** As above, but return the default instead of throwing an exception */\npublic boolean getBoolean(String key, boolean defaultValue) {\n    try {\n        return getBoolean(key);\n    } catch (MissingResourceException e) {\n        if (e instanceof MalformedResourceException)\n            System.err.println(\"WARNING: \" + e.getMessage());\n        return defaultValue;\n    }\n}\n","name":"getBoolean","className":"GUIResourceBundle","variables":{"e":3,"defaultValue":1},"constants":{"\"WARNING: \"":1},"javaDoc":"As above but return the default instead of throwing an exception","comments":" As above, but return the default instead of throwing an exception ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"int","methodCalls":{"intValue":1,"getString":1,"decode":1},"annotations":[],"exceptions":["MissingResourceException","NumberFormatException","MalformedResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":11,"StringLiteralExpr":1,"MethodCallExpr":3},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/** Like getBoolean(), but for integers */\npublic int getInt(String key) throws MissingResourceException {\n    String s = bundle.getString(key);\n    try {\n        // and hexadecimal numbers\n        return Integer.decode(s).intValue();\n    } catch (NumberFormatException e) {\n        throw new MalformedResourceException(\"int\", key);\n    }\n}\n         // Use decode() instead of parseInt() so we support octal\n\n","name":"getInt","className":"GUIResourceBundle","variables":{"Integer":1,"s":1,"e":1,"bundle":1,"key":1},"constants":{"\"int\"":1},"javaDoc":"Like getBoolean() but for integers","comments":"Use decode() instead of parseInt() so we support octal and hexadecimal numbers  Like getBoolean(), but for integers ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","int"],"returnType":"int","methodCalls":{"getInt":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** As above, but with a default value */\npublic int getInt(String key, int defaultValue) {\n    try {\n        return getInt(key);\n    } catch (MissingResourceException e) {\n        if (e instanceof MalformedResourceException)\n            System.err.println(\"WARNING: \" + e.getMessage());\n        return defaultValue;\n    }\n}\n","name":"getInt","className":"GUIResourceBundle","variables":{"e":3,"defaultValue":1},"constants":{"\"WARNING: \"":1},"javaDoc":"As above but with a default value","comments":" As above, but with a default value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"double","methodCalls":{"parseDouble":1,"getString":1},"annotations":[],"exceptions":["MissingResourceException","NumberFormatException","MalformedResourceException"],"concepts":["ExceptionHandling"],"types":{"String":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"NameExpr":9,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ThrowStmt":1,"ExpressionStmt":1},"text":"/** Return a resource of type double */\npublic double getDouble(String key) throws MissingResourceException {\n    String s = bundle.getString(key);\n    try {\n        return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n        throw new MalformedResourceException(\"double\", key);\n    }\n}\n","name":"getDouble","className":"GUIResourceBundle","variables":{"s":1,"e":1,"bundle":1,"Double":1,"key":1},"constants":{"\"double\"":1},"javaDoc":"Return a resource of type double","comments":" Return a resource of type double ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","double"],"returnType":"double","methodCalls":{"getDouble":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** As above, but with a default value */\npublic double getDouble(String key, double defaultValue) {\n    try {\n        return getDouble(key);\n    } catch (MissingResourceException e) {\n        if (e instanceof MalformedResourceException)\n            System.err.println(\"WARNING: \" + e.getMessage());\n        return defaultValue;\n    }\n}\n","name":"getDouble","className":"GUIResourceBundle","variables":{"e":3,"defaultValue":1},"constants":{"\"WARNING: \"":1},"javaDoc":"As above but with a default value","comments":" As above, but with a default value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Font","methodCalls":{"getString":1,"decode":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":[],"types":{},"expressions":{"NameExpr":7,"MethodCallExpr":2},"statements":{"ReturnStmt":1},"text":"/** Look up the named resource and convert to a Font */\npublic Font getFont(String key) throws MissingResourceException {\n    // whether the resource value was well-formed or not.\n    return Font.decode(bundle.getString(key));\n}\n     // Font.decode() always returns a Font object, so we can't check\n\n","name":"getFont","className":"GUIResourceBundle","variables":{"bundle":1,"Font":1},"constants":{},"javaDoc":"Look up the named resource and convert to a Font","comments":"Font decode() always returns a Font object so we can't check whether the resource value was well-formed or not  Look up the named resource and convert to a Font ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Font"],"returnType":"Font","methodCalls":{"getFont":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":2},"text":"/** As above, but with a default value */\npublic Font getFont(String key, Font defaultValue) {\n    try {\n        return getFont(key);\n    } catch (MissingResourceException e) {\n        return defaultValue;\n    }\n}\n","name":"getFont","className":"GUIResourceBundle","variables":{"e":1,"defaultValue":1},"constants":{},"javaDoc":"As above but with a default value","comments":" As above, but with a default value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"Color","methodCalls":{"getString":1,"decode":1},"annotations":[],"exceptions":["MissingResourceException","NumberFormatException","MalformedResourceException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":8,"StringLiteralExpr":1,"MethodCallExpr":2},"statements":{"TryStmt":1,"BlockStmt":2,"ReturnStmt":1,"ThrowStmt":1},"text":"/** Look up the named resource, and convert to a Color */\npublic Color getColor(String key) throws MissingResourceException {\n    try {\n        return Color.decode(bundle.getString(key));\n    } catch (NumberFormatException e) {\n        throw new MalformedResourceException(\"Color\", key);\n    }\n}\n         // It would be useful to try to parse color names here as well\n\n         // as numeric color specifications\n\n","name":"getColor","className":"GUIResourceBundle","variables":{"e":1,"Color":1,"bundle":1,"key":1},"constants":{"\"Color\"":1},"javaDoc":"Look up the named resource and convert to a Color","comments":"It would be useful to try to parse color names here as well as numeric color specifications  Look up the named resource, and convert to a Color ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Color"],"returnType":"Color","methodCalls":{"getColor":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":13,"StringLiteralExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/** As above, but with a default value */\npublic Color getColor(String key, Color defaultValue) {\n    try {\n        return getColor(key);\n    } catch (MissingResourceException e) {\n        if (e instanceof MalformedResourceException)\n            System.err.println(\"WARNING: \" + e.getMessage());\n        return defaultValue;\n    }\n}\n","name":"getColor","className":"GUIResourceBundle","variables":{"e":3,"defaultValue":1},"constants":{"\"WARNING: \"":1},"javaDoc":"As above but with a default value","comments":" As above, but with a default value ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ResourceParser"],"returnType":"void","methodCalls":{"put":1,"getResourceTypes":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Class[]":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"ArrayAccessExpr":1,"BinaryExpr":1,"NameExpr":14,"FieldAccessExpr":1,"UnaryExpr":1,"MethodCallExpr":2},"statements":{"ForStmt":1,"ExpressionStmt":2},"text":"/** An extension mechanism: register a parser for new resource types */\npublic static void registerResourceParser(ResourceParser parser) {\n    // Ask the ResourceParser what types it can parse\n    Class[] supportedTypes = parser.getResourceTypes();\n    // Register it in the hashtable for each of those types\n    for (int i = 0; i < supportedTypes.length; i++) parsers.put(supportedTypes[i], parser);\n}\n","name":"registerResourceParser","className":"GUIResourceBundle","variables":{"parser":1,"parsers":1,"i":4,"supportedTypes":2},"constants":{"0":1},"javaDoc":"An extension mechanism: register a parser for new resource types","comments":"Ask the ResourceParser what types it can parse Register it in the hashtable for each of those types  An extension mechanism: register a parser for new resource types ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"ResourceParser","methodCalls":{"get":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"CastExpr":1,"NameExpr":4,"MethodCallExpr":1},"statements":{"ReturnStmt":1},"text":"/** Look up a ResourceParser for the specified resource type */\npublic static ResourceParser getResourceParser(Class type) {\n    return (ResourceParser) parsers.get(type);\n}\n","name":"getResourceParser","className":"GUIResourceBundle","variables":{"parsers":1},"constants":{},"javaDoc":"Look up a ResourceParser for the specified resource type","comments":" Look up a ResourceParser for the specified resource type ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","Class"],"returnType":"Object","methodCalls":{"getName":4,"get":1,"getMessage":1,"parse":1},"annotations":[],"exceptions":["MissingResourceException","Exception","MalformedResourceException"],"concepts":["Casting","ExceptionHandling"],"types":{"ResourceParser":1,"String":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":8,"CastExpr":1,"NameExpr":30,"StringLiteralExpr":5,"ThisExpr":1,"MethodCallExpr":7},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":3,"ThrowStmt":3,"ReturnStmt":1,"ExpressionStmt":2},"text":"/**\n     * Look for a ResourceParser for the named type, and if one is found, \n     * ask it to parse and return the named resource \n     **/\npublic Object getResource(String key, Class type) throws MissingResourceException {\n    // Get a parser for the specified type\n    ResourceParser parser = (ResourceParser) parsers.get(type);\n    if (parser == null)\n        throw new MissingResourceException(\"No ResourceParser registered for \" + type.getName() + \" resources\", type.getName(), key);\n    try {\n        // Ask the parser to parse the resource\n        return parser.parse(this, key, type);\n    } catch (MissingResourceException e) {\n        throw e;\n    } catch (Exception e) {\n        String msg = \"Malformed \" + type.getName() + \" resource: \" + key + \": \" + e.getMessage();\n        throw new MalformedResourceException(msg, type.getName(), key);\n    }\n}\n                   // Rethrow MissingResourceException exceptions\n\n         // If any other type of exception occurs, convert it to\n\n         // a MalformedResourceException\n\n","name":"getResource","className":"GUIResourceBundle","variables":{"msg":2,"parser":3,"e":4,"parsers":1,"type":4,"key":3},"constants":{"\" resource: \"":1,"\" resources\"":1,"null":1,"\": \"":1,"\"No ResourceParser registered for \"":1,"\"Malformed \"":1},"javaDoc":"Look for a ResourceParser for the named type and if one is found ask it to parse and return the named resource","comments":"Get a parser for the specified type Ask the parser to parse the resource Rethrow MissingResourceException exceptions If any other type of exception occurs convert it to a MalformedResourceException \n     * Look for a ResourceParser for the named type, and if one is found, \n     * ask it to parse and return the named resource \n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","Class","Object"],"returnType":"Object","methodCalls":{"getResource":1,"getMessage":1,"System.err.println":1},"annotations":[],"exceptions":["MissingResourceException"],"concepts":["ExceptionHandling","Recursion"],"types":{},"expressions":{"BinaryExpr":1,"NameExpr":14,"StringLiteralExpr":1,"FieldAccessExpr":1,"InstanceOfExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"TryStmt":1,"BlockStmt":2,"ReturnStmt":2,"ExpressionStmt":1},"text":"/**\n     * Like the 2-argument version of getResource, but return a default value\n     * instead of throwing a MissingResourceException\n     **/\npublic Object getResource(String key, Class type, Object defaultValue) {\n    try {\n        return getResource(key, type);\n    } catch (MissingResourceException e) {\n        if (e instanceof MalformedResourceException)\n            System.err.println(\"WARNING: \" + e.getMessage());\n        return defaultValue;\n    }\n}\n","name":"getResource","className":"GUIResourceBundle","variables":{"e":3,"defaultValue":1},"constants":{"\"WARNING: \"":1},"javaDoc":"Like the 2-argument version of getResource but return a default value instead of throwing a MissingResourceException","comments":"\n     * Like the 2-argument version of getResource, but return a default value\n     * instead of throwing a MissingResourceException\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Class[]","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Return an array of classes that specify what kind of resources\n     * this parser can handle \n     **/\npublic Class[] getResourceTypes();\n","name":"getResourceTypes","className":"ResourceParser","variables":{},"constants":{},"javaDoc":"Return an array of classes that specify what kind of resources this parser can handle","comments":"\n     * Return an array of classes that specify what kind of resources\n     * this parser can handle \n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["GUIResourceBundle","String","Class"],"returnType":"Object","methodCalls":{},"annotations":[],"exceptions":["Exception"],"concepts":[],"types":{},"expressions":{},"statements":{},"text":"/**\n     * Read the property named by key from the specified bundle, convert\n     * it to the specified type, and return it.  For complex resources,\n     * the parser may need to read more than one property from the bundle; \n     * typically it may a number of properties whose names begin with the \n     * specified key.\n     **/\npublic Object parse(GUIResourceBundle bundle, String key, Class type) throws Exception;\n","name":"parse","className":"ResourceParser","variables":{},"constants":{},"javaDoc":"Read the property named by key from the specified bundle convert it to the specified type and return it For complex resources the parser may need to read more than one property from the bundle; typically it may a number of properties whose names begin with the specified key","comments":"\n     * Read the property named by key from the specified bundle, convert\n     * it to the specified type, and return it.  For complex resources,\n     * the parser may need to read more than one property from the bundle; \n     * typically it may a number of properties whose names begin with the \n     * specified key.\n     *","isEmpty":true,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Event"],"returnType":"void","methodCalls":{"setFontFamily":1,"getSelectedValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"CastExpr":1,"MethodCallExpr":2},"statements":{"ExpressionStmt":1},"text":"public void itemChosen(ItemChooser.Event e) {\n    setFontFamily((String) e.getSelectedValue());\n}\n","name":"itemChosen","className":"","variables":{"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Event"],"returnType":"void","methodCalls":{"getSelectedValue":1,"setFontStyle":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":7,"CastExpr":1,"EnclosedExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void itemChosen(ItemChooser.Event e) {\n    setFontStyle(((Integer) e.getSelectedValue()).intValue());\n}\n","name":"itemChosen","className":"","variables":{"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ItemChooser.Event"],"returnType":"void","methodCalls":{"parseInt":1,"getSelectedValue":1,"setFontSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":8,"CastExpr":1,"MethodCallExpr":3},"statements":{"ExpressionStmt":1},"text":"public void itemChosen(ItemChooser.Event e) {\n    setFontSize(Integer.parseInt((String) e.getSelectedValue()));\n}\n","name":"itemChosen","className":"","variables":{"Integer":1,"e":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"hide":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":2,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    hide();\n}\n","name":"actionPerformed","className":"","variables":{},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"hide":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NullLiteralExpr":1,"NameExpr":3,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    selectedFont = null;\n    hide();\n}\n","name":"actionPerformed","className":"","variables":{"selectedFont":1},"constants":{"null":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Frame"],"returnType":"FontChooser","methodCalls":{"add":16,"addActionListener":2,"createGlue":4,"getSelectedValue":3,"getContentPane":1,"addItemChooserListener":3,"pack":1,"setFontStyle":1,"setFontSize":1,"setFontFamily":1,"parseInt":1,"hide":2,"getAvailableFontFamilyNames":1,"setModal":1,"createHorizontalStrut":4,"setFont":1,"createHorizontalBox":2,"getLocalGraphicsEnvironment":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod"],"types":{"Container":1,"Box":2,"GraphicsEnvironment":1},"expressions":{"IntegerLiteralExpr":11,"ObjectCreationExpr":13,"VariableDeclarationExpr":4,"ArrayAccessExpr":1,"NameExpr":194,"StringLiteralExpr":6,"AssignExpr":12,"NullLiteralExpr":3,"BooleanLiteralExpr":1,"CastExpr":3,"FieldAccessExpr":7,"EnclosedExpr":1,"MethodCallExpr":47},"statements":{"BlockStmt":5,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":45},"text":"/** Create a font chooser dialog for the specified frame. */\npublic FontChooser(Frame owner) {\n    // Set dialog frame and title\n    super(owner, \"Choose a Font\");\n    // This dialog must be used as a modal dialog.  In order to be used\n    // as a modeless dialog, it would have to fire a PropertyChangeEvent\n    // whenever the selected font changed, so that applications could be \n    // notified of the user's selections.\n    setModal(true);\n    // Figure out what fonts are available on the system\n    GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n    fontFamilies = env.getAvailableFontFamilyNames();\n    // Set initial values for the properties\n    family = fontFamilies[0];\n    style = Font.PLAIN;\n    size = 18;\n    selectedFont = new Font(family, style, size);\n    // Create ItemChooser objects that allow the user to select font\n    // family, style, and size.\n    families = new ItemChooser(\"Family\", fontFamilies, null, 0, ItemChooser.COMBOBOX);\n    styles = new ItemChooser(\"Style\", styleNames, styleValues, 0, ItemChooser.COMBOBOX);\n    sizes = new ItemChooser(\"Size\", sizeNames, null, 4, ItemChooser.COMBOBOX);\n    // Now register event listeners to handle selections\n    families.addItemChooserListener(new ItemChooser.Listener() {\n\n        public void itemChosen(ItemChooser.Event e) {\n            setFontFamily((String) e.getSelectedValue());\n        }\n    });\n    styles.addItemChooserListener(new ItemChooser.Listener() {\n\n        public void itemChosen(ItemChooser.Event e) {\n            setFontStyle(((Integer) e.getSelectedValue()).intValue());\n        }\n    });\n    sizes.addItemChooserListener(new ItemChooser.Listener() {\n\n        public void itemChosen(ItemChooser.Event e) {\n            setFontSize(Integer.parseInt((String) e.getSelectedValue()));\n        }\n    });\n    // Create a component to preview the font.\n    preview = new JTextArea(defaultPreviewString, 5, 40);\n    preview.setFont(selectedFont);\n    // Create buttons to dismiss the dialog, and set handlers on them\n    okay = new JButton(\"Okay\");\n    cancel = new JButton(\"Cancel\");\n    okay.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            hide();\n        }\n    });\n    cancel.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            selectedFont = null;\n            hide();\n        }\n    });\n    // Put the ItemChoosers in a Box \n    Box choosersBox = Box.createHorizontalBox();\n    choosersBox.add(Box.createHorizontalStrut(15));\n    choosersBox.add(families);\n    choosersBox.add(Box.createHorizontalStrut(15));\n    choosersBox.add(styles);\n    choosersBox.add(Box.createHorizontalStrut(15));\n    choosersBox.add(sizes);\n    choosersBox.add(Box.createHorizontalStrut(15));\n    choosersBox.add(Box.createGlue());\n    // Put the dismiss buttons in another box\n    Box buttonBox = Box.createHorizontalBox();\n    buttonBox.add(Box.createGlue());\n    buttonBox.add(okay);\n    buttonBox.add(Box.createGlue());\n    buttonBox.add(cancel);\n    buttonBox.add(Box.createGlue());\n    // Put the choosers at the top, the buttons at the bottom, and\n    // the preview in the middle.\n    Container contentPane = getContentPane();\n    contentPane.add(new JScrollPane(preview), BorderLayout.CENTER);\n    contentPane.add(choosersBox, BorderLayout.NORTH);\n    contentPane.add(buttonBox, BorderLayout.SOUTH);\n    // Set the dialog size based on the component size.\n    pack();\n}\n","name":"FontChooser","className":"FontChooser","variables":{"preview":3,"cancel":2,"choosersBox":9,"styleValues":1,"buttonBox":6,"defaultPreviewString":1,"contentPane":4,"actionPerformed":2,"sizes":2,"owner":1,"okay":2,"sizeNames":1,"e":8,"itemChosen":3,"Box":10,"env":2,"GraphicsEnvironment":1,"selectedFont":2,"families":2,"Integer":1,"size":2,"styleNames":1,"fontFamilies":3,"style":2,"styles":2,"family":2},"constants":{"\"Style\"":1,"15":4,"18":1,"\"Choose a Font\"":1,"\"Cancel\"":1,"\"Family\"":1,"0":3,"null":3,"4":1,"5":1,"true":1,"\"Size\"":1,"40":1,"\"Okay\"":1},"javaDoc":"Create a font chooser dialog for the specified frame","comments":"This dialog must be used as a modal dialog In order to be used as a modeless dialog it would have to fire a PropertyChangeEvent whenever the selected font changed so that applications could be Create ItemChooser objects that allow the user to select font Put the choosers at the top the buttons at the bottom and Set dialog frame and title notified of the user's selections Figure out what fonts are available on the system Set initial values for the properties family style and size Now register event listeners to handle selections Create a component to preview the font Create buttons to dismiss the dialog and set handlers on them Put the ItemChoosers in a Box Put the dismiss buttons in another box the preview in the middle Set the dialog size based on the component size  Create a font chooser dialog for the specified frame. ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Font","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"/**\n     * Call this method after show() to obtain the user's selection.  If the\n     * user used the \"Cancel\" button, this will return null\n     **/\npublic Font getSelectedFont() {\n    return selectedFont;\n}\n","name":"getSelectedFont","className":"FontChooser","variables":{"selectedFont":1},"constants":{},"javaDoc":"Call this method after show() to obtain the user's selection If the user used the \"Cancel\" button this will return null","comments":"\n     * Call this method after show() to obtain the user's selection.  If the\n     * user used the \"Cancel\" button, this will return null\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"String","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"// These are other property getter methods\npublic String getFontFamily() {\n    return family;\n}\n","name":"getFontFamily","className":"FontChooser","variables":{"family":1},"constants":{},"javaDoc":"","comments":" These are other property getter methods","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getFontStyle() {\n    return style;\n}\n","name":"getFontStyle","className":"FontChooser","variables":{"style":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":1},"statements":{"ReturnStmt":1},"text":"public int getFontSize() {\n    return size;\n}\n","name":"getFontSize","className":"FontChooser","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"changeFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// The property setter methods are a little more complicated.\n// Note that none of these setter methods update the corresponding\n// ItemChooser components as they ought to.\npublic void setFontFamily(String name) {\n    family = name;\n    changeFont();\n}\n","name":"setFontFamily","className":"FontChooser","variables":{"name":1,"family":1},"constants":{},"javaDoc":"","comments":" ItemChooser components as they ought to.","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"changeFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setFontStyle(int style) {\n    this.style = style;\n    changeFont();\n}\n","name":"setFontStyle","className":"FontChooser","variables":{"style":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["int"],"returnType":"void","methodCalls":{"changeFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":5,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public void setFontSize(int size) {\n    this.size = size;\n    changeFont();\n}\n","name":"setFontSize","className":"FontChooser","variables":{"size":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Font"],"returnType":"void","methodCalls":{"getSize":1,"getStyle":1,"getFamily":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":18,"AssignExpr":4,"MethodCallExpr":4},"statements":{"ExpressionStmt":5},"text":"public void setSelectedFont(Font font) {\n    selectedFont = font;\n    family = font.getFamily();\n    style = font.getStyle();\n    size = font.getSize();\n    preview.setFont(font);\n}\n","name":"setSelectedFont","className":"FontChooser","variables":{"preview":1,"size":1,"style":1,"selectedFont":1,"family":1,"font":4},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":8,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"// This method is called when the family, style, or size changes\nprotected void changeFont() {\n    selectedFont = new Font(family, style, size);\n    preview.setFont(selectedFont);\n}\n","name":"changeFont","className":"FontChooser","variables":{"preview":1,"size":1,"style":1,"selectedFont":1,"family":1},"constants":{},"javaDoc":"","comments":" This method is called when the family, style, or size changes","isEmpty":false,"hasInnerClass":false,"modifier":4}
{"paramTypes":[],"returnType":"boolean","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BooleanLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// Override this inherited method to prevent anyone from making us modeless\npublic boolean isModal() {\n    return true;\n}\n","name":"isModal","className":"FontChooser","variables":{},"constants":{"true":1},"javaDoc":"","comments":" Override this inherited method to prevent anyone from making us modeless","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"show":1,"getSelectedFont":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Font":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":3},"text":"public void actionPerformed(ActionEvent e) {\n    // Pop up the dialog\n    chooser.show();\n    // Get the user's selection\n    Font font = chooser.getSelectedFont();\n    // If not cancelled, set the button font\n    if (font != null)\n        button.setFont(font);\n}\n","name":"actionPerformed","className":"","variables":{"button":1,"chooser":2,"font":2},"constants":{"null":1},"javaDoc":"","comments":"Pop up the dialog Get the user's selection If not cancelled set the button font ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"setSize":1,"addActionListener":1,"show":2,"getSelectedFont":1,"getContentPane":1,"setFont":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","FinalVariables"],"types":{"JFrame":1,"FontChooser":1,"JButton":1,"Font":1},"expressions":{"ObjectCreationExpr":4,"NullLiteralExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":4,"BinaryExpr":1,"StringLiteralExpr":2,"NameExpr":29,"MethodCallExpr":8},"statements":{"IfStmt":1,"BlockStmt":1,"ExpressionStmt":10},"text":"public static void main(String[] args) {\n    // Create some components and a FontChooser dialog\n    final JFrame frame = new JFrame(\"demo\");\n    final JButton button = new JButton(\"Push Me!\");\n    final FontChooser chooser = new FontChooser(frame);\n    // Handle button clicks\n    button.addActionListener(new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            // Pop up the dialog\n            chooser.show();\n            // Get the user's selection\n            Font font = chooser.getSelectedFont();\n            // If not cancelled, set the button font\n            if (font != null)\n                button.setFont(font);\n        }\n    });\n    // Display the demo\n    frame.getContentPane().add(button);\n    frame.setSize(200, 100);\n    frame.show();\n}\n","name":"main","className":"Demo","variables":{"button":3,"actionPerformed":1,"e":1,"chooser":3,"frame":5,"font":2},"constants":{"100":1,"200":1,"\"Push Me!\"":1,"null":1,"\"demo\"":1},"javaDoc":"","comments":"Create some components and a FontChooser dialog Handle button clicks Pop up the dialog Get the user's selection If not cancelled set the button font Display the demo ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String","String","String"],"returnType":"MalformedResourceException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MalformedResourceException(String msg, String type, String key) {\n    super(msg, type, key);\n}\n","name":"MalformedResourceException","className":"MalformedResourceException","variables":{"msg":1,"type":1,"key":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"MalformedResourceException","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":4},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"// Convenience constructors: automatically generate exception message\npublic MalformedResourceException(String type, String key) {\n    super(\"Malformed \" + type + \" resource: \" + key, type, key);\n}\n","name":"MalformedResourceException","className":"MalformedResourceException","variables":{"type":2,"key":2},"constants":{"\" resource: \"":1,"\"Malformed \"":1},"javaDoc":"","comments":" Convenience constructors: automatically generate exception message","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Class","String"],"returnType":"MalformedResourceException","methodCalls":{"getName":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public MalformedResourceException(Class type, String key) {\n    this(type.getName(), key);\n}\n","name":"MalformedResourceException","className":"MalformedResourceException","variables":{"type":1,"key":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"setVisible":1,"setSize":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Scribble":1},"expressions":{"ObjectCreationExpr":1,"IntegerLiteralExpr":2,"VariableDeclarationExpr":1,"BooleanLiteralExpr":1,"NameExpr":6,"MethodCallExpr":2},"statements":{"ExpressionStmt":3},"text":"/**\n     * The main method instantiates an instance of the class, sets it size,\n     * and makes it visible on the screen\n     **/\npublic static void main(String[] args) {\n    Scribble scribble = new Scribble();\n    scribble.setSize(500, 300);\n    scribble.setVisible(true);\n}\n","name":"main","className":"Scribble","variables":{"scribble":3},"constants":{"300":1,"500":1,"true":1},"javaDoc":"The main method instantiates an instance of the class sets it size and makes it visible on the screen","comments":"\n     * The main method instantiates an instance of the class, sets it size,\n     * and makes it visible on the screen\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["WindowEvent"],"returnType":"void","methodCalls":{"exit":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void windowClosing(WindowEvent e) {\n    System.exit(0);\n}\n","name":"windowClosing","className":"","variables":{"System":1},"constants":{"0":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"Scribble","methodCalls":{"add":17,"setOrientation":1,"exit":1,"setBorder":1,"setLayout":1,"setBackground":1},"annotations":[],"exceptions":[],"concepts":["InnerMethod","PolyMorphism"],"types":{"ClearAction":1,"Container":1,"Action":6,"QuitAction":1,"ColorAction":3,"SelectColorAction":1,"JToolBar":2,"JMenuBar":1,"JMenu":2},"expressions":{"ObjectCreationExpr":15,"IntegerLiteralExpr":1,"VariableDeclarationExpr":12,"StringLiteralExpr":3,"NameExpr":120,"FieldAccessExpr":9,"ThisExpr":3,"MethodCallExpr":25,"AssignExpr":1},"statements":{"BlockStmt":1,"ExplicitConstructorInvocationStmt":1,"ExpressionStmt":37},"text":"/**\n     * This constructor creates the GUI for this application.\n     **/\npublic Scribble() {\n    // Call superclass constructor and set window title\n    super(\"Scribble\");\n    // Handle window close requests\n    this.addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            System.exit(0);\n        }\n    });\n    // All content of a JFrame (except for the menubar) goes in the\n    // Frame's internal \"content pane\", not in the frame itself.\n    // The same is true for JDialog and similar top-level containers.\n    Container contentPane = this.getContentPane();\n    // Specify a layout manager for the content pane\n    contentPane.setLayout(new BorderLayout());\n    // Create the main scribble pane component, give it a border, and\n    // a background color, and add it to the content pane\n    scribblePane = new ScribblePane2();\n    scribblePane.setBorder(new BevelBorder(BevelBorder.LOWERED));\n    scribblePane.setBackground(Color.white);\n    contentPane.add(scribblePane, BorderLayout.CENTER);\n    // Create a menubar and add it to this window.  Note that JFrame\n    // handles menus specially and has a special method for adding them\n    // outside of the content pane.\n    // Create a menubar\n    JMenuBar menubar = new JMenuBar();\n    // Display it in the JFrame\n    this.setJMenuBar(menubar);\n    // Create menus and add to the menubar\n    JMenu filemenu = new JMenu(\"File\");\n    JMenu colormenu = new JMenu(\"Color\");\n    menubar.add(filemenu);\n    menubar.add(colormenu);\n    // Create some Action objects for use in the menus and toolbars.\n    // An Action combines a menu title and/or icon with an ActionListener.\n    // These Action classes are defined as inner classes below.\n    Action clear = new ClearAction();\n    Action quit = new QuitAction();\n    Action black = new ColorAction(Color.black);\n    Action red = new ColorAction(Color.red);\n    Action blue = new ColorAction(Color.blue);\n    Action select = new SelectColorAction();\n    // Populate the menus using Action objects\n    filemenu.add(clear);\n    filemenu.add(quit);\n    colormenu.add(black);\n    colormenu.add(red);\n    colormenu.add(blue);\n    colormenu.add(select);\n    // Now create a toolbar, add actions to it, and add it to the\n    // top of the frame (where it appears underneath the menubar)\n    JToolBar toolbar = new JToolBar();\n    toolbar.add(clear);\n    toolbar.add(select);\n    toolbar.add(quit);\n    contentPane.add(toolbar, BorderLayout.NORTH);\n    // Create another toolbar for use as a color palette and add to \n    // the left side of the window.\n    JToolBar palette = new JToolBar();\n    palette.add(black);\n    palette.add(red);\n    palette.add(blue);\n    palette.setOrientation(SwingConstants.VERTICAL);\n    contentPane.add(palette, BorderLayout.WEST);\n}\n","name":"Scribble","className":"Scribble","variables":{"select":1,"e":1,"filemenu":3,"clear":1,"black":1,"contentPane":5,"System":1,"red":1,"toolbar":4,"menubar":3,"scribblePane":3,"blue":1,"windowClosing":1,"quit":1,"palette":5,"colormenu":5},"constants":{"0":1,"\"File\"":1,"\"Color\"":1,"\"Scribble\"":1},"javaDoc":"This constructor creates the GUI for this application","comments":"All content of a JFrame (except for the menubar) goes in the Frame's internal \"content pane\" not in the frame itself Create the main scribble pane component give it a border and Create a menubar and add it to this window Note that JFrame handles menus specially and has a special method for adding them outside of the content pane Create some Action objects for use in the menus and toolbars An Action combines a menu title and/or icon with an ActionListener Now create a toolbar add actions to it and add it to the Create another toolbar for use as a color palette and add to Call superclass constructor and set window title Handle window close requests The same is true for JDialog and similar top-level containers Specify a layout manager for the content pane a background color and add it to the content pane Create a menubar Display it in the JFrame Create menus and add to the menubar These Action classes are defined as inner classes below Populate the menus using Action objects top of the frame (where it appears underneath the menubar) the left side of the window \n     * This constructor creates the GUI for this application.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"ClearAction","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public ClearAction() {\n    // Specify the name of the action\n    super(\"Clear\");\n}\n","name":"ClearAction","className":"ClearAction","variables":{},"constants":{"\"Clear\"":1},"javaDoc":"","comments":"Specify the name of the action ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"clear":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    scribblePane.clear();\n}\n","name":"actionPerformed","className":"ClearAction","variables":{"scribblePane":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"QuitAction","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public QuitAction() {\n    super(\"Quit\");\n}\n","name":"QuitAction","className":"QuitAction","variables":{},"constants":{"\"Quit\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"exit":1,"showConfirmDialog":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":11,"StringLiteralExpr":1,"FieldAccessExpr":1,"ThisExpr":1,"MethodCallExpr":2},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    // Use JOptionPane to confirm that the user really wants to quit\n    int response = JOptionPane.showConfirmDialog(Scribble.this, \"Really Quit?\");\n    if (response == JOptionPane.YES_OPTION)\n        System.exit(0);\n}\n","name":"actionPerformed","className":"QuitAction","variables":{"response":2,"Scribble":1,"JOptionPane":1,"System":1},"constants":{"\"Really Quit?\"":1,"0":1},"javaDoc":"","comments":"Use JOptionPane to confirm that the user really wants to quit ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"ColorAction","methodCalls":{"putValue":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"ObjectCreationExpr":1,"NameExpr":9,"FieldAccessExpr":2,"ThisExpr":1,"AssignExpr":1,"MethodCallExpr":1},"statements":{"ExpressionStmt":2},"text":"public ColorAction(Color color) {\n    this.color = color;\n    // specify icon\n    putValue(Action.SMALL_ICON, new ColorIcon(color));\n}\n","name":"ColorAction","className":"ColorAction","variables":{"color":2},"constants":{},"javaDoc":"","comments":"specify icon ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":4,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"public void actionPerformed(ActionEvent e) {\n    // Set current drawing color\n    scribblePane.setColor(color);\n}\n","name":"actionPerformed","className":"ColorAction","variables":{"scribblePane":1},"constants":{},"javaDoc":"","comments":"Set current drawing color ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Color"],"returnType":"ColorIcon","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"public ColorIcon(Color color) {\n    this.color = color;\n}\n","name":"ColorIcon","className":"ColorIcon","variables":{"color":1},"constants":{},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"// These two methods specify the size of the icon\npublic int getIconHeight() {\n    return 16;\n}\n","name":"getIconHeight","className":"ColorIcon","variables":{},"constants":{"16":1},"javaDoc":"","comments":" These two methods specify the size of the icon","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"int","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1},"statements":{"ReturnStmt":1},"text":"public int getIconWidth() {\n    return 16;\n}\n","name":"getIconWidth","className":"ColorIcon","variables":{},"constants":{"16":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Component","Graphics","int","int"],"returnType":"void","methodCalls":{"setColor":1,"fillRect":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":2,"NameExpr":9,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"// This method draws the icon\npublic void paintIcon(Component c, Graphics g, int x, int y) {\n    g.setColor(color);\n    g.fillRect(x, y, 16, 16);\n}\n","name":"paintIcon","className":"ColorIcon","variables":{"g":2},"constants":{"16":2},"javaDoc":"","comments":" This method draws the icon","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"SelectColorAction","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"StringLiteralExpr":1},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"public SelectColorAction() {\n    super(\"Select Color...\");\n}\n","name":"SelectColorAction","className":"SelectColorAction","variables":{},"constants":{"\"Select Color...\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"setColor":1,"showDialog":1,"getColor":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"Color":1},"expressions":{"NullLiteralExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":1,"NameExpr":12,"StringLiteralExpr":1,"ThisExpr":1,"MethodCallExpr":3},"statements":{"IfStmt":1,"ExpressionStmt":2},"text":"public void actionPerformed(ActionEvent e) {\n    Color color = JColorChooser.showDialog(Scribble.this, \"Select Drawing Color\", scribblePane.getColor());\n    if (color != null)\n        scribblePane.setColor(color);\n}\n","name":"actionPerformed","className":"SelectColorAction","variables":{"scribblePane":2,"color":2,"Scribble":1,"JColorChooser":1},"constants":{"null":1,"\"Select Drawing Color\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getDriverName":1,"next":2,"getProperty":4,"forName":1,"length":2,"getDatabaseProductVersion":1,"getString":3,"getColumns":1,"getConnection":1,"getURL":1,"getDatabaseProductName":1,"load":1,"getTables":1,"getUserName":1,"getMetaData":1,"System.err.println":3,"close":1,"getDriverVersion":1,"System.out.println":8},"annotations":[],"exceptions":["Exception","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"Connection":1,"ResultSet":2,"String":6,"Properties":1,"DatabaseMetaData":1,"int":1},"expressions":{"ObjectCreationExpr":3,"IntegerLiteralExpr":6,"VariableDeclarationExpr":12,"ArrayAccessExpr":11,"BinaryExpr":26,"NameExpr":187,"StringLiteralExpr":35,"UnaryExpr":5,"InstanceOfExpr":1,"AssignExpr":7,"NullLiteralExpr":8,"CastExpr":1,"ClassExpr":1,"FieldAccessExpr":12,"EnclosedExpr":3,"MethodCallExpr":41},"statements":{"IfStmt":10,"WhileStmt":2,"TryStmt":3,"BlockStmt":10,"ForStmt":1,"ThrowStmt":2,"ExpressionStmt":32},"text":"public static void main(String[] args) {\n    // The JDBC connection to the database server\n    Connection c = null;\n    try {\n        // Look for the properties file DB.props in the same directory as\n        // this program.  It will contain default values for the various\n        // parameters needed to connect to a database\n        Properties p = new Properties();\n        try {\n            p.load(GetDBInfo.class.getResourceAsStream(\"DB.props\"));\n        } catch (Exception e) {\n        }\n        // Get default values from the properties file\n        // Driver class name\n        String driver = p.getProperty(\"driver\");\n        // JDBC URL for server\n        String server = p.getProperty(\"server\", \"\");\n        // db user name\n        String user = p.getProperty(\"user\", \"\");\n        // db password\n        String password = p.getProperty(\"password\", \"\");\n        // These variables don't have defaults\n        // The db name (appended to server URL)\n        String database = null;\n        // The optional name of a table in the db\n        String table = null;\n        // Parse the command-line args to override the default values above\n        for (int i = 0; i < args.length; i++) {\n            if (//-d <driver>\n            args[i].equals(\"-d\"))\n                //-d <driver>\n                driver = args[++i];\n            else if (//-s <server>\n            args[i].equals(\"-s\"))\n                //-s <server>\n                server = args[++i];\n            else if (//-u <user>\n            args[i].equals(\"-u\"))\n                //-u <user>\n                user = args[++i];\n            else if (args[i].equals(\"-p\"))\n                password = args[++i];\n            else if (// <dbname>\n            database == null)\n                // <dbname>\n                database = args[i];\n            else if (// <table>\n            table == null)\n                // <table>\n                table = args[i];\n            else\n                throw new IllegalArgumentException(\"Unknown argument: \" + args[i]);\n             // Make sure that at least a server or a database were specified. \n\n        }\n        // If not, we have no idea what to connect to, and cannot continue.\n        if ((server.length() == 0) && (database.length() == 0))\n            throw new IllegalArgumentException(\"No database specified.\");\n        // Load the db driver, if any was specified.\n        if (driver != null)\n            Class.forName(driver);\n        // Now attempt to open a connection to the specified database on\n        // the specified server, using the specified name and password\n        c = DriverManager.getConnection(server + database, user, password);\n        // Get the DatabaseMetaData object for the connection.  This is the\n        // object that will return us all the data we're interested in here\n        DatabaseMetaData md = c.getMetaData();\n        // Display information about the server, the driver, etc.\n        System.out.println(\"DBMS: \" + md.getDatabaseProductName() + \" \" + md.getDatabaseProductVersion());\n        System.out.println(\"JDBC Driver: \" + md.getDriverName() + \" \" + md.getDriverVersion());\n        System.out.println(\"Database: \" + md.getURL());\n        System.out.println(\"User: \" + md.getUserName());\n        // returned in a ResultSet, just like query results are.\n        if (table == null) {\n            System.out.println(\"Tables:\");\n            ResultSet r = md.getTables(\"\", \"\", \"%\", null);\n            while (r.next()) System.out.println(\"\\t\" + r.getString(3));\n             // Now, if the user did not specify a table, then display a list of\n\n             // all tables defined in the named database.  Note that tables are\n\n        } else // Otherwise, list all columns of the specified table.\n        // Again, information about the columns is returned in a ResultSet\n        {\n            System.out.println(\"Columns of \" + table + \": \");\n            ResultSet r = md.getColumns(\"\", \"\", table, \"%\");\n            while (r.next()) System.out.println(\"\\t\" + r.getString(4) + \" : \" + r.getString(6));\n        }\n    }// Print an error message if anything goes wrong.\n     catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java GetDBInfo [-d <driver] \" + \"[-s <dbserver>]\\n\" + \"\\t[-u <username>] [-p <password>] <dbname>\");\n    } finally // Always remember to close the Connection object when we're done!\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"GetDBInfo","variables":{"server":4,"c":4,"e":5,"i":14,"p":6,"args":11,"password":2,"database":5,"r":7,"driver":3,"md":9,"Class":1,"user":2,"DriverManager":1,"table":5},"constants":{"\"\"":7,"\"driver\"":1,"\"-u\"":1,"\"-s\"":1,"\": \"":1,"\"\\t[-u <username>] [-p <password>] <dbname>\"":1,"\" : \"":1,"\"JDBC Driver: \"":1,"\"User: \"":1,"\"-d\"":1,"\"Unknown argument: \"":1,"\"Tables:\"":1,"\" \"":2,"\"DBMS: \"":1,"\"password\"":1,"\"Columns of \"":1,"\"-p\"":1,"\"No database specified.\"":1,"0":3,"\"[-s <dbserver>]\\n\"":1,"3":1,"\"Usage: java GetDBInfo [-d <driver] \"":1,"null":8,"\"DB.props\"":1,"\"Database: \"":1,"4":1,"\"server\"":1,"6":1,"\"\\t\"":2,"\"user\"":1,"\"%\"":2},"javaDoc":"","comments":"The JDBC connection to the database server Look for the properties file DB props in the same directory as this program It will contain default values for the various Get default values from the properties file These variables don't have defaults Make sure that at least a server or a database were specified Now attempt to open a connection to the specified database on Get the DatabaseMetaData object for the connection This is the Now if the user did not specify a table then display a list of all tables defined in the named database Note that tables are parameters needed to connect to a database Driver class name JDBC URL for server db user name db password The db name (appended to server URL) The optional name of a table in the db Parse the command-line args to override the default values above -d <driver> -d <driver> -s <server> -s <server> -u <user> -u <user> <dbname> <dbname> <table> <table> If not we have no idea what to connect to and cannot continue Load the db driver if any was specified the specified server using the specified name and password object that will return us all the data we're interested in here Display information about the server the driver etc returned in a ResultSet just like query results are Otherwise list all columns of the specified table Again information about the columns is returned in a ResultSet Print an error message if anything goes wrong Always remember to close the Connection object when we're done! ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection"],"returnType":"RemoteDBBankServer","methodCalls":{},"annotations":[],"exceptions":["RemoteException"],"concepts":[],"types":{},"expressions":{"NameExpr":3,"FieldAccessExpr":1,"ThisExpr":1,"AssignExpr":1},"statements":{"ExpressionStmt":1},"text":"/** The constructor.  Just save the database connection object away */\npublic RemoteDBBankServer(Connection db) throws RemoteException {\n    this.db = db;\n}\n","name":"RemoteDBBankServer","className":"RemoteDBBankServer","variables":{"db":1},"constants":{},"javaDoc":"The constructor Just save the database connection object away","comments":" The constructor.  Just save the database connection object away ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"void","methodCalls":{"createStatement":2,"next":1,"rollback":1,"getResultSet":1,"commit":1,"getMessage":1,"getSQLState":1,"close":1,"executeQuery":1,"executeUpdate":3},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"ResultSet":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":3,"VariableDeclarationExpr":2,"BinaryExpr":16,"NameExpr":46,"StringLiteralExpr":14,"AssignExpr":2,"MethodCallExpr":13},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":2,"ExpressionStmt":11},"text":"/** Open an account */\npublic synchronized void openAccount(String name, String password) throws RemoteException, BankingException {\n    // First, check if there is already an account with that name\n    Statement s = null;\n    try {\n        s = db.createStatement();\n        s.executeQuery(\"SELECT * FROM accounts WHERE name='\" + name + \"'\");\n        ResultSet r = s.getResultSet();\n        if (r.next())\n            throw new BankingException(\"Account name in use.\");\n        // If it doesn't exist, go ahead and create it Also, create a\n        // table for the transaction history of this account and insert an\n        // initial transaction into it.\n        s = db.createStatement();\n        s.executeUpdate(\"INSERT INTO accounts VALUES ('\" + name + \"', '\" + password + \"', 0)\");\n        s.executeUpdate(\"CREATE TABLE \" + name + \"_history (msg VARCHAR(80))\");\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Account opened at \" + new Date() + \"')\");\n        // And if we've been successful so far, commit these updates,\n        // ending the atomic transaction.  All the methods below also use\n        // this atomic transaction commit/rollback scheme\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally // No matter what happens, don't forget to close the DB Statement\n    {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n             // If an exception was thrown, \"rollback\" the prior updates,\n\n             // removing them from the database.  This also ends the atomic\n\n             // transaction.\n\n             // Pass the SQLException on in the body of a BankingException\n\n","name":"openAccount","className":"RemoteDBBankServer","variables":{"r":2,"password":1,"s":9,"e":4,"name":4,"e2":1,"db":4},"constants":{"\"_history \"":1,"\"VALUES ('Account opened at \"":1,"\"CREATE TABLE \"":1,"\"', '\"":1,"\": \"":1,"\"', 0)\"":1,"\"INSERT INTO accounts VALUES ('\"":1,"\"')\"":1,"null":1,"\"SELECT * FROM accounts WHERE name='\"":1,"\"Account name in use.\"":1,"\"_history (msg VARCHAR(80))\"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Open an account","comments":"First check if there is already an account with that name If it doesn't exist go ahead and create it Also create a table for the transaction history of this account and insert an And if we've been successful so far commit these updates ending the atomic transaction All the methods below also use initial transaction into it this atomic transaction commit/rollback scheme If an exception was thrown \"rollback\" the prior updates removing them from the database This also ends the atomic transaction Pass the SQLException on in the body of a BankingException No matter what happens don't forget to close the DB Statement  Open an account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"createStatement":1,"next":1,"getInt":1,"getResultSet":1,"close":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException","BankingException","Exception"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"ResultSet":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":1,"IntegerLiteralExpr":1,"VariableDeclarationExpr":2,"BinaryExpr":6,"NameExpr":21,"StringLiteralExpr":6,"UnaryExpr":1,"AssignExpr":1,"MethodCallExpr":6},"statements":{"IfStmt":1,"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":5},"text":"/** \n     * This convenience method checks whether the name and password match\n     * an existing account.  If so, it returns the balance in that account.\n     * If not, it throws an exception.  Note that this method does not call\n     * commit() or rollback(), so its query is part of a larger transaction.\n     **/\npublic int verify(String name, String password) throws BankingException, SQLException {\n    Statement s = null;\n    try {\n        s = db.createStatement();\n        s.executeQuery(\"SELECT balance FROM accounts \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        ResultSet r = s.getResultSet();\n        if (!r.next())\n            throw new BankingException(\"Bad account name or password\");\n        return r.getInt(1);\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"verify","className":"RemoteDBBankServer","variables":{"password":1,"r":3,"s":5,"e":1,"name":1,"db":1},"constants":{"\"Bad account name or password\"":1,"1":1,"null":1,"\"WHERE name='\"":1,"\"' \"":1,"\"SELECT balance FROM accounts \"":1,"\"  AND password = '\"":1,"\"'\"":1},"javaDoc":"This convenience method checks whether the name and password match an existing account If so it returns the balance in that account If not it throws an exception Note that this method does not call commit() or rollback() so its query is part of a larger transaction","comments":" \n     * This convenience method checks whether the name and password match\n     * an existing account.  If so, it returns the balance in that account.\n     * If not, it throws an exception.  Note that this method does not call\n     * commit() or rollback(), so its query is part of a larger transaction.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["String","String"],"returnType":"FunnyMoney","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":11,"NameExpr":34,"StringLiteralExpr":9,"AssignExpr":2,"MethodCallExpr":9},"statements":{"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Close a named account */\npublic synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        s = db.createStatement();\n        // Delete the account from the accounts table\n        s.executeUpdate(\"DELETE FROM accounts \" + \"WHERE name = '\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // And drop the transaction history table for this account\n        s.executeUpdate(\"DROP TABLE \" + name + \"_history\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // Finally, return whatever balance remained in the account\n    return new FunnyMoney(balance);\n}\n","name":"closeAccount","className":"RemoteDBBankServer","variables":{"password":1,"s":5,"balance":3,"e":4,"name":2,"e2":1,"db":3},"constants":{"0":1,"null":1,"\"DELETE FROM accounts \"":1,"\"' \"":1,"\"DROP TABLE \"":1,"\"_history\"":1,"\"SQLException: \"":1,"\": \"":1,"\"WHERE name = '\"":1,"\"  AND password = '\"":1,"\"'\"":1},"javaDoc":"Close a named account","comments":"Delete the account from the accounts table And drop the transaction history table for this account Finally return whatever balance remained in the account  Close a named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","FunnyMoney"],"returnType":"void","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":2,"VariableDeclarationExpr":2,"BinaryExpr":20,"NameExpr":40,"StringLiteralExpr":14,"FieldAccessExpr":2,"AssignExpr":2,"MethodCallExpr":9},"statements":{"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ExpressionStmt":9},"text":"/** Deposit the specified money into the named account */\npublic synchronized void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        s = db.createStatement();\n        // Update the balance\n        s.executeUpdate(\"UPDATE accounts \" + \"SET balance = \" + balance + money.amount + \" \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // Add a row to the transaction history\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Deposited \" + money.amount + \" at \" + new Date() + \"')\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"deposit","className":"RemoteDBBankServer","variables":{"password":1,"s":5,"balance":3,"e":4,"name":2,"e2":1,"db":3},"constants":{"\"_history \"":1,"\" \"":1,"\"WHERE name='\"":1,"\" at \"":1,"\": \"":1,"\"  AND password = '\"":1,"\"')\"":1,"0":1,"\"SET balance = \"":1,"\"VALUES ('Deposited \"":1,"null":1,"\"UPDATE accounts \"":1,"\"' \"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Deposit the specified money into the named account","comments":"Update the balance Add a row to the transaction history  Deposit the specified money into the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String","int"],"returnType":"FunnyMoney","methodCalls":{"createStatement":1,"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1,"close":1,"executeUpdate":2},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"Statement":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"NullLiteralExpr":1,"ObjectCreationExpr":4,"VariableDeclarationExpr":2,"BinaryExpr":21,"NameExpr":39,"StringLiteralExpr":15,"EnclosedExpr":1,"AssignExpr":2,"MethodCallExpr":9},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":2,"ReturnStmt":1,"ExpressionStmt":9},"text":"/** Withdraw the specified amount from the named account */\npublic synchronized FunnyMoney withdraw(String name, String password, int amount) throws RemoteException, BankingException {\n    int balance = 0;\n    Statement s = null;\n    try {\n        balance = verify(name, password);\n        if (balance < amount)\n            throw new BankingException(\"Insufficient Funds\");\n        s = db.createStatement();\n        // Update the account balance\n        s.executeUpdate(\"UPDATE accounts \" + \"SET balance = \" + (balance - amount) + \" \" + \"WHERE name='\" + name + \"' \" + \"  AND password = '\" + password + \"'\");\n        // Add a row to the transaction history\n        s.executeUpdate(\"INSERT INTO \" + name + \"_history \" + \"VALUES ('Withdrew \" + amount + \" at \" + new Date() + \"')\");\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    return new FunnyMoney(amount);\n}\n","name":"withdraw","className":"RemoteDBBankServer","variables":{"amount":4,"password":1,"s":5,"balance":4,"e":4,"name":2,"e2":1,"db":3},"constants":{"\"_history \"":1,"\"Insufficient Funds\"":1,"\" \"":1,"\"WHERE name='\"":1,"\" at \"":1,"\": \"":1,"\"  AND password = '\"":1,"\"')\"":1,"0":1,"\"SET balance = \"":1,"null":1,"\"UPDATE accounts \"":1,"\"' \"":1,"\"VALUES ('Withdrew \"":1,"\"INSERT INTO \"":1,"\"SQLException: \"":1,"\"'\"":1},"javaDoc":"Withdraw the specified amount from the named account","comments":"Update the account balance Add a row to the transaction history  Withdraw the specified amount from the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"int","methodCalls":{"rollback":1,"commit":1,"verify":1,"getMessage":1,"getSQLState":1},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["ExceptionHandling","Synchronization"],"types":{"int":1},"expressions":{"ObjectCreationExpr":1,"VariableDeclarationExpr":1,"BinaryExpr":3,"NameExpr":18,"StringLiteralExpr":2,"AssignExpr":1,"MethodCallExpr":5},"statements":{"TryStmt":2,"BlockStmt":4,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":4},"text":"/** Return the balance of the specified account */\npublic synchronized int getBalance(String name, String password) throws RemoteException, BankingException {\n    int balance;\n    try {\n        // Get the balance\n        balance = verify(name, password);\n        // Commit the transaction\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    }\n    // Return the balance\n    return balance;\n}\n","name":"getBalance","className":"RemoteDBBankServer","variables":{"balance":3,"e":3,"e2":1,"db":2},"constants":{"\"SQLException: \"":1,"\": \"":1},"javaDoc":"Return the balance of the specified account","comments":"Get the balance Commit the transaction Return the balance  Return the balance of the specified account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String","String"],"returnType":"List","methodCalls":{"createStatement":1,"next":1,"add":1,"rollback":1,"getResultSet":1,"commit":1,"verify":1,"getMessage":1,"getString":1,"getSQLState":1,"close":1,"executeQuery":1},"annotations":[],"exceptions":["SQLException","BankingException","RemoteException","Exception"],"concepts":["PolyMorphism","ExceptionHandling","Synchronization"],"types":{"Statement":1,"ArrayList":1,"ResultSet":1,"List":1},"expressions":{"NullLiteralExpr":1,"ObjectCreationExpr":2,"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":40,"StringLiteralExpr":4,"MethodCallExpr":12,"AssignExpr":1},"statements":{"WhileStmt":1,"TryStmt":3,"BlockStmt":7,"ThrowStmt":1,"ReturnStmt":1,"ExpressionStmt":10},"text":"/** Get the transaction history of the named account */\npublic synchronized List getTransactionHistory(String name, String password) throws RemoteException, BankingException {\n    Statement s = null;\n    List list = new ArrayList();\n    try {\n        // Call verify to check the password, even though we don't \n        // care what the current balance is.\n        verify(name, password);\n        s = db.createStatement();\n        // Request everything out of the history table\n        s.executeQuery(\"SELECT * from \" + name + \"_history\");\n        // Get the results of the query and put them in a Vector\n        ResultSet r = s.getResultSet();\n        while (r.next()) list.add(r.getString(1));\n        // Commit the transaction\n        db.commit();\n    } catch (SQLException e) {\n        try {\n            db.rollback();\n        } catch (Exception e2) {\n        }\n        throw new BankingException(\"SQLException: \" + e.getMessage() + \": \" + e.getSQLState());\n    } finally {\n        try {\n            s.close();\n        } catch (Exception e) {\n        }\n    }\n    // Return the Vector of transaction history.\n    return list;\n}\n","name":"getTransactionHistory","className":"RemoteDBBankServer","variables":{"r":3,"s":5,"e":4,"name":1,"list":3,"e2":1,"db":3},"constants":{"\"SELECT * from \"":1,"1":1,"null":1,"\"_history\"":1,"\"SQLException: \"":1,"\": \"":1},"javaDoc":"Get the transaction history of the named account","comments":"Call verify to check the password even though we don't care what the current balance is Request everything out of the history table Get the results of the query and put them in a Vector Commit the transaction Return the Vector of transaction history  Get the transaction history of the named account ","isEmpty":false,"hasInnerClass":false,"modifier":33}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getConnection":1,"exit":1,"getProperty":5,"setTransactionIsolation":1,"load":2,"forName":1,"rebind":1,"setAutoCommit":1,"System.err.println":3,"System.out.println":1},"annotations":[],"exceptions":["Exception"],"concepts":["ExceptionHandling"],"types":{"RemoteDBBankServer":1,"Connection":1,"String":5,"Properties":1},"expressions":{"ObjectCreationExpr":4,"IntegerLiteralExpr":2,"VariableDeclarationExpr":8,"ArrayAccessExpr":1,"BinaryExpr":4,"NameExpr":76,"StringLiteralExpr":14,"InstanceOfExpr":1,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":5,"EnclosedExpr":1,"MethodCallExpr":18},"statements":{"IfStmt":1,"TryStmt":3,"BlockStmt":6,"ExpressionStmt":19},"text":"/**\n     * This main() method is the standalone program that figures out what\n     * database to connect to with what driver, connects to the database,\n     * creates a RemoteDBBankServer object, and registers it with the registry,\n     * making it available for client use\n     **/\npublic static void main(String[] args) {\n    try {\n        // Create a new Properties object.  Attempt to initialize it from\n        // the BankDB.props file or the file optionally specified on the \n        // command line, ignoring errors.\n        Properties p = new Properties();\n        try {\n            p.load(new FileInputStream(args[0]));\n        } catch (Exception e) {\n            try {\n                p.load(new FileInputStream(\"BankDB.props\"));\n            } catch (Exception e2) {\n            }\n        }\n        // The BankDB.props file (or file specified on the command line)\n        // must contain properties \"driver\" and \"database\", and may\n        // optionally contain properties \"user\" and \"password\".\n        String driver = p.getProperty(\"driver\");\n        String database = p.getProperty(\"database\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // Load the database driver class\n        Class.forName(driver);\n        // Connect to the database that stores our accounts\n        Connection db = DriverManager.getConnection(database, user, password);\n        // Configure the database to allow multiple queries and updates\n        // to be grouped into atomic transactions\n        db.setAutoCommit(false);\n        db.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        // Create a server object that uses our database connection\n        RemoteDBBankServer bank = new RemoteDBBankServer(db);\n        // Read a system property to figure out how to name this server.\n        // Use \"SecondRemote\" as the default.\n        String name = System.getProperty(\"bankname\", \"SecondRemote\");\n        // Register the server with the name\n        Naming.rebind(name, bank);\n        // And tell everyone that we're up and running.\n        System.out.println(name + \" is open and ready for customers.\");\n    } catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQL State: \" + ((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java [-Dbankname=<name>] \" + \"com.davidflanagan.examples.sql.RemoteDBBankServer \" + \"[<dbpropsfile>]\");\n        System.exit(1);\n    }\n}\n","name":"main","className":"RemoteDBBankServer","variables":{"e":4,"Naming":1,"e2":1,"System":2,"p":7,"args":1,"database":1,"password":1,"bank":1,"driver":1,"name":2,"Class":1,"user":1,"DriverManager":1,"db":4},"constants":{"\"\"":2,"\"Usage: java [-Dbankname=<name>] \"":1,"\" is open and ready for customers.\"":1,"\"com.davidflanagan.examples.sql.RemoteDBBankServer \"":1,"\"driver\"":1,"false":1,"\"password\"":1,"0":1,"1":1,"\"BankDB.props\"":1,"\"[<dbpropsfile>]\"":1,"\"bankname\"":1,"\"SQL State: \"":1,"\"user\"":1,"\"database\"":1,"\"SecondRemote\"":1},"javaDoc":"This main() method is the standalone program that figures out what database to connect to with what driver connects to the database creates a RemoteDBBankServer object and registers it with the registry making it available for client use","comments":"Create a new Properties object Attempt to initialize it from the BankDB props file or the file optionally specified on the The BankDB props file (or file specified on the command line) must contain properties \"driver\" and \"database\" and may Configure the database to allow multiple queries and updates Read a system property to figure out how to name this server command line ignoring errors optionally contain properties \"user\" and \"password\" Load the database driver class Connect to the database that stores our accounts to be grouped into atomic transactions Create a server object that uses our database connection Use \"SecondRemote\" as the default Register the server with the name And tell everyone that we're up and running \n     * This main() method is the standalone program that figures out what\n     * database to connect to with what driver, connects to the database,\n     * creates a RemoteDBBankServer object, and registers it with the registry,\n     * making it available for client use\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":1,"getProperty":4,"forName":1,"prepareStatement":3,"readLine":1,"createStatement":1,"getConnection":1,"storeClass":1,"load":2,"size":1,"get":2,"System.err.println":3,"close":1,"executeUpdate":3,"System.out.println":1},"annotations":[],"exceptions":["ClassNotFoundException","Exception","IllegalArgumentException"],"concepts":["ExceptionHandling"],"types":{"Statement":1,"Connection":1,"ArrayList":1,"BufferedReader":1,"String":5,"Properties":1,"int":2},"expressions":{"ObjectCreationExpr":8,"IntegerLiteralExpr":3,"VariableDeclarationExpr":12,"ArrayAccessExpr":2,"BinaryExpr":11,"NameExpr":109,"StringLiteralExpr":23,"UnaryExpr":1,"InstanceOfExpr":1,"AssignExpr":5,"NullLiteralExpr":4,"CastExpr":2,"FieldAccessExpr":4,"EnclosedExpr":2,"MethodCallExpr":27},"statements":{"IfStmt":3,"WhileStmt":1,"TryStmt":5,"BlockStmt":12,"ThrowStmt":2,"ForStmt":1,"ExpressionStmt":28},"text":"public static void main(String args[]) {\n    // The connection to the database\n    Connection c = null;\n    try {\n        // Read the classes to index from a file specified by args[0]\n        ArrayList classnames = new ArrayList();\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        String name;\n        while ((name = in.readLine()) != null) classnames.add(name);\n        // Now determine the values needed to set up the database\n        // connection The program attempts to read a property file named\n        // \"APIDB.props\", or optionally specified by args[1].  This\n        // property file (if any) may contain \"driver\", \"database\", \"user\",\n        // and \"password\" properties that specify the necessary values for\n        // connecting to the db.  If the properties file does not exist, or\n        // does not contain the named properties, defaults will be used.\n        // Empty properties\n        Properties p = new Properties();\n        try {\n            // Try to load properties\n            p.load(new FileInputStream(args[1]));\n        } catch (Exception e1) {\n            try {\n                p.load(new FileInputStream(\"APIDB.props\"));\n            } catch (Exception e2) {\n            }\n        }\n        // Read values from Properties file\n        String driver = p.getProperty(\"driver\");\n        String database = p.getProperty(\"database\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // The driver and database properties are mandatory\n        if (driver == null)\n            throw new IllegalArgumentException(\"No driver specified!\");\n        if (database == null)\n            throw new IllegalArgumentException(\"No database specified!\");\n        // Load the driver.  It registers itself with DriverManager.\n        Class.forName(driver);\n        // And set up a connection to the specified database\n        c = DriverManager.getConnection(database, user, password);\n        // Create three new tables for our data\n        // The package table contains a package id and a package name.\n        // The class table contains a class id, a package id, and a name.\n        // The member table contains a class id, a member name, and an bit\n        // that indicates whether the class member is a field or a method.\n        Statement s = c.createStatement();\n        s.executeUpdate(\"CREATE TABLE package \" + \"(id INT, name VARCHAR(80))\");\n        s.executeUpdate(\"CREATE TABLE class \" + \"(id INT, packageId INT, name VARCHAR(48))\");\n        s.executeUpdate(\"CREATE TABLE member \" + \"(classId INT, name VARCHAR(48), isField BIT)\");\n        // Prepare some statements that will be used to insert records into\n        // these three tables.\n        insertpackage = c.prepareStatement(\"INSERT INTO package VALUES(?,?)\");\n        insertclass = c.prepareStatement(\"INSERT INTO class VALUES(?,?,?)\");\n        insertmember = c.prepareStatement(\"INSERT INTO member VALUES(?,?,?)\");\n        // Now loop through the list of classes and use reflection\n        // to store them all in the tables\n        int numclasses = classnames.size();\n        for (int i = 0; i < numclasses; i++) {\n            try {\n                storeClass((String) classnames.get(i));\n            } catch (ClassNotFoundException e) {\n                System.out.println(\"WARNING: class not found: \" + classnames.get(i) + \"; SKIPPING\");\n            }\n        }\n    } catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQLState: \" + ((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java MakeAPIDB \" + \"<classlistfile> <propfile>\");\n    } finally // When we're done, close the connection to the database\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n        }\n    }\n}\n","name":"main","className":"MakeAPIDB","variables":{"insertpackage":1,"c":7,"in":2,"e":5,"insertmember":1,"i":3,"e1":1,"classnames":5,"e2":1,"args":2,"p":7,"insertclass":1,"database":2,"password":1,"s":4,"driver":2,"numclasses":2,"name":2,"Class":1,"user":1,"DriverManager":1},"constants":{"\"\"":2,"\"SQLState: \"":1,"\"driver\"":1,"\"CREATE TABLE class \"":1,"\"INSERT INTO member VALUES(?,?,?)\"":1,"\"APIDB.props\"":1,"\"(classId INT, name VARCHAR(48), isField BIT)\"":1,"\"(id INT, name VARCHAR(80))\"":1,"\"; SKIPPING\"":1,"\"database\"":1,"\"INSERT INTO package VALUES(?,?)\"":1,"\"CREATE TABLE member \"":1,"\"WARNING: class not found: \"":1,"\"password\"":1,"\"Usage: java MakeAPIDB \"":1,"\"<classlistfile> <propfile>\"":1,"0":2,"1":1,"null":4,"\"(id INT, packageId INT, name VARCHAR(48))\"":1,"\"No driver specified!\"":1,"\"No database specified!\"":1,"\"CREATE TABLE package \"":1,"\"user\"":1,"\"INSERT INTO class VALUES(?,?,?)\"":1},"javaDoc":"","comments":"The connection to the database Now determine the values needed to set up the database connection The program attempts to read a property file named \"APIDB props\" or optionally specified by args[1] This property file (if any) may contain \"driver\" \"database\" \"user\" and \"password\" properties that specify the necessary values for connecting to the db If the properties file does not exist or does not contain the named properties defaults will be used Create three new tables for our data The package table contains a package id and a package name The class table contains a class id a package id and a name The member table contains a class id a member name and an bit Prepare some statements that will be used to insert records into Now loop through the list of classes and use reflection Read the classes to index from a file specified by args[0] Empty properties Try to load properties Read values from Properties file The driver and database properties are mandatory Load the driver It registers itself with DriverManager And set up a connection to the specified database that indicates whether the class member is a field or a method these three tables to store them all in the tables When we're done close the connection to the database ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String"],"returnType":"void","methodCalls":{"forName":1,"intValue":1,"isPrivate":2,"substring":2,"put":1,"setInt":5,"lastIndexOf":1,"getDeclaredMethods":1,"getDeclaredFields":1,"setString":4,"get":1,"System.out.println":1,"executeUpdate":4,"setBoolean":2},"annotations":[],"exceptions":["SQLException","ClassNotFoundException"],"concepts":[],"types":{"Integer":1,"Class":1,"String":1,"Method[]":1,"int":3,"Field[]":1},"expressions":{"IntegerLiteralExpr":16,"ObjectCreationExpr":1,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":6,"NameExpr":132,"StringLiteralExpr":2,"CharLiteralExpr":1,"UnaryExpr":5,"AssignExpr":6,"NullLiteralExpr":1,"BooleanLiteralExpr":2,"CastExpr":1,"FieldAccessExpr":3,"MethodCallExpr":31},"statements":{"ContinueStmt":2,"IfStmt":4,"BlockStmt":5,"ForStmt":2,"ExpressionStmt":29},"text":"/**\n     * Given a fully-qualified classname, this method stores the package name\n     * in the package table (if it is not already there), stores the class name\n     * in the class table, and then uses the Java Reflection API to look up all\n     * methods and fields of the class, and stores those in the member table.\n     **/\npublic static void storeClass(String name) throws SQLException, ClassNotFoundException {\n    String packagename, classname;\n    // Dynamically load the class.\n    Class c = Class.forName(name);\n    // Display output so the user knows that the program is progressing\n    System.out.println(\"Storing data for: \" + name);\n    // Figure out the packagename and the classname\n    int pos = name.lastIndexOf('.');\n    if (pos == -1) {\n        packagename = \"\";\n        classname = name;\n    } else {\n        packagename = name.substring(0, pos);\n        classname = name.substring(pos + 1);\n    }\n    // Figure out what the package id is.  If there is one, then this\n    // package has already been stored in the database.  Otherwise, assign\n    // an id, and store it and the packagename in the db.\n    Integer pid;\n    // Check hashtable\n    pid = (Integer) package_to_id.get(packagename);\n    if (pid == null) {\n        // Assign an id\n        pid = new Integer(++packageId);\n        // Remember it\n        package_to_id.put(packagename, pid);\n        // Set statement args\n        insertpackage.setInt(1, packageId);\n        insertpackage.setString(2, packagename);\n        // Insert into package db\n        insertpackage.executeUpdate();\n    }\n    // Now, store the classname in the class table of the database.\n    // This record includes the package id, so that the class is linked to \n    // the package that contains it.  To store the class, we set arguments\n    // to the PreparedStatement, then execute that statement\n    // Set class identifier\n    insertclass.setInt(1, ++classId);\n    // Set package identifier\n    insertclass.setInt(2, pid.intValue());\n    // Set class name\n    insertclass.setString(3, classname);\n    // Insert the class record\n    insertclass.executeUpdate();\n    // Now, get a list of all non-private methods of the class, and\n    // insert those into the \"members\" table of the database.  Each\n    // record includes the class id of the containing class, and also\n    // a value that indicates that these are methods, not fields.\n    // Get a list of methods\n    Method[] methods = c.getDeclaredMethods();\n    for (int i = 0; i < methods.length; i++) {\n        // For all non-private\n        if (Modifier.isPrivate(methods[i].getModifiers()))\n            continue;\n        // Set the class id\n        insertmember.setInt(1, classId);\n        // Set method name\n        insertmember.setString(2, methods[i].getName());\n        // It is not a field\n        insertmember.setBoolean(3, false);\n        // Insert into db\n        insertmember.executeUpdate();\n    }\n    // Do the same thing for the non-private fields of the class\n    // Get a list of fields\n    Field[] fields = c.getDeclaredFields();\n    for (int i = 0; i < fields.length; i++) {\n        // For each non-private\n        if (Modifier.isPrivate(fields[i].getModifiers()))\n            continue;\n        // Set the class id\n        insertmember.setInt(1, classId);\n        // Set field name\n        insertmember.setString(2, fields[i].getName());\n        // It is a field\n        insertmember.setBoolean(3, true);\n        // Insert the record\n        insertmember.executeUpdate();\n    }\n}\n","name":"storeClass","className":"MakeAPIDB","variables":{"insertpackage":3,"c":3,"methods":3,"packagename":3,"packageId":1,"i":10,"insertmember":8,"pid":5,"insertclass":4,"classId":1,"package_to_id":2,"classname":3,"pos":3,"name":5,"Class":1,"fields":3,"Modifier":2},"constants":{"'.'":1,"\"\"":1,"0":3,"1":6,"2":4,"3":3,"null":1,"false":1,"true":1,"\"Storing data for: \"":1},"javaDoc":"Given a fully-qualified classname this method stores the package name in the package table (if it is not already there) stores the class name in the class table and then uses the Java Reflection API to look up all methods and fields of the class and stores those in the member table","comments":"Figure out what the package id is If there is one then this package has already been stored in the database Otherwise assign Now store the classname in the class table of the database This record includes the package id so that the class is linked to the package that contains it To store the class we set arguments to the PreparedStatement then execute that statement Now get a list of all non-private methods of the class and insert those into the \"members\" table of the database Each record includes the class id of the containing class and also a value that indicates that these are methods not fields Do the same thing for the non-private fields of the class Dynamically load the class Display output so the user knows that the program is progressing Figure out the packagename and the classname an id and store it and the packagename in the db Check hashtable Assign an id Remember it Set statement args Insert into package db Set class identifier Set package identifier Set class name Insert the class record Get a list of methods For all non-private Set the class id Set method name It is not a field Insert into db Get a list of fields For each non-private Set the class id Set field name It is a field Insert the record \n     * Given a fully-qualified classname, this method stores the package name\n     * in the package table (if it is not already there), stores the class name\n     * in the class table, and then uses the Java Reflection API to look up all\n     * methods and fields of the class, and stores those in the member table.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"getConnection":1,"lookup":1,"getProperty":4,"load":1,"forName":1,"list":1,"close":1,"setReadOnly":1,"System.out.println":3},"annotations":[],"exceptions":["IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"boolean":1,"Connection":1,"String":6,"Properties":1,"int":1},"expressions":{"IntegerLiteralExpr":1,"ObjectCreationExpr":6,"VariableDeclarationExpr":10,"ArrayAccessExpr":5,"BinaryExpr":7,"StringLiteralExpr":15,"NameExpr":88,"UnaryExpr":2,"InstanceOfExpr":1,"AssignExpr":4,"NullLiteralExpr":6,"BooleanLiteralExpr":3,"CastExpr":1,"FieldAccessExpr":4,"EnclosedExpr":1,"MethodCallExpr":17},"statements":{"IfStmt":8,"TryStmt":3,"BlockStmt":8,"ForStmt":1,"ThrowStmt":4,"ExpressionStmt":22},"text":"public static void main(String[] args) {\n    // JDBC connection to the database\n    Connection c = null;\n    try {\n        // Some default values\n        // The name to look up\n        String target = null;\n        // List members or lookup name?\n        boolean list = false;\n        // The file of db parameters\n        String propfile = \"APIDB.props\";\n        // Parse the command-line arguments\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-l\"))\n                list = true;\n            else if (args[i].equals(\"-p\"))\n                propfile = args[++i];\n            else if (target != null)\n                throw new IllegalArgumentException(\"Unexpected argument: \" + args[i]);\n            else\n                target = args[i];\n        }\n        if (target == null)\n            throw new IllegalArgumentException(\"No target specified\");\n        // Now determine the values needed to set up the database\n        // connection The program attempts to read a property file\n        // named \"APIDB.props\", or optionally specified with the\n        // -p argument.  This property file may contain \"driver\",\n        // \"database\", \"user\", and \"password\" properties that\n        // specify the necessary values for connecting to the db.\n        // If the properties file does not exist, or does not\n        // contain the named properties, defaults will be used.\n        // Empty properties\n        Properties p = new Properties();\n        try // Try to load props\n        {\n            p.load(new FileInputStream(propfile));\n        } catch (Exception e) {\n        }\n        // Read values from Properties file\n        String driver = p.getProperty(\"driver\");\n        String database = p.getProperty(\"database\");\n        String user = p.getProperty(\"user\", \"\");\n        String password = p.getProperty(\"password\", \"\");\n        // The driver and database properties are mandatory\n        if (driver == null)\n            throw new IllegalArgumentException(\"No driver specified!\");\n        if (database == null)\n            throw new IllegalArgumentException(\"No database specified!\");\n        // Load the database driver\n        Class.forName(driver);\n        // And set up a connection to the specified database\n        c = DriverManager.getConnection(database, user, password);\n        // Tell it we will not do any updates.\n        // This hint may improve efficiency.\n        c.setReadOnly(true);\n        // matches for the specified member, class, or package.\n        if (list)\n            list(c, target);\n        else\n            lookup(c, target);\n    }// a SQLException is thrown, display the state message it includes.\n     catch (Exception e) {\n        System.out.println(e);\n        if (e instanceof SQLException)\n            System.out.println(((SQLException) e).getSQLState());\n        System.out.println(\"Usage: java LookupAPI [-l] [-p <propfile>] \" + \"target\");\n    } finally // Always close the DB connection when we're done with it.\n    {\n        try {\n            c.close();\n        } catch (Exception e) {\n        }\n    }\n}\n         // If anything goes wrong, print the exception and a usage message.  If\n\n             // If the \"-l\" option was given, then list the members of\n\n             // the named package or class.  Otherwise, lookup all\n\n","name":"main","className":"LookupAPI","variables":{"c":4,"e":5,"i":8,"list":3,"target":4,"args":5,"p":6,"propfile":3,"database":2,"password":1,"driver":2,"Class":1,"user":1,"DriverManager":1},"constants":{"\"\"":2,"\"Unexpected argument: \"":1,"\"driver\"":1,"false":1,"\"password\"":1,"\"-p\"":1,"0":1,"\"-l\"":1,"null":6,"\"APIDB.props\"":1,"\"No driver specified!\"":1,"true":2,"\"target\"":1,"\"No database specified!\"":1,"\"Usage: java LookupAPI [-l] [-p <propfile>] \"":1,"\"user\"":1,"\"No target specified\"":1,"\"database\"":1},"javaDoc":"","comments":"JDBC connection to the database If anything goes wrong print the exception and a usage message If Some default values Now determine the values needed to set up the database connection The program attempts to read a property file named \"APIDB props\" or optionally specified with the -p argument This property file may contain \"driver\" \"database\" \"user\" and \"password\" properties that specify the necessary values for connecting to the db If the properties file does not exist or does not contain the named properties defaults will be used Tell it we will not do any updates If the \"-l\" option was given then list the members of the named package or class Otherwise lookup all The name to look up List members or lookup name? The file of db parameters Parse the command-line arguments Empty properties Try to load props Read values from Properties file The driver and database properties are mandatory Load the database driver And set up a connection to the specified database This hint may improve efficiency matches for the specified member class or package a SQLException is thrown display the state message it includes Always close the DB connection when we're done with it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection","String"],"returnType":"void","methodCalls":{"createStatement":1,"next":3,"getResultSet":3,"getBoolean":1,"getString":6,"close":1,"executeQuery":3,"System.out.println":3},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"boolean":1,"Statement":1,"ResultSet":1,"String":3},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":6,"BinaryExpr":31,"NameExpr":81,"StringLiteralExpr":26,"FieldAccessExpr":3,"EnclosedExpr":1,"ConditionalExpr":1,"MethodCallExpr":21,"AssignExpr":2},"statements":{"WhileStmt":3,"BlockStmt":1,"ExpressionStmt":15},"text":"/**\n     * This method looks up all matches for the specified target string in the\n     * database.  First, it prints the full name of any members by that name.\n     * Then it prints the full name of any classes by that name.  Then it \n     * prints the name of any packages that contain the specified name\n     **/\npublic static void lookup(Connection c, String target) throws SQLException {\n    // Create the Statement object we'll use to query the database\n    Statement s = c.createStatement();\n    // Go find all class members with the specified name\n    s.executeQuery(\"SELECT DISTINCT \" + \"package.name, class.name, member.name, member.isField\" + \" FROM package, class, member\" + \" WHERE member.name='\" + target + \"'\" + \"   AND member.classId=class.id \" + \"   AND class.packageId=package.id\");\n    // Loop through the results, and print them out (if there are any).\n    ResultSet r = s.getResultSet();\n    while (r.next()) {\n        // package name\n        String pkg = r.getString(1);\n        // class name\n        String cls = r.getString(2);\n        // member name\n        String member = r.getString(3);\n        // is the member a field?\n        boolean isField = r.getBoolean(4);\n        // Display this match\n        System.out.println(pkg + \".\" + cls + \".\" + member + (isField ? \"\" : \"()\"));\n    }\n    // Now look for a class with the specified name\n    s.executeQuery(\"SELECT package.name, class.name \" + \"FROM package, class \" + \"WHERE class.name='\" + target + \"' \" + \"  AND class.packageId=package.id\");\n    // Loop through the results and print them out\n    r = s.getResultSet();\n    while (r.next()) System.out.println(r.getString(1) + \".\" + r.getString(2));\n    // Finally, look for a package that matches a part of of the name.\n    // Note the use of the SQL LIKE keyword and % wildcard characters\n    s.executeQuery(\"SELECT name FROM package \" + \"WHERE name='\" + target + \"'\" + \"   OR name LIKE '%.\" + target + \".%' \" + \"   OR name LIKE '\" + target + \".%' \" + \"   OR name LIKE '%.\" + target + \"'\");\n    // Loop through the results and print them out\n    r = s.getResultSet();\n    while (r.next()) System.out.println(r.getString(1));\n    // Finally, close the Statement object\n    s.close();\n}\n","name":"lookup","className":"LookupAPI","variables":{"r":13,"s":8,"c":1,"isField":2,"member":2,"cls":2,"pkg":2,"target":6},"constants":{"\"\"":1,"\"WHERE name='\"":1,"\"FROM package, class \"":1,"\"   AND class.packageId=package.id\"":1,"\"   OR name LIKE '\"":1,"\"SELECT DISTINCT \"":1,"\" FROM package, class, member\"":1,"\".%' \"":2,"\"()\"":1,"\" WHERE member.name='\"":1,"1":3,"2":2,"3":1,"4":1,"\"   OR name LIKE '%.\"":2,"\"package.name, class.name, member.name, member.isField\"":1,"\"  AND class.packageId=package.id\"":1,"\".\"":3,"\"' \"":1,"\"WHERE class.name='\"":1,"\"SELECT name FROM package \"":1,"\"'\"":3,"\"   AND member.classId=class.id \"":1,"\"SELECT package.name, class.name \"":1},"javaDoc":"This method looks up all matches for the specified target string in the database First it prints the full name of any members by that name Then it prints the full name of any classes by that name Then it prints the name of any packages that contain the specified name","comments":"Finally look for a package that matches a part of of the name Create the Statement object we'll use to query the database Go find all class members with the specified name Loop through the results and print them out (if there are any) package name class name member name is the member a field? Display this match Now look for a class with the specified name Loop through the results and print them out Note the use of the SQL LIKE keyword and % wildcard characters Loop through the results and print them out Finally close the Statement object \n     * This method looks up all matches for the specified target string in the\n     * database.  First, it prints the full name of any members by that name.\n     * Then it prints the full name of any classes by that name.  Then it \n     * prints the name of any packages that contain the specified name\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Connection","String"],"returnType":"void","methodCalls":{"createStatement":2,"next":4,"getInt":1,"getResultSet":4,"getString":5,"close":2,"executeQuery":4,"System.out.println":5},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"Statement":2,"ResultSet":3,"String":4,"int":1},"expressions":{"IntegerLiteralExpr":7,"VariableDeclarationExpr":10,"BinaryExpr":42,"NameExpr":105,"StringLiteralExpr":38,"FieldAccessExpr":5,"EnclosedExpr":2,"ConditionalExpr":1,"MethodCallExpr":27,"AssignExpr":1},"statements":{"WhileStmt":4,"BlockStmt":3,"ExpressionStmt":22},"text":"/**\n     * This method looks for classes with the specified name, or packages\n     * that contain the specified name.  For each class it finds, it displays\n     * all methods and fields of the class.  For each package it finds, it\n     * displays all classes in the package.\n     **/\npublic static void list(Connection conn, String target) throws SQLException {\n    // Create two Statement objects to query the database with\n    Statement s = conn.createStatement();\n    Statement t = conn.createStatement();\n    // Look for a class with the given name\n    s.executeQuery(\"SELECT package.name, class.name \" + \"FROM package, class \" + \"WHERE class.name='\" + target + \"' \" + \"  AND class.packageId=package.id\");\n    // Loop through all matches\n    ResultSet r = s.getResultSet();\n    while (r.next()) {\n        // package name\n        String p = r.getString(1);\n        // class name\n        String c = r.getString(2);\n        // Print out the matching class name\n        System.out.println(\"class \" + p + \".\" + c + \" {\");\n        // Now query all members of the class\n        t.executeQuery(\"SELECT DISTINCT member.name, member.isField \" + \"FROM package, class, member \" + \"WHERE package.name = '\" + p + \"' \" + \"  AND class.name = '\" + c + \"' \" + \"  AND member.classId=class.id \" + \"  AND class.packageId=package.id \" + \"ORDER BY member.isField, member.name\");\n        // Loop through the ordered list of all members, and print them out\n        ResultSet r2 = t.getResultSet();\n        while (r2.next()) {\n            String m = r2.getString(1);\n            int isField = r2.getInt(2);\n            System.out.println(\"  \" + m + ((isField == 1) ? \"\" : \"()\"));\n        }\n        // End the class listing\n        System.out.println(\"}\");\n    }\n    // Now go look for a package that matches the specified name\n    s.executeQuery(\"SELECT name FROM package \" + \"WHERE name='\" + target + \"'\" + \"   OR name LIKE '%.\" + target + \".%' \" + \"   OR name LIKE '\" + target + \".%' \" + \"   OR name LIKE '%.\" + target + \"'\");\n    // Loop through any matching packages\n    r = s.getResultSet();\n    while (r.next()) {\n        // Display the name of the package\n        String p = r.getString(1);\n        System.out.println(\"Package \" + p + \": \");\n        // Get a list of all classes and interfaces in the package\n        t.executeQuery(\"SELECT class.name FROM package, class \" + \"WHERE package.name='\" + p + \"' \" + \"  AND class.packageId=package.id \" + \"ORDER BY class.name\");\n        // Loop through the list and print them out.\n        ResultSet r2 = t.getResultSet();\n        while (r2.next()) System.out.println(\"  \" + r2.getString(1));\n    }\n    // Finally, close both Statement objects\n    s.close();\n    t.close();\n}\n","name":"list","className":"LookupAPI","variables":{"p":6,"r2":7,"conn":2,"r":7,"s":6,"c":3,"t":6,"isField":2,"m":2,"target":5},"constants":{"\"\"":1,"\"SELECT DISTINCT member.name, member.isField \"":1,"\"   OR name LIKE '\"":1,"\"  AND member.classId=class.id \"":1,"\" {\"":1,"\": \"":1,"\"  \"":2,"\"()\"":1,"\"class \"":1,"\"ORDER BY member.isField, member.name\"":1,"\"ORDER BY class.name\"":1,"\"  AND class.packageId=package.id\"":1,"\".\"":1,"\"FROM package, class, member \"":1,"\"' \"":4,"\"WHERE class.name='\"":1,"\"Package \"":1,"\"SELECT name FROM package \"":1,"\"  AND class.name = '\"":1,"\"WHERE name='\"":1,"\"FROM package, class \"":1,"\"}\"":1,"\"SELECT class.name FROM package, class \"":1,"\"WHERE package.name='\"":1,"\".%' \"":2,"1":5,"2":2,"\"   OR name LIKE '%.\"":2,"\"  AND class.packageId=package.id \"":2,"\"'\"":2,"\"WHERE package.name = '\"":1,"\"SELECT package.name, class.name \"":1},"javaDoc":"This method looks for classes with the specified name or packages that contain the specified name For each class it finds it displays all methods and fields of the class For each package it finds it displays all classes in the package","comments":"Create two Statement objects to query the database with Look for a class with the given name Loop through all matches package name class name Print out the matching class name Now query all members of the class Loop through the ordered list of all members and print them out End the class listing Now go look for a package that matches the specified name Loop through any matching packages Display the name of the package Get a list of all classes and interfaces in the package Loop through the list and print them out Finally close both Statement objects \n     * This method looks for classes with the specified name, or packages\n     * that contain the specified name.  For each class it finds, it displays\n     * all methods and fields of the class.  For each package it finds, it\n     * displays all classes in the package.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"System.out.flush":1,"getWarnings":1,"length":1,"getMoreResults":1,"getMessage":2,"getUpdateCount":2,"getSQLState":2,"readLine":1,"execute":1,"createStatement":1,"getConnection":1,"getResultSet":1,"equals":1,"printResultsTable":1,"System.err.println":5,"getNextWarning":1,"close":1,"System.out.print":1,"System.out.println":1},"annotations":[],"exceptions":["SQLException","IllegalArgumentException","Exception"],"concepts":["ExceptionHandling"],"types":{"SQLWarning":1,"boolean":1,"Statement":1,"Connection":1,"BufferedReader":1,"ResultSet":1,"String":2,"int":2},"expressions":{"IntegerLiteralExpr":3,"ObjectCreationExpr":4,"VariableDeclarationExpr":10,"ArrayAccessExpr":7,"BinaryExpr":20,"StringLiteralExpr":18,"NameExpr":154,"UnaryExpr":5,"InstanceOfExpr":1,"AssignExpr":8,"NullLiteralExpr":8,"BooleanLiteralExpr":1,"CastExpr":1,"FieldAccessExpr":11,"EnclosedExpr":2,"MethodCallExpr":31},"statements":{"ContinueStmt":1,"IfStmt":10,"WhileStmt":1,"BreakStmt":1,"TryStmt":3,"BlockStmt":13,"ForStmt":2,"ThrowStmt":2,"ExpressionStmt":26,"DoStmt":1},"text":"public static void main(String[] args) {\n    // Our JDBC connection to the database server\n    Connection conn = null;\n    try {\n        String driver = null, url = null, user = \"\", password = \"\";\n        // Parse all the command-line arguments\n        for (int n = 0; n < args.length; n++) {\n            if (args[n].equals(\"-d\"))\n                driver = args[++n];\n            else if (args[n].equals(\"-u\"))\n                user = args[++n];\n            else if (args[n].equals(\"-p\"))\n                password = args[++n];\n            else if (url == null)\n                url = args[n];\n            else\n                throw new IllegalArgumentException(\"Unknown argument.\");\n        }\n        // The only required argument is the database URL.\n        if (url == null)\n            throw new IllegalArgumentException(\"No database specified\");\n        // to register itself with the DriverManager.\n        if (driver != null)\n            Class.forName(driver);\n        // Now open a connection the specified database, using the\n        // user-specified username and password, if any.  The driver\n        // manager will try all of the DB drivers it knows about to try to\n        // parse the URL and connect to the DB server.\n        conn = DriverManager.getConnection(url, user, password);\n        // Now create the statement object we'll use to talk to the DB\n        Statement s = conn.createStatement();\n        // Get a stream to read from the console\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        // Loop forever, reading the user's queries and executing them\n        while (true) {\n            // prompt the user\n             // If the user specified the classname for the DB driver, load\n\n             // that class dynamically.  This gives the driver the opportunity\n\n            System.out.print(\"sql> \");\n            // make the prompt appear now.\n            System.out.flush();\n            // get a line of input from user\n            String sql = in.readLine();\n            // Quit when the user types \"quit\".\n            if ((sql == null) || sql.equals(\"quit\"))\n                break;\n            // Ignore blank lines\n            if (sql.length() == 0)\n                continue;\n            // Now, execute the user's line of SQL and display results.\n            try {\n                // We don't know if this is a query or some kind of\n                // update, so we use execute() instead of executeQuery()\n                // or executeUpdate() If the return value is true, it was\n                // a query, else an update.\n                boolean status = s.execute(sql);\n                // of results, so loop until there are no more results\n                do {\n                    if (status) {\n                        // it was a query and returns a ResultSet\n                        // Get results\n                        ResultSet rs = s.getResultSet();\n                        // Display them\n                        printResultsTable(rs, System.out);\n                    } else {\n                        // If the SQL command that was executed was some\n                        // kind of update rather than a query, then it\n                        // doesn't return a ResultSet.  Instead, we just\n                        // print the number of rows that were affected.\n                        int numUpdates = s.getUpdateCount();\n                        System.out.println(\"Ok. \" + numUpdates + \" rows affected.\");\n                    }\n                    // Now go see if there are even more results, and\n                    // continue the results display loop if there are.\n             // Some complex SQL queries can return more than one set\n\n                    status = s.getMoreResults();\n                } while (status || s.getUpdateCount() != -1);\n            }// DB-specific message returned by getSQLState()\n             catch (SQLException e) {\n                System.err.println(\"SQLException: \" + e.getMessage() + \":\" + e.getSQLState());\n            } finally // Each time through this loop, check to see if there were any\n            // warnings.  Note that there can be a whole chain of warnings.\n            {\n                // print out any warnings that occurred\n                SQLWarning w;\n                for (w = conn.getWarnings(); w != null; w = w.getNextWarning()) System.err.println(\"WARNING: \" + w.getMessage() + \":\" + w.getSQLState());\n            }\n        }\n    }// connection setup, etc.  For SQLExceptions, print the details.\n     catch (Exception e) {\n        System.err.println(e);\n        if (e instanceof SQLException)\n            System.err.println(\"SQL State: \" + ((SQLException) e).getSQLState());\n        System.err.println(\"Usage: java ExecuteSQL [-d <driver>] \" + \"[-u <user>] [-p <password>] <database URL>\");\n    } finally // Be sure to always close the database connection when we exit,\n    // whether we exit because the user types 'quit' or because of an\n    // exception thrown while setting things up.  Closing this connection\n                 // If a SQLException is thrown, display an error message.\n\n                 // Note that SQLExceptions can have a general message and a\n\n    // also implicitly closes any open statements and result sets\n    // associated with it.\n    {\n        try {\n            conn.close();\n        } catch (Exception e) {\n        }\n    }\n}\n         // Handle exceptions that occur during argument parsing, database\n\n","name":"main","className":"ExecuteSQL","variables":{"rs":1,"conn":5,"in":2,"e":7,"url":4,"n":10,"sql":4,"args":7,"numUpdates":2,"password":2,"s":6,"driver":3,"w":7,"Class":1,"user":2,"DriverManager":1,"status":4},"constants":{"\"\"":2,"\"quit\"":1,"\"Unknown argument.\"":1,"\"-u\"":1,"\":\"":2,"\" rows affected.\"":1,"\"-p\"":1,"\"sql> \"":1,"0":2,"1":1,"\"Usage: java ExecuteSQL [-d <driver>] \"":1,"null":8,"\"No database specified\"":1,"\"[-u <user>] [-p <password>] <database URL>\"":1,"true":1,"\"-d\"":1,"\"SQLException: \"":1,"\"WARNING: \"":1,"\"SQL State: \"":1,"\"Ok. \"":1},"javaDoc":"","comments":"Our JDBC connection to the database server Handle exceptions that occur during argument parsing database Be sure to always close the database connection when we exit whether we exit because the user types 'quit' or because of an exception thrown while setting things up Closing this connection also implicitly closes any open statements and result sets If the user specified the classname for the DB driver load that class dynamically This gives the driver the opportunity Now open a connection the specified database using the user-specified username and password if any The driver manager will try all of the DB drivers it knows about to try to Parse all the command-line arguments The only required argument is the database URL to register itself with the DriverManager parse the URL and connect to the DB server Now create the statement object we'll use to talk to the DB Get a stream to read from the console Loop forever reading the user's queries and executing them prompt the user make the prompt appear now get a line of input from user Quit when the user types \"quit\" Ignore blank lines Now execute the user's line of SQL and display results If a SQLException is thrown display an error message Note that SQLExceptions can have a general message and a Each time through this loop check to see if there were any We don't know if this is a query or some kind of update so we use execute() instead of executeQuery() or executeUpdate() If the return value is true it was Some complex SQL queries can return more than one set a query else an update of results so loop until there are no more results Now go see if there are even more results and it was a query and returns a ResultSet Get results Display them If the SQL command that was executed was some kind of update rather than a query then it doesn't return a ResultSet Instead we just print the number of rows that were affected continue the results display loop if there are DB-specific message returned by getSQLState() warnings Note that there can be a whole chain of warnings print out any warnings that occurred connection setup etc For SQLExceptions print the details associated with it ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["ResultSet","OutputStream"],"returnType":"void","methodCalls":{"next":1,"getObject":1,"getColumnLabel":1,"setCharAt":4,"insert":2,"getColumnCount":1,"println":5,"trim":1,"flush":1,"toString":3,"getMetaData":1,"overwrite":4,"getColumnDisplaySize":1},"annotations":[],"exceptions":["SQLException"],"concepts":[],"types":{"ResultSetMetaData":1,"StringBuffer":3,"int[]":2,"Object":1,"String[]":1,"int":10,"PrintWriter":1},"expressions":{"ObjectCreationExpr":5,"IntegerLiteralExpr":22,"VariableDeclarationExpr":19,"ArrayAccessExpr":15,"BinaryExpr":23,"NameExpr":158,"StringLiteralExpr":3,"CharLiteralExpr":5,"UnaryExpr":6,"AssignExpr":9,"NullLiteralExpr":1,"EnclosedExpr":1,"ArrayCreationExpr":3,"MethodCallExpr":28},"statements":{"IfStmt":4,"WhileStmt":1,"BlockStmt":5,"ForStmt":5,"ExpressionStmt":39},"text":"/**\n     * This method attempts to output the contents of a ResultSet in a \n     * textual table.  It relies on the ResultSetMetaData class, but a fair\n     * bit of the code is simple string manipulation.\n     **/\nstatic void printResultsTable(ResultSet rs, OutputStream output) throws SQLException {\n    // Set up the output stream\n    PrintWriter out = new PrintWriter(output);\n    // Get some \"meta data\" (column names, etc.) about the results\n    ResultSetMetaData metadata = rs.getMetaData();\n    // Variables to hold important data about the table to be displayed\n    // how many columns\n    int numcols = metadata.getColumnCount();\n    // the column labels\n    String[] labels = new String[numcols];\n    // the width of each\n    int[] colwidths = new int[numcols];\n    // start position of each\n    int[] colpos = new int[numcols];\n    // total width of table\n    int linewidth;\n    // Figure out how wide the columns are, where each one begins, \n    // how wide each row of the table will be, etc.\n    // for the initial '|'.\n    linewidth = 1;\n    for (int i = 0; i < numcols; i++) {\n        // for each column\n        // save its position\n        colpos[i] = linewidth;\n        // get its label \n        labels[i] = metadata.getColumnLabel(i + 1);\n        // Get the column width.  If the db doesn't report one, guess\n        // 30 characters.  Then check the length of the label, and use\n        // it if it is larger than the column width\n        int size = metadata.getColumnDisplaySize(i + 1);\n        // Some drivers return -1...\n        if (size == -1)\n            size = 30;\n        // Don't allow unreasonable sizes\n        if (size > 500)\n            size = 30;\n        int labelsize = labels[i].length();\n        if (labelsize > size)\n            size = labelsize;\n        // save the column the size  \n        colwidths[i] = size + 1;\n        // increment total size\n        linewidth += colwidths[i] + 2;\n    }\n    // Create a horizontal divider line we use in the table.\n    // Also create a blank line that is the initial value of each \n    // line of the table\n    StringBuffer divider = new StringBuffer(linewidth);\n    StringBuffer blankline = new StringBuffer(linewidth);\n    for (int i = 0; i < linewidth; i++) {\n        divider.insert(i, '-');\n        blankline.insert(i, \" \");\n    }\n    // Put special marks in the divider line at the column positions\n    for (int i = 0; i < numcols; i++) divider.setCharAt(colpos[i] - 1, '+');\n    divider.setCharAt(linewidth - 1, '+');\n    // Begin the table output with a divider line\n    out.println(divider);\n    // The next line of the table contains the column labels.\n    // Begin with a blank line, and put the column names and column\n    // divider characters \"|\" into it.  overwrite() is defined below.\n    StringBuffer line = new StringBuffer(blankline.toString());\n    line.setCharAt(0, '|');\n    for (int i = 0; i < numcols; i++) {\n        int pos = colpos[i] + 1 + (colwidths[i] - labels[i].length()) / 2;\n        overwrite(line, pos, labels[i]);\n        overwrite(line, colpos[i] + colwidths[i], \" |\");\n    }\n    // Then output the line of column labels and another divider\n    out.println(line);\n    out.println(divider);\n    // we did for the column labels above.\n    while (rs.next()) {\n        line = new StringBuffer(blankline.toString());\n        line.setCharAt(0, '|');\n        for (int i = 0; i < numcols; i++) {\n            Object value = rs.getObject(i + 1);\n            if (value != null)\n                overwrite(line, colpos[i] + 1, value.toString().trim());\n            overwrite(line, colpos[i] + colwidths[i], \" |\");\n        }\n        out.println(line);\n    }\n    // Finally, end the table with one last divider line.\n    out.println(divider);\n    out.flush();\n}\n         // Now, output the table data.  Loop through the ResultSet, using\n\n         // the next() method to get the rows one at a time. Obtain the \n\n         // value of each column with getObject(), and output it, much as \n\n","name":"printResultsTable","className":"ExecuteSQL","variables":{"rs":3,"labelsize":3,"metadata":4,"line":4,"i":33,"colpos":7,"colwidths":6,"linewidth":8,"out":7,"labels":5,"output":1,"blankline":4,"size":8,"divider":4,"pos":1,"numcols":8,"value":3},"constants":{"0":7,"1":10,"'-'":1,"2":2,"'|'":2,"'+'":2,"\" \"":1,"null":1,"500":1,"\" |\"":2,"30":2},"javaDoc":"This method attempts to output the contents of a ResultSet in a textual table It relies on the ResultSetMetaData class but a fair bit of the code is simple string manipulation","comments":"Variables to hold important data about the table to be displayed Figure out how wide the columns are where each one begins how wide each row of the table will be etc Create a horizontal divider line we use in the table Also create a blank line that is the initial value of each The next line of the table contains the column labels Begin with a blank line and put the column names and column Now output the table data Loop through the ResultSet using the next() method to get the rows one at a time Obtain the value of each column with getObject() and output it much as Set up the output stream Get some \"meta data\" (column names etc ) about the results how many columns the column labels the width of each start position of each total width of table for the initial '|' for each column Get the column width If the db doesn't report one guess 30 characters Then check the length of the label and use save its position get its label it if it is larger than the column width Some drivers return -1 Don't allow unreasonable sizes save the column the size increment total size line of the table Put special marks in the divider line at the column positions Begin the table output with a divider line divider characters \"|\" into it overwrite() is defined below Then output the line of column labels and another divider we did for the column labels above Finally end the table with one last divider line \n     * This method attempts to output the contents of a ResultSet in a \n     * textual table.  It relies on the ResultSetMetaData class, but a fair\n     * bit of the code is simple string manipulation.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["StringBuffer","int","String"],"returnType":"void","methodCalls":{"length":2,"setCharAt":1,"charAt":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"int":3},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":3,"BinaryExpr":5,"NameExpr":24,"UnaryExpr":1,"MethodCallExpr":4,"AssignExpr":1},"statements":{"IfStmt":1,"ForStmt":1,"ExpressionStmt":4},"text":"/** This utility method is used when printing the table of results */\nstatic void overwrite(StringBuffer b, int pos, String s) {\n    // string length\n    int slen = s.length();\n    // buffer length\n    int blen = b.length();\n    // does it fit?\n    if (pos + slen > blen)\n        slen = blen - pos;\n    for (// copy string into buffer\n    int i = 0; // copy string into buffer\n    i < slen; // copy string into buffer\n    i++) b.setCharAt(pos + i, s.charAt(i));\n}\n","name":"overwrite","className":"ExecuteSQL","variables":{"b":2,"s":2,"pos":3,"slen":4,"i":4,"blen":3},"constants":{"0":1},"javaDoc":"This utility method is used when printing the table of results","comments":"string length buffer length does it fit? copy string into buffer copy string into buffer copy string into buffer  This utility method is used when printing the table of results ","isEmpty":false,"hasInnerClass":false,"modifier":8}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"forName":1,"print_class":1},"annotations":[],"exceptions":["ClassNotFoundException"],"concepts":[],"types":{"Class":1},"expressions":{"IntegerLiteralExpr":1,"VariableDeclarationExpr":1,"ArrayAccessExpr":1,"NameExpr":7,"MethodCallExpr":2},"statements":{"ExpressionStmt":2},"text":"/** The main method.  Print info about the named class */\npublic static void main(String[] args) throws ClassNotFoundException {\n    Class c = Class.forName(args[0]);\n    print_class(c);\n}\n","name":"main","className":"ShowClass","variables":{"args":1,"c":1,"Class":1},"constants":{"0":1},"javaDoc":"The main method Print info about the named class","comments":" The main method.  Print info about the named class ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"void","methodCalls":{"getDeclaredConstructors":1,"getInterfaces":1,"getDeclaredFields":1,"getDeclaredMethods":1,"toString":3,"getModifiers":3,"print_field":1,"print_method_or_constructor":2,"isInterface":2,"System.out.print":7,"typename":5,"getSuperclass":2,"System.out.println":5},"annotations":[],"exceptions":[],"concepts":[],"types":{"Class[]":1,"Constructor[]":1,"Method[]":1,"int":4,"Field[]":1},"expressions":{"NullLiteralExpr":2,"IntegerLiteralExpr":6,"VariableDeclarationExpr":8,"ArrayAccessExpr":4,"BinaryExpr":17,"NameExpr":154,"StringLiteralExpr":12,"FieldAccessExpr":17,"EnclosedExpr":2,"UnaryExpr":4,"MethodCallExpr":34},"statements":{"IfStmt":5,"BlockStmt":5,"ForStmt":4,"ExpressionStmt":19},"text":"/**\n     * Display the modifiers, name, superclass and interfaces of a class\n     * or interface. Then go and list all constructors, fields, and methods.\n     **/\npublic static void print_class(Class c) {\n    // Print modifiers, type (class or interface), name and superclass.\n    if (c.isInterface()) {\n        // The modifiers will include the \"interface\" keyword here...\n        System.out.print(Modifier.toString(c.getModifiers()) + \" \" + typename(c));\n    } else if (c.getSuperclass() != null) {\n        System.out.print(Modifier.toString(c.getModifiers()) + \" class \" + typename(c) + \" extends \" + typename(c.getSuperclass()));\n    } else {\n        System.out.print(Modifier.toString(c.getModifiers()) + \" class \" + typename(c));\n    }\n    // Print interfaces or super-interfaces of the class or interface.\n    Class[] interfaces = c.getInterfaces();\n    if ((interfaces != null) && (interfaces.length > 0)) {\n        if (c.isInterface())\n            System.out.print(\" extends \");\n        else\n            System.out.print(\" implements \");\n        for (int i = 0; i < interfaces.length; i++) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(typename(interfaces[i]));\n        }\n    }\n    // Begin class member listing.\n    System.out.println(\" {\");\n    // Now look up and display the members of the class.\n    System.out.println(\"  // Constructors\");\n    Constructor[] constructors = c.getDeclaredConstructors();\n    for (// Display constructors.\n    int i = 0; // Display constructors.\n    i < constructors.length; // Display constructors.\n    i++) print_method_or_constructor(constructors[i]);\n    System.out.println(\"  // Fields\");\n    // Look up fields.\n    Field[] fields = c.getDeclaredFields();\n    for (// Display them.\n    int i = 0; // Display them.\n    i < fields.length; // Display them.\n    i++) print_field(fields[i]);\n    System.out.println(\"  // Methods\");\n    // Look up methods.\n    Method[] methods = c.getDeclaredMethods();\n    for (// Display them.\n    int i = 0; // Display them.\n    i < methods.length; // Display them.\n    i++) print_method_or_constructor(methods[i]);\n    // End class member listing.\n    System.out.println(\"}\");\n}\n","name":"print_class","className":"ShowClass","variables":{"constructors":2,"interfaces":3,"c":11,"methods":2,"i":17,"fields":2,"Modifier":3},"constants":{"0":6,"\" class \"":2,"\" \"":1,"null":2,"\"  // Constructors\"":1,"\"}\"":1,"\" extends \"":2,"\" {\"":1,"\", \"":1,"\"  // Fields\"":1,"\" implements \"":1,"\"  // Methods\"":1},"javaDoc":"Display the modifiers name superclass and interfaces of a class or interface Then go and list all constructors fields and methods","comments":"Print modifiers type (class or interface) name and superclass The modifiers will include the \"interface\" keyword here Print interfaces or super-interfaces of the class or interface Begin class member listing Now look up and display the members of the class Display constructors Display constructors Display constructors Look up fields Display them Display them Display them Look up methods Display them Display them Display them End class member listing \n     * Display the modifiers, name, superclass and interfaces of a class\n     * or interface. Then go and list all constructors, fields, and methods.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Class"],"returnType":"String","methodCalls":{"lastIndexOf":1,"getName":1,"getComponentType":1,"isArray":1,"substring":1},"annotations":[],"exceptions":[],"concepts":[],"types":{"String":2,"int":1},"expressions":{"IntegerLiteralExpr":2,"VariableDeclarationExpr":3,"BinaryExpr":3,"StringLiteralExpr":2,"NameExpr":22,"CharLiteralExpr":1,"UnaryExpr":1,"MethodCallExpr":5,"AssignExpr":3},"statements":{"IfStmt":1,"WhileStmt":1,"BlockStmt":1,"ReturnStmt":1,"ExpressionStmt":6},"text":"/** Return the name of an interface or primitive type, handling arrays. */\npublic static String typename(Class t) {\n    String brackets = \"\";\n    while (t.isArray()) {\n        brackets += \"[]\";\n        t = t.getComponentType();\n    }\n    String name = t.getName();\n    int pos = name.lastIndexOf('.');\n    if (pos != -1)\n        name = name.substring(pos + 1);\n    return name + brackets;\n}\n","name":"typename","className":"ShowClass","variables":{"t":4,"pos":3,"name":5,"brackets":3},"constants":{"\"\"":1,"'.'":1,"1":2,"\"[]\"":1},"javaDoc":"Return the name of an interface or primitive type handling arrays","comments":" Return the name of an interface or primitive type, handling arrays. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["int"],"returnType":"String","methodCalls":{"toString":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"IntegerLiteralExpr":1,"BinaryExpr":2,"NameExpr":5,"StringLiteralExpr":2,"MethodCallExpr":1},"statements":{"IfStmt":1,"ReturnStmt":2},"text":"/** Return a string version of modifiers, handling spaces nicely. */\npublic static String modifiers(int m) {\n    if (m == 0)\n        return \"\";\n    else\n        return Modifier.toString(m) + \" \";\n}\n","name":"modifiers","className":"ShowClass","variables":{"m":1,"Modifier":1},"constants":{"0":1,"\"\"":1,"\" \"":1},"javaDoc":"Return a string version of modifiers handling spaces nicely","comments":" Return a string version of modifiers, handling spaces nicely. ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Field"],"returnType":"void","methodCalls":{"getName":1,"getType":1,"getModifiers":1,"modifiers":1,"typename":1,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"BinaryExpr":5,"NameExpr":18,"StringLiteralExpr":3,"FieldAccessExpr":1,"MethodCallExpr":6},"statements":{"ExpressionStmt":1},"text":"/** Print the modifiers, type, and name of a field */\npublic static void print_field(Field f) {\n    System.out.println(\"  \" + modifiers(f.getModifiers()) + typename(f.getType()) + \" \" + f.getName() + \";\");\n}\n","name":"print_field","className":"ShowClass","variables":{"f":3},"constants":{"\" \"":1,"\";\"":1,"\"  \"":1},"javaDoc":"Print the modifiers type and name of a field","comments":" Print the modifiers, type, and name of a field ","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Member"],"returnType":"void","methodCalls":{"getExceptionTypes":2,"getDeclaringClass":1,"getName":1,"getReturnType":1,"getParameterTypes":2,"getModifiers":2,"modifiers":2,"System.out.print":8,"typename":4,"System.out.println":1},"annotations":[],"exceptions":[],"concepts":["Casting"],"types":{"Constructor":1,"Class":1,"Method":1,"int":2},"expressions":{"IntegerLiteralExpr":5,"VariableDeclarationExpr":5,"ArrayAccessExpr":2,"BinaryExpr":13,"NameExpr":112,"StringLiteralExpr":10,"InstanceOfExpr":1,"UnaryExpr":2,"AssignExpr":5,"NullLiteralExpr":1,"CastExpr":2,"FieldAccessExpr":12,"MethodCallExpr":24},"statements":{"IfStmt":4,"BlockStmt":4,"ForStmt":2,"ExpressionStmt":17},"text":"/**\n     * Print the modifiers, return type, name, parameter types and exception\n     * type of a method or constructor.  Note the use of the Member interface\n     * to allow this method to work with both Method and Constructor objects\n     **/\npublic static void print_method_or_constructor(Member member) {\n    Class returntype = null, parameters[], exceptions[];\n    if (member instanceof Method) {\n        Method m = (Method) member;\n        returntype = m.getReturnType();\n        parameters = m.getParameterTypes();\n        exceptions = m.getExceptionTypes();\n        System.out.print(\"  \" + modifiers(member.getModifiers()) + typename(returntype) + \" \" + member.getName() + \"(\");\n    } else {\n        Constructor c = (Constructor) member;\n        parameters = c.getParameterTypes();\n        exceptions = c.getExceptionTypes();\n        System.out.print(\"  \" + modifiers(member.getModifiers()) + typename(c.getDeclaringClass()) + \"(\");\n    }\n    for (int i = 0; i < parameters.length; i++) {\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(typename(parameters[i]));\n    }\n    System.out.print(\")\");\n    if (exceptions.length > 0)\n        System.out.print(\" throws \");\n    for (int i = 0; i < exceptions.length; i++) {\n        if (i > 0)\n            System.out.print(\", \");\n        System.out.print(typename(exceptions[i]));\n    }\n    System.out.println(\";\");\n}\n","name":"print_method_or_constructor","className":"ShowClass","variables":{"c":4,"returntype":2,"member":6,"i":10,"parameters":4,"m":4,"exceptions":4},"constants":{"0":5,"null":1,"\" \"":1,"\" throws \"":1,"\";\"":1,"\")\"":1,"\"(\"":2,"\", \"":2,"\"  \"":2},"javaDoc":"Print the modifiers return type name parameter types and exception type of a method or constructor Note the use of the Member interface to allow this method to work with both Method and Constructor objects","comments":"\n     * Print the modifiers, return type, name, parameter types and exception\n     * type of a method or constructor.  Note the use of the Member interface\n     * to allow this method to work with both Method and Constructor objects\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["Object","Method"],"returnType":"Command","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":3},"statements":{"ExplicitConstructorInvocationStmt":1},"text":"/** This constructor creates a Command object for a no-arg method */\npublic Command(Object target, Method m) {\n    this(target, m, nullargs);\n}\n","name":"Command","className":"Command","variables":{"nullargs":1,"m":1,"target":1},"constants":{},"javaDoc":"This constructor creates a Command object for a no-arg method","comments":" This constructor creates a Command object for a no-arg method ","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","Method","Object[]"],"returnType":"Command","methodCalls":{},"annotations":[],"exceptions":[],"concepts":[],"types":{},"expressions":{"NameExpr":9,"FieldAccessExpr":3,"ThisExpr":3,"AssignExpr":3},"statements":{"ExpressionStmt":3},"text":"/** \n     * This constructor creates a Command object for a method that takes the\n     * specified array of arguments.  Note that the parse() method provides\n     * another way to create a Command object\n     **/\npublic Command(Object target, Method m, Object[] args) {\n    this.target = target;\n    this.m = m;\n    this.args = args;\n}\n","name":"Command","className":"Command","variables":{"args":1,"m":1,"target":1},"constants":{},"javaDoc":"This constructor creates a Command object for a method that takes the specified array of arguments Note that the parse() method provides another way to create a Command object","comments":" \n     * This constructor creates a Command object for a method that takes the\n     * specified array of arguments.  Note that the parse() method provides\n     * another way to create a Command object\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":[],"returnType":"void","methodCalls":{"invoke":1},"annotations":[],"exceptions":["InvocationTargetException","IllegalAccessException"],"concepts":[],"types":{},"expressions":{"NameExpr":5,"MethodCallExpr":1},"statements":{"ExpressionStmt":1},"text":"/**\n     * Invoke the Command by calling the method on its target, and passing\n     * the arguments.  See also actionPerformed() which does not throw the\n     * checked exceptions that this method does.\n     **/\npublic void invoke() throws IllegalAccessException, InvocationTargetException {\n    // Use reflection to invoke the method\n    m.invoke(target, args);\n}\n","name":"invoke","className":"Command","variables":{"m":1},"constants":{},"javaDoc":"Invoke the Command by calling the method on its target and passing the arguments See also actionPerformed() which does not throw the checked exceptions that this method does","comments":"Use reflection to invoke the method \n     * Invoke the Command by calling the method on its target, and passing\n     * the arguments.  See also actionPerformed() which does not throw the\n     * checked exceptions that this method does.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["ActionEvent"],"returnType":"void","methodCalls":{"getTargetException":1,"invoke":1,"toString":2},"annotations":[],"exceptions":["RuntimeException","// but handle the exceptions\nInvocationTargetException","IllegalAccessException"],"concepts":["ExceptionHandling"],"types":{},"expressions":{"ObjectCreationExpr":2,"BinaryExpr":2,"NameExpr":10,"StringLiteralExpr":2,"MethodCallExpr":4},"statements":{"TryStmt":1,"BlockStmt":3,"ThrowStmt":2,"ExpressionStmt":1},"text":"/**\n     * This method implements the ActionListener interface.  It is like\n     * invoke() except that it catches the exceptions thrown by that method\n     * and rethrows them as an unchecked RuntimeException\n     **/\npublic void actionPerformed(ActionEvent e) {\n    try {\n        // Call the invoke method\n        invoke();\n    } catch (// but handle the exceptions\n    InvocationTargetException // but handle the exceptions\n    ex) {\n        throw new RuntimeException(\"Command: \" + ex.getTargetException().toString());\n    } catch (IllegalAccessException ex) {\n        throw new RuntimeException(\"Command: \" + ex.toString());\n    }\n}\n","name":"actionPerformed","className":"Command","variables":{"ex":4},"constants":{"\"Command: \"":2},"javaDoc":"This method implements the ActionListener interface It is like invoke() except that it catches the exceptions thrown by that method and rethrows them as an unchecked RuntimeException","comments":"Call the invoke method but handle the exceptions but handle the exceptions \n     * This method implements the ActionListener interface.  It is like\n     * invoke() except that it catches the exceptions thrown by that method\n     * and rethrows them as an unchecked RuntimeException\n     *","isEmpty":false,"hasInnerClass":false,"modifier":1}
{"paramTypes":["Object","String"],"returnType":"Command","methodCalls":{"t.sval.equals":2,"add":12,"getClass":1,"pushBack":3,"nextToken":5,"toArray":2,"getMethod":1},"annotations":[],"exceptions":["IOException","Exception"],"concepts":["Casting","ExceptionHandling"],"types":{"Class[]":1,"ArrayList":2,"String":1,"Method":1,"StreamTokenizer":1,"int":2,"Object[]":1},"expressions":{"ObjectCreationExpr":10,"VariableDeclarationExpr":9,"BinaryExpr":16,"NameExpr":145,"StringLiteralExpr":8,"CastExpr":2,"FieldAccessExpr":15,"CharLiteralExpr":6,"ClassExpr":6,"ArrayCreationExpr":1,"MethodCallExpr":26,"AssignExpr":6},"statements":{"IfStmt":12,"BreakStmt":1,"BlockStmt":15,"TryStmt":1,"ThrowStmt":3,"ForStmt":1,"ReturnStmt":1,"ExpressionStmt":30},"text":"/**\n     * This static method creates a Command using the specified target object,\n     * and the specified string.  The string should contain method name\n     * followed by an optional parenthesized comma-separated argument list and\n     * a semicolon.  The arguments may be boolean, integer or double literals,\n     * or double-quoted strings.  The parser is lenient about missing commas,\n     * semicolons and quotes, but throws an IOException if it cannot parse the\n     * string.\n     **/\npublic static Command parse(Object target, String text) throws IOException {\n    // The name of the method\n    String methodname;\n    // Hold arguments as we parse them.\n    ArrayList args = new ArrayList();\n    // Hold argument types.\n    ArrayList types = new ArrayList();\n    // Convert the string into a character stream, and use the\n    // StreamTokenizer class to convert it into a stream of tokens\n    StreamTokenizer t = new StreamTokenizer(new StringReader(text));\n    // The first token must be the method name\n    // read a token\n    int c = t.nextToken();\n    if (// check the token type\n    c != t.TT_WORD)\n        throw new IOException(\"Missing method name for command\");\n    // Remember the method name\n    methodname = t.sval;\n    // Now we either need a semicolon or a open paren\n    c = t.nextToken();\n    if (c == '(') {\n        // If we see an open paren, then parse an arg list\n        for (; ; ) {\n            // Loop 'till end of arglist\n            // Read next token\n            c = t.nextToken();\n            if (c == ')') {\n                // See if we're done parsing arguments.\n                // If so, parse an optional semicolon\n                c = t.nextToken();\n                if (c != ';')\n                    t.pushBack();\n                // Now stop the loop.\n                break;\n            }\n            // Otherwise, the token is an argument; figure out its type\n            if (c == t.TT_WORD) {\n                // and treat any other tokens as unquoted string literals.\n                if (t.sval.equals(\"true\")) {\n                    // Boolean literal\n                    args.add(Boolean.TRUE);\n                    types.add(boolean.class);\n                } else if (t.sval.equals(\"false\")) {\n                    // Boolean literal\n                    args.add(Boolean.FALSE);\n                    types.add(boolean.class);\n                } else {\n                    // Assume its a string\n                    args.add(t.sval);\n                    types.add(String.class);\n                }\n            } else if (c == '\"') {\n                // If the token is a quoted string\n                args.add(t.sval);\n                types.add(String.class);\n            } else if (c == t.TT_NUMBER) {\n                // If the token is a number\n                int i = (int) t.nval;\n                if (i == t.nval) {\n                    // Check if its an integer\n                    // Note: this code treats a token like \"2.0\" as an int!\n                    args.add(new Integer(i));\n                    types.add(int.class);\n                } else {\n                    // Otherwise, its a double\n                    args.add(new Double(t.nval));\n                    types.add(double.class);\n                }\n            } else {\n                // Any other token is an error\n                throw new IOException(\"Unexpected token \" + t.sval + \" in argument list of \" + methodname + \"().\");\n            }\n            // Next should be a comma, but we don't complain if its not \n            c = t.nextToken();\n            if (c != ',')\n                t.pushBack();\n        }\n    } else if (c != ';') {\n        // if a method name is not followed by a paren  \n        // then allow a semi-colon but don't require it.\n        t.pushBack();\n    }\n    // We've parsed the argument list.\n    // Next, convert the lists of argument values and types to arrays\n    Object[] argValues = args.toArray();\n    Class[] argtypes = (Class[]) types.toArray(new Class[argValues.length]);\n    // At this point, we've got a method name, and arrays of argument\n    // values and types.  Use reflection on the class of the target object\n    // to find a method with the given name and argument types.  Throw\n    // an exception if we can't find the named method.\n    Method method;\n    try {\n        method = target.getClass().getMethod(methodname, argtypes);\n    } catch (Exception e) {\n        throw new IOException(\"No such method found, or wrong argument \" + \"types: \" + methodname);\n    }\n    // the array of argument values we parsed from the string.\n    return new Command(target, method, argValues);\n}\n     // Finally, create and return a Command object, using the target object\n\n     // passed to this method, the Method object we obtained above, and\n\n             // If the token is an identifier, parse boolean literals, \n\n","name":"parse","className":"Command","variables":{"args":8,"types":8,"c":14,"t":9,"method":3,"argtypes":1,"e":1,"argValues":2,"i":3,"text":1,"methodname":4,"target":2},"constants":{"','":1,"\"Unexpected token \"":1,"')'":1,"'('":1,"\"().\"":1,"\"false\"":1,"\"Missing method name for command\"":1,"'\"'":1,"\" in argument list of \"":1,"\"true\"":1,"\"types: \"":1,"';'":2,"\"No such method found, or wrong argument \"":1},"javaDoc":"This static method creates a Command using the specified target object and the specified string The string should contain method name followed by an optional parenthesized comma-separated argument list and a semicolon The arguments may be boolean integer or double literals or double-quoted strings The parser is lenient about missing commas semicolons and quotes but throws an IOException if it cannot parse the string","comments":"Convert the string into a character stream and use the The first token must be the method name We've parsed the argument list At this point we've got a method name and arrays of argument values and types Use reflection on the class of the target object to find a method with the given name and argument types Throw Finally create and return a Command object using the target object passed to this method the Method object we obtained above and The name of the method Hold arguments as we parse them Hold argument types StreamTokenizer class to convert it into a stream of tokens read a token check the token type Remember the method name Now we either need a semicolon or a open paren If we see an open paren then parse an arg list Loop 'till end of arglist Read next token See if we're done parsing arguments If so parse an optional semicolon Now stop the loop Otherwise the token is an argument; figure out its type If the token is an identifier parse boolean literals and treat any other tokens as unquoted string literals Boolean literal Boolean literal Assume its a string If the token is a quoted string If the token is a number Check if its an integer Note: this code treats a token like \"2 0\" as an int! Otherwise its a double Any other token is an error Next should be a comma but we don't complain if its not if a method name is not followed by a paren then allow a semi-colon but don't require it Next convert the lists of argument values and types to arrays an exception if we can't find the named method the array of argument values we parsed from the string \n     * This static method creates a Command using the specified target object,\n     * and the specified string.  The string should contain method name\n     * followed by an optional parenthesized comma-separated argument list and\n     * a semicolon.  The arguments may be boolean, integer or double literals,\n     * or double-quoted strings.  The parser is lenient about missing commas,\n     * semicolons and quotes, but throws an IOException if it cannot parse the\n     * string.\n     *","isEmpty":false,"hasInnerClass":false,"modifier":9}
{"paramTypes":["String[]"],"returnType":"void","methodCalls":{"add":3,"addActionListener":2,"show":1,"getContentPane":1,"parse":2,"pack":1},"annotations":[],"exceptions":["IOException"],"concepts":[],"types":{"javax.swing.JButton":2,"javax.swing.JLabel":1,"java.awt.Container":1,"javax.swing.JFrame":1},"expressions":{"ObjectCreationExpr":4,"VariableDeclarationExpr":5,"StringLiteralExpr":6,"NameExpr":56,"FieldAccessExpr":9,"MethodCallExpr":10},"statements":{"ExpressionStmt":12},"text":"public static void main(String[] args) throws IOException {\n    javax.swing.JFrame f = new javax.swing.JFrame(\"Command Test\");\n    javax.swing.JButton b1 = new javax.swing.JButton(\"Tick\");\n    javax.swing.JButton b2 = new javax.swing.JButton(\"Tock\");\n    javax.swing.JLabel label = new javax.swing.JLabel(\"Hello world\");\n    java.awt.Container pane = f.getContentPane();\n    pane.add(b1, java.awt.BorderLayout.WEST);\n    pane.add(b2, java.awt.BorderLayout.EAST);\n    pane.add(label, java.awt.BorderLayout.NORTH);\n    b1.addActionListener(Command.parse(label, \"setText(\\\"tick\\\");\"));\n    b2.addActionListener(Command.parse(label, \"setText(\\\"tock\\\");\"));\n    f.pack();\n    f.show();\n}\n","name":"main","className":"Test","variables":{"b2":2,"Command":2,"f":4,"label":1,"pane":4,"b1":2},"constants":{"\"Tock\"":1,"\"Tick\"":1,"\"setText(\\\"tock\\\");\"":1,"\"Command Test\"":1,"\"Hello world\"":1,"\"setText(\\\"tick\\\");\"":1},"javaDoc":"","isEmpty":false,"hasInnerClass":false,"modifier":9}
