Extracting solution vectors...
public void actionPerformed(ActionEvent ev) {
    try {
        // make (and open) a sequencer, make a sequence and track
        Sequencer sequencer = MidiSystem.getSequencer();
        sequencer.open();
        sequencer.addControllerEventListener(myPanel, new int[] { 127 });
        Sequence seq = new Sequence(Sequence.PPQ, 4);
        Track track = seq.createTrack();
        for (int i = 0; i < 100; i += 4) {
            int rNum = (int) ((Math.random() * 50) + 1);
            if (rNum < 38) {
                // so now only do it if num <38 (75% of the time)
                track.add(makeEvent(144, 1, rNum, 100, i));
                track.add(makeEvent(176, 1, 127, 0, i));
                track.add(makeEvent(128, 1, rNum, 100, i + 2));
            }
        }
        // end loop
        // add the events to the track            
        // add the sequence to the sequencer, set timing, and start
        sequencer.setSequence(seq);
        sequencer.start();
        sequencer.setTempoInBPM(220);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

{'message', 'containing'}
// close method
public void setUpMidi() {
    try {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        // sequencer.addMetaEventListener(this);
        sequence = new Sequence(Sequence.PPQ, 4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

{'addmetaeventlistener'}
public ArrayList<String> placeDotCom(int comSize) {
    // line 19
    ArrayList<String> alphaCells = new ArrayList<String>();
    // holds 'f6' type coords
    String[] alphacoords = new String[comSize];
    // temporary String for concat
    String temp = null;
    // current candidate coords
    int[] coords = new int[comSize];
    // current attempts counter
    int attempts = 0;
    // flag = found a good location ?
    boolean success = false;
    // current starting location
    int location = 0;
    // nth dot com to place
    comCount++;
    // set horizontal increment
    int incr = 1;
    if ((comCount % 2) == 1) {
        // if odd dot com  (place vertically)
        // set vertical increment
        incr = gridLength;
    }
    while (!success & attempts++ < 200) {
        // main search loop  (32)
        // get random starting point
        location = (int) (Math.random() * gridSize);
        //System.out.print(" try " + location);
        // nth position in dotcom to place
        int x = 0;
        // assume success
        success = true;
        while (success && x < comSize) {
            // look for adjacent unused spots
            if (grid[location] == 0) {
                // if not already used
                // save location
                coords[x++] = location;
                // try 'next' adjacent
                location += incr;
                if (location >= gridSize) {
                    // out of bounds - 'bottom'
                    // failure
                    success = false;
                }
                if (x > 0 & (location % gridLength == 0)) {
                    // out of bounds - right edge
                    // failure
                    success = false;
                }
            } else {
                // found already used location
                // System.out.print(" used " + location);  
                // failure
                success = false;
            }
        }
    }
    // end while
    // turn good location into alpha coords
    int x = 0;
    int row = 0;
    int column = 0;
    // System.out.println("\n");
    while (x < comSize) {
        // mark master grid pts. as 'used'
        grid[coords[x]] = 1;
        // get row value
        row = (int) (coords[x] / gridLength);
        // get numeric column value
        column = coords[x] % gridLength;
        // convert to alpha
        temp = String.valueOf(alphabet.charAt(column));
        alphaCells.add(temp.concat(Integer.toString(row)));
        x++;
    // System.out.print("  coord "+x+" = " + alphaCells.get(x-1));
    }
    return alphaCells;
}

{'alphacells'}
// close method
public void setUpMidi() {
    try {
        sequencer = MidiSystem.getSequencer();
        sequencer.open();
        // sequencer.addMetaEventListener(this);
        sequence = new Sequence(Sequence.PPQ, 4);
        track = sequence.createTrack();
        sequencer.setTempoInBPM(120);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

{'addmetaeventlistener'}
/**
      Constructs a pair containing two given elements.
      @param firstElement the first element
      @param secondElement the second element
   */
public Pair(T firstElement, S secondElement) {
    first = firstElement;
    second = secondElement;
}

{'secondelement', 'firstelement'}
public static <E> void addAll(ArrayList<E> lst, ArrayList<? extends E> other) // public static <E> void addAll(ArrayList<E> lst, ArrayList<E> other)
// doesn't work with Student array list
{
    for (E e : other) {
        lst.add(e);
    }
}

{'arraylist', 'addall'}
public static <E extends Comparable<? super E>> E max(ArrayList<E> a) // public static <E extends Comparable<E>> E max(ArrayList<E> a) 
// doesn't work with Student array list
{
    E largest = a.get(0);
    for (int i = 1; i < a.size(); i++) {
        if (a.get(i).compareTo(largest) > 0) {
            largest = a.get(i);
        }
    }
    return largest;
}

{'arraylist'}
/**
      Constructs a Student object.
      @param aName the name of the student
      @param aMajor the major of the student
   */
public Student(String aName, String aMajor) {
    super(aName);
    major = aMajor;
}

{'aname', 'amajor'}
/**
      Constructs a Person object
      @param aName the name of the person
   */
public Person(String aName) {
    name = aName;
}

{'aname'}
/**
      Constructs a Student object.
      @param aName the name of the student
      @param aMajor the major of the student
   */
public Student(String aName, String aMajor) {
    super(aName);
    major = aMajor;
}

{'aname', 'amajor'}
public static void main(String[] args) {
    BinarySearchTree2<Student> students = new BinarySearchTree2<>();
    // Can form BinarySearchTree2<Student> even though Student
    // implements Comparable<Person> and not Comparable<Student>
    students.add(new Student("Romeo", "Art History"));
    students.add(new Student("Juliet", "CS"));
    students.add(new Student("Tom", "Leisure Studies"));
    students.add(new Student("Diana", "EE"));
    students.add(new Student("Harry", "Biology"));
    class PrintVisitor implements Visitor<Object> {

        public void visit(Object data) {
            System.out.println(data);
        }
    }
    // Can pass a Visitor<Object>, not just a Visitor<Student>
    students.inorder(new PrintVisitor());
}

{'binarysearchtreeD'}
/**
      Tries to remove an object from the tree. Does nothing
      if the object is not contained in the tree.
      @param obj the object to remove
   */
public void remove(E obj) {
    // Find node to be removed
    Node toBeRemoved = root;
    Node parent = null;
    boolean found = false;
    while (!found && toBeRemoved != null) {
        int d = toBeRemoved.data.compareTo(obj);
        if (d == 0) {
            found = true;
        } else {
            parent = toBeRemoved;
            if (d > 0) {
                toBeRemoved = toBeRemoved.left;
            } else {
                toBeRemoved = toBeRemoved.right;
            }
        }
    }
    if (!found) {
        return;
    }
    if (toBeRemoved.left == null || toBeRemoved.right == null) {
        Node newChild;
        if (toBeRemoved.left == null) {
            newChild = toBeRemoved.right;
        } else {
            newChild = toBeRemoved.left;
        }
        if (// Found in root
        parent == null) {
            root = newChild;
        } else if (parent.left == toBeRemoved) {
            parent.left = newChild;
        } else {
            parent.right = newChild;
        }
        return;
    }
    // Neither subtree is empty
    // Find smallest element of the right subtree
    Node smallestParent = toBeRemoved;
    Node smallest = toBeRemoved.right;
    while (smallest.left != null) {
        smallestParent = smallest;
        smallest = smallest.left;
    }
    // smallest contains smallest child in right subtree
    // Move contents, unlink child
    toBeRemoved.data = smallest.data;
    if (smallestParent == toBeRemoved) {
        smallestParent.right = smallest.right;
    } else {
        smallestParent.left = smallest.right;
    }
}

{'use', 'toberemoved'}
/**
         Inserts a new node as a descendant of this node.
         @param newNode the node to insert
      */
public void addNode(Node newNode) {
    int comp = newNode.data.compareTo(data);
    if (comp < 0) {
        if (left == null) {
            left = newNode;
        } else {
            left.addNode(newNode);
        }
    } else if (comp > 0) {
        if (right == null) {
            right = newNode;
        } else {
            right.addNode(newNode);
        }
    }
}

{'newnode'}
/**
      Tries to remove an object from the tree. Does nothing
      if the object is not contained in the tree.
      @param obj the object to remove
   */
public void remove(E obj) {
    // Find node to be removed
    Node toBeRemoved = root;
    Node parent = null;
    boolean found = false;
    while (!found && toBeRemoved != null) {
        int d = toBeRemoved.data.compareTo(obj);
        if (d == 0) {
            found = true;
        } else {
            parent = toBeRemoved;
            if (d > 0) {
                toBeRemoved = toBeRemoved.left;
            } else {
                toBeRemoved = toBeRemoved.right;
            }
        }
    }
    if (!found) {
        return;
    }
    if (toBeRemoved.left == null || toBeRemoved.right == null) {
        Node newChild;
        if (toBeRemoved.left == null) {
            newChild = toBeRemoved.right;
        } else {
            newChild = toBeRemoved.left;
        }
        if (// Found in root
        parent == null) {
            root = newChild;
        } else if (parent.left == toBeRemoved) {
            parent.left = newChild;
        } else {
            parent.right = newChild;
        }
        return;
    }
    // Neither subtree is empty
    // Find smallest element of the right subtree
    Node smallestParent = toBeRemoved;
    Node smallest = toBeRemoved.right;
    while (smallest.left != null) {
        smallestParent = smallest;
        smallest = smallest.left;
    }
    // smallest contains smallest child in right subtree
    // Move contents, unlink child
    toBeRemoved.data = smallest.data;
    if (smallestParent == toBeRemoved) {
        smallestParent.right = smallest.right;
    } else {
        smallestParent.left = smallest.right;
    }
}

{'use', 'toberemoved'}
/**
         Inserts a new node as a descendant of this node.
         @param newNode the node to insert
      */
public void addNode(Node newNode) {
    int comp = newNode.data.compareTo(data);
    if (comp < 0) {
        if (left == null) {
            left = newNode;
        } else {
            left.addNode(newNode);
        }
    } else if (comp > 0) {
        if (right == null) {
            right = newNode;
        } else {
            right.addNode(newNode);
        }
    }
}

{'newnode'}
/**
      Constructs a Person object
      @param aName the name of the person
   */
public Person(String aName) {
    name = aName;
}

{'aname'}
public static void main(String[] args) {
    // Here, we use the linked list class from Chapter 16
    LinkedList numbers = new LinkedList();
    numbers.addFirst(1);
    numbers.addFirst(2);
    numbers.addFirst(3);
    print(numbers);
    System.out.println("Sum: " + sum(numbers));
    // No error message
    numbers.addFirst("4");
    // No error
    print(numbers);
    System.out.println("Sum: " + sum(numbers));
// ClassCastException
}

{'classcastexception'}
public static void main(String[] args) throws FileNotFoundException {
    // Prompt for the input and output file names
    Scanner console = new Scanner(System.in);
    System.out.print("Input file: ");
    String inputFileName = console.next();
    System.out.print("Output file: ");
    String outputFileName = console.next();
    // Construct the Scanner and PrintWriter objects for reading and writing
    File inputFile = new File(inputFileName);
    Scanner in = new Scanner(inputFile);
    PrintWriter out = new PrintWriter(outputFileName);
    // Read the input and write the output
    double total = 0;
    // We read a line at a time since there may be spaces in the item names
    while (in.hasNextLine()) {
        String line = in.nextLine();
        boolean found = false;
        String item = "";
        double price = 0;
        for (int i = 0; !found && i < line.length(); i++) {
            char ch = line.charAt(i);
            if (ch == ':') {
                found = true;
                item = line.substring(0, i + 1);
                price = Double.parseDouble(line.substring(i + 1).trim());
                total = total + price;
            }
        }
        // If no colon was found, we skip the line
        if (found) {
            out.printf("%-20s%10.2f\n", item, price);
        }
    }
    out.printf("%-20s%10.2f\n", "Total:", total);
    in.close();
    out.close();
}

{'printwriter'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Tests the methods of the BankAccount class.
      @param args not used
   */
public static void main(String[] args) {
    BankAccount harrysChecking = new BankAccount();
    harrysChecking.deposit(2000);
    harrysChecking.withdraw(5000);
    // The last statement is not executed since an exception has
    // terminated the program
    System.out.println(harrysChecking.getBalance());
}

{'bankaccount'}
/**
      Constructs a CountryValue from an input line.
      @param line a line containing a country name, followed by a value
   */
public CountryValue(String line) {
    // Locate the start of the first digit
    int i = 0;
    while (!Character.isDigit(line.charAt(i))) {
        i++;
    }
    // Locate the end of the preceding word
    int j = i - 1;
    while (Character.isWhitespace(line.charAt(j))) {
        j--;
    }
    // Extract the country name
    country = line.substring(0, j + 1);
    // Extract the value
    value = Double.parseDouble(line.substring(i).trim());
}

{'countryvalue'}
/**
      Constructs a RecordReader with a zero total.
   */
public RecordReader(double aLimit) {
    total = 0;
    limit = aLimit;
}

{'recordreader'}
public static void main(String[] args) throws FileNotFoundException {
    // Prompt for the input and output file names
    Scanner console = new Scanner(System.in);
    System.out.print("Input file: ");
    String inputFileName = console.next();
    System.out.print("Output file: ");
    String outputFileName = console.next();
    // Construct the Scanner and PrintWriter objects for reading and writing
    File inputFile = new File(inputFileName);
    Scanner in = new Scanner(inputFile);
    PrintWriter out = new PrintWriter(outputFileName);
    // Read the input and write the output
    double total = 0;
    while (in.hasNextDouble()) {
        double value = in.nextDouble();
        out.printf("%15.2f\n", value);
        total = total + value;
    }
    out.printf("Total: %8.2f\n", total);
    in.close();
    out.close();
}

{'printwriter'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Tests the methods of the BankAccount class.
      @param args not used
   */
public static void main(String[] args) {
    BankAccount harrysChecking = new BankAccount();
    harrysChecking.deposit(2000);
    harrysChecking.withdraw(5000);
    // The last statement is not executed since an exception has
    // terminated the program
    System.out.println(harrysChecking.getBalance());
}

{'bankaccount'}
/**
      Constructs a cipher object with a given key.
      @param aKey the encryption key
   */
public CaesarCipher(int aKey) {
    key = aKey;
}

{'akey'}
/**
      Constructs a bank account with a zero balance.
      @param anAccountNumber the account number for this account
   */
public BankAccount(int anAccountNumber) {
    accountNumber = anAccountNumber;
    balance = 0;
}

{'anaccountnumber'}
/**
      Constructs a bank account with a given balance.
      @param anAccountNumber the account number for this account
      @param initialBalance the initial balance
   */
public BankAccount(int anAccountNumber, double initialBalance) {
    accountNumber = anAccountNumber;
    balance = initialBalance;
}

{'initialbalance', 'anaccountnumber'}
/**
      Constructs a BankData object that is not associated with a file.
   */
public BankData() {
    file = null;
}

{'bankdata'}
/**
      Finds the position of a bank account with a given number.
      @param accountNumber the number to find
      @return the position of the account with the given number, 
      or -1 if there is no such account
   */
public int find(int accountNumber) throws IOException {
    for (int i = 0; i < size(); i++) {
        file.seek(i * RECORD_SIZE);
        int a = file.readInt();
        if (a == accountNumber) {
            return i;
        }
    // Found a match            
    }
    // No match in the entire file
    return -1;
}

{'accountnumber'}
/**
      Constructs a bank account with a zero balance.
      @param anAccountNumber the account number for this account
   */
public BankAccount(int anAccountNumber) {
    accountNumber = anAccountNumber;
    balance = 0;
}

{'anaccountnumber'}
/**
      Constructs a bank account with a given balance.
      @param anAccountNumber the account number for this account
      @param initialBalance the initial balance
   */
public BankAccount(int anAccountNumber, double initialBalance) {
    accountNumber = anAccountNumber;
    balance = initialBalance;
}

{'initialbalance', 'anaccountnumber'}
/**
      Finds a bank account with a given number.
      @param accountNumber the number to find
      @return the account with the given number, or null if there
      is no such account
   */
public BankAccount find(int accountNumber) {
    for (BankAccount a : accounts) {
        if (// Found a match
        a.getAccountNumber() == accountNumber) {
            return a;
        }
    }
    // No match in the entire array list
    return null;
}

{'accountnumber'}
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    Stack<Integer> results = new Stack<>();
    System.out.println("Enter one number or operator per line, Q to quit. ");
    boolean done = false;
    while (!done) {
        String input = in.nextLine();
        if (input.equals("+")) {
            results.push(results.pop() + results.pop());
        } else if (input.equals("-")) {
            Integer arg2 = results.pop();
            results.push(results.pop() - arg2);
        } else if (input.equals("*") || input.equals("x")) {
            results.push(results.pop() * results.pop());
        } else if (input.equals("/")) {
            Integer arg2 = results.pop();
            results.push(results.pop() / arg2);
        } else if (input.equals("Q") || input.equals("q")) {
            done = true;
        } else {
            // Not an operator--push the input value
            results.push(Integer.parseInt(input));
        }
        System.out.println(results);
    }
}

{'command', 'argument'}
/**
      Constructs a work order with a given priority and description.
      @param aPriority the priority of this work order
      @param aDescription the description of this work order
   */
public WorkOrder(int aPriority, String aDescription) {
    priority = aPriority;
    description = aDescription;
}

{'adescription', 'apriority'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
public static void main(String[] args) throws FileNotFoundException {
    // Read the dictionary and the document
    Set<String> dictionaryWords = readWords("words");
    Set<String> documentWords = readWords("alice30.txt");
    for (String word : documentWords) {
        if (!dictionaryWords.contains(word)) {
            System.out.println(word);
        }
    }
}

{'print'}
public static void main(String[] args) throws FileNotFoundException {
    Map<String, Integer> frequencies = new TreeMap<>();
    Scanner in = new Scanner(new File("alice30.txt"));
    while (in.hasNext()) {
        String word = clean(in.next());
        // Get the old frequency count
        Integer count = frequencies.get(word);
        if (count == null) {
            count = 1;
        } else {
            count = count + 1;
        }
        frequencies.put(word, count);
    }
    for (String key : frequencies.keySet()) {
        System.out.printf("%-20s%10d\n", key, frequencies.get(key));
    }
}

{'increment', 'none', 'otherwise', 'print'}
/**
      Constructs a tree with one node and no children.
      @param rootData the data for the root
   */
public BinaryTree(Object rootData) {
    root = new Node();
    root.data = rootData;
    root.left = null;
    root.right = null;
}

{'rootdata'}
/**
      Constructs a binary tree.
      @param rootData the data for the root
      @param left the left subtree
      @param right the right subtree
   */
public BinaryTree(Object rootData, BinaryTree left, BinaryTree right) {
    root = new Node();
    root.data = rootData;
    root.left = left.root;
    root.right = right.root;
}

{'rootdata'}
/**
      Adds a new element to this heap.
      @param newElement the element to add
   */
public void add(Comparable newElement) {
    // Add a new leaf
    elements.add(null);
    int index = elements.size() - 1;
    // Demote parents that are larger than the new element
    while (index > 1 && getParent(index).compareTo(newElement) > 0) {
        elements.set(index, getParent(index));
        index = getParentIndex(index);
    }
    // Store the new element into the vacant slot
    elements.set(index, newElement);
}

{'newelement'}
/**
      Constructs a work order with a given priority and description.
      @param aPriority the priority of this work order
      @param aDescription the description of this work order
   */
public WorkOrder(int aPriority, String aDescription) {
    priority = aPriority;
    description = aDescription;
}

{'adescription', 'apriority'}
/**
      Tries to remove an object from the tree. Does nothing
      if the object is not contained in the tree.
      @param obj the object to remove
   */
public void remove(Comparable obj) {
    // Find node to be removed
    Node toBeRemoved = root;
    Node parent = null;
    boolean found = false;
    while (!found && toBeRemoved != null) {
        int d = toBeRemoved.data.compareTo(obj);
        if (d == 0) {
            found = true;
        } else {
            parent = toBeRemoved;
            if (d > 0) {
                toBeRemoved = toBeRemoved.left;
            } else {
                toBeRemoved = toBeRemoved.right;
            }
        }
    }
    if (!found) {
        return;
    }
    if (toBeRemoved.left == null || toBeRemoved.right == null) {
        Node newChild;
        if (toBeRemoved.left == null) {
            newChild = toBeRemoved.right;
        } else {
            newChild = toBeRemoved.left;
        }
        if (// Found in root
        parent == null) {
            root = newChild;
        } else if (parent.left == toBeRemoved) {
            parent.left = newChild;
        } else {
            parent.right = newChild;
        }
        return;
    }
    // Neither subtree is empty
    // Find smallest element of the right subtree
    Node smallestParent = toBeRemoved;
    Node smallest = toBeRemoved.right;
    while (smallest.left != null) {
        smallestParent = smallest;
        smallest = smallest.left;
    }
    // smallest contains smallest child in right subtree
    // Move contents, unlink child
    toBeRemoved.data = smallest.data;
    if (smallestParent == toBeRemoved) {
        smallestParent.right = smallest.right;
    } else {
        smallestParent.left = smallest.right;
    }
}

{'use', 'toberemoved'}
/**
         Inserts a new node as a descendant of this node.
         @param newNode the node to insert
      */
public void addNode(Node newNode) {
    int comp = newNode.data.compareTo(data);
    if (comp < 0) {
        if (left == null) {
            left = newNode;
        } else {
            left.addNode(newNode);
        }
    } else if (comp > 0) {
        if (right == null) {
            right = newNode;
        } else {
            right.addNode(newNode);
        }
    }
}

{'newnode'}
/**
      Tests removal, given a template for a tree with a black node that
      is to be deleted. All other nodes should be given all possible combinations 
      of red and black.
      @param t the template for the test cases
   */
public static void removalTest(RedBlackTree t) {
    for (int m = 0; m <= 1; m++) {
        // We don't recolor the root or toDelete
        int nodesToColor = count(t.root) - 2;
        for (int k = 0; k < Math.pow(2, nodesToColor); k++) {
            RedBlackTree rb = new RedBlackTree();
            if (m == 0) {
                rb.root = copy(t.root);
            } else {
                rb.root = mirror(t.root);
            }
            RedBlackTree.Node[] nodes = getNodes(rb);
            RedBlackTree.Node toDelete = null;
            // Color with the bit pattern of k
            int bits = k;
            for (RedBlackTree.Node n : nodes) {
                if (n == rb.root) {
                    n.color = RedBlackTree.BLACK;
                } else if (n.color == RedBlackTree.BLACK) {
                    toDelete = n;
                } else {
                    n.color = bits % 2;
                    bits = bits / 2;
                }
            }
            // Add children to make equal costs to null
            int targetCost = costToRoot(toDelete);
            for (RedBlackTree.Node n : nodes) {
                int cost = targetCost - costToRoot(n);
                if (n.left == null) {
                    n.setLeftChild(fullTree(cost));
                }
                if (n.right == null) {
                    n.setRightChild(fullTree(cost));
                }
            }
            int filledSize = populate(rb);
            boolean good = true;
            try {
                checkRedBlack(rb);
            } catch (IllegalStateException ex) {
                good = false;
            }
            if (good) {
                Comparable d = toDelete.data;
                rb.remove(d);
                checkRedBlack(rb);
                for (Integer j = 0; j < filledSize; j++) {
                    if (!rb.find(j) && !d.equals(j)) {
                        throw new IllegalStateException(j + " deleted");
                    }
                    if (rb.find(d)) {
                        throw new IllegalStateException(d + " not deleted");
                    }
                }
            }
        }
    }
}

{'todelete'}
/**
      Checks that the tree with the given node is a red-black tree, and throws an
      exception if a structural error is found.
      @param n the root of the subtree to check
      @param isRoot true if this is the root of the tree
      @return the black depth of this subtree 
   */
private static int checkRedBlack(RedBlackTree.Node n, boolean isRoot) {
    if (n == null) {
        return 0;
    }
    int nleft = checkRedBlack(n.left, false);
    int nright = checkRedBlack(n.right, false);
    if (nleft != nright) {
        throw new IllegalStateException("Left and right children of " + n.data + " have different black depths");
    }
    if (n.parent == null) {
        if (!isRoot) {
            throw new IllegalStateException(n.data + " is not root and has no parent");
        }
        if (n.color != RedBlackTree.BLACK) {
            throw new IllegalStateException("Root " + n.data + " is not black");
        }
    } else {
        if (isRoot) {
            throw new IllegalStateException(n.data + " is root and has a parent");
        }
        if (n.color == RedBlackTree.RED && n.parent.color == RedBlackTree.RED) {
            throw new IllegalStateException("Parent of red " + n.data + " is red");
        }
    }
    if (n.left != null && n.left.parent != n) {
        throw new IllegalStateException("Left child of " + n.data + " has bad parent link");
    }
    if (n.right != null && n.right.parent != n) {
        throw new IllegalStateException("Right child of " + n.data + " has bad parent link");
    }
    if (n.color != RedBlackTree.RED && n.color != RedBlackTree.BLACK) {
        throw new IllegalStateException(n.data + " has color " + n.color);
    }
    return n.color + nleft;
}

{'isroot'}
/**
      Constructs a permutation generator.
      @param aWord the word to permute
   */
public PermutationGenerator(String aWord) {
    word = aWord;
}

{'aword'}
/**
      Gets all permutations of a given word.
   */
public ArrayList<String> getPermutations() {
    ArrayList<String> permutations = new ArrayList<>();
    // The empty string has a single permutation: itself
    if (word.length() == 0) {
        permutations.add(word);
        return permutations;
    }
    // Loop through all character positions
    for (int i = 0; i < word.length(); i++) {
        // Form a simpler word by removing the ith character
        String shorterWord = word.substring(0, i) + word.substring(i + 1);
        // Generate all permutations of the simpler word
        PermutationGenerator shorterPermutationGenerator = new PermutationGenerator(shorterWord);
        ArrayList<String> shorterWordPermutations = shorterPermutationGenerator.getPermutations();
        // each permutation of the simpler word, 
        for (String s : shorterWordPermutations) {
            permutations.add(word.charAt(i) + s);
        }
    }
    // Return all permutations
    return permutations;
}

{'removed', 'front'}
/**
      Tries to remove an object from the tree. Does nothing
      if the object is not contained in the tree.
      @param obj the object to remove
   */
public void remove(Comparable obj) {
    // Find node to be removed
    Node toBeRemoved = root;
    boolean found = false;
    while (!found && toBeRemoved != null) {
        int d = toBeRemoved.data.compareTo(obj);
        if (d == 0) {
            found = true;
        } else {
            if (d > 0) {
                toBeRemoved = toBeRemoved.left;
            } else {
                toBeRemoved = toBeRemoved.right;
            }
        }
    }
    if (!found) {
        return;
    }
    if (toBeRemoved.left == null || toBeRemoved.right == null) {
        Node newChild;
        if (toBeRemoved.left == null) {
            newChild = toBeRemoved.right;
        } else {
            newChild = toBeRemoved.left;
        }
        fixBeforeRemove(toBeRemoved);
        replaceWith(toBeRemoved, newChild);
        return;
    }
    // Neither subtree is empty
    // Find smallest element of the right subtree
    Node smallest = toBeRemoved.right;
    while (smallest.left != null) {
        smallest = smallest.left;
    }
    // smallest contains smallest child in right subtree
    // Move contents, unlink child
    toBeRemoved.data = smallest.data;
    fixBeforeRemove(smallest);
    replaceWith(smallest, smallest.right);
}

{'use', 'toberemoved'}
/**
         Inserts a new node as a descendant of this node.
         @param newNode the node to insert
      */
public void addNode(Node newNode) {
    int comp = newNode.data.compareTo(data);
    if (comp < 0) {
        if (left == null) {
            left = newNode;
            left.parent = this;
        } else {
            left.addNode(newNode);
        }
    } else if (comp > 0) {
        if (right == null) {
            right = newNode;
            right.parent = this;
        } else {
            right.addNode(newNode);
        }
    }
}

{'newnode'}
/**
      Updates the parent's and replacement node's links when this node is replaced.
      Also updates the root reference if it is replaced.
      @param toBeReplaced the node that is to be replaced
      @param replacement the node that replaces that node
   */
private void replaceWith(Node toBeReplaced, Node replacement) {
    if (toBeReplaced.parent == null) {
        replacement.parent = null;
        root = replacement;
    } else if (toBeReplaced == toBeReplaced.parent.left) {
        toBeReplaced.parent.setLeftChild(replacement);
    } else {
        toBeReplaced.parent.setRightChild(replacement);
    }
}

{'tobereplaced'}
/**
      Restores the tree to a red-black tree after a node has been added.
      @param newNode the node that has been added
   */
private void fixAfterAdd(Node newNode) {
    if (newNode.parent == null) {
        newNode.color = BLACK;
    } else {
        newNode.color = RED;
        if (newNode.parent.color == RED) {
            fixDoubleRed(newNode);
        }
    }
}

{'newnode'}
/** 	
     Fixes the tree so that it is a red-black tree after a node has been removed.
     @param toBeRemoved the node that is to be removed
   */
private void fixBeforeRemove(Node toBeRemoved) {
    if (toBeRemoved.color == RED) {
        return;
    }
    if (// It is not a leaf
    toBeRemoved.left != null || toBeRemoved.right != null) {
        // Color the child black
        if (toBeRemoved.left == null) {
            toBeRemoved.right.color = BLACK;
        } else {
            toBeRemoved.left.color = BLACK;
        }
    } else {
        bubbleUp(toBeRemoved.parent);
    }
}

{'toberemoved'}
/**
      Fixes a "negative red" violation.
      @param negRed the negative red node
   */
private void fixNegativeRed(Node negRed) {
    Node parent = negRed.parent;
    Node child;
    if (parent.left == negRed) {
        Node n1 = negRed.left;
        Node n2 = negRed;
        Node n3 = negRed.right;
        Node n4 = parent;
        Node t1 = n3.left;
        Node t2 = n3.right;
        Node t3 = n4.right;
        n1.color = RED;
        n2.color = BLACK;
        n4.color = BLACK;
        replaceWith(n4, n3);
        n3.setLeftChild(n2);
        n3.setRightChild(n4);
        n2.setLeftChild(n1);
        n2.setRightChild(t1);
        n4.setLeftChild(t2);
        n4.setRightChild(t3);
        child = n1;
    } else // Mirror image
    {
        Node n4 = negRed.right;
        Node n3 = negRed;
        Node n2 = negRed.left;
        Node n1 = parent;
        Node t3 = n2.right;
        Node t2 = n2.left;
        Node t1 = n1.left;
        n4.color = RED;
        n3.color = BLACK;
        n1.color = BLACK;
        replaceWith(n1, n2);
        n2.setRightChild(n3);
        n2.setLeftChild(n1);
        n3.setRightChild(n4);
        n3.setLeftChild(t3);
        n1.setRightChild(t2);
        n1.setLeftChild(t1);
        child = n4;
    }
    if (child.left != null && child.left.color == RED) {
        fixDoubleRed(child.left);
    } else if (child.right != null && child.right.color == RED) {
        fixDoubleRed(child.right);
    }
}

{'negred'}
/**
      Constructs a tree with one node and no children.
      @param rootData the data for the root
   */
public Tree(Object rootData) {
    root = new Node();
    root.data = rootData;
    root.children = new ArrayList<>();
}

{'rootdata'}
/**
      Ensures the heap property for a subtree, provided its
      children already fulfill the heap property.
      @param a the array to sort
      @param rootIndex the index of the subtree to be fixed
      @param lastIndex the last valid index of the tree that 
      contains the subtree to be fixed
   */
private static void fixHeap(int[] a, int rootIndex, int lastIndex) {
    // Remove root
    int rootValue = a[rootIndex];
    // Promote children while they are larger than the root      
    int index = rootIndex;
    boolean more = true;
    while (more) {
        int childIndex = getLeftChildIndex(index);
        if (childIndex <= lastIndex) {
            // Use right child instead if it is larger
            int rightChildIndex = getRightChildIndex(index);
            if (rightChildIndex <= lastIndex && a[rightChildIndex] > a[childIndex]) {
                childIndex = rightChildIndex;
            }
            if (a[childIndex] > rootValue) {
                // Promote child
                a[index] = a[childIndex];
                index = childIndex;
            } else {
                // Root value is larger than both children
                more = false;
            }
        } else {
            // No children
            more = false;
        }
    }
    // Store root value in vacant slot
    a[index] = rootValue;
}

{'lastindex', 'rootindex'}
/**
      Constructs a tree with one node and no children.
      @param rootData the data for the root
   */
public Tree(Object rootData) {
    root = new Node();
    root.data = rootData;
    root.children = new LinkedList<>();
}

{'rootdata'}
public static void main(String[] args) {
    int[] values = new int[10];
    for (int i = 0; i < values.length; i++) {
        values[i] = i * i;
    }
    // In this loop, we don't need the index value. 
    // The enhanced for loop simplifies the code.
    int total = 0;
    for (int element : values) {
        System.out.println(element);
        total = total + element;
    }
    System.out.println("Sum: " + total);
}

{'use'}
public static void main(String[] args) {
    final int LENGTH = 100;
    double[] values = new double[LENGTH];
    int currentSize = 0;
    // Read inputs
    System.out.println("Please enter values, Q to quit:");
    Scanner in = new Scanner(System.in);
    while (in.hasNextDouble() && currentSize < values.length) {
        values[currentSize] = in.nextDouble();
        currentSize++;
    }
    // Find the largest value
    double largest = values[0];
    for (int i = 1; i < currentSize; i++) {
        if (values[i] > largest) {
            largest = values[i];
        }
    }
    for (int i = 0; i < currentSize; i++) {
        System.out.print(values[i]);
        if (values[i] == largest) {
            System.out.print(" <== largest value");
        }
        System.out.println();
    }
}

{'marking'}
public void countInputs() {
    System.out.println("Please enter values, Q to quit:");
    Scanner in = new Scanner(System.in);
    while (in.hasNextInt()) {
        int value = in.nextInt();
        if (1 <= value && value <= counters.length) {
            counters[value]++;
        } else {
            System.out.println(value + " is not a valid input.");
        }
    }
}

{'increment'}
public static void main(String[] args) {
    final int ROWS = 6;
    final int COLUMNS = 7;
    int[][] populations = { { 106, 107, 111, 133, 221, 767, 1766 }, { 502, 635, 809, 947, 1402, 3634, 5268 }, { 2, 2, 2, 6, 13, 30, 46 }, { 163, 203, 276, 408, 547, 729, 628 }, { 2, 7, 26, 82, 172, 307, 392 }, { 16, 24, 38, 74, 167, 511, 809 } };
    String[] continents = { "Africa", "Asia", "Australia", "Europe", "North America", "South America" };
    System.out.println("                Year 1750 1800 1850 1900 1950 2000 2050");
    for (int i = 0; i < ROWS; i++) {
        // Print the ith row
        System.out.printf("%20s", continents[i]);
        for (int j = 0; j < COLUMNS; j++) {
            System.out.printf("%5d", populations[i][j]);
        }
        // Start a new line at the end of the row
        System.out.println();
    }
    // Print column totals
    System.out.print("               World");
    for (int j = 0; j < COLUMNS; j++) {
        int total = 0;
        for (int i = 0; i < ROWS; i++) {
            total = total + populations[i][j];
        }
        System.out.printf("%5d", total);
    }
    System.out.println();
}

{'data'}
public static void main(String[] args) {
    // An array of five values, initialized in a loop
    int[] values = new int[5];
    for (int i = 0; i < values.length; i++) {
        values[i] = 2 * i;
    }
    // An array of four strings, with initial values specified
    String[] names = { "Fred", "Amy", "Cindy", "Henry" };
    for (int i = 0; i < values.length; i++) {
        System.out.print(values[i] + " ");
    }
    System.out.println();
    for (int i = 0; i < names.length; i++) {
        System.out.print(names[i] + " ");
    }
    System.out.println();
    // When you copy an array variable, you get another reference 
    // to the same array. (See Section 7.1.2.)
    int[] copy = values;
    values[0] = 42;
    for (int i = 0; i < copy.length; i++) {
        System.out.print(copy[i] + " ");
    }
    System.out.println();
    // Here, we read numbers into a partially filled array.
    // (See Section 7.1.4.)
    System.out.println("Enter scores, -1 to quit: ");
    Scanner in = new Scanner(System.in);
    boolean done = false;
    int currentSize = 0;
    final int LENGTH = 100;
    int[] scores = new int[LENGTH];
    while (!done && currentSize < LENGTH) {
        int score = in.nextInt();
        if (score == -1) {
            done = true;
        } else {
            scores[currentSize] = score;
            currentSize++;
        }
    }
    System.out.println("You entered the following scores:");
    for (int i = 0; i < currentSize; i++) {
        System.out.print(scores[i] + " ");
    }
    System.out.println();
}

{'change', 'element'}
public static void main(String[] args) {
    SoundClip clip = new SoundClip();
    clip.pick();
    clip.show();
    int[] samples = clip.getSampleValues();
    for (int i = 0; i < samples.length; i++) {
        samples[i] = 3 * samples[i];
    }
    clip.show();
}

{'call', 'need', 'getsamplerate', 'rate', 'example'}
/**
      Removes a score at a given position.
      @param pos the position of the score to remove
   */
public void removeScore(int pos) {
    scores.remove(pos);
/*
        Alternatively, for a more efficient implementation,
        follow Section 7.3.6:
        int lastPosition = scores.size() - 1;
        scores.set(pos, scores.get(lastPosition));
        scores.remove(lastPosition);
      */
}

{'lastposition'}
public static void main(String[] args) {
    ArrayList<Double> values = new ArrayList<Double>();
    // Read inputs
    System.out.println("Please enter values, Q to quit:");
    Scanner in = new Scanner(System.in);
    while (in.hasNextDouble()) {
        values.add(in.nextDouble());
    }
    // Find the largest value
    double largest = values.get(0);
    for (int i = 1; i < values.size(); i++) {
        if (values.get(i) > largest) {
            largest = values.get(i);
        }
    }
    for (double element : values) {
        System.out.print(element);
        if (element == largest) {
            System.out.print(" <== largest value");
        }
        System.out.println();
    }
}

{'marking'}
public static void main(String[] args) {
    final int TRIES = 10000;
    Random generator = new Random();
    int hits = 0;
    for (int i = 1; i <= TRIES; i++) {
        // Generate two random numbers between -1 and 1
        double r = generator.nextDouble();
        double x = -1 + 2 * r;
        r = generator.nextDouble();
        double y = -1 + 2 * r;
        if (x * x + y * y <= 1) {
            hits++;
        }
    }
    /*
         The ratio hits / tries is approximately the same as the ratio 
         circle area / square area = pi / 4
      */
    double piEstimate = 4.0 * hits / TRIES;
    System.out.println("Estimate for pi: " + piEstimate);
}

{'check', 'lie', 'unit', 'whether', 'point'}
public static void main(String[] args) {
    double sum = 0;
    int count = 0;
    double salary = 0;
    System.out.print("Enter salaries, -1 to finish: ");
    Scanner in = new Scanner(System.in);
    while (salary != -1) {
        salary = in.nextDouble();
        if (salary != -1) {
            sum = sum + salary;
            count++;
        }
    }
    if (count > 0) {
        double average = sum / count;
        System.out.println("Average salary: " + average);
    } else {
        System.out.println("No data");
    }
}

{'sentinel', 'process', 'compute', 'entered'}
/**
      Constructs an Investment object from a starting balance and
      interest rate.
      @param aBalance the starting balance
      @param aRate the interest rate in percent
   */
public Investment(double aBalance, double aRate) {
    balance = aBalance;
    rate = aRate;
    year = 0;
}

{'abalance', 'arate'}
/**
      Keeps accumulating interest until a target balance has
      been reached.
      @param targetBalance the desired balance
   */
public void waitForBalance(double targetBalance) {
    while (balance < targetBalance) {
        year++;
        double interest = balance * rate / 100;
        balance = balance + interest;
    }
}

{'targetbalance'}
/**
      Keeps accumulating interest for a given number of years.
      @param numberOfYears the number of years to wait
   */
public void waitYears(int numberOfYears) {
    for (int i = 1; i <= numberOfYears; i++) {
        double interest = balance * rate / 100;
        balance = balance + interest;
    }
    year = year + numberOfYears;
}

{'numberofyears'}
/**
      Gets the color of a pixel.
      @param x the column index (between 0 and getWidth() - 1)
      @param y the row index (between 0 and getHeight() - 1)
      @return the color of the pixel at position (x, y)
   */
public Color getColorAt(int x, int y) {
    Raster raster = image.getRaster();
    ColorModel model = image.getColorModel();
    int argb = model.getRGB(raster.getDataElements(x, y, null));
    return new Color(argb, true);
}

{'getwidth', 'getheight'}
/**
      Sets the color of a pixel.
      @param x the column index (between 0 and getWidth() - 1)
      @param y the row index (between 0 and getHeight() - 1)
      @param c the color for the pixel at position (x, y)
   */
public void setColorAt(int x, int y, Color c) {
    WritableRaster raster = image.getRaster();
    ColorModel model = image.getColorModel();
    Object colorData = model.getDataElements(c.getRGB(), null);
    raster.setDataElements(x, y, colorData);
    label.repaint();
}

{'getwidth', 'getheight'}
/**
      Constructs an Investment object from a starting balance and
      interest rate.
      @param aBalance the starting balance
      @param aRate the interest rate in percent
   */
public Investment(double aBalance, double aRate) {
    balance = aBalance;
    rate = aRate;
    year = 0;
}

{'abalance', 'arate'}
/**
      Keeps accumulating interest until a target balance has
      been reached.
      @param targetBalance the desired balance
   */
public void waitForBalance(double targetBalance) {
    while (balance < targetBalance) {
        year++;
        double interest = balance * rate / 100;
        balance = balance + interest;
    }
}

{'targetbalance'}
public static void main(String[] args) {
    final int NMAX = 4;
    final double XMAX = 10;
    for (int n = 1; n <= NMAX; n++) {
        System.out.printf("%10d", n);
    }
    System.out.println();
    for (int n = 1; n <= NMAX; n++) {
        System.out.printf("%10s", "x ");
    }
    System.out.println();
    for (double x = 1; x <= XMAX; x++) {
        for (int n = 1; n <= NMAX; n++) {
            System.out.printf("%10.0f", Math.pow(x, n));
        }
        System.out.println();
    }
}

{'row', 'table', 'body', 'print', 'header'}
/**
      Constructs a TaxReturn object for a given income and 
      marital status.
      @param anIncome the taxpayer income
      @param aStatus either SINGLE or MARRIED
   */
public TaxReturn(double anIncome, int aStatus) {
    income = anIncome;
    status = aStatus;
}

{'astatus', 'taxreturn', 'anincome'}
/**
         Constructs a listener whose actionPerformed method adds a digit
         to the display.
         @param aDigit the digit to add
      */
public DigitButtonListener(String aDigit) {
    digit = aDigit;
}

{'actionperformed', 'adigit'}
/**
         Constructs a listener whose actionPerformed method adds a digit
         to the display.
         @param aDigit the digit to add
      */
public DigitButtonListener(String aDigit) {
    digit = aDigit;
}

{'actionperformed', 'adigit'}
/**
         Constructs a listener whose actionPerformed method
         schedules an operator for execution.
      */
public OperatorButtonListener(String anOperator) {
    operator = anOperator;
}

{'actionperformed'}
public static void main(String[] args) {
    Rectangle box = new Rectangle(5, 10, 20, 30);
    System.out.print("box: ");
    System.out.println(box);
    // getWidth is an accessor method
    double width = box.getWidth();
    System.out.print("width: ");
    System.out.println(width);
    // Calling an accessor doesn't change the object
    System.out.print("box: ");
    System.out.println(box);
    // translate is a mutator method
    box.translate(15, 25);
    // Calling a mutator changes the object.
    System.out.print("box: ");
    System.out.println(box);
}

{'getwidth'}
/**
      Constructs a day with a given year, month, and day
      of the Julian/Gregorian calendar. The Julian calendar
      is used for all days before October 15, 1582
      @param aYear a year != 0
      @param aMonth a month between 1 and 12
      @param aDate a date between 1 and 31
   */
public Day(int aYear, int aMonth, int aDate) {
    year = aYear;
    month = aMonth;
    date = aDate;
}

{'ayear', 'amonth', 'adate'}
/**
      Scales this picture to a new size. If the new size is smaller 
      than the old size, the remainder is filled with transparent 
      pixels. If it is larger, it is clipped.
      @param newWidth the new width of the picture
      @param newHeight the new height of the picture
   */
public void scale(int newWidth, int newHeight) {
    double dx = newWidth * 1.0 / image.getWidth();
    double dy = newHeight * 1.0 / image.getHeight();
    BufferedImageOp op = new AffineTransformOp(AffineTransform.getScaleInstance(dx, dy), AffineTransformOp.TYPE_BILINEAR);
    BufferedImage filteredImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
    op.filter(image, filteredImage);
    setImage(filteredImage);
}

{'newwidth', 'newheight'}
/**
      Gets the color of a pixel.
      @param x the column index (between 0 and getWidth() - 1)
      @param y the row index (between 0 and getHeight() - 1)
      @return the color of the pixel at position (x, y)
   */
public Color getColorAt(int x, int y) {
    Raster raster = image.getRaster();
    ColorModel model = image.getColorModel();
    int argb = model.getRGB(raster.getDataElements(x, y, null));
    return new Color(argb, true);
}

{'getwidth', 'getheight'}
/**
      Sets the color of a pixel.
      @param x the column index (between 0 and getWidth() - 1)
      @param y the row index (between 0 and getHeight() - 1)
      @param c the color for the pixel at position (x, y)
   */
public void setColorAt(int x, int y, Color c) {
    WritableRaster raster = image.getRaster();
    ColorModel model = image.getColorModel();
    Object colorData = model.getDataElements(c.getRGB(), null);
    raster.setDataElements(x, y, colorData);
    label.repaint();
}

{'getwidth', 'getheight'}
/**
      Constructs a product from a description and a price.
      @param aDescription the product description
      @param aPrice the product price
   */
public Product(String aDescription, double aPrice) {
    description = aDescription;
    price = aPrice;
}

{'adescription', 'aprice'}
/**
      Parses an XML file containing an item list.
      @param fileName the name of the file
      @return an array list containing all items in the XML file
   */
public ArrayList<LineItem> parse(String fileName) throws SAXException, IOException, XPathExpressionException {
    File f = new File(fileName);
    Document doc = builder.parse(f);
    ArrayList<LineItem> items = new ArrayList<>();
    int itemCount = Integer.parseInt(path.evaluate("count(/items/item)", doc));
    for (int i = 1; i <= itemCount; i++) {
        String description = path.evaluate("/items/item[" + i + "]/product/description", doc);
        double price = Double.parseDouble(path.evaluate("/items/item[" + i + "]/product/price", doc));
        Product pr = new Product(description, price);
        int quantity = Integer.parseInt(path.evaluate("/items/item[" + i + "]/quantity", doc));
        LineItem it = new LineItem(pr, quantity);
        items.add(it);
    }
    return items;
}

{'filename'}
/**
      Constructs an item from the product and quantity.
      @param aProduct the product
      @param aQuantity the item quantity
   */
public LineItem(Product aProduct, int aQuantity) {
    theProduct = aProduct;
    quantity = aQuantity;
}

{'aproduct', 'aquantity'}
/**
      Constructs a product from a description and a price.
      @param aDescription the product description
      @param aPrice the product price
   */
public Product(String aDescription, double aPrice) {
    description = aDescription;
    price = aPrice;
}

{'adescription', 'aprice'}
/**
      Constructs an item from the product and quantity.
      @param aProduct the product
      @param aQuantity the item quantity
   */
public LineItem(Product aProduct, int aQuantity) {
    theProduct = aProduct;
    quantity = aQuantity;
}

{'aproduct', 'aquantity'}
/**
      Builds a DOM element for an item.
      @param anItem the item
      @return a DOM element describing the item
   */
private Element createItem(LineItem anItem) {
    Element e = doc.createElement("item");
    e.appendChild(createProduct(anItem.getProduct()));
    e.appendChild(createTextElement("quantity", "" + anItem.getQuantity()));
    return e;
}

{'anitem'}
public static void main(String[] args) throws IOException {
    Stream<String> words = Stream.of("Mary", "had", "a", "little", "lamb");
    show("A stream of individually specified words", words);
    Stream<Integer> digits = Stream.of(3, 1, 4, 1, 5, 9);
    show("A stream of individually specified digits", digits);
    Integer[] digitArray = { 3, 1, 4, 1, 5, 9 };
    digits = Stream.of(digitArray);
    show("A stream of digits from an array", digits);
    List<String> wordList = new ArrayList<>();
    // Populate wordList
    wordList.add("Hello");
    wordList.add("World");
    words = wordList.stream();
    show("A stream of words from a list", words);
    try (Stream<String> lines = Files.lines(Paths.get("../countries.txt"))) {
        show("A stream of lines from a file", lines);
    }
}

{'wordlist'}
public static void main(String[] args) {
    Stream<String> words = Stream.of("Zimbabwe", "Namibia", "Uganda", "Botswana", "Madagascar", "Mozambique", // "Ivory Coast",
    "Swaziland", "Togo");
    Optional<String> optResult = words.filter( w -> w.length() > 10).findFirst();
    // Using orElse
    String first = optResult.orElse("(None)");
    System.out.println("The first country with more than ten characters: " + first);
    // Using ifPresent
    optResult.ifPresent( v -> System.out.println("The first country with more than ten characters: " + v));
    // Using isPresent/get
    if (optResult.isPresent()) {
        System.out.println("The first country with more than ten characters: " + optResult.get());
    } else {
        System.out.println("None of these countries has more than ten characters");
    }
}

{'ifpresent', 'orelse', 'ispresent'}
private static List<String> getList(String line) {
    return Stream.of(getString(line).split(", ")).collect(Collectors.toList());
/* Alternative without streams:
      ArrayList<String> result = new ArrayList<>();
      for (String s : getString(line).split(", "))
      {
         result.add(s);
      }
      return result;
      */
}

{'getstring', 'arraylist'}
public static void main(String[] args) throws IOException {
    List<Movie> movieList = readMovies("movies.txt");
    List<String> result1 = movieList.stream().map( m -> m.getTitle()).filter( t -> t.startsWith("X")).collect(Collectors.toList());
    System.out.println("Movies that start with X: " + result1);
    long count = movieList.stream().map( m -> intersect(m.getDirectors(), m.getActors())).filter( l -> l.size() > 0).count();
    System.out.println("Movies in which directors are actors: " + count);
    count = movieList.stream().filter( m -> commonActorAndDirector(m)).count();
    System.out.println("Movies in which directors are actors: " + count);
    int result2 = movieList.stream().mapToInt( m -> m.getActors().size()).max().orElse(0);
    System.out.println("The most actors in a movie: " + result2);
    movieList.stream().max(( a,  b) -> a.getActors().size() - b.getActors().size()).ifPresent( m -> System.out.println("Movie with most actors: " + m));
    /* Alternative: 
      movieList.stream()
         .max(Comparator.comparing(m -> m.getActors().size()))
	     .ifPresent(m -> System.out.println("Movie with most actors: " + m));
      */
    Map<String, Long> firstLetters = movieList.stream().collect(Collectors.groupingBy( m -> m.getTitle().substring(0, 1), Collectors.counting()));
    System.out.println("Movies by first letter: " + firstLetters);
    System.out.println("Movies starting with The: " + movieList.stream().filter( m -> m.getTitle().startsWith("The ")).count());
    Map<String, List<Movie>> moviesByDirector = movieList.stream().filter( m -> m.getDirectors().size() > 0).collect(Collectors.groupingBy( m -> m.getDirectors().get(0)));
    moviesByDirector.remove("");
    System.out.println("Directors in the database: " + moviesByDirector.size());
    String mostProlificDirector = Collections.max(moviesByDirector.entrySet(), Comparator.comparing( e -> e.getValue().size())).getKey();
    System.out.println(mostProlificDirector + " directed " + moviesByDirector.get(mostProlificDirector).size() + " movies:");
    List<String> titles = moviesByDirector.get(mostProlificDirector).stream().map( m -> m.getTitle()).collect(Collectors.toList());
    System.out.println(titles);
}

{'ifpresent', 'movielist', 'getactors'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
public static void main(String[] args) throws IOException {
    Scanner in = new Scanner(new File("../countries.txt"));
    // This file contains one country name per line
    List<String> wordList = new ArrayList<>();
    while (in.hasNextLine()) {
        wordList.add(in.nextLine());
    }
    // Now wordList is a list of country names
    // Traditional loop for counting the long words
    long count = 0;
    for (String w : wordList) {
        if (w.length() > 10) {
            count++;
        }
    }
    System.out.println("Long words: " + count);
    // The same computation with streams
    count = wordList.stream().filter( w -> w.length() > 10).count();
    System.out.println("Long words: " + count);
}

{'wordlist'}
public static void main(String[] args) throws IOException {
    Scanner in = new Scanner(new File("../words.txt"));
    List<String> wordList = new ArrayList<>();
    while (in.hasNext()) {
        wordList.add(in.next());
    }
    Stream<String> words = wordList.stream();
    String result = words.parallel().filter( w -> w.length() > 10).filter( w -> w.endsWith("y")).findAny().orElse("None found");
    // Note the use of findAny. Run this program several times
    // and check whether the result changes
    System.out.println("A word ending in y: " + result);
    words = wordList.stream();
    Optional<String> result2 = words.max(( v,  w) -> v.length() - w.length());
    System.out.print("The longest word: ");
    result2.ifPresent( w -> System.out.println(w));
    words = wordList.stream();
    boolean result3 = words.allMatch( w -> w.contains("e"));
    System.out.println("All words contain an e: " + result3);
}

{'findany'}
public static void main(String[] args) throws IOException {
    try (Stream<String> lines = Files.lines(Paths.get("../countries.txt"))) {
        // Read the lines
        List<String> result = lines.filter(// Keep only long words
         w -> w.length() > 10).map(// Truncate to seven characters
         w -> w.substring(0, 7)).map(// Add ellipses
         w -> w + "...").distinct().limit(// Keep only the first twenty
        20).collect(// Collect into a list
        Collectors.toList());
        System.out.println(result);
    }
}

{'duplicate', 'remove'}
public RectangleComponent3() {
    // The rectangle that the paintComponent method draws 
    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);
}

{'paintcomponent'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
public static void main(String[] args) {
    // Calling the static average method
    // with an array of BankAccount objects
    Measurable[] accounts = new Measurable[3];
    accounts[0] = new BankAccount(0);
    accounts[1] = new BankAccount(10000);
    accounts[2] = new BankAccount(2000);
    double averageBalance = Measurable.average(accounts);
    System.out.println("Average balance: " + averageBalance);
    System.out.println("Expected: 4000");
    // Calling the static average method
    // with an array of Country objects
    Measurable[] countries = new Measurable[3];
    countries[0] = new Country("Uruguay", 176220);
    countries[1] = new Country("Thailand", 513120);
    countries[2] = new Country("Belgium", 30510);
    double averageArea = Measurable.average(countries);
    System.out.println("Average area: " + averageArea);
    System.out.println("Expected: 239950");
}

{'bankaccount'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
/**
      Computes the measure of an object.
      @param anObject the object to be measured
      @return the measure
   */
double measure(Object anObject);

{'anobject'}
public void addScore(int studentId, double score) {
    // Ignore studentId
    scores.add(score);
}

{'studentid'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
public RectangleComponent2() {
    // The rectangle that the paintComponent method draws 
    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);
}

{'paintcomponent'}
/**
      Processes values from this sequence.
      @param seq the sequence from which to obtain the values
      @param valuesToProcess the number of values to process
   */
public void process(Sequence seq, int valuesToProcess) {
    for (int i = 1; i <= valuesToProcess; i++) {
        int value = seq.next();
        int lastDigit = value % 10;
        counters[lastDigit]++;
    }
}

{'valuestoprocess'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
public static void main(String[] args) {
    // Calling the average method with an array of BankAccount objects
    Measurable[] accounts = new Measurable[3];
    accounts[0] = new BankAccount(0);
    accounts[1] = new BankAccount(10000);
    accounts[2] = new BankAccount(2000);
    double averageBalance = Data.average(accounts);
    System.out.println("Average balance: " + averageBalance);
    System.out.println("Expected: 4000");
    // Calling the average method with an array of Country objects
    Measurable[] countries = new Measurable[3];
    countries[0] = new Country("Uruguay", 176220);
    countries[1] = new Country("Thailand", 513120);
    countries[2] = new Country("Belgium", 30510);
    double averageArea = Data.average(countries);
    System.out.println("Average area: " + averageArea);
    System.out.println("Expected: 239950");
}

{'bankaccount'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
public RectangleComponent3() {
    // The rectangle that the paintComponent method draws 
    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);
}

{'paintcomponent'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Computes the measure of an object.
      @param anObject the object to be measured
      @return the measure
   */
double measure(Object anObject);

{'anobject'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Computes the measure of an object.
      @param anObject the object to be measured
      @return the measure
   */
double measure(Object anObject);

{'anobject'}
public RectangleComponent() {
    // The rectangle that the paintComponent method draws 
    box = new Rectangle(BOX_X, BOX_Y, BOX_WIDTH, BOX_HEIGHT);
}

{'paintcomponent'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
// implementation—filled in later
}

{'initialbalance'}
/**
      Advances the value of this counter by 1.
   */
public void click() {
    int updatedValue = value + 1;
    // updatedValue is a local variable
    value = updatedValue;
// updatedValue is forgotten here
}

{'updatedvalue'}
/**
      Resets the value of this counter to a given value.
   */
public void resetTo(int newValue) // newValue is a parameter variable
// newValue is initialized with the argument of a method call
{
    value = newValue;
// newValue is forgotten here     
}

{'newvalue'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Gets the previous value of this counter.
      @return the previous value
   */
public int getPrevious() {
    return getValue() - 1;
// When you call a method without an object, it is invoked
// on the this reference, i.e this.getValue().
}

{'getvalue'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Tests the methods of the BankAccount class.
      @param args not used
   */
public static void main(String[] args) {
    BankAccount harrysChecking = new BankAccount();
    harrysChecking.deposit(2000);
    harrysChecking.withdraw(500);
    System.out.println(harrysChecking.getBalance());
    System.out.println("Expected: 1500");
}

{'bankaccount'}
/**
      Constructs an evaluator.
      @param anExpression a string containing the expression
      to be evaluated
   */
public Evaluator(String anExpression) {
    tokenizer = new ExpressionTokenizer(anExpression);
}

{'anexpression'}
/**
      Constructs a tokenizer.
      @param anInput the string to tokenize
   */
public ExpressionTokenizer(String anInput) {
    input = anInput;
    start = 0;
    end = 0;
    // Find the first token
    nextToken();
}

{'aninput'}
/**
      Prints all files whose names end in a given extension.
      @param aFile a file or directory
      @param extension a file extension (such as ".java")
   */
public static void find(File aFile, String extension) {
    if (aFile.isDirectory()) {
        for (File child : aFile.listFiles()) {
            find(child, extension);
        }
    } else {
        String fileName = aFile.toString();
        if (fileName.endsWith(extension)) {
            System.out.println(fileName);
        }
    }
}

{'afile'}
/**
      Constructs a file finder for a given directory tree.
      @param startingDirectory the starting directory of the tree
   */
public FileFinder(File startingDirectory) {
    children = startingDirectory.listFiles();
}

{'startingdirectory'}
/**
      Constructs a triangular shape.
      @param aWidth the width (and height) of the triangle
   */
public Triangle(int aWidth) {
    width = aWidth;
}

{'awidth'}
/**
      Gets all permutations of a given word.
      @param word the string to permute
      @return a list of all permutations
   */
public static ArrayList<String> permutations(String word) {
    ArrayList<String> result = new ArrayList<String>();
    // The empty string has a single permutation: itself
    if (word.length() == 0) {
        result.add(word);
        return result;
    } else {
        // Loop through all character positions
        for (int i = 0; i < word.length(); i++) {
            // Form a shorter word by removing the ith character
            String shorter = word.substring(0, i) + word.substring(i + 1);
            // Generate all permutations of the simpler word
            ArrayList<String> shorterPermutations = permutations(shorter);
            // each permutation of the simpler word, 
            for (String s : shorterPermutations) {
                result.add(word.charAt(i) + s);
            }
        }
        // Return all permutations
        return result;
    }
}

{'removed', 'front'}
/**
      Constructs a coin.
      @param aValue the monetary value of the coin
      @param aName the name of the coin
   */
public Coin(double aValue, String aName) {
    value = aValue;
    name = aName;
}

{'aname', 'avalue'}
/**
      Enters the payment received from the customer.
      @param coinCount the number of coins received
      @param coinType the type of coin that was received
   */
public void receivePayment(int coinCount, Coin coinType) {
    payment = payment + coinCount * coinType.getValue();
}

{'cointype', 'coincount'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Transfers money from this account and tries to add it
      @param amount the amount of money to transfer
      @param otherBalance balance to add the amount to
   */
void transfer(double amount, double otherBalance) {
    balance = balance - amount;
    otherBalance = otherBalance + amount;
// Won’t update the argument
}

{'otherbalance'}
/**
      Transfers money from this account to another.
      @param amount the amount of money to transfer
      @param otherAccount account to add the amount to
   */
public void transfer(double amount, BankAccount otherAccount) {
    balance = balance - amount;
    otherAccount.deposit(amount);
}

{'otheraccount'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Setter for cityToAdd property.
      @param city the city to add to the list of cities
   */
public void setCityToAdd(String city) {
    cityToAdd = city;
}

{'citytoadd'}
/**
      Getter for cityToAdd property.
      @return the city to add to the list of cities
   */
public String getCityToAdd() {
    return cityToAdd;
}

{'citytoadd'}
/**
      Setter for the cityToRemove property.
      @param city the city to remove from the list of cities
   */
public void setCityToRemove(String city) {
    cityToRemove = city;
}

{'citytoremove'}
/**
      Getter for the cityToRemove property.
      @return the city to remove from the list of cities
   */
public String getCityToRemove() {
    return cityToRemove;
}

{'citytoremove'}
/**
      Read-only citiesAndTimes property.
      @return a map containing the cities and formatted times
   */
public Map<String, String> getCitiesAndTimes() {
    Date time = new Date();
    Map<String, String> result = new TreeMap<>();
    for (int i = 0; i < cities.size(); i++) {
        String city = cities.get(i);
        String label = city + ": ";
        TimeZone zone = getTimeZone(city);
        if (zone != null) {
            timeFormatter.setTimeZone(zone);
            String timeString = timeFormatter.format(time);
            label = label + timeString;
        } else {
            label = label + "unavailable";
        }
        result.put(label, city);
    }
    return result;
}

{'citiesandtimes'}
/**
      Setter for cityToAdd property.
      @param city the city to add to the list of cities
   */
public void setCityToAdd(String city) {
    cityToAdd = city;
}

{'citytoadd'}
/**
      Getter for cityToAdd property.
      @return the city to add to the list of cities
   */
public String getCityToAdd() {
    return cityToAdd;
}

{'citytoadd'}
/**
      Setter for the cityToRemove property.
      @param city the city to remove from the list of cities
   */
public void setCityToRemove(String city) {
    cityToRemove = city;
}

{'citytoremove'}
/**
      Getter for the cityToRemove property.
      @return the city to remove from the list of cities
   */
public String getCityToRemove() {
    return cityToRemove;
}

{'citytoremove'}
/**
      Read-only citiesAndTimes property.
      @return a map containing the cities and formatted times
   */
public Map<String, String> getCitiesAndTimes() {
    Date time = new Date();
    Map<String, String> result = new TreeMap<>();
    for (int i = 0; i < cities.size(); i++) {
        String city = cities.get(i);
        String label = city + ": ";
        TimeZone zone = getTimeZone(city);
        if (zone != null) {
            timeFormatter.setTimeZone(zone);
            String timeString = timeFormatter.format(time);
            label = label + timeString;
        } else {
            label = label + "unavailable";
        }
        result.put(label, city);
    }
    return result;
}

{'citiesandtimes'}
/**
      Looks up the time zone for a city.
      @param aCity the city for which to find the time zone
      @return the time zone or null if no match is found
   */
private static TimeZone getTimeZone(String aCity) {
    String[] ids = TimeZone.getAvailableIDs();
    for (int i = 0; i < ids.length; i++) {
        if (timeZoneIDmatch(ids[i], aCity)) {
            return TimeZone.getTimeZone(ids[i]);
        }
    }
    return null;
}

{'acity'}
/**
      Checks whether a time zone ID matches a city.
      @param id the time zone ID (e.g. "America/Los_Angeles")
      @param aCity the city to match (e.g. "Los Angeles")
      @return true if the ID and city match
   */
private static boolean timeZoneIDmatch(String id, String aCity) {
    String idCity = id.substring(id.indexOf('/') + 1);
    return idCity.replace('_', ' ').equals(aCity);
}

{'acity'}
/**
      Setter for city property.
      @param aCity the city for which to report the local time
   */
public void setCity(String aCity) {
    city = aCity;
}

{'acity'}
/**
      Looks up the time zone for a city.
      @param aCity the city for which to find the time zone
      @return the time zone or null if no match is found
   */
private static TimeZone getTimeZone(String aCity) {
    String[] ids = TimeZone.getAvailableIDs();
    for (int i = 0; i < ids.length; i++) {
        if (timeZoneIDmatch(ids[i], aCity)) {
            return TimeZone.getTimeZone(ids[i]);
        }
    }
    return null;
}

{'acity'}
/**
      Checks whether a time zone ID matches a city.
      @param id the time zone ID (e.g. "America/Los_Angeles")
      @param aCity the city to match (e.g. "Los Angeles")
      @return true if the ID and city match
   */
private static boolean timeZoneIDmatch(String id, String aCity) {
    String idCity = id.substring(id.indexOf('/') + 1);
    return idCity.replace('_', ' ').equals(aCity);
}

{'acity'}
/**
      Sets the question text.
      @param questionText the text of this question
   */
public void setText(String questionText) {
    text = questionText;
}

{'questiontext'}
/**
      Sets the answer for this question.
      @param correctResponse the answer
   */
public void setAnswer(String correctResponse) {
    answer = correctResponse;
}

{'correctresponse'}
/**
      Constructs an invoice.
      @param anAddress the billing address
   */
public Invoice(Address anAddress) {
    items = new ArrayList<LineItem>();
    billingAddress = anAddress;
}

{'anaddress'}
/**
      Adds a charge for a product to this invoice.
      @param aProduct the product that the customer ordered
      @param quantity the quantity of the product
   */
public void add(Product aProduct, int quantity) {
    LineItem anItem = new LineItem(aProduct, quantity);
    items.add(anItem);
}

{'aproduct'}
/**
      Constructs a product from a description and a price.
      @param aDescription the product description
      @param aPrice the product price
   */
public Product(String aDescription, double aPrice) {
    description = aDescription;
    price = aPrice;
}

{'adescription', 'aprice'}
/**
      Constructs a mailing address. 
      @param aName the recipient name
      @param aStreet the street
      @param aCity the city
      @param aState the two-letter state code
      @param aZip the ZIP postal code
   */
public Address(String aName, String aStreet, String aCity, String aState, String aZip) {
    name = aName;
    street = aStreet;
    city = aCity;
    state = aState;
    zip = aZip;
}

{'aname', 'astate', 'astreet', 'acity', 'azip'}
/**
      Constructs an item from the product and quantity.
      @param aProduct the product
      @param aQuantity the item quantity
   */
public LineItem(Product aProduct, int aQuantity) {
    theProduct = aProduct;
    quantity = aQuantity;
}

{'aproduct', 'aquantity'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Constructs a customer with a given number and PIN.
      @param aNumber the customer number
      @param aPin the personal identification number
   */
public Customer(int aNumber, int aPin) {
    customerNumber = aNumber;
    pin = aPin;
    checkingAccount = new BankAccount();
    savingsAccount = new BankAccount();
}

{'anumber', 'apin'}
/** 
      Tests if this customer matches a customer number 
      and PIN.
      @param aNumber a customer number
      @param aPin a personal identification number
      @return true if the customer number and PIN match
   */
public boolean match(int aNumber, int aPin) {
    return customerNumber == aNumber && pin == aPin;
}

{'anumber', 'apin'}
/** 
      Finds a customer in the bank.
      @param aNumber a customer number
      @param aPin a personal identification number
      @return the matching customer, or null if no customer 
      matches
   */
public Customer findCustomer(int aNumber, int aPin) {
    for (Customer c : customers) {
        if (c.match(aNumber, aPin)) {
            return c;
        }
    }
    return null;
}

{'anumber', 'apin'}
/**
      Constructs an ATM for a given bank.
      @param aBank the bank to which this ATM connects
   */
public ATM(Bank aBank) {
    theBank = aBank;
    reset();
}

{'abank'}
public static void main(String[] args) throws IOException {
    // Get command-line arguments
    String host;
    String resource;
    if (args.length == 2) {
        host = args[0];
        resource = args[1];
    } else {
        System.out.println("Getting / from horstmann.com");
        host = "horstmann.com";
        resource = "/";
    }
    // Open socket
    final int HTTP_PORT = 80;
    try (Socket s = new Socket(host, HTTP_PORT)) {
        // Get streams
        InputStream instream = s.getInputStream();
        OutputStream outstream = s.getOutputStream();
        // Turn streams into scanners and writers
        Scanner in = new Scanner(instream);
        PrintWriter out = new PrintWriter(outstream);
        // Send command
        String command = "GET " + resource + " HTTP/1.1\n" + "Host: " + host + "\n\n";
        out.print(command);
        out.flush();
        while (in.hasNextLine()) {
            String input = in.nextLine();
            System.out.println(input);
        }
    }
// The try-with-resources statement closes the socket
}

{'read', 'response', 'server'}
/**
      Constructs a bank account with a given balance.
      @param initialBalance the initial balance
   */
public BankAccount(double initialBalance) {
    balance = initialBalance;
}

{'initialbalance'}
/**
      Deposits money into a bank account.
      @param accountNumber the account number
      @param amount the amount to deposit
   */
public void deposit(int accountNumber, double amount) {
    BankAccount account = accounts[accountNumber];
    account.deposit(amount);
}

{'accountnumber'}
/**
      Withdraws money from a bank account.
      @param accountNumber the account number
      @param amount the amount to withdraw
   */
public void withdraw(int accountNumber, double amount) {
    BankAccount account = accounts[accountNumber];
    account.withdraw(amount);
}

{'accountnumber'}
/**
      Gets the balance of a bank account.
      @param accountNumber the account number
      @return the account balance
   */
public double getBalance(int accountNumber) {
    BankAccount account = accounts[accountNumber];
    return account.getBalance();
}

{'accountnumber'}
/**
      Constructs a service object that processes commands
      from a socket for a bank.
      @param aSocket the socket
      @param aBank the bank
   */
public BankService(Socket aSocket, Bank aBank) {
    s = aSocket;
    bank = aBank;
}

{'abank', 'asocket'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
/**
      Merges two sorted arrays into an array
      @param first the first sorted array
      @param second the second sorted array
      @param a the array into which to merge first and second
   */
private static void merge(int[] first, int[] second, int[] a) {
    // Next element to consider in the first array
    int iFirst = 0;
    // Next element to consider in the second array
    int iSecond = 0;
    // Next open position in a
    int j = 0;
    // the smaller element into a
    while (iFirst < first.length && iSecond < second.length) {
        if (first[iFirst] < second[iSecond]) {
            a[j] = first[iFirst];
            iFirst++;
        } else {
            a[j] = second[iSecond];
            iSecond++;
        }
        j++;
    }
    // Copy any remaining entries of the first array
    while (iFirst < first.length) {
        a[j] = first[iFirst];
        iFirst++;
        j++;
    }
    // Copy any remaining entries of the second half
    while (iSecond < second.length) {
        a[j] = second[iSecond];
        iSecond++;
        j++;
    }
}

{'isecond', 'ifirst', 'past', 'end', 'move', 'loop', 'neither', 'note', 'long'}
/**
      Constructs a country.
      @param aName the name of the country
      @param anArea the area of the country
   */
public Country(String aName, double anArea) {
    name = aName;
    area = anArea;
}

{'anarea', 'aname'}
/**
      Merges two sorted arrays into an array
      @param first the first sorted array
      @param second the second sorted array
      @param a the array into which to merge first and second
   */
private static void merge(int[] first, int[] second, int[] a) {
    // Next element to consider in the first array
    int iFirst = 0;
    // Next element to consider in the second array
    int iSecond = 0;
    // Next open position in a
    int j = 0;
    // the smaller element into a
    while (iFirst < first.length && iSecond < second.length) {
        if (first[iFirst] < second[iSecond]) {
            a[j] = first[iFirst];
            iFirst++;
        } else {
            a[j] = second[iSecond];
            iSecond++;
        }
        j++;
    }
    // Copy any remaining entries of the first array
    while (iFirst < first.length) {
        a[j] = first[iFirst];
        iFirst++;
        j++;
    }
    // Copy any remaining entries of the second half
    while (iSecond < second.length) {
        a[j] = second[iSecond];
        iSecond++;
        j++;
    }
}

{'isecond', 'ifirst', 'past', 'end', 'move', 'loop', 'neither', 'note', 'long'}
/**
      Initializes the data source.
      @param fileName the name of the property file that 
      contains the database driver, URL, username, and password
   */
public static void init(String fileName) throws IOException, ClassNotFoundException {
    Properties props = new Properties();
    FileInputStream in = new FileInputStream(fileName);
    props.load(in);
    String driver = props.getProperty("jdbc.driver");
    url = props.getProperty("jdbc.url");
    username = props.getProperty("jdbc.username");
    if (username == null) {
        username = "";
    }
    password = props.getProperty("jdbc.password");
    if (password == null) {
        password = "";
    }
    if (driver != null) {
        Class.forName(driver);
    }
}

{'filename'}
/**
      Initializes the data source.
      @param fileName the name of the property file that 
      contains the database driver, URL, username, and password
   */
public static void init(String fileName) throws IOException, ClassNotFoundException {
    Properties props = new Properties();
    FileInputStream in = new FileInputStream(fileName);
    props.load(in);
    String driver = props.getProperty("jdbc.driver");
    url = props.getProperty("jdbc.url");
    username = props.getProperty("jdbc.username");
    if (username == null) {
        username = "";
    }
    password = props.getProperty("jdbc.password");
    if (password == null) {
        password = "";
    }
    if (driver != null) {
        Class.forName(driver);
    }
}

{'filename'}
/**
      Constructs a bank account with a given balance.
      @param anAccountNumber the account number
   */
public BankAccount(int anAccountNumber) {
    accountNumber = anAccountNumber;
}

{'anaccountnumber'}
/**
      Constructs a customer with a given number and PIN.
      @param aCustomerNumber the customer number
      @param checkingAccountNumber the checking account number
      @param savingsAccountNumber the savings account number
   */
public Customer(int aCustomerNumber, int checkingAccountNumber, int savingsAccountNumber) {
    customerNumber = aCustomerNumber;
    checkingAccount = new BankAccount(checkingAccountNumber);
    savingsAccount = new BankAccount(savingsAccountNumber);
}

{'checkingaccountnumber', 'acustomernumber', 'savingsaccountnumber'}
/**
      Finds a customer with a given number and PIN.
      @param customerNumber the customer number
      @param pin the personal identification number
      @return the matching customer, or null if none found
   */
public Customer findCustomer(int customerNumber, int pin) throws SQLException {
    try (Connection conn = SimpleDataSource.getConnection()) {
        Customer c = null;
        PreparedStatement stat = conn.prepareStatement("SELECT * FROM BankCustomer WHERE Customer_Number = ?");
        stat.setInt(1, customerNumber);
        ResultSet result = stat.executeQuery();
        if (result.next() && pin == result.getInt("PIN")) {
            c = new Customer(customerNumber, result.getInt("Checking_Account_Number"), result.getInt("Savings_Account_Number"));
        }
        return c;
    }
}

{'customernumber'}
/**
      Constructs an ATM for a given bank.
      @param aBank the bank to which this ATM connects
   */
public ATM(Bank aBank) {
    theBank = aBank;
    reset();
}

{'abank'}
/**
      Initializes the data source.
      @param fileName the name of the property file that 
      contains the database driver, URL, username, and password
   */
public static void init(String fileName) throws IOException, ClassNotFoundException {
    Properties props = new Properties();
    FileInputStream in = new FileInputStream(fileName);
    props.load(in);
    String driver = props.getProperty("jdbc.driver");
    url = props.getProperty("jdbc.url");
    username = props.getProperty("jdbc.username");
    if (username == null) {
        username = "";
    }
    password = props.getProperty("jdbc.password");
    if (password == null) {
        password = "";
    }
    if (driver != null) {
        Class.forName(driver);
    }
}

{'filename'}
/**
      Initializes the data source.
      @param fileName the name of the property file that 
      contains the database driver, URL, username, and password
   */
public static void init(String fileName) throws IOException, ClassNotFoundException {
    Properties props = new Properties();
    FileInputStream in = new FileInputStream(fileName);
    props.load(in);
    String driver = props.getProperty("jdbc.driver");
    url = props.getProperty("jdbc.url");
    username = props.getProperty("jdbc.username");
    if (username == null) {
        username = "";
    }
    password = props.getProperty("jdbc.password");
    if (password == null) {
        password = "";
    }
    if (driver != null) {
        Class.forName(driver);
    }
}

{'filename'}
/**
      Constructs a withdraw runnable.
      @param anAccount the account from which to withdraw money
      @param anAmount the amount to withdraw in each repetition
      @param aCount the number of repetitions
   */
public WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {
    account = anAccount;
    amount = anAmount;
    count = aCount;
}

{'anamount', 'anaccount', 'acount'}
/**
      Constructs a deposit runnable.
      @param anAccount the account into which to deposit money
      @param anAmount the amount to deposit in each repetition
      @param aCount the number of repetitions
   */
public DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {
    account = anAccount;
    amount = anAmount;
    count = aCount;
}

{'anamount', 'anaccount', 'acount'}
/**
      Constructs a selection sorter.
      @param anArray the array to sort
      @param aComponent the component to be repainted when the animation 
      pauses
   */
public SelectionSorter(int[] anArray, JComponent aComponent) {
    a = anArray;
    sortStateLock = new ReentrantLock();
    component = aComponent;
}

{'anarray', 'acomponent'}
/**
      Constructs a withdraw runnable.
      @param anAccount the account from which to withdraw money
      @param anAmount the amount to withdraw in each repetition
      @param aCount the number of repetitions
   */
public WithdrawRunnable(BankAccount anAccount, double anAmount, int aCount) {
    account = anAccount;
    amount = anAmount;
    count = aCount;
}

{'anamount', 'anaccount', 'acount'}
/**
      Constructs a deposit runnable.
      @param anAccount the account into which to deposit money
      @param anAmount the amount to deposit in each repetition
      @param aCount the number of repetitions
   */
public DepositRunnable(BankAccount anAccount, double anAmount, int aCount) {
    account = anAccount;
    amount = anAmount;
    count = aCount;
}

{'anamount', 'anaccount', 'acount'}
/**
      Constructs the runnable object.
      @param aGreeting the greeting to display
   */
public GreetingRunnable(String aGreeting) {
    greeting = aGreeting;
}

{'agreeting'}
public Car() {
    // Use the public interface to access the instance variable of the superclass
    // same as this.setNumberOfTires(4)
    setNumberOfTires(4);
    licensePlateNumber = "??????";
}

{'setnumberoftires'}
public String toString() {
    return getClass().getName() + "[numberOfTires=" + numberOfTires + "]";
// This is a good way of implementing toString in a superclass--see Special Topic 9.6
}

{'tostring'}
public String toString() {
    return super.toString() + "[licensePlateNumber=" + licensePlateNumber + "]";
// This is a good way of implementing toString in a subclass--see Special Topic 9.6
}

{'tostring'}
public static void process(Vehicle v, String plateNumber) {
    // This example shows the syntax of instanceof and casting
    if (v instanceof Car) {
        // Vehicle has no setLicensePlateNumber method--must cast
        Car c = (Car) v;
        c.setLicensePlateNumber(plateNumber);
    }
    // calls v.toString()
    System.out.println(v);
}

{'tostring', 'setlicenseplatenumber'}
/**
      Sets the question text.
      @param questionText the text of this question
   */
public void setText(String questionText) {
    text = questionText;
}

{'questiontext'}
/**
      Sets the answer for this question.
      @param correctResponse the answer
   */
public void setAnswer(String correctResponse) {
    answer = correctResponse;
}

{'correctresponse'}
/**
      Sets the name of this employee.
      @param employeeName the new name 
   */
public void setName(String employeeName) {
    name = employeeName;
}

{'employeename'}
/**
      Computes the pay for one week of work.
      @param hoursWorked the number of hours worked in the week
      @return the pay for the given number of hours
   */
public double weeklyPay(int hoursWorked) {
    return 0;
}

{'hoursworked'}
/**
      Sets the question text.
      @param questionText the text of this question
   */
public void setText(String questionText) {
    text = questionText;
}

{'questiontext'}
/**
      Sets the answer for this question.
      @param correctResponse the answer
   */
public void setAnswer(String correctResponse) {
    answer = correctResponse;
}

{'correctresponse'}
/**
      Sets the question text.
      @param questionText the text of this question
   */
public void setText(String questionText) {
    text = questionText;
}

{'questiontext'}
/**
      Sets the answer for this question.
      @param correctResponse the answer
   */
public void setAnswer(String correctResponse) {
    answer = correctResponse;
}

{'correctresponse'}
/**
      Throws an IndexOutOfBoundsException if the checked index is out of bounds
      @param n the index to check
   */
private void checkBounds(int n) {
    if (n < 0 || n >= currentSize) {
        throw new IndexOutOfBoundsException();
    }
}

{'indexoutofboundsexception'}
/**
      Adds an element after a given position.
      @param pos the position
      @param newElement the element to add
   */
public boolean add(int pos, Object newElement) {
    growIfNecessary();
    currentSize++;
    checkBounds(pos);
    for (int i = currentSize - 1; i > pos; i--) {
        elements[i] = elements[i - 1];
    }
    elements[pos] = newElement;
    return true;
}

{'newelement'}
/**
      Adds an element after the end of the array list
      @param newElement the element to add
   */
public boolean addLast(Object newElement) {
    growIfNecessary();
    currentSize++;
    elements[currentSize - 1] = newElement;
    return true;
}

{'newelement'}
/**
      Adds an element to the tail of this queue.
      @param newElement the element to add
   */
public void add(Object newElement) {
    growIfNecessary();
    currentSize++;
    elements[tail] = newElement;
    tail = (tail + 1) % elements.length;
}

{'newelement'}
/**
         Returns the last node traversed by this iterator, or
         throws an IllegalStateException if there wasn't an immediately
         preceding call to next or previous.
         @return the last traversed node
      */
private Node lastPosition() {
    if (isAfterNext) {
        return position;
    } else if (isAfterPrevious) {
        if (position == null) {
            return first;
        } else {
            return position.next;
        }
    } else {
        throw new IllegalStateException();
    }
}

{'illegalstateexception'}
/**
      Constructs a hash table.
      @param bucketsLength the length of the buckets array
   */
public HashSet(int bucketsLength) {
    buckets = new Node[bucketsLength];
    currentSize = 0;
}

{'bucketslength'}
public static void main(String[] args) throws IOException {
    System.out.println("NetLogSimple: Starting...");
    // Get the connection to the NetLog
    NetLog nl = new NetLog();
    // Show sending a String
    nl.log("Hello Java");
    // Show sending Objects
    nl.log(new java.util.Date());
    nl.log(nl);
    // Show sending null and "" (normally an accident...)
    nl.log(null);
    nl.log("");
    // All done, close the log
    nl.close();
    System.out.println("NetLogSimple: Done...");
}

{'netlog'}
public static void main(String[] args) {
    Logger myLogger = Logger.getLogger("com.darwinsys");
    // PropertyConfigurator.configure("log4j.properties");
    Object o = new Object();
    myLogger.info("I created an object: " + o);
}

{'propertyconfigurator'}
public static void main(String[] args) {
    System.setProperty("java.util.logging.config.file", "logging/logging.properties");
    Logger logger = Logger.getLogger("com.darwinsys");
    try {
        Object o = new Object();
        logger.info("I created an object: " + o);
        if (o != null) {
            // bogus, just to show logging
            throw new IllegalArgumentException("Just testing");
        }
    } catch (Exception t) {
        logger.log(Level.SEVERE, "Caught Exception", t);
    }
}

{'form', 'alternate', 'control', 'msg', 'call', 'setthrown', 'DIGIT', 'logrecord', 'long'}
/** Constructor */
public NetLogServer(int port, int numThreads) {
    ServerSocket servSock;
    try {
        servSock = new ServerSocket(PORT);
    } catch (IOException e) {
        System.err.println("Could not create ServerSocket " + e);
        System.exit(1);
        return;
    }
    // Build the GUI - must be before Handler constructors!
    theFrame = new JFrame("NetLog Server");
    theTextArea = new JTextArea(24, 80);
    theTextArea.setEditable(false);
    theTextArea.setBorder(BorderFactory.createTitledBorder("NetLogServer"));
    theFrame.getContentPane().add(new JScrollPane(theTextArea));
    // Now start the Threads
    for (int i = 0; i < numThreads; i++) {
        new Handler(servSock, i).start();
    }
    theFrame.pack();
    theFrame.setVisible(true);
    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}

{'fails', 'notreached', 'crash', 'happened', 'something', 'bad'}
public void run() {
    /* Wait for a connection */
    while (true) {
        try {
            // log(tid, getName() + " waiting");
            Socket clientSocket = servSock.accept();
            log(tid, getName() + " START, IP=" + clientSocket.getInetAddress());
            BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            String line;
            while ((line = is.readLine()) != null) {
                // System.out.println(">> " + line);
                log(tid, line);
            }
            log(tid, getName() + " ENDED ");
            clientSocket.close();
        } catch (IOException ex) {
            log(tid, getName() + ": IO Error on socket " + ex);
            return;
        }
    }
}

{'getname'}
/** Construct a TTFontDemo -- Create a Font from TTF.
     */
public TTFontDemo(String fontFileName, String text) throws IOException, FontFormatException {
    super(text, JLabel.CENTER);
    setBackground(Color.white);
    // First, see if we can load the font file.
    InputStream is = this.getClass().getResourceAsStream(fontFileName);
    if (is == null) {
        throw new IOException("Cannot open " + fontFileName);
    }
    // createFont makes a 1-point font, bit hard to read :-)
    Font ttfBase = Font.createFont(Font.TRUETYPE_FONT, is);
    // So scale it to 24 pt.
    Font ttfReal = ttfBase.deriveFont(Font.PLAIN, 24);
    setFont(ttfReal);
}

{'ttfontdemo', 'createfont'}
/** Simple main program for TTFontDemo */
public static void main(String[] args) throws Exception {
    String DEFAULT_MESSAGE = "What hath man wrought? Or at least rendered?";
    // Loaded as Resource so don't need graphics/ in front
    String DEFAULT_FONTFILE = "Kellyag_.ttf";
    String message = args.length == 1 ? args[0] : DEFAULT_MESSAGE;
    JFrame f = new JFrame("TrueType Font Demo");
    TTFontDemo ttfd = new TTFontDemo(DEFAULT_FONTFILE, message);
    f.getContentPane().add(ttfd);
    f.setBounds(100, 100, 700, 250);
    f.setVisible(true);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
}

{'ttfontdemo'}
/** "main program" method - construct and show */
public static void main(String[] av) {
    // create a TexturedText object, tell it to show up
    final Frame f = new Frame("TexturedText");
    TexturedText comp = new TexturedText();
    f.add(comp);
    f.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            f.setVisible(false);
            f.dispose();
            System.exit(0);
        }
    });
    f.pack();
    f.setLocation(200, 200);
    f.setVisible(true);
}

{'texturedtext'}
/** Construct the player object and the GUI. */
public JMFPlayer(JFrame pf, String media) {
    parentFrame = pf;
    mediaName = media;
    // cp = getContentPane();
    cp = this;
    cp.setLayout(new BorderLayout());
    try {
        theURL = new URL(getClass().getResource("."), mediaName);
        thePlayer = Manager.createPlayer(theURL);
        thePlayer.addControllerListener(this);
    } catch (MalformedURLException e) {
        System.err.println("JMF URL creation error: " + e);
    } catch (Exception e) {
        System.err.println("JMF Player creation error: " + e);
        return;
    }
    System.out.println("theURL = " + theURL);
    // Start the player: this will notify our ControllerListener.
    // start playing
    thePlayer.start();
}

{'controllerlistener', 'getcontentpane'}
/** Called by JMF when the Player has something to tell us about. */
public synchronized void controllerUpdate(ControllerEvent event) {
    // System.out.println("controllerUpdate(" + event + ")");
    if (event instanceof RealizeCompleteEvent) {
        if ((visualComponent = thePlayer.getVisualComponent()) != null)
            cp.add(BorderLayout.CENTER, visualComponent);
        if ((controlComponent = thePlayer.getControlPanelComponent()) != null)
            cp.add(BorderLayout.SOUTH, controlComponent);
        // resize the main window
        if (parentFrame != null) {
            parentFrame.pack();
            parentFrame.setTitle(mediaName);
        }
    }
}

{'controllerupdate'}
/** Set the list from an existing List, as from GraphReader.read() */
public void setListData(List<Point2D> newData) {
    data = newData;
    figure();
}

{'graphreader'}
/** Called by the window system to draw the text. */
@Override
public void paintComponent(Graphics g) {
    // Get the current Font, and ask it for its FontMetrics.
    FontMetrics fm = getFontMetrics(getFont());
    // Use the FontMetrics to get the width of the String.
    // Subtract this from width, divide by 2, that's our starting point.
    int textX = (getSize().width - fm.stringWidth(message)) / 2;
    if (// If string too long, start at 0
    textX < 0)
        textX = 0;
    // Same as above but for the height
    int textY = (getSize().height - fm.getAscent()) / 2 - fm.getDescent();
    if (textY < 0)
        textY = getSize().height - fm.getDescent() - 1;
    // Now draw the text at the computed spot.
    g.drawString(message, textX, textY);
}

{'fontmetrics'}
public void loadImage() {
    // Portable version: getClass().getResource() works in either
    // applet or application, 1.1 or 1.3, returns URL for file name.
    URL url = getClass().getResource("Duke.gif");
    image = getToolkit().getImage(url);
// Or just:
// image = getToolkit().getImage(getClass().getResource("Duke.gif"));
}

{'getimage', 'getresource', 'gettoolkit', 'getclass'}
/**
     * Set up the GUI
     * limit ourselves to the ubiquitous IllegalArgumentException.
     */
public DropShadow() {
    this("DropShadow");
}

{'illegalargumentexception'}
/**
     * Component subclasses can override paint(), but
     * JComponent subclasses should normally use paintComponent()
     * instead, to avoid clobbering border painting and the like.
     */
@Override
public void paint(Graphics g) {
    g.setColor(Color.red);
    g.fillRect(rectX, rectY, rectWidth, rectHeight);
}

{'paintcomponent', 'jcomponent'}
/** Iterate over all the Shapes, getting their areas;
     * this cannot use the Java 8 Collection.forEach because the
     * variable total would have to be final, which would defeat the purpose :-) 
     */
public double totalAreas() {
    double total = 0.0;
    for (Shape s : allShapes) {
        total += s.computeArea();
    }
    return total;
}

{'foreach'}
/** Scenario: goodNight() is called from a timer Thread at 2200, or when
     * we get the "shutdown" command from the security guard.
     */
public void goodNight() {
    for (int i = 0; i < things.length; i++) if (things[i] instanceof PowerSwitchable)
        ((PowerSwitchable) things[i]).powerDown();
}

{'goodnight'}
public static void main(String[] args) throws Exception {
    // Create an Object with a finalize() method - Bad idea!
    Object f = new Object() {

        public void finalize() throws Throwable {
            System.out.println("Running finalize()");
            super.finalize();
        }
    };
    // Add a shutdownHook to the JVM
    Runtime.getRuntime().addShutdownHook(new Thread() {

        public void run() {
            System.out.println("Running Shutdown Hook");
        }
    });
    if (args.length == 1 && args[0].equals("-f")) {
        f = null;
        System.gc();
    }
    System.out.println("Calling System.exit(), with f = " + f);
    System.exit(0);
}

{'argument', 'unless', 'holding', 'command', 'program', 'call', 'reference', 'user', 'therefore', 'free', 'shutdownhook', 'put', 'specific', 'finalized', 'line'}
/** Keep the screen updated forever, unless stop()ped. */
public void run() {
    String thePort = props.getProperty("rmiwatch.port", "");
    String theURL = "rmi://" + hostName + ":" + thePort;
    while (!done) {
        try {
            String[] names = Naming.list(theURL);
            ta.setText("");
            for (int i = 0; i < names.length; i++) {
                ta.append(i + ": " + names[i] + "\n");
            }
            // If we didnt get an exception, host is up.
            String expect = props.getProperty("rmiwatch.expect");
            String fullText = ta.getText();
            if (fullText.length() == 0) {
                ta.setText("(nothing registered!)");
                setState(EMPTY);
            } else if (expect != null && fullText.indexOf(expect) == -1) {
                setState(DUBIOUS);
            } else
                setState(FINE);
        } catch (java.rmi.ConnectIOException e) {
            setState(DOWN);
            ta.setText("Net error: " + e.detail.getClass());
        } catch (java.rmi.ConnectException e) {
            setState(NOREG);
            ta.setText("RMI error: " + e.getClass().getName() + "\n" + "  " + e.detail.getClass());
        } catch (RemoteException e) {
            setState(NOREG);
            ta.setText("RMI error: " + e.getClass().getName() + "\n" + "  " + e.detail.getClass());
        } catch (MalformedURLException e) {
            setState(DOWN);
            ta.setText("Invalid host: " + e.toString());
        } finally {
            // Randomize time so we dont make net load bursty.
            try {
                Thread.sleep((int) (sleepTime * MSEC * 2 * Math.random()));
            } catch (InterruptedException e) {
            }
        }
    }
}

{'hostname', 'common', 'err', 'bypass', 'println', 'system', 'canthappen'}
public NetPanel(String host, Properties p) {
    hostName = host;
    props = p;
    String s = props.getProperty("rmiwatch.sleep");
    if (s != null)
        sleepTime = Integer.parseInt(s);
    // Maybe get font name and size from props?
    if (cwFont == null)
        cwFont = new Font("lucidasansTypewriter", Font.PLAIN, 10);
    // Gooey gooey stuff.
    ta = new JTextArea(2, 26);
    ta.setEditable(false);
    ta.setFont(cwFont);
    add(BorderLayout.CENTER, ta);
    setBorder(BorderFactory.createTitledBorder(hostName));
    // Sparks. Ignition!
    new Thread(this).start();
}

{'system', 'sleeptime', 'println'}
/** Record the new state of the current machine.
     * If this machine has changed state, set its color
     * @param newState - one of the five valid states in the introduction.
     */
protected void setState(int newState) {
    if (state == /*already*/
    newState)
        // nothing to do.
        return;
    switch(newState) {
        case // Server has "expect"ed name registered.
        FINE:
            ta.setBackground(COLOR_FINE);
            ta.setForeground(Color.black);
            break;
        case // Server does not have expected name registered.
        DUBIOUS:
            ta.setBackground(COLOR_DUBIOUS);
            ta.setForeground(Color.black);
            break;
        case // Server has nothing registered.
        EMPTY:
            ta.setBackground(COLOR_EMPTY);
            ta.setForeground(Color.black);
            break;
        case // host is up but not running RMI
        NOREG:
            ta.setBackground(COLOR_NOREG);
            ta.setForeground(Color.white);
            break;
        case // host unreachable, not responding, ECONN, etc.
        DOWN:
            ta.setBackground(COLOR_DOWN);
            ta.setForeground(Color.white);
            break;
        default:
            throw new IllegalStateException("setState(" + state + ") invalid");
    }
    state = newState;
}

{'newstate'}
public static void main(String[] argv) {
    Properties p = null;
    NetFrame f = new NetFrame("Network Watcher", p);
    try {
        FileInputStream is = new FileInputStream("NetWatch.properties");
        p = new Properties();
        p.load(is);
        is.close();
    } catch (IOException e) {
        JOptionPane.showMessageDialog(f, e.toString(), "Properties error", JOptionPane.ERROR_MESSAGE);
    }
    // If arguments, use them as hostnames.
    if (argv.length != 0) {
        for (int i = 0; i < argv.length; i++) {
            f.addHost(argv[i], p);
        }
    // No arguments. Can we use properties?
    } else if (p != null && p.size() > 0) {
        String net = p.getProperty("netwatch.net");
        int start = Integer.parseInt(p.getProperty("netwatch.start"));
        int end = Integer.parseInt(p.getProperty("netwatch.end"));
        for (int i = start; i <= end; i++) {
            f.addHost(net + "." + i, p);
        }
        for (int i = 0; ; i++) {
            String nextHost = p.getProperty("nethost" + i);
            if (nextHost == null)
                break;
            f.addHost(nextHost, p);
        }
    } else // None of the above. Fall back to localhost
    {
        f.addHost("localhost", p);
    }
    // All done. Pack the Frame and show it.
    f.pack();
    // UtilGUI.centre(f);
    f.setVisible(true);
    f.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
}

{'construct', 'utilgui', 'panel'}
/** print one file, given an open BufferedReader */
public void process(BufferedReader is) {
    try {
        String inputLine;
        // BEGIN main
        while ((inputLine = is.readLine()) != null) {
            int toRemove = 0;
            for (int i = 0; i < nSpaces && i < inputLine.length() && Character.isWhitespace(inputLine.charAt(i)); i++) ++toRemove;
            System.out.println(inputLine.substring(toRemove));
        }
        // END main
        is.close();
    } catch (IOException e) {
        System.out.println("IOException: " + e);
    }
}

{'bufferedreader'}
/** CheckSum one text file, given an open BufferedReader.
     * Checksumm does not include line endings, so will give the
     * same value for given text on any platform. Do not use
     * on binary files!
     */
public static int process(BufferedReader is) {
    int sum = 0;
    try {
        String inputLine;
        while ((inputLine = is.readLine()) != null) {
            int i;
            for (i = 0; i < inputLine.length(); i++) {
                sum += inputLine.charAt(i);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("IOException: " + e);
    }
    return sum;
}

{'checksum', 'bufferedreader'}
/** print one file, given an open BufferedReader */
public void process(BufferedReader is) {
    try {
        String inputLine;
        // BEGIN main
        while ((inputLine = is.readLine()) != null) {
            for (int i = 0; i < nSpaces; i++) System.out.print(' ');
            System.out.println(inputLine);
        }
        // END main
        is.close();
    } catch (IOException e) {
        System.out.println("IOException: " + e);
    }
}

{'bufferedreader'}
/**
     * entab: process one file, replacing blanks with tabs.
     * 
     * @param is A BufferedReader opened to the file to be read.
     * @param out a PrintWriter to send the output to.
     */
public void entab(BufferedReader is, PrintWriter out) throws IOException {
    String line;
    // main loop: process entire file one line at a time.
    while ((line = is.readLine()) != null) {
        out.println(entabLine(line));
    }
}

{'printwriter', 'bufferedreader'}
/**
     * entab: process one file, replacing blanks with tabs.
     * 
     * @param is A BufferedReader opened to the file to be read.
     * @param out A PrintStream to write the output to.
     */
public void entab(BufferedReader is, PrintStream out) throws IOException {
    entab(is, new PrintWriter(out));
}

{'printstream', 'bufferedreader'}
/**
     * entabLine: process one line, replacing blanks with tabs.
     * 
     * @param line -
     *            the string to be processed
     */
public String entabLine(String line) {
    int N = line.length(), outCol = 0;
    StringBuffer sb = new StringBuffer();
    char ch;
    int consumedSpaces = 0;
    for (int inCol = 0; inCol < N; inCol++) {
        ch = line.charAt(inCol);
        // If this takes us to a tab stop, output a tab character.
        if (ch == ' ') {
            Debug.println("space", "Got space at " + inCol);
            if (!tabs.isTabStop(inCol)) {
                consumedSpaces++;
            } else {
                Debug.println("tab", "Got a Tab Stop " + inCol);
                sb.append('\t');
                outCol += consumedSpaces;
                consumedSpaces = 0;
            }
            continue;
        }
        // them above.
        while (inCol - 1 > outCol) {
            Debug.println("pad", "Padding space at " + inCol);
            sb.append(' ');
            outCol++;
        }
        // Now we have a plain character to output.
        sb.append(ch);
        outCol++;
    }
    // If line ended with trailing (or only!) spaces, preserve them.
    for (int i = 0; i < consumedSpaces; i++) {
        Debug.println("trail", "Padding space at end # " + i);
        sb.append(' ');
    }
    return sb.toString();
}

{'non', 'back', 'past', 'since', 'entabline', 'consume', 'get', 'need', 'put', 'leftover'}
/** Processes one String, returns it as an array of Strings */
public static String[] process(String line) {
    String[] results = new String[MAXFIELDS];
    // Unless you ask StringTokenizer to give you the tokens,
    // it silently discards multiple null tokens.
    StringTokenizer st = new StringTokenizer(line, DELIM, true);
    int i = 0;
    // stuff each token into the current slot in the array.
    while (st.hasMoreTokens()) {
        String s = st.nextToken();
        if (s.equals(DELIM)) {
            if (i++ >= MAXFIELDS)
                // a List to allow any number of fields.
                throw new IllegalArgumentException("Input line " + line + " has too many fields");
            continue;
        }
        results[i] = s;
    }
    return results;
}

{'us', 'messy', 'stringtokenizer', 'strtokdemoDb', 'see'}
public static void main(String[] args) {
    // BEGIN main
    // Method using regexp split 
    StringBuilder sb1 = new StringBuilder();
    for (String word : SAMPLE_STRING.split(" ")) {
        if (sb1.length() > 0) {
            sb1.append(", ");
        }
        sb1.append(word);
    }
    System.out.println(sb1);
    // Method using a StringTokenizer
    StringTokenizer st = new StringTokenizer(SAMPLE_STRING);
    StringBuilder sb2 = new StringBuilder();
    while (st.hasMoreElements()) {
        sb2.append(st.nextToken());
        if (st.hasMoreElements()) {
            sb2.append(", ");
        }
    }
    System.out.println(sb2);
// END main
}

{'stringtokenizer'}
public static void main(String[] argv) {
    // BEGIN main
    // UnicodeChars.java
    StringBuffer b = new StringBuffer();
    for (char c = 'a'; c < 'd'; c++) {
        b.append(c);
    }
    // Japanese Yen symbol
    b.append('¥');
    // Roman AE with acute accent
    b.append('Ǽ');
    // GREEK Capital Alpha
    b.append('Α');
    // GREEK Capital Omega
    b.append('Ω');
    for (int i = 0; i < b.length(); i++) {
        System.out.printf("Character #%d (%04x) is %c%n", i, (int) b.charAt(i), b.charAt(i));
    }
    System.out.println("Accumulated characters are " + b);
// END main
}

{'unicodechars'}
/** Construct a StringAlign formatter; length and alignment are
     * passed to the Constructor instead of each format() call as the
     * expected common use is in repetitive formatting e.g., page numbers.
     * @param maxChars - the maximum length of the output
     * @param just - one of the enum values LEFT, CENTER or RIGHT
     */
public StringAlign(int maxChars, Justify just) {
    switch(just) {
        case LEFT:
        case CENTER:
        case RIGHT:
            this.just = just;
            break;
        default:
            throw new IllegalArgumentException("invalid justification arg.");
    }
    if (maxChars < 0) {
        throw new IllegalArgumentException("maxChars must be positive.");
    }
    this.maxChars = maxChars;
}

{'stringalign', 'maxchars'}
/** Format a String.
     * @param input - the string to be aligned.
     * @parm where - the StringBuffer to append it to.
     * @param ignore - a FieldPosition (may be null, not used but
     * specified by the general contract of Format).
     */
public StringBuffer format(Object input, StringBuffer where, FieldPosition ignore) {
    String s = input.toString();
    String wanted = s.substring(0, Math.min(s.length(), maxChars));
    // Get the spaces in the right place.
    switch(just) {
        case RIGHT:
            pad(where, maxChars - wanted.length());
            where.append(wanted);
            break;
        case CENTER:
            int toAdd = maxChars - wanted.length();
            pad(where, toAdd / 2);
            where.append(wanted);
            pad(where, toAdd - toAdd / 2);
            break;
        case LEFT:
            where.append(wanted);
            pad(where, maxChars - wanted.length());
            break;
    }
    return where;
}

{'fieldposition', 'stringbuffer'}
/** ParseObject is required, but not useful here. */
public Object parseObject(String source, ParsePosition pos) {
    return source;
}

{'parseobject'}
/** Convert the given String to its Soundex code.
     * @return null If the given string can't be mapped to Soundex.
     */
public static String soundex(String s) {
    // Algorithm works on uppercase (mainframe era).
    String t = s.toUpperCase();
    StringBuffer res = new StringBuffer();
    char c, prev = '?', prevOutput = '?';
    // Main loop: find up to 4 chars that map.
    for (int i = 0; i < t.length() && res.length() < 4 && (c = t.charAt(i)) != ','; i++) {
        // Also, skip double letters.
        if (c >= 'A' && c <= 'Z' && c != prev) {
            prev = c;
            // First char is installed unchanged, for sorting.
            if (i == 0) {
                res.append(c);
            } else {
                char m = MAP[c - 'A'];
                if (debug) {
                    System.out.println(c + " --> " + m);
                }
                if (m != '0' && m != prevOutput) {
                    res.append(m);
                    prevOutput = m;
                }
            }
        }
    }
    if (res.length() == 0)
        return null;
    for (int i = res.length(); i < 4; i++) res.append('0');
    return res.toString();
}

{'converted', 'alphabetic', 'text', 'use', 'isletter', 'handle', 'already', 'see', 'character', 'check', 'ascii'}
public static void main(String[] argv) {
    String s1 = "Hello" + ", " + "World";
    System.out.println(s1);
    // Build a StringBuilder, and append some things to it.
    StringBuilder sb2 = new StringBuilder();
    sb2.append("Hello");
    sb2.append(',');
    sb2.append(' ');
    sb2.append("World");
    // Get the StringBuilder's value as a String, and print it.
    String s2 = sb2.toString();
    System.out.println(s2);
    // Now do the above all over again, but in a more 
    // concise (and typical "real-world" Java) fashion.
    System.out.println(new StringBuilder().append("Hello").append(',').append(' ').append("World"));
}

{'stringbuilder'}
/** Format the File contained in a constructed Fmt object */
public void format() throws IOException {
    String line;
    StringBuilder outBuf = new StringBuilder();
    while ((line = in.readLine()) != null) {
        if (line.length() == 0) {
            // null line
            // end current line
            out.println(outBuf);
            // output blank line
            out.println();
            outBuf.setLength(0);
        } else {
            // otherwise it's text, so format it.
            StringTokenizer st = new StringTokenizer(line);
            while (st.hasMoreTokens()) {
                String word = st.nextToken();
                // first dump out anything previous.
                if (outBuf.length() + word.length() > COLWIDTH) {
                    out.println(outBuf);
                    outBuf.setLength(0);
                }
                outBuf.append(word).append(' ');
            }
        }
    }
    if (outBuf.length() > 0) {
        out.println(outBuf);
    } else {
        out.println();
    }
}

{'margin', 'past', 'go', 'would'}
/**
     * @return Returns the tabSpace.
     */
public int getTabSpacing() {
    return tabSpace;
}

{'tabspace'}
/** isTabStop - returns true if given column is a tab stop.
     * @param col - the current column number
     */
public boolean isTabStop(int col) {
    if (col <= 0)
        return false;
    return (col + 1) % tabSpace == 0;
}

{'istabstop'}
/** The demo itself */
public void demo() {
    // BEGIN main
    // Find the ClassLoader that loaded us.
    // Regard it as the One True ClassLoader for this app.
    ClassLoader loader = this.getClass().getClassLoader();
    // Use the loader's getResource() method to open the file.
    InputStream is = loader.getResourceAsStream("widgets.properties");
    if (is == null) {
        System.err.println("Can't load properties file");
        return;
    }
    // Create a Properties object
    Properties p = new Properties();
    // Load the properties file into the Properties object
    try {
        p.load(is);
    } catch (IOException ex) {
        System.err.println("Load failed: " + ex);
        return;
    }
    // List it to confirm that we loaded it.
    p.list(System.out);
// END main
}

{'getresource', 'classloader'}
/** Decide whether a given Appointment matches the given y/m/d.
     */
public boolean matches(int y, int m, int d) {
    // Do the simple case first!
    if (year == y && month == m && day == d)
        return true;
    // If NOT today AND no repetition, not interesting.
    if (r_count == NONE)
        return false;
    // Else potentially interesting!
    // System.out.println("ME:"+year+","+month+","+day);
    // System.out.println("YE:"+y   +","+m    +","+d  );
    // using our GregorianCalendar for calculations from here on... 
    gc.set(Calendar.YEAR, year);
    gc.set(Calendar.MONTH, month - 1);
    gc.set(Calendar.DAY_OF_MONTH, day);
    gc.set(Calendar.HOUR, hour);
    gc.set(Calendar.MINUTE, minute);
    System.out.println(gc.getTime().toString());
    for (int i = 0; i < r_count && gc.get(Calendar.YEAR) <= year && gc.get(Calendar.MONTH) <= month && gc.get(Calendar.DAY_OF_MONTH) <= day; i++) {
        switch(r_type) {
            case HOURLY:
                break;
            case DAILY:
                gc.add(Calendar.DAY_OF_MONTH, r_interval);
                break;
            case WEEKLY:
                break;
            case MONTHLY_NUMDAY_OF_M:
                break;
            case MONTHLY_WEEKDAY_OF_M:
                break;
            case YEARLY:
                break;
        }
        // matches the date we're looking for.
        if (gc.get(Calendar.YEAR) == y && gc.get(Calendar.MONTH) == m && gc.get(Calendar.DAY_OF_MONTH) == d)
            return true;
    }
    // We got out of the loop without finding a match, so...
    return false;
}

{'ok', 'gregoriancalendar', 'increment', 'see'}
/** compareTo method, from Comparable interface.
     * Compare this Appointment against another, for purposes of sorting.
     * <P>Only text, and date and time participate, not repetition!
     * (Repetition has to do with recurring events, e.g., 
     *  "Meeting every Tuesday at 9").
     * This methods is consistent with equals().
     * @return -1 if this<a2, +1 if this>a2, else 0.
     */
@Override
public int compareTo(Appt a2) {
    if (year < a2.year)
        return -1;
    if (year > a2.year)
        return +1;
    if (month < a2.month)
        return -1;
    if (month > a2.month)
        return +1;
    if (day < a2.day)
        return -1;
    if (day > a2.day)
        return +1;
    if (hour < a2.hour)
        return -1;
    if (hour > a2.hour)
        return +1;
    if (minute < a2.minute)
        return -1;
    if (minute > a2.minute)
        return +1;
    return text.compareTo(a2.text);
}

{'compareto'}
/** Compare this appointment against another, for equality.
     * Consistent with compareTo(). For this reason, only
     * text, date & time participate, not repetition.
     * @returns true if the objects are equal, false if not.
     */
@Override
public boolean equals(Object o2) {
    Appt a2 = (Appt) o2;
    if (year != a2.year || month != a2.month || day != a2.day || hour != a2.hour || minute != a2.minute)
        return false;
    return text.equals(a2.text);
}

{'compareto'}
/** Factory: build a String representation into an Appt.
     * Cast as a static factory for minor efficiency gains - reconsider.
     */
public static Appt fromString(String s) {
    StringTokenizer st = new StringTokenizer(s);
    if (st.countTokens() < 6)
        throw new IllegalArgumentException("Too few fields in " + s);
    int y = Integer.parseInt(st.nextToken());
    int m = Integer.parseInt(st.nextToken());
    int d = Integer.parseInt(st.nextToken());
    int h = Integer.parseInt(st.nextToken());
    int i = Integer.parseInt(st.nextToken());
    StringBuffer sb = new StringBuffer();
    while (st.hasMoreElements()) {
        sb.append(st.nextToken());
        if (st.hasMoreElements())
            sb.append(' ');
    }
    return new Appt(sb.toString(), y, m, d, h, i);
}

{'still'}
/** Construct a LinkList: initialize the first and last nodes */
public LinkList() {
    clear();
}

{'linklist'}
/** Construct a LinkList given another Collection.
     * This method is recommended by the general contract of List.
     */
public LinkList(Collection<T> c) {
    this();
    addAll(c);
}

{'linklist'}
public static void main(String[] argv) {
    ArrayList<Date> al = new ArrayList<>();
    // Create a source of Objects
    StructureDemo source = new StructureDemo(15);
    // Add lots of elements to the ArrayList...
    al.add(source.getDate());
    al.add(source.getDate());
    al.add(source.getDate());
    // Print them out using old-style for loop to index number.
    System.out.println("Retrieving by index:");
    for (int i = 0; i < al.size(); i++) {
        System.out.println("Element " + i + " = " + al.get(i));
    }
}

{'arraylist'}
@SuppressWarnings("unchecked")
public void oldWay() {
    @SuppressWarnings("rawtypes") // BEGIN oldWay
    List myList = new ArrayList();
    myList.add("hello");
    myList.add("goodbye");
    for (int i = 0; i < myList.size(); i++) {
        String s = (String) myList.get(i);
        System.out.println(s);
    }
// END oldWay
}

{'compile', 'failure', 'mylist', 'oldway', 'date', 'cause', 'would', 'later'}
public void newWay() {
    // BEGIN newWay
    // Java 6: new ArrayList<String>();
    List<String> myList = new ArrayList<>();
    myList.add("hello");
    myList.add("goodbye");
    for (String s : myList) {
        // Look Ma, no downcast!
        System.out.println(s);
    }
// END newWay
}

{'compile', 'mylist', 'date', 'would', 'arraylist', 'newway'}
@SuppressWarnings("unused")
public static void main(String[] argv) {
    // declare a reference
    int[] monthLen1;
    // construct it
    monthLen1 = new int[12];
    // short form
    int[] monthLen2 = new int[12];
    // even shorter is this initializer form:
    int[] monthLen3 = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    final int MAX = 10;
    Calendar[] days = new Calendar[MAX];
    for (int i = 0; i < MAX; i++) {
        // Note that this actually stores GregorianCalendar
        // etc. instances into a Calendar Array
        days[i] = Calendar.getInstance();
    }
    // Two-Dimensional Arrays
    // Want a 10-by-24 array
    int[][] me = new int[10][];
    for (int i = 0; i < 10; i++) me[i] = new int[24];
    // Remember that an array has a ".length" attribute
    System.out.println(me.length);
    System.out.println(me[0].length);
}

{'gregoriancalendar'}
public static void main(String[] argv) {
    int nDates = 0;
    Date[] dates = new Date[INITIAL];
    StructureDemo source = new StructureDemo(21);
    Date c;
    while ((c = (Date) (source.getDate())) != null) {
        // better: reallocate, making data structure dynamic
        if (nDates >= dates.length) {
            Date[] tmp = new Date[dates.length * GROW_FACTOR];
            System.arraycopy(dates, 0, tmp, 0, dates.length);
            // copies the array reference
            dates = tmp;
        // old array will be garbage collected soon...
        }
        dates[nDates++] = c;
    }
    System.out.println("Final array size = " + dates.length);
}

{'life', 'err', 'many', 'exit', 'wimp', 'simplify', 'ndates'}
public static void main(String[] argv) {
    List<Date> l = new ArrayList<>();
    StructureDemo source = new StructureDemo(15);
    // Add lots of elements to the list...
    l.add(source.getDate());
    l.add(source.getDate());
    l.add(source.getDate());
    int i = 0;
    Iterator it = l.iterator();
    // if the data is an an array, a List, a Vector, or whatever.
    while (it.hasNext()) {
        Object o = it.next();
        System.out.println("Element " + i++ + " = " + o);
    }
}

{'part', 'care', 'know', 'code', 'using', 'process'}
public static void main(String[] argv) {
    // BEGIN main
    // A TreeSet keeps objects in sorted order. Use a Comparator
    // published by String for case-insensitive sorting order.
    TreeSet<String> theSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
    theSet.add("Gosling");
    theSet.add("da Vinci");
    theSet.add("van Gogh");
    theSet.add("Java To Go");
    theSet.add("Vanguard");
    theSet.add("Darwin");
    // TreeSet is Set, ignores duplicates.
    theSet.add("Darwin");
    System.out.printf("Our set contains %d elements", theSet.size());
    // Since it is sorted we can easily get various subsets
    System.out.println("Lowest (alphabetically) is " + theSet.first());
    // Print how many elements are greater than "k"
    // Should be 2 - "van Gogh" and "Vanguard"
    System.out.println(theSet.tailSet("k").toArray().length + " elements higher than \"k\"");
    // Print the whole list in sorted order
    System.out.println("Sorted list:");
    theSet.forEach( name -> System.out.println(name));
// END main
}

{'treeset'}
@Override
public int compare(String s1, String s2) {
    s1 = s1.substring(1);
    s2 = s2.substring(1);
    return s1.compareTo(s2);
// or, more concisely:
// return s1.substring(1).compareTo(s2.substring(1));
}

{'compareto'}
public static void main(String[] argv) {
    // Construct and load the hash. This simulates loading a
    // database or reading from a file, or wherever the data is.
    Map<String, String> map = new HashMap<String, String>();
    // The hash maps from company name to address.
    // In real life this might map to an Address object...
    map.put("Adobe", "Mountain View, CA");
    map.put("IBM", "White Plains, NY");
    map.put("Learning Tree", "Los Angeles, CA");
    map.put("Microsoft", "Redmond, WA");
    map.put("Netscape", "Mountain View, CA");
    map.put("O'Reilly", "Sebastopol, CA");
    map.put("Sun", "Mountain View, CA");
    // BEGIN SafeRemoval
    // Version 2: get ALL the keys and values 
    // with concurrent modification
    Iterator<String> it = map.keySet().iterator();
    while (it.hasNext()) {
        String key = it.next();
        if (key.equals("Sun")) {
            it.remove();
            continue;
        }
        System.out.println("Company " + key + "; " + "Address " + map.get(key));
    }
// END SafeRemoval
}

{'saferemoval'}
// BEGIN main
@SuppressWarnings("unchecked")
public static void main(String[] args) {
    System.out.println("In lang.InvokeMain.main()");
    if (args.length == 1 && args[0].equals("quit")) {
        return;
    }
    try {
        // First, find the class.
        Class<?> c = Class.forName("lang.InvokeMain");
        System.out.println(c);
        // Create the array of Argument Types
        Class<?>[] argTypes = { // args is String!
        args.getClass() };
        // Now find the method
        Method m = c.getMethod("main", argTypes);
        System.out.println("Found method" + m);
        // Create the actual argument array
        String[] newArgs = { "quit" };
        Object[] passedArgs = { newArgs };
        // Now invoke the method. Null for "this ref" because it's static
        m.invoke(null, passedArgs);
    } catch (Exception e) {
        System.err.println(e);
    }
}

{'printstacktrace'}
public static void main(String[] argv) {
    // System.out.println(new InnerChild.InnerInnerChild()); // NOT how!
    InnerChild x = new InnerChild();
    System.out.println(x.new InnerInnerChild());
}

{'innerchild', 'innerinnerchild'}
public static void main(String[] args) {
    mySumCalls();
    // BEGIN processCalls
    process(System.out, "Hello", "Goodbye");
    process(System.out, (int) 42, (int) 1066, (int) 1776);
    process(System.out, "Foo", new Date(), new Object());
    // END processCalls
    // BEGIN passThroughCalls
    passThrough(System.out, "%s %s %s%n", "Foo", new Date(), new Object());
// END passThroughCalls
}

{'passthroughcalls', 'processcalls'}
// BEGIN mySumDefn
static int mySum(int... args) {
    int total = 0;
    for (int a : args) {
        total += a;
    }
    return total;
}

{'mysumdefn'}
// END mySumDefn
public static void mySumCalls() {
    // BEGIN mySumCalls
    System.out.println(mySum(5, 7, 9));
    System.out.println(mySum(5));
    System.out.println(mySum());
    int[] nums = { 5, 7, 9 };
    System.out.println(mySum(nums));
// END mySumCalls
}

{'mysumcalls'}
public void run() {
    while (true) {
        // entire run method runs forever.
        try {
            sleep(SECONDS * 1000);
        } catch (InterruptedException e) {
        }
        if (model.wantAutoSave() && model.hasUnsavedChanges())
            model.saveFile(null);
    }
}

{'nothing'}
/** Ask the model if it wants AutoSave done for it */
public boolean wantAutoSave();

{'autosave'}
public static void main(String[] argv) {
    // BEGIN main
    long t0 = System.currentTimeMillis();
    while (true) {
        long t1 = System.currentTimeMillis();
        int seconds = (int) (t1 - t0) / 1000;
        System.out.print("Elapsed: " + seconds + "\r");
        try {
            Thread.sleep(999);
        } catch (InterruptedException e) {
        }
    }
// END main
}

{'say', 'nothing'}
public static void main(String[] args) {
    Thread t = new Thread() {

        public void run() {
            System.out.println("Reading");
            try {
                System.in.read();
            } catch (java.io.IOException ex) {
                System.err.println(ex);
            }
            System.out.println("Thread Finished.");
        }
    };
    System.out.println("Starting");
    t.start();
    System.out.println("Joining");
    try {
        t.join();
    } catch (InterruptedException ex) {
        System.out.println("Who dares interrupt my sleep?");
    }
    System.out.println("Main Finished.");
}

{'happen'}
/**
     * Main program, test driver for ThreadsDemo2 class.
     */
public static void main(String[] argv) {
    new ThreadsDemo2("Hello from X", 10);
    new ThreadsDemo2("Hello from Y", 15);
}

{'threadsdemoD'}
/**
     * Construct a ThreadsDemo2 object
     * @param m Message to display
     * @param n How many times to display it
     */
public ThreadsDemo2(String m, int n) {
    count = n;
    mesg = m;
    t = new Thread(this);
    t.setName(m + " runner Thread");
    t.start();
}

{'threadsdemoD'}
public void run() {
    try {
        // HTTP
        io = new Socket("java.sun.com", 80);
        BufferedReader is = new BufferedReader(new InputStreamReader(io.getInputStream()));
        System.out.println("StopClose reading");
        // The following line will deadlock (intentionally), since HTTP 
        // enjoins the client to send a request (like "GET / HTTP/1.0")
        // and a null line, before reading the response.
        // DEADLOCK
        String line = is.readLine();
        // Should only get out of the readLine if an interrupt
        // is thrown, as a result of closing the socket.
        // So we shouldn't get here, ever:
        System.out.printf("StopClose FINISHED after reading %s!?", line);
    } catch (IOException ex) {
        System.out.println("StopClose terminating: " + ex);
    }
}

{'readline'}
/** Run does the work: print a message, "count" number of times */
public void run() {
    while (count-- > 0) {
        System.out.println(mesg);
        try {
            // in mSec
            Thread.sleep(100);
        } catch (InterruptedException e) {
            return;
        }
    }
    System.out.println(mesg + " all done.");
}

{'msec'}
/**
     * Construct a ThreadsDemo1 object.
     * @param m Message to display
     * @param n How many times to display it
     */
public ThreadsDemo1(final String mesg, int n) {
    this.mesg = mesg;
    count = n;
    setName(mesg + " runner Thread");
}

{'threadsdemoD'}
/**
     * Main program, test driver for ThreadsDemo1 class.
     */
public static void main(String[] argv) {
    // could say: new ThreadsDemo1("Hello from X", 10).run();
    // could say: new ThreadsDemo1("Hello from Y", 15).run();
    // But then it wouldn't be multi-threaded!
    new ThreadsDemo1("Hello from X", 10).start();
    new ThreadsDemo1("Hello from Y", 15).start();
}

{'threadsdemoD'}
public void run() {
    while (true) {
        Object justProduced = getRequestFromNetwork();
        // might have to wait for hours if the client is having coffee.
        synchronized (list) {
            while (list.size() == MAX) {
                // queue "full"
                try {
                    System.out.println("Producer WAITING");
                    // Limit the size
                    list.wait();
                } catch (InterruptedException ex) {
                    System.out.println("Producer INTERRUPTED");
                }
            }
            list.addFirst(justProduced);
            // must own the lock
            list.notifyAll();
            System.out.println("Produced 1; List size now " + list.size());
            if (done)
                break;
        // yield();    // Useful for green threads & demo programs.
        }
    }
}

{'actually', 'synch', 'outside', 'reading', 'section', 'simulating'}
Object getRequestFromNetwork() {
    // }
    return (new Object());
}

{'passing', 'client', 'simulation', 'time', 'simulate', 'reading', 'catch', 'interrupted', 'thread', 'read', 'sleep', 'DIGIT', 'producer', 'system', 'println', 'interruptedexception', 'ex', 'try'}
public void run() {
    while (!done) {
        lock.readLock().lock();
        try {
            theData.forEach( p -> System.out.printf("%s: votes %d%n", p.getName(), p.getVotes()));
        } finally {
            // Unlock in "finally" to be sure it gets done.
            lock.readLock().unlock();
        }
        try {
            Thread.sleep(((long) (Math.random() * 1000)));
        } catch (InterruptedException ex) {
        }
    }
}

{'nothing'}
public void run() {
    while (!done) {
        lock.writeLock().lock();
        try {
            theData.voteFor(// Performance: should have one PRNG per thread.
            (((int) (Math.random() * theData.getCandidateCount()))));
        } finally {
            lock.writeLock().unlock();
        }
        try {
            Thread.sleep(((long) (Math.random() * 1000)));
        } catch (InterruptedException ex) {
        }
    }
}

{'nothing'}
/**
     * Run a demo with more readers than writers
     */
private void demo() {
    // Start two reader threads
    for (int i = 0; i < NUM_READER_THREADS; i++) {
        new Thread() {

            public void run() {
                while (!done) {
                    lock.readLock().lock();
                    try {
                        theData.forEach( p -> System.out.printf("%s: votes %d%n", p.getName(), p.getVotes()));
                    } finally {
                        // Unlock in "finally" to be sure it gets done.
                        lock.readLock().unlock();
                    }
                    try {
                        Thread.sleep(((long) (Math.random() * 1000)));
                    } catch (InterruptedException ex) {
                    }
                }
            }
        }.start();
    }
    // Start one writer thread to simulate occasional voting
    new Thread() {

        public void run() {
            while (!done) {
                lock.writeLock().lock();
                try {
                    theData.voteFor(// Performance: should have one PRNG per thread.
                    (((int) (Math.random() * theData.getCandidateCount()))));
                } finally {
                    lock.writeLock().unlock();
                }
                try {
                    Thread.sleep(((long) (Math.random() * 1000)));
                } catch (InterruptedException ex) {
                }
            }
        }
    }.start();
    // In the main thread, wait a while then terminate the run.
    try {
        Thread.sleep(10 * 1000);
    } catch (InterruptedException ex) {
    } finally {
        done = true;
    }
}

{'nothing'}
public void run() {
    while (!done) {
        System.out.println("StopBoolean running");
        try {
            sleep(720);
        } catch (InterruptedException ex) {
        }
    }
    System.out.println("StopBoolean finished.");
}

{'nothing'}
/**
     * Run one Sprite around the screen.
     * This version just moves them around either across, down, or
     * at some 45-degree angle.
     */
public void run() {
    int width = parent.getSize().width;
    int height = parent.getSize().height;
    // Set initial location
    x = (int) (Math.random() * width);
    y = (int) (Math.random() * height);
    // Flip coin for x & y directions
    int xincr = Math.random() > 0.5 ? 1 : -1;
    int yincr = Math.random() > 0.5 ? 1 : -1;
    while (!done) {
        width = parent.getSize().width;
        height = parent.getSize().height;
        if ((x += xincr) >= width)
            x = 0;
        if ((y += yincr) >= height)
            y = 0;
        if (x < 0)
            x = width;
        if (y < 0)
            y = height;
        switch(direction) {
            case VERTICAL:
                x = 0;
                break;
            case HORIZONTAL:
                y = 0;
                break;
            case DIAGONAL:
                break;
        }
        //System.out.println("from " + getLocation() + "->" + x + "," + y);
        setLocation(x, y);
        repaint();
        try {
            Thread.sleep(sleepTime);
        } catch (InterruptedException e) {
            return;
        }
    }
}

{'getlocation'}
/**
     * Main program, test driver for ThreadsDemo4 class.
     */
public static void main(String[] argv) {
    new ThreadsDemo4("Hello from X", 10);
    new ThreadsDemo4("Hello from Y", 15);
}

{'threadsdemoD'}
/**
     * Construct a ThreadDemo object
     * @param m Message to display
     * @param n How many times to display it
     */
public ThreadsDemo4(final String mesg, int n) {
    count = n;
    t = new Thread(() -> {
        while (count-- > 0) {
            System.out.println(mesg);
            try {
                // 100 msec
                Thread.sleep(100);
            } catch (InterruptedException e) {
                return;
            }
        }
        System.out.println(mesg + " thread all done.");
    });
    t.setName(mesg + " runner Thread");
    t.start();
}

{'threaddemo'}
/**
     * Main program, test driver for ThreadsDemo3 class.
     */
public static void main(String[] argv) {
    new ThreadsDemo3("Hello from X", 10);
    new ThreadsDemo3("Hello from Y", 15);
}

{'threadsdemoD'}
/**
     * Construct a ThreadDemo object
     * @param m Message to display
     * @param n How many times to display it
     */
public ThreadsDemo3(final String mesg, int n) {
    count = n;
    t = new Thread(new Runnable() {

        public void run() {
            while (count-- > 0) {
                System.out.println(mesg);
                try {
                    // 100 msec
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    return;
                }
            }
            System.out.println(mesg + " thread all done.");
        }
    });
    t.setName(mesg + " runner Thread");
    t.start();
}

{'threaddemo'}
/** doGet is called from the contestants web page.
     * Uses a synchronized code block to ensure that
     * only one contestant can change the state of "buzzed".
     */
public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    ServletContext application = getServletContext();
    boolean iWon = false;
    String user = request.getRemoteHost() + '@' + request.getRemoteAddr();
    // Do the synchronized stuff first, and all in one place.
    synchronized (application) {
        if (application.getAttribute(WINNER) == null) {
            application.setAttribute(WINNER, user);
            application.log("BuzzInServlet: WINNER " + user);
            iWon = true;
        }
    }
    response.setContentType("text/html");
    PrintWriter out = response.getWriter();
    out.println("<html><head><title>Thanks for playing</title></head>");
    out.println("<body bgcolor=\"white\">");
    if (iWon) {
        out.println("<b>YOU GOT IT</b>");
    // TODO - output HTML to play a sound file :-)
    } else {
        out.println("Thanks for playing, " + request.getRemoteAddr());
        out.println(", but " + application.getAttribute(WINNER) + " buzzed in first");
    }
    out.println("</body></html>");
}

{'doget'}
public static void main(String[] args) {
    Date legacyDate = new Date();
    System.out.println(legacyDate);
    ZoneOffset zoneOffset1 = ZoneOffset.of("-0400");
    // using the long integer-based methods
    long longTime = legacyDate.getTime();
    LocalDateTime convertedDate1 = LocalDateTime.ofEpochSecond(longTime / 1000, (int) ((longTime % 1000) * 1000), zoneOffset1);
    System.out.println(convertedDate1);
    // Using individual values
    LocalDateTime convertedDate2 = LocalDateTime.of(legacyDate.getYear() + 1900, legacyDate.getMonth() + 1, legacyDate.getDate(), legacyDate.getHours(), legacyDate.getMinutes(), legacyDate.getSeconds());
    System.out.println(convertedDate2);
    // Timezone
    TimeZone timeZone = TimeZone.getTimeZone("EST");
    ZoneId zoneId = timeZone.toZoneId();
    System.out.println("EST - > " + zoneId);
    // Convert new DateTimeFormatter to old java.util.Format, but it
    // will only format things that implement TemporalAccessor, e.g., new API
    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy MM dd");
    Format legacyFormat = dateTimeFormatter.toFormat();
    System.out.println("Formatted: " + legacyFormat.format(convertedDate2));
}

{'datetimeformatter', 'temporalaccessor'}
public static void main(String[] args) {
    // BEGIN ofTime
    Date endOfTime = new Date(Long.MAX_VALUE);
    System.out.println("Java8 time overflows on " + endOfTime);
// END ofTime
}

{'oftime'}
public static void main(String[] args) {
    int total = 0;
    for (int i : integers) {
        // Call doTheMath with 'i' and a Lambda for n^2 +1
        total += doTheMath(i,  k -> k * k + 1);
    }
    System.out.println(total);
}

{'dothemath'}
public static void main(String[] args) throws Exception {
    ReferencesDemo2 rd2 = new ReferencesDemo2();
    // short for close, but just to she the method name isn't what matters).
    try (AutoCloseable autoCloseable = rd2::cloz) {
        System.out.println("Some action happening here.");
    }
}

{'signature', 'obviously', 'variable', 'use', 'autocloseable', 'interface', 'assign', 'matching', 'ac'}
public static void main(String[] a) {
    Random r = new Random();
    for (int i = 0; i < 1000; i++) // nextInt(10) goes from 0-9; add 1 for 1-10;
    System.out.println(1 + r.nextInt(10));
}

{'nextint'}
/**
     * Calculate a set of operands; the input is an Object array containing
     * either BigDecimal objects (which may be pushed onto the Stack) and
     * operators (which are operated on immediately).
     * @param input
     * @return
     */
public BigDecimal calculate(Object[] input) {
    BigDecimal tmp;
    for (int i = 0; i < input.length; i++) {
        Object o = input[i];
        if (o instanceof BigDecimal) {
            stack.push((BigDecimal) o);
        } else if (o instanceof String) {
            switch(((String) o).charAt(0)) {
                // + and * are commutative, order doesn't matter
                case '+':
                    stack.push((stack.pop()).add(stack.pop()));
                    break;
                case '*':
                    stack.push((stack.pop()).multiply(stack.pop()));
                    break;
                // - and /, order *does* matter
                case '-':
                    tmp = (BigDecimal) stack.pop();
                    stack.push((stack.pop()).subtract(tmp));
                    break;
                case '/':
                    tmp = stack.pop();
                    stack.push((stack.pop()).divide(tmp, BigDecimal.ROUND_HALF_UP));
                    break;
                default:
                    throw new IllegalStateException("Unknown OPERATOR popped");
            }
        } else {
            throw new IllegalArgumentException("Syntax error in input");
        }
    }
    return stack.pop();
}

{'bigdecimal'}
/* Generate a hashCode; not sure how well distributed these are.
     */
public int hashCode() {
    return (int) (r) | (int) i;
}

{'hashcode'}
public static void main(String[] argv) {
    // BEGIN main
    double someValue;
    // compute someValue...
    someValue = 0;
    double log_e = Math.log(someValue);
    System.out.println("Log(e) of " + someValue + " is " + log_e);
// END main
}

{'somevalue'}
/** The main (and only) method in this class. */
public static void main(String[] av) {
    // BEGIN part2
    NumberFormat defForm = NumberFormat.getInstance();
    NumberFormat ourForm = new DecimalFormat("##0.##");
    // toPattern() will reveal the combination of #0., etc
    // that this particular Locale uses to format with!
    System.out.println("defForm's pattern is " + ((DecimalFormat) defForm).toPattern());
    System.out.println(intlNumber + " formats as " + defForm.format(intlNumber));
    System.out.println(ourNumber + " formats as " + ourForm.format(ourNumber));
    System.out.println(ourNumber + " formats as " + defForm.format(ourNumber) + " using the default format");
// END part2
}

{'topattern'}
public static void main(String[] args) {
    // starting at 1.
    for (int i = 1; i <= months.length; i++) System.out.println("Month # " + i);
    // starting at 0.
    for (int i = 0; i < months.length; i++) System.out.println("Month " + months[i]);
    // For e.g., counting by 3 from 11 to 27, use a for loop
    for (int i = 11; i <= 27; i += 3) {
        System.out.println("i = " + i);
    }
    // A discontiguous set of integers, using a BitSet
    // Create a BitSet and turn on a couple of bits.
    BitSet b = new BitSet();
    // January
    b.set(0);
    // April
    b.set(3);
    // September
    b.set(8);
    // Presumably this would be somewhere else in the code.
    for (int i = 0; i < months.length; i++) {
        if (b.get(i))
            System.out.println("Month " + months[i]);
    }
    // Same example but shorter:
    // a discontiguous set of integers, using an array
    int[] numbers = { 0, 3, 8 };
    // Presumably this would be somewhere else in the code.
    for (int n : numbers) {
        System.out.println("Month: " + months[n]);
    }
}

{'ordinal', 'want', 'index', 'list', 'bitset'}
public static void main(String[] argv) {
    double da = 3 * .3333333333;
    double db = 0.99999992857;
    // Compare two numbers that are expected to be close.
    if (da == db) {
        System.out.println("Java considers " + da + "==" + db);
    // else compare with our own equals overload
    } else if (equals(da, db, 0.0000001)) {
        System.out.println("Equal within epsilon " + EPSILON);
    } else {
        System.out.println(da + " != " + db);
    }
    System.out.println("NaN prints as " + Double.NaN);
    // Show that comparing two NaNs is not a good idea:
    double nan1 = Double.NaN;
    double nan2 = Double.NaN;
    if (nan1 == nan2)
        System.out.println("Comparing two NaNs incorrectly returns true.");
    else
        System.out.println("Comparing two NaNs correctly reports false.");
    if (new Double(nan1).equals(new Double(nan2)))
        System.out.println("Double(NaN).equals(NaN) correctly returns true.");
    else
        System.out.println("Double(NaN).equals(NaN) incorrectly returns false.");
}

{'nan'}
/* Format the given Number as a Roman Numeral, returning the
     * Stringbuffer (updated), and updating the FieldPosition.
     * This method is the REAL FORMATTING ENGINE.
     * Method signature is overkill, but required as a subclass of Format.
     */
public StringBuffer format(Object on, StringBuffer sb, FieldPosition fp) {
    if (!(on instanceof Number))
        throw new IllegalArgumentException(on + " must be a Number object");
    if (fp.getField() != NumberFormat.INTEGER_FIELD)
        throw new IllegalArgumentException(fp + " must be FieldPosition(NumberFormat.INTEGER_FIELD");
    // TODO: check in range.
    int n = ((Number) on).intValue();
    // First, put the digits on a tiny stack. Must be 4 digits.
    for (int i = 0; i < 4; i++) {
        int d = n % 10;
        push(d);
        // System.out.println("Pushed " + d);
        n = n / 10;
    }
    // Now pop and convert.
    for (int i = 0; i < 4; i++) {
        int ch = pop();
        // System.out.println("Popped " + ch);
        if (ch == 0)
            continue;
        else if (ch <= 3) {
            for (int k = 1; k <= ch; k++) // I
            sb.append(A2R[i][1]);
        } else if (ch == 4) {
            // I
            sb.append(A2R[i][1]);
            // V
            sb.append(A2R[i][2]);
        } else if (ch == 5) {
            // V
            sb.append(A2R[i][2]);
        } else if (ch <= 8) {
            // V
            sb.append(A2R[i][2]);
            for (int k = 6; k <= ch; k++) // I
            sb.append(A2R[i][1]);
        } else {
            // 9
            sb.append(A2R[i][1]);
            sb.append(A2R[i][3]);
        }
    }
    // fp.setEndIndex(3);
    return sb;
}

{'setbeginindex', 'fieldposition', 'setendindex'}
/** Construct an ArrayIterator object.
     * @param d The array of objects to be iterated over.
     */
public ArrayIterator(final T[] d) {
    setData(d);
}

{'arrayiterator'}
/** Remove the object that next() just returned.
     * An Iterator is not required to support this interface,
     * and we don't.
     * @throws UnsupportedOperationException unconditionally
     */
@Override
public void remove() {
    throw new UnsupportedOperationException("This demo Iterator does not implement the remove method");
}

{'unsupportedoperationexception'}
/** Construct a GetOpt parser, given the option specifications
     * in an array of GetOptDesc objects. This is the preferred constructor.
     */
public GetOpt(final GetOptDesc[] opt) {
    this.options = opt.clone();
}

{'getoptdesc', 'getopt'}
/** Construct a GetOpt parser, storing the set of option characters.
     * This is a legacy constructor for backward compatibility.
     * That said, it is easier to use if you don't need long-name options,
     * so it has not been and will not be marked "deprecated".
     */
public GetOpt(final String patt) {
    if (patt == null) {
        throw new IllegalArgumentException("Pattern may not be null");
    }
    if (patt.charAt(0) == ':') {
        throw new IllegalArgumentException("Pattern incorrect, may not begin with ':'");
    }
    // Pass One: just count the option letters in the pattern
    int n = 0;
    for (char ch : patt.toCharArray()) {
        if (ch != ':')
            ++n;
    }
    if (n == 0) {
        throw new IllegalArgumentException("No option letters found in " + patt);
    }
    // Pass Two: construct an array of GetOptDesc objects.
    options = new GetOptDesc[n];
    for (int i = 0, ix = 0; i < patt.length(); i++) {
        final char c = patt.charAt(i);
        boolean argTakesValue = false;
        if (i < patt.length() - 1 && patt.charAt(i + 1) == ':') {
            argTakesValue = true;
            ++i;
        }
        Debug.println("getopt", "CONSTR: options[" + ix + "] = " + c + ", " + argTakesValue);
        options[ix++] = new GetOptDesc(c, null, argTakesValue);
    }
}

{'getoptdesc'}
/** Reset this GetOpt parser */
public void rewind() {
    fileNameArguments = null;
    done = false;
    optind = 0;
    optarg = null;
}

{'getopt'}
/** 
     * Modern way of using GetOpt: call this once and get all options.
     * <p>
     * This parses the options, returns a Map whose keys are the found options.
     * Normally followed by a call to getFilenameList().
     * <br>Side effect: sets "fileNameArguments" to a new List
     * @return a Map whose keys are Strings of length 1 (containing the char
     * from the option that was matched) and whose value is a String
     * containing the value, or null for a non-option argument.
     */
public Map<String, String> parseArguments(String[] argv) {
    Map<String, String> optionsValueMap = new HashMap<String, String>();
    fileNameArguments = new ArrayList<String>();
    for (int i = 0; i < argv.length; i++) {
        // Cannot use foreach, need i
        Debug.println("getopt", "parseArg: i=" + i + ": arg " + argv[i]);
        // sets global "optarg"
        char c = getopt(argv);
        if (c == DONE) {
            fileNameArguments.add(argv[i]);
        } else {
            optionsValueMap.put(Character.toString(c), optarg);
            // If this arg takes an option, must arrange here to skip it.
            if (optarg != null) {
                i++;
            }
        }
    }
    return optionsValueMap;
}

{'filenamearguments', 'getfilenamelist'}
/** Get the list of filename-like arguments after options;
     * only for use if you called parseArguments.
     */
public List<String> getFilenameList() {
    if (fileNameArguments == null) {
        throw new IllegalArgumentException("Illegal call to getFilenameList() before parseOptions()");
    }
    return fileNameArguments;
}

{'parsearguments'}
/** The true heart of getopt, whether used old way or new way:
     * returns one argument; call repeatedly until it returns DONE.
     * Side-effect: sets globals optarg, optind
     */
public char getopt(String argv[]) {
    Debug.println("getopt", "optind=" + optind + ", argv.length=" + argv.length);
    if (optind >= (argv.length) || !argv[optind].startsWith("-")) {
        done = true;
    }
    // Do not collapse this into the "if" above
    if (done) {
        return DONE;
    }
    optarg = null;
    // XXX TODO - two-pass, 1st check long args, 2nd check for
    // char, to allow advanced usage like "-no outfile" == "-n -o outfile".
    // Pick off next command line argument, if it starts "-",
    // then look it up in the list of valid args.
    String thisArg = argv[optind];
    if (thisArg.startsWith("-")) {
        for (GetOptDesc option : options) {
            if ((thisArg.length() == 2 && option.getArgLetter() == thisArg.charAt(1)) || (option.getArgName() != null && option.getArgName().equals(thisArg.substring(1)))) {
                // If it needs an option argument, get it.
                if (option.takesArgument()) {
                    if (optind < argv.length - 1) {
                        optarg = argv[++optind];
                    } else {
                        throw new IllegalArgumentException("Option " + option.getArgLetter() + " needs value but found end of arg list");
                    }
                }
                ++optind;
                return option.getArgLetter();
            }
        }
        // Began with "-" but not matched, so must be error.
        ++optind;
        return '?';
    } else {
        // Found non-argument non-option word in argv: end of options.
        ++optind;
        done = true;
        return DONE;
    }
}

{'finished', 'bail', 'either'}
/** advQuoted: quoted field; return index of next separator */
protected int advQuoted(String s, StringBuffer sb, int i) {
    int j;
    int len = s.length();
    for (j = i; j < len; j++) {
        if (s.charAt(j) == '"' && j + 1 < len) {
            if (s.charAt(j + 1) == '"') {
                // skip escape char
                j++;
            } else if (s.charAt(j + 1) == fieldSep) {
                //next delimeter
                // skip end quotes
                j++;
                break;
            }
        } else if (s.charAt(j) == '"' && j + 1 == len) {
            //done
            break;
        }
        // regular character.
        sb.append(s.charAt(j));
    }
    return j;
}

{'advquoted', 'line'}
/** advPlain: unquoted field; return index of next separator */
protected int advPlain(String s, StringBuffer sb, int i) {
    int j;
    // look for separator
    j = s.indexOf(fieldSep, i);
    Debug.println("csv", "i = " + i + ", j = " + j);
    if (j == -1) {
        // none found
        sb.append(s.substring(i));
        return s.length();
    } else {
        sb.append(s.substring(i, j));
        return j;
    }
}

{'advplain'}
/** Set to list to an ArrayList of Strings */
public void setToList(ArrayList<String> to) {
    toList = to;
}

{'arraylist'}
/** Set cc list to an ArrayList of Strings */
public void setCcList(ArrayList<String> cc) {
    ccList = cc;
}

{'arraylist'}
/** Set bcc list to an ArrayList of Strings */
public void setBccList(List<String> bcc) {
    bccList = bcc;
}

{'arraylist'}
/** Check if all required fields have been set before sending.
     * Normally called before doSend; called by doSend for verification.
     */
public boolean isComplete() {
    if (from == null || from.length() == 0) {
        System.err.println("doSend: no FROM");
        return false;
    }
    if (subject == null || subject.length() == 0) {
        System.err.println("doSend: no SUBJECT");
        return false;
    }
    if (toList.size() == 0) {
        System.err.println("doSend: no recipients");
        return false;
    }
    if (body == null || body.length() == 0) {
        System.err.println("doSend: no body");
        return false;
    }
    if (mailHost == null || mailHost.length() == 0) {
        System.err.println("doSend: no server host");
        return false;
    }
    return true;
}

{'dosend'}
/** Construct a JGrep object.
     * @param patt The pattern to look for
     * @param args the command-line options.
     */
public JGrep(String patt) throws PatternSyntaxException {
    if (debug) {
        System.err.printf("JGrep.JGrep(%s)%n", patt);
    }
    // compile the regular expression
    int caseMode = ignoreCase ? Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE : 0;
    pattern = Pattern.compile(patt, caseMode);
    matcher = pattern.matcher("");
}

{'jgrep'}
/** Process one command line argument (file or directory)
     * @throws FileNotFoundException 
     */
public void process(File file) throws FileNotFoundException {
    if (!file.exists() || !file.canRead()) {
        System.err.println("ERROR: can't read file " + file.getAbsolutePath());
        return;
    }
    if (file.isFile()) {
        process(new BufferedReader(new FileReader(file)), file.getAbsolutePath());
        return;
    }
    if (file.isDirectory()) {
        if (!recursive) {
            System.err.println("ERROR: -r not specified but directory given " + file.getAbsolutePath());
            return;
        }
        for (File nf : file.listFiles()) {
            // "Recursion, n.: See Recursion."
            process(nf);
        }
        return;
    }
    System.err.println("WEIRDNESS: neither file nor directory: " + file.getAbsolutePath());
}

{'filenotfoundexception'}
/** Convenience routine to make a JButton */
public static JButton mkButton(ResourceBundle b, String name) {
    String label;
    try {
        label = b.getString(name + ".label");
    } catch (MissingResourceException e) {
        label = name;
    }
    return new JButton(label);
}

{'jbutton'}
/** Convenience routine to make a JMenu */
public static JMenu mkMenu(ResourceBundle b, String name) {
    String menuLabel;
    try {
        menuLabel = b.getString(name + ".label");
    } catch (MissingResourceException e) {
        menuLabel = name;
    }
    return new JMenu(menuLabel);
}

{'jmenu'}
/** Convenience routine to make a JMenuItem */
public static JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {
    String miLabel;
    try {
        miLabel = b.getString(menu + "." + name + ".label");
    } catch (MissingResourceException e) {
        miLabel = name;
    }
    String key = null;
    try {
        key = b.getString(menu + "." + name + ".key");
    } catch (MissingResourceException e) {
        key = null;
    }
    if (key == null)
        return new JMenuItem(miLabel);
    else
        return new JMenuItem(miLabel, key.charAt(0));
}

{'jmenuitem'}
/** Show a JOptionPane message dialog */
public static void mkDialog(ResourceBundle b, JFrame parent, String dialogTag, String titleTag, int messageType) {
    JOptionPane.showMessageDialog(parent, getString(b, dialogTag, "DIALOG TEXT MISSING: " + dialogTag), getString(b, titleTag, "DIALOG TITLE MISSING: " + titleTag), messageType);
}

{'joptionpane'}
/** Construct a WindowCloser that doesn't exit, just closes the window */
public WindowCloser(Window w) {
    this(w, false);
}

{'windowcloser'}
/** Construct a WindowCloser with control over whether it exits */
public WindowCloser(Window w, boolean exit) {
    win = w;
    doExit = exit;
}

{'windowcloser'}
/** Centre a Window, Frame, JFrame, Dialog, etc. */
public static void centre(final Window w) {
    // After packing a Frame or Dialog, centre it on the screen.
    Dimension us = w.getSize(), them = Toolkit.getDefaultToolkit().getScreenSize();
    int newX = (them.width - us.width) / 2;
    int newY = (them.height - us.height) / 2;
    w.setLocation(newX, newY);
}

{'jframe'}
/** Center a Window, Frame, JFrame, Dialog, etc., 
     * but do it the American Spelling Way :-)
     */
public static void center(final Window w) {
    UtilGUI.centre(w);
}

{'jframe'}
/** 
     * Track a Window's position across application restarts; location is saved
     * in a Preferences node that you pass in; we attach a ComponentListener to
     * the Window.
     */
public static void monitorWindowPosition(final Window w, final Preferences pNode) {
    // Get the current saved position, if any
    Point p = getSavedLocation(pNode);
    int savedX = (int) p.getX();
    int savedY = (int) p.getY();
    if (savedX != -1) {
        // Move window to is previous location
        w.setLocation(savedX, savedY);
    } else {
        // Not saved yet, at least make it look nice
        centre(w);
    }
    // Now make sure that if the user moves the window,
    // we will save the new position.
    w.addComponentListener(new ComponentAdapter() {

        @Override
        public void componentMoved(ComponentEvent e) {
            setSavedLocation(pNode, w);
        }
    });
}

{'componentlistener'}
/** Construct an EntryLayout with widths and padding specified.
     * @param relWidths    Array of doubles specifying relative column widths.
     * @param h            Horizontal padding between items
     * @param v            Vertical padding between items
     */
public EntryLayout(double[] relWidths, int h, int v) {
    COLUMNS = relWidths.length;
    widthPercentages = new double[COLUMNS];
    for (int i = 0; i < relWidths.length; i++) {
        if (relWidths[i] >= 1.0)
            throw new IllegalArgumentException("EntryLayout: widths must be fractions < 1");
        widthPercentages[i] = relWidths[i];
    }
    validWidths = true;
    hpad = h;
    vpad = v;
}

{'relwidths', 'entrylayout'}
/** Construct an EntryLayout with widths and with default padding amounts.
     * @param relWidths    Array of doubles specifying column widths.
     */
public EntryLayout(double[] relWidths) {
    this(relWidths, HPAD, VPAD);
}

{'relwidths', 'entrylayout'}
/** Adds the specified component with the specified constraint
     * to the layout; required by LayoutManager but not used.
     */
public void addLayoutComponent(String name, Component comp) {
// nothing to do
}

{'layoutmanager'}
/** Removes the specified component from the layout;
     * required by LayoutManager, but does nothing.
     */
public void removeLayoutComponent(Component comp) {
// nothing to do
}

{'layoutmanager'}
/** Calculates the preferred size dimensions for the specified panel
     * given the components in the specified parent container. */
public Dimension preferredLayoutSize(Container parent) {
    // System.out.println("preferredLayoutSize");
    return computeLayoutSize(parent, hpad, vpad);
}

{'preferredlayoutsize'}
/** Find the minimum Dimension for the
     * specified container given the components therein.
     */
public Dimension minimumLayoutSize(Container parent) {
    // System.out.println("minimumLayoutSize");
    return computeLayoutSize(parent, 0, 0);
}

{'minimumlayoutsize'}
/** Compute the size of the whole mess. Serves as the guts of
     * preferredLayoutSize() and minimumLayoutSize().
     * @param parent The container in which to do the layout.
     * @param hp The horizontal padding (may be zero)
     * @param vp The Vertical Padding (may be zero).
     */
protected Dimension computeLayoutSize(Container parent, int hp, int vp) {
    if (!validWidths)
        return null;
    Component[] components = parent.getComponents();
    int preferredWidth = 0, preferredHeight = 0;
    widths = new int[COLUMNS];
    heights = new int[components.length / COLUMNS];
    // System.out.println("Grid: " + widths.length + ", " + heights.length);
    int i;
    // Pass One: Compute largest widths and heights.
    for (i = 0; i < components.length; i++) {
        int row = i / widthPercentages.length;
        int col = i % widthPercentages.length;
        Component c = components[i];
        Dimension d = c.getPreferredSize();
        widths[col] = Math.max(widths[col], d.width);
        heights[row] = Math.max(heights[row], d.height);
    }
    // Pass two: agregate them.
    for (i = 0; i < widths.length; i++) preferredWidth += widths[i] + hp;
    for (i = 0; i < heights.length; i++) preferredHeight += heights[i] + vp;
    // Finally, pass the sums back as the actual size.
    return new Dimension(preferredWidth, preferredHeight);
}

{'minimumlayoutsize', 'preferredlayoutsize'}
/** Construct the object with no initial values.
     * To be usable as a JavaBean there must be a no-argument constructor.
     */
public LabelText() {
    this("(LabelText)", 12);
}

{'javabean'}
/** Construct the object with given label, textfield size,
     * and "Extra" component
     * @param label The text to display
     * @param numChars The size of the text area
     * @param extra A third component such as a cancel button;
     * may be null, in which case only the label and textfield exist.
     */
public LabelText(String label, int numChars, JComponent extra) {
    super();
    setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
    theLabel = new JLabel(label);
    add(theLabel);
    theTextField = new JTextField(numChars);
    add(theTextField);
    if (extra != null) {
        add(extra);
    }
}

{'numchars'}
/** Set the font used in both subcomponents. */
public void setFont(Font f) {
    // before we create our components, so work around this.
    if (theLabel != null)
        theLabel.setFont(f);
    if (theTextField != null)
        theTextField.setFont(f);
}

{'trigger', 'super', 'setfont', 'call', 'constructor', 'lookandfeel', 'installcolorsandfont', 'swing', 'class'}
/** Adds the ActionListener to receive action events from the textfield */
public void addActionListener(ActionListener l) {
    theTextField.addActionListener(l);
}

{'actionlistener'}
/** Remove an ActionListener from the textfield. */
public void removeActionListener(ActionListener l) {
    theTextField.removeActionListener(l);
}

{'actionlistener'}
/** Convenience routine for use with AWT's dispatch thread; this is the old,
     * never-supported and now often-doesn't-work method, but the code is still here.
     * Usage:
     * <pre>
     * System.setProperty("sun.awt.exception.handler", "com.darwinsys.swingui.ErrorUtil");
     * </pre>
     */
public void handle(Throwable th) {
    //System.out.println("handle() called with " + th.getClass().getName());
    showExceptions(null, th);
}

{'errorutil', 'getname', 'setproperty', 'getclass'}
/**
     * Show the given Exception (and any nested Exceptions) in JOptionPane(s).
     */
public static void showExceptions(Component parent, Throwable theExc) {
    Throwable next = null;
    do {
        String className = theExc.getClass().getName();
        String message = className;
        if (theExc instanceof SQLException) {
            SQLException sexc = (SQLException) theExc;
            message += "; code=" + sexc.getErrorCode();
            next = sexc.getNextException();
        } else {
            // Comment out if < JDK 1.4
            next = theExc.getCause();
        }
        String[] choices = next != null ? choicesMore : choicesNoMore;
        /* Show the Dialog! */
        int response = JOptionPane.showOptionDialog(parent, message, // title
        className, // icontType
        JOptionPane.YES_NO_CANCEL_OPTION, // messageType
        JOptionPane.ERROR_MESSAGE, // icon
        null, // options
        choices, // default
        choices[0]);
        if (// "OK"
        response == 0)
            return;
        if (response == 1) {
            // show ANOTHER JDialog with a JTextArea of printStackTrace();
            if (// first time, lazy creation
            detailsDialog == null)
                detailsDialog = new DetailsDialog((JFrame) parent);
            detailsDialog.showStackTrace(theExc);
        }
        // else resp = 2, "Next", let it fall through:
        theExc = next;
    } while (next != null);
}

{'messagetype', 'printstacktrace', 'jdialog', 'jtextarea', 'iconttype', 'joptionpane'}
/** Construct a DetailsDialog given a parent (Frame/JFrame) */
DetailsDialog(JFrame parent) {
    super(parent);
    Container cp = getContentPane();
    text = new JTextArea(40, 40);
    cp.add(text, BorderLayout.CENTER);
    ok = new JButton("Close");
    cp.add(ok, BorderLayout.SOUTH);
    ok.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            dispose();
        }
    });
    pack();
}

{'jframe', 'detailsdialog'}
/** Display the stackTrace from the given Throwable in this Dialog. */
void showStackTrace(Throwable exc) {
    CharArrayWriter buff = new CharArrayWriter();
    PrintWriter pw = new PrintWriter(buff);
    exc.printStackTrace(pw);
    pw.close();
    text.setText(buff.toString());
    setVisible(true);
}

{'stacktrace'}
/** Construct a FontChooser -- Sets title and gets
     * array of fonts on the system. Builds a GUI to let
     * the user choose one font at one size.
     */
public FontChooser(JFrame f) {
    super(f, "Font Chooser", true);
    Container cp = getContentPane();
    JPanel top = new JPanel();
    top.setBorder(new TitledBorder(new EtchedBorder(), "Font"));
    top.setLayout(new FlowLayout());
    // This gives a longish list; most of the names that come
    // with your OS (e.g., Helvetica, Times), plus the Sun/Java ones (Lucida,
    // Lucida Bright, Lucida Sans...)
    String[] fontList = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
    fontNameChoice = new JList(fontList);
    top.add(new JScrollPane(fontNameChoice));
    fontNameChoice.setVisibleRowCount(fontSizes.length);
    fontNameChoice.setSelectedValue("Serif", true);
    fontSizeChoice = new JList(fontSizes);
    top.add(fontSizeChoice);
    fontSizeChoice.setSelectedIndex(fontSizes.length * 3 / 4);
    cp.add(top, BorderLayout.NORTH);
    JPanel attrs = new JPanel();
    top.add(attrs);
    attrs.setLayout(new GridLayout(0, 1));
    attrs.add(bold = new JCheckBox("Bold", false));
    attrs.add(italic = new JCheckBox("Italic", false));
    // Make sure that any change to the GUI will trigger a font preview.
    ListSelectionListener waker = new ListSelectionListener() {

        public void valueChanged(ListSelectionEvent e) {
            previewFont();
        }
    };
    fontSizeChoice.addListSelectionListener(waker);
    fontNameChoice.addListSelectionListener(waker);
    ItemListener waker2 = new ItemListener() {

        public void itemStateChanged(ItemEvent e) {
            previewFont();
        }
    };
    bold.addItemListener(waker2);
    italic.addItemListener(waker2);
    previewArea = new JLabel(displayText, JLabel.CENTER);
    previewArea.setSize(200, 50);
    cp.add(previewArea, BorderLayout.CENTER);
    JPanel bot = new JPanel();
    JButton okButton = new JButton("Apply");
    bot.add(okButton);
    okButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            previewFont();
            dispose();
            setVisible(false);
        }
    });
    JButton canButton = new JButton("Cancel");
    bot.add(canButton);
    canButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            // Set all values to null. Better: restore previous.
            resultFont = null;
            resultName = null;
            resultSize = 0;
            isBold = false;
            isItalic = false;
            dispose();
            setVisible(false);
        }
    });
    cp.add(bot, BorderLayout.SOUTH);
    // ensure view is up to date!
    previewFont();
    pack();
    setLocation(100, 100);
}

{'fontchooser'}
/** Called from the action handlers to get the font info,
     * build a font, and set it.
     */
protected void previewFont() {
    resultName = (String) fontNameChoice.getSelectedValue();
    String resultSizeName = fontSizeChoice.getSelectedValue().toString();
    int resultSize = Integer.parseInt(resultSizeName);
    isBold = bold.isSelected();
    isItalic = italic.isSelected();
    int attrs = Font.PLAIN;
    if (isBold)
        attrs = Font.BOLD;
    if (isItalic)
        attrs |= Font.ITALIC;
    resultFont = new Font(resultName, attrs, resultSize);
    // System.out.println("resultName = " + resultName + "; " +
    //         "resultFont = " + resultFont);
    previewArea.setFont(resultFont);
    // ensure Dialog is big enough.
    pack();
}

{'resultfont', 'resultname'}
/**
     * Return a reference to the contained File object, to
     * promote reuse (File objects are immutable so this
     * is at least moderately safe). Typical use would be:
     * <pre>
     * if (fileSaver == null ||
     *   !(fileSaver.getFile().equals(file))) {
     *        fileSaver = new FileSaver(file);
     * }
     * </pre>
     */
public File getFile() {
    return inputFile;
}

{'getfile', 'filesaver'}
/** Return an output file that the client should use to
     * write the client's data to.
     * @return An OutputStream, which should be wrapped in a
     *     buffered OutputStream to ensure reasonable performance.
     * @throws IOException if the temporary file cannot be written
     */
public OutputStream getOutputStream() throws IOException {
    if (state != State.AVAILABLE) {
        throw new IllegalStateException("FileSaver not opened");
    }
    OutputStream out = new FileOutputStream(tmpFile);
    state = State.INUSE;
    return out;
}

{'outputstream', 'ioexception'}
/** Return an output file that the client should use to
     * write the client's data to.
     * @return A Writer, which should be wrapped in a
     *     buffered Writer to ensure reasonable performance.
     * @throws IOException if the temporary file cannot be written
     */
public Writer getWriter() throws IOException {
    if (state != State.AVAILABLE) {
        throw new IllegalStateException("FileSaver not opened");
    }
    Writer out = new FileWriter(tmpFile);
    state = State.INUSE;
    return out;
}

{'ioexception'}
/** Close the output file and rename the temp file to the original name.
     * @throws IOException If anything goes wrong
     */
public void finish() throws IOException {
    if (state != State.INUSE) {
        throw new IllegalStateException("FileSaver not in use");
    }
    // Delete the previous backup file if it exists;
    backupFile.delete();
    // UNLESS this is a new file ;
    if (inputFile.exists() && !inputFile.renameTo(backupFile)) {
        throw new IOException("Could not rename file to backup file");
    }
    // Rename the temporary file to the save file.
    if (!tmpFile.renameTo(inputFile)) {
        throw new IOException("Could not rename temp file to save file");
    }
    state = State.AVAILABLE;
}

{'user', 'ioexception', 'bak', 'itsname'}
/** Copy a file from an opened InputStream to opened OutputStream */
public static void copyFile(InputStream is, OutputStream os, boolean close) throws IOException {
    // the byte read from the file
    byte[] b = new byte[BLKSIZ];
    int i;
    while ((i = is.read(b)) != -1) {
        os.write(b, 0, i);
    }
    is.close();
    if (close)
        os.close();
}

{'outputstream', 'inputstream'}
/** Copy a file from a filename to a PrintWriter. */
public static void copyFile(String inName, PrintWriter pw, boolean close) throws FileNotFoundException, IOException {
    BufferedReader ir = new BufferedReader(new FileReader(inName));
    copyFile(ir, pw, close);
}

{'printwriter'}
/**
     * Copy a file to a directory, given File objects representing the files.
     * @param file File representing the source, must be a single file.
     * @param target File representing the location, may be file or directory.
     * @throws IOException
     */
public static void copyFile(File file, File target) throws IOException {
    if (!file.exists() || !file.isFile() || !(file.canRead())) {
        throw new IOException(file + " is not a readable file");
    }
    File dest = target;
    if (target.isDirectory()) {
        dest = new File(dest, file.getName());
    }
    InputStream is = null;
    OutputStream os = null;
    try {
        is = new FileInputStream(file);
        os = new FileOutputStream(dest);
        // the byte count
        int count = 0;
        // the bytes read from the file
        byte[] b = new byte[BLKSIZ];
        while ((count = is.read(b)) != -1) {
            os.write(b, 0, count);
        }
    } finally {
        is.close();
        os.close();
    }
}

{'ioexception'}
/** Copy a data file from one filename to another, alternative method.
     * As the name suggests, use my own buffer instead of letting
     * the BufferedReader allocate and use the buffer.
     */
public void copyFileBuffered(String inName, String outName) throws FileNotFoundException, IOException {
    InputStream is = null;
    OutputStream os = null;
    try {
        is = new FileInputStream(inName);
        os = new FileOutputStream(outName);
        // the byte count
        int count = 0;
        // the bytes read from the file
        byte[] b = new byte[BLKSIZ];
        while ((count = is.read(b)) != -1) {
            os.write(b, 0, count);
        }
    } finally {
        if (is != null) {
            is.close();
        }
        if (os != null) {
            os.close();
        }
    }
}

{'bufferedreader'}
/**
     * Copy all objects found in and under "fromdir", to their places in "todir".
     * @param fromDir
     * @param toDir
     * @throws IOException
     */
public static void copyRecursively(File fromDir, File toDir, boolean create) throws IOException {
    Debug.printf("fileio", "copyRecursively(%s, %s%n", fromDir, toDir);
    if (!fromDir.exists()) {
        throw new IOException(String.format("Source directory %s does not exist", fromDir));
    }
    if (create) {
        toDir.mkdirs();
    } else if (!toDir.exists()) {
        throw new IOException(String.format("Destination dir %s must exist", toDir));
    }
    for (File src : fromDir.listFiles()) {
        if (src.isDirectory()) {
            File destSubDir = new File(toDir, src.getName());
            copyRecursively(src, destSubDir, true);
        } else if (src.isFile()) {
            copyFile(src, toDir);
        } else {
            System.err.println(String.format("Warning: %s is neither file nor directory", src));
        }
    }
}

{'ioexception'}
/**
     * Copy a tree of files to directory, given File objects representing the files.
     * @param base File representing the source, must be a single file.
     * @param startingDir
     * @param toDir File representing the location, may be file or directory.
     * @throws IOException 
     */
public static void copyRecursively(JarFile base, JarEntry startingDir, File toDir) throws IOException {
    if (!startingDir.isDirectory()) {
        throw new IOException(String.format("Starting point %s is not a directory", startingDir));
    }
    if (!toDir.exists()) {
        throw new IOException(String.format("Destination dir %s must exist", toDir));
    }
    Enumeration<JarEntry> all = base.entries();
    while (all.hasMoreElements()) {
        JarEntry file = all.nextElement();
        // XXX ensure that it matches starting dir
        if (file.isDirectory()) {
            copyRecursively(base, file, new File(toDir, file.getName()));
        } else {
            InputStream is = null;
            OutputStream os = null;
            try {
                is = base.getInputStream(file);
                os = new FileOutputStream(new File(toDir, file.getName()));
                copyFile(is, os, false);
            } finally {
                if (os != null)
                    os.close();
                if (is != null)
                    is.close();
            }
        }
    }
}

{'todir', 'ioexception', 'startingdir'}
/** Open a BufferedReader from a named file. */
public static BufferedReader openFile(String fileName) throws IOException {
    return new BufferedReader(new FileReader(fileName));
}

{'bufferedreader'}
/**
     * Check one HTTP link; not recursive. Returns a LinkStatus with
     * boolean success, and the filename or an error message in the
     * message part of the LinkStatus.  The end of this method is one of
     * the few places where a whole raft of different "catch" clauses is
     * actually needed for the intent of the program.
     */
public LinkStatus check(String urlString) {
    URL url;
    HttpURLConnection conn = null;
    HttpURLConnection.setFollowRedirects(false);
    try {
        url = new URL(urlString);
        conn = (HttpURLConnection) url.openConnection();
        switch(conn.getResponseCode()) {
            case 200:
                return new LinkStatus(true, urlString);
            case 403:
                return new LinkStatus(false, "403: " + urlString);
            case 404:
                return new LinkStatus(false, "404: " + urlString);
        }
        conn.getInputStream();
        return new LinkStatus(true, urlString);
    } catch (IllegalArgumentException | MalformedURLException e) {
        return new LinkStatus(false, "Malformed URL: " + urlString);
    } catch (UnknownHostException e) {
        return new LinkStatus(false, "Host invalid/dead: " + urlString);
    } catch (FileNotFoundException e) {
        return new LinkStatus(false, "NOT FOUND (404) " + urlString);
    } catch (ConnectException e) {
        return new LinkStatus(false, "Server not listening: " + urlString);
    } catch (SocketException e) {
        return new LinkStatus(false, e + ": " + urlString);
    } catch (IOException e) {
        return new LinkStatus(false, e.toString());
    } catch (Exception e) {
        return new LinkStatus(false, "Unexpected exception! " + e);
    } finally {
        if (conn != null) {
            conn.disconnect();
        }
    }
}

{'iae', 'determined', 'oracle', 'linkstatus', 'includes', 'throw', 'failing', 'jdk'}
/** Construct a SQLRunner object
     * @param driver String for the JDBC driver
     * @param dbUrl String for the JDBC URL
     * @param user String for the username
     * @param password String for the password, normally in cleartext
     * @param outputMode One of the MODE_XXX constants.
     * @throws ClassNotFoundException
     * @throws SQLException
     */
public SQLRunner(String driver, String dbUrl, String user, String password, String outputFile, String outputMode) throws IOException, ClassNotFoundException, SQLException {
    conn = ConnectionUtil.getConnection(driver, dbUrl, user, password);
    commonSetup(outputFile, outputMode);
}

{'outputmode', 'dburl', 'sqlrunner', 'sqlexception', 'classnotfoundexception'}
/** Set the output mode.
     * @param outputMode Must be a value equal to one of the MODE_XXX values.
     * @throws IllegalArgumentException if the mode is not valid.
     */
void setOutputMode(String outputModeName) {
    if (outputModeName == null || outputModeName.length() == 0) {
        System.err.println("invalid mode: " + outputMode + "; must be t, h or s");
    }
    outputMode = OutputMode.valueOf(outputModeName);
    setOutputMode(outputMode);
}

{'illegalargumentexception', 'outputmode'}
/** Assign the correct ResultsDecorator, creating them on the fly
     * using lazy evaluation.
     */
void setOutputMode(OutputMode outputMode) {
    ResultsDecorator newDecorator = null;
    switch(outputMode) {
        case t:
            newDecorator = textDecorator;
            break;
        case h:
            if (htmlDecorator == null) {
                htmlDecorator = new ResultsDecoratorHTML(out, verbosity);
            }
            newDecorator = htmlDecorator;
            break;
        case s:
            if (sqlDecorator == null) {
                sqlDecorator = new ResultsDecoratorSQL(out, verbosity);
            }
            newDecorator = sqlDecorator;
            break;
        case x:
            if (xmlDecorator == null) {
                xmlDecorator = new ResultsDecoratorXML(out, verbosity);
            }
            newDecorator = xmlDecorator;
            break;
        case j:
            if (jtableDecorator == null) {
                if (gui == null) {
                    throw new IllegalArgumentException("Can't set mode to JTable before calling setGUI()");
                }
                jtableDecorator = new ResultsDecoratorJTable(gui.getJTable(), out, verbosity);
            }
            newDecorator = jtableDecorator;
            break;
        default:
            System.err.println("invalid mode: " + outputMode + "; must be one of: ");
            for (OutputMode t : OutputMode.values()) {
                out.print(t);
                out.print(' ');
            }
            out.println();
    }
    if (currentDecorator != newDecorator) {
        currentDecorator = newDecorator;
        if (debug)
            System.out.println("Mode set to  " + outputMode);
    }
    currentDecorator.setWriter(out);
}

{'resultsdecorator'}
/** Run one script file, by name. Called from cmd line main
     * or from user code. Deprecated because of the poor capability
     * for error handling; it would be better for the user interface
     * code to create a Reader and then say:
     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {
            stmt = stmt.trim();
            try {
                myRunner.runStatement(stmt);
            } catch (Exception e) {
                // Display the message to the user ...
            }
        }
     * </pre>
     * @throws SyntaxException
     */
@Deprecated
public void runScript(String scriptFile) throws IOException, SQLException, SyntaxException {
    BufferedReader is;
    // Load the script file first, it's the most likely error
    is = new BufferedReader(new FileReader(scriptFile));
    runScript(is, scriptFile);
}

{'syntaxexception', 'myrunner', 'sqlrunner', 'runstatement', 'getstatement'}
/** Run one script, by name, given a BufferedReader.
     * Deprecated because of the poor capability
     * for error handling; it would be better for the
     * user interface code to do:
     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {
            stmt = stmt.trim();
            try {
                myRunner.runStatement(stmt);
            } catch (Exception e) {
                // Display the message to the user ...
            }
        }
     * </pre>
     * @throws SyntaxException
     */
@Deprecated
public void runScript(BufferedReader is, String name) throws IOException, SQLException, SyntaxException {
    String stmt;
    while ((stmt = getStatement(is)) != null) {
        stmt = stmt.trim();
        runStatement(stmt);
    }
}

{'bufferedreader', 'getstatement', 'sqlrunner', 'syntaxexception', 'myrunner', 'runstatement'}
/**
     * Process an escape, like "\ms;" for mode=sql.
     * @throws SyntaxException
     */
private void doEscape(String str) throws IOException, SQLException, SyntaxException {
    String rest = null;
    if (str.length() > 2) {
        rest = str.substring(2);
    }
    if (str.startsWith("\\d")) {
        // Display
        if (rest == null) {
            throw new SyntaxException("\\d needs display arg");
        }
        display(rest);
    } else if (str.startsWith("\\m")) {
        // MODE
        if (rest == null) {
            throw new SyntaxException("\\m needs output mode arg");
        }
        setOutputMode(rest);
    } else if (str.startsWith("\\o")) {
        if (rest == null) {
            throw new SyntaxException("\\o needs output file arg");
        }
        setOutputFile(rest);
    } else if (str.startsWith("\\q")) {
        exit(0);
    } else {
        throw new SyntaxException("Unknown escape: " + str);
    }
}

{'syntaxexception'}
/**
     * Display - generate output for \dt and similar escapes
     * @param rest - what to display - the argument with the \d stripped off
     * XXX: Move more formatting to ResultsDecorator: listTables(rs), listColumns(rs)
     */
private void display(String rest) throws IOException, SQLException, SyntaxException {
    // setOutputMode(OutputMode.t);
    if (rest.equals("t")) {
        // Display list of tables
        DatabaseMetaData md = conn.getMetaData();
        ResultSet rs = md.getTables(null, null, "%", new String[] { "TABLE", "VIEW" });
        textDecorator.setWriter(out);
        textDecorator.write(rs);
        textDecorator.flush();
    } else if (rest.startsWith("t")) {
        // Display one table. Some DatabaseMetaData implementations
        // don't do ignorecase so, for now, convert to UPPERCASE.
        String tableName = rest.substring(1).trim();
        if (upperCaseTableNames) {
            tableName = tableName.toUpperCase();
        }
        System.out.println("-- Display table " + tableName);
        DatabaseMetaData md = conn.getMetaData();
        ResultSet rs = md.getColumns(null, null, tableName, "%");
        currentDecorator.displayTable(tableName, rs);
        textDecorator.flush();
    } else
        throw new SyntaxException("\\d" + rest + " invalid");
}

{'setoutputmode', 'listtables', 'outputmode', 'resultsdecorator', 'listcolumns', 'databasemetadata'}
/**
     * @param rs
     * @return
     * @throws SQLException
     */
private static CachedRowSet cacheResultSet(ResultSet rs) throws SQLException {
    //new com.sun.rowset.WebRowSetImpl();
    CachedRowSet rows = null;
    rows.populate(rs);
    return rows;
}

{'sqlexception', 'webrowsetimpl'}
/** Set the output to the given Writer; immediately 
     * update the textDecorator so \dt works...
     * @param writer
     */
public void setOutputFile(PrintWriter writer) {
    out = writer;
    currentDecorator.setWriter(out);
}

{'textdecorator'}
/** Run one Statement, and format results as per Update or Query.
     * Called from runScript or from user code.
     * @throws SyntaxException
     */
public void runStatement(final String rawString) throws IOException, SQLException, SyntaxException {
    final String inString = rawString.trim();
    if (verbosity != Verbosity.QUIET) {
        out.println("Executing : <<" + inString + ">>");
        out.flush();
    }
    currentDecorator.println(String.format("-- output from command -- \"%s\"%n", inString));
    escape = false;
    if (inString.startsWith("\\")) {
        escape = true;
        doEscape(inString);
        return;
    }
    boolean hasResultSet = // DO IT - call the database.
    statement.execute(inString);
    if (!hasResultSet) {
        currentDecorator.printRowCount(statement.getUpdateCount());
    } else {
        int n = currentDecorator.write(cacheResultSet(statement.getResultSet()));
        if (verbosity == Verbosity.VERBOSE || verbosity == Verbosity.DEBUG) {
            currentDecorator.printRowCount(n);
        }
    }
    currentDecorator.flush();
}

{'syntaxexception', 'runscript'}
/* (non-Javadoc)
     * @see ResultsDecorator#getName()
     */
@Override
public String getName() {
    return "Plain text";
}

{'resultsdecorator', 'getname'}
/** Return a printable name for this decorator
     * @see ResultsDecorator#getName()
     */
public String getName() {
    return "HTML";
}

{'resultsdecorator', 'getname'}
/** Print the contents of a ResultSet */
public abstract int write(ResultSet rs) throws IOException, SQLException;

{'resultset'}
/** "main program" method - construct and show */
public static void main(String[] av) {
    // create a BusCard object, tell it to show up
    new BusCard().setVisible(true);
}

{'buscard'}
/** Construct the object including its GUI */
public BusCard() {
    Container cp = getContentPane();
    cp.setLayout(new GridLayout(0, 1));
    addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            setVisible(false);
            dispose();
            System.exit(0);
        }
    });
    JMenuBar mb = new JMenuBar();
    setJMenuBar(mb);
    ResourceBundle b = ResourceBundle.getBundle("i18n.BusCard");
    JMenu aMenu;
    aMenu = I18N.mkMenu(b, "filemenu");
    mb.add(aMenu);
    JMenuItem mi = I18N.mkMenuItem(b, "filemenu", "exit");
    aMenu.add(mi);
    mi.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    aMenu = I18N.mkMenu(b, "editmenu");
    mb.add(aMenu);
    aMenu = I18N.mkMenu(b, "viewmenu");
    mb.add(aMenu);
    aMenu = I18N.mkMenu(b, "optionsmenu");
    mb.add(aMenu);
    aMenu = I18N.mkMenu(b, "helpmenu");
    mb.add(aMenu);
    //mb.setHelpMenu(aMenu);        // needed for portability (Motif, etc.).
    setTitle(I18N.getString(b, "card" + ".company", "TITLE"));
    JPanel p1 = new JPanel();
    p1.setLayout(new GridLayout(0, 1, 50, 10));
    nameTF = new JLabel("My Name", JLabel.CENTER);
    nameTF.setFont(new Font("helvetica", Font.BOLD, 18));
    nameTF.setText(I18N.getString(b, "card" + ".myname", "MYNAME"));
    p1.add(nameTF);
    jobChoice = new JComboBox<>();
    jobChoice.setFont(new Font("helvetica", Font.BOLD, 14));
    // Get Job Titles from the Properties file loaded into "b"!
    String next;
    int i = 1;
    do {
        next = I18N.getString(b, "job_title" + i++, null);
        if (next != null)
            jobChoice.addItem(next);
    } while (next != null);
    p1.add(jobChoice);
    cp.add(p1);
    JPanel p2 = new JPanel();
    p2.setLayout(new GridLayout(2, 2, 10, 10));
    B1 = new JButton();
    B1.setText(I18N.getString(b, "button1.label", "BUTTON LABEL"));
    p2.add(B1);
    B2 = new JButton();
    B2.setText(I18N.getString(b, "button2.label", "BUTTON LABEL"));
    p2.add(B2);
    B3 = new JButton();
    B3.setText(I18N.getString(b, "button3.label", "BUTTON LABEL"));
    p2.add(B3);
    B4 = new JButton();
    B4.setText(I18N.getString(b, "button4.label", "BUTTON LABEL"));
    p2.add(B4);
    cp.add(p2);
    pack();
}

{'sethelpmenu', 'amenu'}
/** "main program" method - construct and show */
public static void main(String[] av) {
    // create an MenuIntl object, tell it to show up
    new MenuIntl().setVisible(true);
}

{'menuintl'}
/** Construct the object including its GUI */
public MenuIntl() {
    super("MenuIntlTest");
    // used in various spots
    JMenuItem mi;
    Container cp = getContentPane();
    cp.setLayout(new FlowLayout());
    JLabel lab;
    cp.add(lab = new JLabel());
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    JMenuBar mb = new JMenuBar();
    setJMenuBar(mb);
    ResourceBundle b = ResourceBundle.getBundle("i18n.Widgets");
    String titlebar;
    try {
        titlebar = b.getString("program" + ".title");
    } catch (MissingResourceException e) {
        titlebar = "MenuIntl Demo";
    }
    setTitle(titlebar);
    String message;
    try {
        message = b.getString("program" + ".message");
    } catch (MissingResourceException e) {
        message = "Welcome to the world of Java";
    }
    lab.setText(message);
    JMenu fm = mkMenu(b, "file");
    // In finished code there would be a call to
    // mi.addActionListener(...) after *each* of
    // these mkMenuItem calls!
    fm.add(mi = mkMenuItem(b, "file", "open"));
    fm.add(mi = mkMenuItem(b, "file", "new"));
    fm.add(mi = mkMenuItem(b, "file", "save"));
    fm.add(mi = mkMenuItem(b, "file", "exit"));
    mi.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            MenuIntl.this.setVisible(false);
            MenuIntl.this.dispose();
            System.exit(0);
        }
    });
    mb.add(fm);
    JMenu vm = mkMenu(b, "view");
    vm.add(mi = mkMenuItem(b, "view", "tree"));
    vm.add(mi = mkMenuItem(b, "view", "list"));
    vm.add(mi = mkMenuItem(b, "view", "longlist"));
    mb.add(vm);
    JMenu hm = mkMenu(b, "help");
    hm.add(mi = mkMenuItem(b, "help", "about"));
    // mb.setHelpMenu(hm);    // needed for portability (Motif, etc.).
    // the main window
    JLabel jl = new JLabel("Menu Demo Window");
    jl.setSize(200, 150);
    cp.add(jl);
    pack();
}

{'mkmenuitem', 'sethelpmenu', 'addactionlistener'}
/** Convenience routine to make a JMenu */
public JMenu mkMenu(ResourceBundle b, String name) {
    String menuLabel;
    try {
        menuLabel = b.getString(name + ".label");
    } catch (MissingResourceException e) {
        menuLabel = name;
    }
    return new JMenu(menuLabel);
}

{'jmenu'}
/** Convenience routine to make a JMenuItem */
public JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {
    String miLabel;
    try {
        miLabel = b.getString(menu + "." + name + ".label");
    } catch (MissingResourceException e) {
        miLabel = name;
    }
    String key = null;
    try {
        key = b.getString(menu + "." + name + ".key");
    } catch (MissingResourceException e) {
        key = null;
    }
    if (key == null)
        return new JMenuItem(miLabel);
    else
        return new JMenuItem(miLabel, key.charAt(0));
}

{'jmenuitem'}
public static void main(String[] args) {
    switch(args.length) {
        case 0:
            Locale.setDefault(Locale.FRANCE);
            break;
        case 1:
            throw new IllegalArgumentException();
        case 2:
            Locale.setDefault(new Locale(args[0], args[1]));
            break;
        default:
            System.out.println("Usage: SetLocale [language [country]]");
    }
    DateFormat df = DateFormat.getInstance();
    NumberFormat nf = NumberFormat.getInstance();
    System.out.println(df.format(new Date()));
    System.out.println(nf.format(123.4567));
}

{'fallthrough'}
/** main program: instantiate and show. 
     * @throws IOException */
public static void main(String[] av) throws Exception {
    SwingUtilities.invokeLater(new Runnable() {

        public void run() {
            try {
                new PrintServiceDemo("Print Demo").setVisible(true);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    });
}

{'ioexception'}
/** Print a file by name 
     * @throws IOException
     * @throws PrintException 
     */
public void print(String fileName) throws IOException, PrintException {
    System.out.println("PrintServiceDemo.print(): Printing " + fileName);
    DocFlavor flavor = DocFlavor.INPUT_STREAM.TEXT_PLAIN_UTF_8;
    PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
    //aset.add(MediaSize.NA.LETTER);
    aset.add(MediaSizeName.NA_LETTER);
    //aset.add(new JobName(INPUT_FILE_NAME, null));
    PrintService[] pservices = PrintServiceLookup.lookupPrintServices(flavor, aset);
    int i;
    switch(pservices.length) {
        case 0:
            System.err.println(0);
            JOptionPane.showMessageDialog(PrintServiceDemo.this, "Error: No PrintService Found", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        case 1:
            // Only one printer, use it.
            i = 0;
            break;
        default:
            i = JOptionPane.showOptionDialog(this, "Pick a printer", "Choice", JOptionPane.OK_OPTION, JOptionPane.QUESTION_MESSAGE, null, pservices, pservices[0]);
            break;
    }
    DocPrintJob pj = pservices[i].createPrintJob();
    InputStream is = getClass().getResourceAsStream(INPUT_FILE_NAME);
    if (is == null) {
        throw new NullPointerException("Input Stream is null: file not found?");
    }
    Doc doc = new SimpleDoc(is, flavor, null);
    pj.print(doc, aset);
}

{'jobname', 'mediasize', 'ioexception', 'printexception'}
public static void main(String[] argv) throws IOException {
    // Ensure that a filename (or something) was given in argv[0]
    if (argv.length == 0) {
        System.err.println("Usage: Creat filename");
        System.exit(1);
    }
    for (String a : argv) {
        // Constructing a File object doesn't affect the disk, but
        // the createNewFile() method does.
        new File(a).createNewFile();
    }
}

{'createnewfile'}
/** doName - handle one filesystem object by name */
private void doName(String s) {
    Debug.println("flow", "doName(" + s + ")");
    File f = new File(s);
    if (!f.exists()) {
        System.out.println(s + " does not exist");
        return;
    }
    if (f.isFile())
        doFile(f);
    else if (f.isDirectory()) {
        // System.out.println("d " + f.getPath());
        String objects[] = f.list(filter);
        for (String o : objects) doName(s + File.separator + o);
    } else
        System.err.println("Unknown type: " + s);
}

{'getpath', 'doname'}
/** doFile - process one regular file. */
private static void doFile(File f) {
    System.out.println("f " + f.getPath());
}

{'dofile'}
/** Do the filtering. For now, only filter on name */
public boolean accept(File dir, String fileName) {
    File f = new File(dir, fileName);
    if (f.isDirectory()) {
        // allow recursion
        return true;
    }
    if (nameRE != null) {
        return nameRE.matcher(fileName).matches();
    }
    // Catchall
    return false;
}

{'size', 'todo', 'handling'}
/** un-serialize an Object from a byte array. */
protected Object toObject(byte[] b) throws IOException {
    Object o;
    ByteArrayInputStream bi = new ByteArrayInputStream(b);
    ObjectInputStream os = new ObjectInputStream(bi);
    try {
        o = os.readObject();
    } catch (ClassNotFoundException ex) {
        throw new IOException(ex.getMessage());
    }
    os.close();
    return o;
}

{'error', 'convert', 'classnotfoundexception'}
/**
     * Parse one or more XML documents with optional validation.
     * <b>Note:</b> It is an unpleasant limitation of javax.xml.validation that parsing DTD-based documents can
     * extract the DTD name/location and use it, whereas Schema(etc)-based validation requires the user to do
     * this manually before invoking the parser.
     * @param av Command args, may include -v for validation, and -a schema.xsd, before the filename(s);
     * all documents parsed in this run must use the same Schema.
     * @throws SAXException
     */
// BEGIN main
public static void main(String[] av) throws SAXException {
    if (av.length == 0) {
        System.err.println("Usage: XParse file");
        return;
    }
    boolean validate = false;
    Schema schema = null;
    try {
        for (int i = 0; i < av.length; i++) {
            if (av[i].equals("-v"))
                validate = true;
            else if (av[i].equals("-a")) {
                // "create a SchemaFactory capable of understanding W3C schemas"
                //   -- from the Javadoc page
                SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
                // load the W3c XML schema, represented by a Schema instance
                String schemaLocation = av[++i];
                File schemaFile = new File(schemaLocation);
                if (!schemaFile.exists()) {
                    throw new IOException("Schema location = " + schemaLocation + " does not exist");
                }
                schema = schemaFactory.newSchema(schemaFile);
            } else {
                File xmlFile = new File(av[i]);
                System.err.println("Parsing " + xmlFile.getAbsolutePath() + "...");
                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
                if (validate) {
                    if (schema != null) {
                        dbFactory.setSchema(schema);
                    } else {
                        dbFactory.setValidating(true);
                        dbFactory.setNamespaceAware(true);
                        dbFactory.setAttribute("http://java.sun.com/xml/jaxp/properties/schemaLanguage", XMLConstants.W3C_XML_SCHEMA_NS_URI);
                    }
                }
                DocumentBuilder parser = dbFactory.newDocumentBuilder();
                // If not using schema, Get local copies of DTDs...
                if (schema == null) {
                    parser.setEntityResolver(new MyDTDResolver());
                }
                parser.parse(xmlFile);
                System.out.println("Parsed/Validated OK");
            }
        }
    // Just +catch+ statements below here...
    // END main
    } catch (SAXParseException ex) {
        System.err.println("+================================+");
        System.err.println("|       *SAX Parse Error*        |");
        System.err.println("+================================+");
        System.err.println(ex.toString());
        System.err.println("At line " + ex.getLineNumber());
    } catch (Exception ex) {
        System.err.println("+================================+");
        System.err.println("|           *XML Error*          |");
        System.err.println("+================================+");
        ex.printStackTrace();
    }
}

{'dtds', 'schemafactory'}
public void startElement(String nsURI, String localName, String rawName, Attributes attributes) throws SAXException {
    if (DEBUG) {
        System.out.println("startElement: " + localName + "," + rawName);
    }
    // Consult rawName since we aren't using xmlns prefixes here.
    if (rawName.equalsIgnoreCase("name"))
        person = true;
    if (rawName.equalsIgnoreCase("email"))
        email = true;
}

{'rawname'}
public static void main(String argv[]) throws IOException {
    // BEGIN main
    // A Runtime object has methods for dealing with the OS
    Runtime r = Runtime.getRuntime();
    // Process tracks one external native process
    Process p;
    // reader for output of process
    BufferedReader is;
    String line;
    // Our argv[0] contains the program to run; remaining elements
    // of argv contain args for the target program. This is just
    // what is needed for the String[] form of exec.
    p = r.exec(argv);
    System.out.println("In Main after exec");
    // getInputStream gives an Input stream connected to
    // the process p's standard output. Just use it to make
    // a BufferedReader to readLine() what the program writes out.
    is = new BufferedReader(new InputStreamReader(p.getInputStream()));
    while ((line = is.readLine()) != null) System.out.println(line);
    System.out.println("In Main after EOF");
    System.out.flush();
    try {
        // wait for process to complete
        p.waitFor();
    } catch (InterruptedException e) {
        System.err.println(e);
        return;
    }
    System.err.println("Process done, exit status was " + p.exitValue());
// END main
}

{'getinputstream', 'thappen', 'readline', 'bufferedreader'}
@Override
public Object eval(Reader reader, ScriptContext context) throws ScriptException {
    System.out.println("CalcScriptEngine.eval()");
    // return eval(scriptString, context);
    throw new IllegalStateException("eval(Reader) not written yet");
}

{'read', 'file', 'scriptstring'}
public void run() {
    try {
        p.waitFor();
    } catch (InterruptedException ex) {
        return;
    }
    System.out.println("Program terminated!");
    done = true;
}

{'ok', 'quit'}
public static void main(String argv[]) throws IOException {
    // Process tracks one external native process
    final Process p;
    // reader for output of process
    BufferedReader is;
    String line;
    p = Runtime.getRuntime().exec(PROGRAM);
    Debug.println("exec", "In Main after exec");
    // Optional: start a thread to wait for the process to terminate.
    // Don't just wait in main line, but here set a "done" flag and
    // use that to control the main reading loop below.
    Thread waiter = new Thread() {

        public void run() {
            try {
                p.waitFor();
            } catch (InterruptedException ex) {
                return;
            }
            System.out.println("Program terminated!");
            done = true;
        }
    };
    waiter.start();
    // getInputStream gives an Input stream connected to
    // the process p's standard output (and vice versa). We use
    // that to construct a BufferedReader so we can readLine() it.
    is = new BufferedReader(new InputStreamReader(p.getInputStream()));
    while (!done && ((line = is.readLine()) != null)) System.out.println(line);
    Debug.println("exec", "In Main after EOF");
    return;
}

{'getinputstream', 'readline', 'ok', 'quit', 'bufferedreader'}
public static void main(String[] args) throws ScriptException {
    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    // Print list of supported languages
    scriptEngineManager.getEngineFactories().forEach( factory -> System.out.println(factory.getLanguageName()));
    // Run a script in the JavaScript language
    String lang = "ECMAScript";
    ScriptEngine engine = scriptEngineManager.getEngineByName(lang);
    if (engine == null) {
        System.err.println("Could not find engine");
        return;
    }
    engine.eval("print(\"Hello from " + lang + "\");");
}

{'javascript'}
public static void main(String[] args) throws IOException {
    // The RE pattern
    Pattern patt = Pattern.compile("[A-Za-z][a-z]+");
    // A FileReader (see the I/O chapter)
    BufferedReader r = new BufferedReader(new FileReader(args[0]));
    // For each line of input, try matching in it.
    String line;
    while ((line = r.readLine()) != null) {
        // For each match in the line, extract and print it.
        Matcher m = patt.matcher(line);
        while (m.find()) {
            // Simplest method:
            // System.out.println(m.group(0));
            // Get the starting position of the text
            int start = m.start(0);
            // Get ending position
            int end = m.end(0);
            // Print whatever matched.
            // Use CharacterIterator.substring(offset, end);
            System.out.println(line.substring(start, end));
        }
    }
}

{'characteriterator', 'filereader'}
static void process(Pattern pattern, String fileName) throws IOException {
    // Get a FileChannel from the given file.
    FileChannel fc = new FileInputStream(fileName).getChannel();
    // Map the file's content
    ByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
    // Decode ByteBuffer into CharBuffer
    CharBuffer cbuf = Charset.forName("ISO-8859-1").newDecoder().decode(buf);
    Matcher m = pattern.matcher(cbuf);
    while (m.find()) {
        System.out.println(m.group(0));
    }
}

{'filechannel', 'bytebuffer', 'charbuffer'}
/** Grab the sales rank off the web page and log it. */
public static void main(String[] args) throws Exception {
    Properties p = new Properties();
    p.load(new FileInputStream(args.length == 0 ? "bookrank.properties" : args[1]));
    String title = p.getProperty("title", "NO TITLE IN PROPERTIES");
    // The url must have the "isbn=" at the very end, or otherwise
    // be amenable to being string-catted to, like the default.
    String url = p.getProperty("url", "http://test.ing/test.cgi?isbn=");
    // The 10-digit ISBN for the book.
    String isbn = p.getProperty("isbn", "0000000000");
    // The RE pattern (MUST have ONE capture group for the number)
    String pattern = p.getProperty("pattern", "Rank: (\\d+)");
    int rank = getBookRank(isbn);
    System.out.println("Rank is " + rank);
    // Now try to draw the graph, using external
    // plotting program against all historical data.
    // Could use gnuplot, R, any other math/graph program.
    // Better yet: use one of the Java plotting APIs.
    PrintWriter pw = new PrintWriter(new FileWriter(DATA_FILE, true));
    String date = new SimpleDateFormat("MM dd hh mm ss yyyy ").format(new Date());
    pw.println(date + " " + rank);
    pw.close();
    String gnuplot_cmd = "set term png\n" + "set output \"" + GRAPH_FILE + "\"\n" + "set xdata time\n" + "set ylabel \"Book sales rank\"\n" + "set bmargin 3\n" + "set logscale y\n" + "set yrange [1:60000] reverse\n" + "set timefmt \"%m %d %H %M %S %Y\"\n" + "plot \"" + DATA_FILE + "\" using 1:7 title \"" + title + "\" with lines\n";
    if (!new File(PLOTTER_PROG).exists()) {
        System.out.println("Plotting software not installed");
        return;
    }
    Process proc = Runtime.getRuntime().exec(PLOTTER_PROG);
    PrintWriter gp = new PrintWriter(proc.getOutputStream());
    gp.print(gnuplot_cmd);
    gp.close();
}

{'apis'}
/**
     * Look for something like this in the HTML input:
     *     <b>Sales Rank:</b> 
     *     #26,252
     *      </font><br>
     * @throws IOException 
     * @throws IOException 
     */
public static int getBookRank(String isbn) throws IOException {
    // The RE pattern - digits and commas allowed
    final String pattern = "Rank:</b> #([\\d,]+)";
    final Pattern r = Pattern.compile(pattern);
    // The url -- must have the "isbn=" at the very end, or otherwise
    // be amenable to being appended to.
    final String url = "http://www.amazon.com/exec/obidos/ASIN/" + isbn;
    // Open the URL and get a Reader from it.
    final BufferedReader is = new BufferedReader(new InputStreamReader(new URL(url).openStream()));
    // Read the URL looking for the rank information, as
    // a single long string, so can match RE across multi-lines.
    final String input = readerToString(is);
    // If found, append to sales data file.
    Matcher m = r.matcher(input);
    if (m.find()) {
        // Paren 1 is the digits (and maybe ','s) that matched; remove comma
        return Integer.parseInt(m.group(1).replace(",", ""));
    } else {
        throw new RuntimeException("Pattern not matched in `" + url + "'!");
    }
}

{'ioexception'}
public static void main(String[] argv) {
    // Make an RE pattern to match as a word only (\b=word boundary)
    String patt = "\\bfavor\\b";
    // A test input.
    String input = "Do me a favor? Fetch my favorite.";
    System.out.println("Input: " + input);
    // Run it from a RE instance and see that it works
    Pattern r = Pattern.compile(patt);
    Matcher m = r.matcher(input);
    System.out.println("ReplaceAll: " + m.replaceAll("favour"));
    // Show the appendReplacement method
    m.reset();
    StringBuffer sb = new StringBuffer();
    System.out.print("Append methods: ");
    while (m.find()) {
        // Copy to before first match,
        // plus the word "favor"
        m.appendReplacement(sb, "favour");
    }
    // copy remainder
    m.appendTail(sb);
    System.out.println(sb.toString());
}

{'appendreplacement'}
public static void main(String[] argv) {
    String hostName;
    if (argv.length == 0)
        hostName = "localhost";
    else
        hostName = argv[0];
    try {
        Socket sock = new Socket(hostName, TIME_PORT);
        DataInputStream is = new DataInputStream(new BufferedInputStream(sock.getInputStream()));
        // Read 4 bytes from the network, unsigned.
        // Do it yourself; there is no readUnsignedInt().
        // Long is 8 bytes on Java, but we are using the
        // existing time protocol, which uses 4-byte ints.
        long remoteTime = (((long) (is.readUnsignedByte()) << 24) | ((long) (is.readUnsignedByte()) << 16) | ((long) (is.readUnsignedByte()) << 8) | ((long) (is.readUnsignedByte()) << 0));
        System.out.println("Remote time is " + remoteTime);
        System.out.println("BASE_DIFF is " + BASE_DIFF);
        System.out.println("Time diff == " + (remoteTime - BASE_DIFF));
        Date d = new Date((remoteTime - BASE_DIFF) * MSEC);
        System.out.println("Time on " + hostName + " is " + d.toString());
        System.out.println("Local date/time = " + LocalDateTime.now());
    } catch (IOException e) {
        System.err.println(e);
    }
}

{'readunsignedint'}
public static void main(String[] args) throws IOException {
    String hostName = "www.darwinsys.com";
    // currently a well-known Google DNS server
    String ipNumber = "8.8.8.8";
    // Show getting the InetAddress (looking up a host) by host name
    System.out.println(hostName + "'s address is " + InetAddress.getByName(hostName).getHostAddress());
    // Look up a host by address
    System.out.println(ipNumber + "'s name is " + InetAddress.getByName(ipNumber).getHostName());
    // Look up my localhost addresss
    final InetAddress localHost = InetAddress.getLocalHost();
    System.out.println("My localhost address is " + localHost);
    // Show getting the InetAddress from an open Socket
    String someServerName = "www.google.com";
    // assuming there's a web server on the named server:
    Socket theSocket = new Socket(someServerName, 80);
    InetAddress remote = theSocket.getInetAddress();
    System.out.printf("The InetAddress for %s is %s%n", someServerName, remote);
}

{'inetaddress'}
/** Get an HTTPS ServerSocket using JSSE.
     * @see WebServer0#getServerSocket(int)
     * @throws ClassNotFoundException if the SecurityProvider cannot be instantiated.
     */
protected ServerSocket getServerSocket(int port) throws Exception {
    SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
    return ssf.createServerSocket(port);
}

{'securityprovider', 'serversocket', 'webserverD', 'getserversocket', 'classnotfoundexception'}
/** Construct an EchoServer on the given port number */
public EchoServer(int port) {
    try {
        sock = new ServerSocket(port);
    } catch (IOException e) {
        System.err.println("I/O error in setup");
        System.err.println(e);
        System.exit(1);
    }
}

{'echoserver'}
/** This handles the connections */
protected void handle() {
    Socket ios = null;
    BufferedReader is = null;
    PrintWriter os = null;
    while (true) {
        try {
            System.out.println("Waiting for client...");
            ios = sock.accept();
            System.err.println("Accepted from " + ios.getInetAddress().getHostName());
            is = new BufferedReader(new InputStreamReader(ios.getInputStream(), "8859_1"));
            os = new PrintWriter(new OutputStreamWriter(ios.getOutputStream(), "8859_1"), true);
            String echoLine;
            while ((echoLine = is.readLine()) != null) {
                System.err.println("Read " + echoLine);
                os.print(echoLine + "\r\n");
                os.flush();
                System.err.println("Wrote " + echoLine);
            }
            System.err.println("All done!");
        } catch (IOException e) {
            System.err.println(e);
        } finally {
            try {
                if (is != null)
                    is.close();
                if (os != null)
                    os.close();
                if (ios != null)
                    ios.close();
            } catch (IOException e) {
                System.err.println("IO Error in close");
            }
        }
    }
/*NOTREACHED*/
}

{'indicate', 'end', 'might', 'filled', 'shut', 'unlikely', 'disk', 'detected', 'etc', 'early'}
public static void main(String[] a) throws IOException {
    Enumeration list = NetworkInterface.getNetworkInterfaces();
    while (list.hasMoreElements()) {
        // Get one NetworkInterface
        NetworkInterface iface = (NetworkInterface) list.nextElement();
        // Print its name
        System.out.println(iface.getDisplayName());
        Enumeration addrs = iface.getInetAddresses();
        // And its address(es)
        while (addrs.hasMoreElements()) {
            InetAddress addr = (InetAddress) addrs.nextElement();
            System.out.println(addr);
        }
    }
    // Try to get the Interface for a given local (this machine's) address
    InetAddress destAddr = InetAddress.getByName("laptop");
    try {
        NetworkInterface dest = NetworkInterface.getByInetAddress(destAddr);
        System.out.println("Address for " + destAddr + " is " + dest);
    } catch (SocketException ex) {
        System.err.println("Couldn't get address for " + destAddr);
    }
}

{'networkinterface'}
public void runServer() {
    ServerSocket sock;
    Socket clientSocket;
    try {
        sock = new ServerSocket(ECHOPORT);
        System.out.println("EchoServerThreaded ready for connections.");
        /* Wait for a connection */
        while (true) {
            clientSocket = sock.accept();
            /* Create a thread to do the communication, and start it */
            new Handler(clientSocket).start();
        }
    } catch (IOException e) {
        System.err.println("Could not accept " + e);
        System.exit(1);
    }
}

{'happened', 'crash', 'fails', 'something', 'bad'}
/** Constructor */
public EchoServerThreaded2(int port, int numThreads) {
    ServerSocket servSock;
    try {
        servSock = new ServerSocket(port);
    } catch (IOException e) {
        throw new RuntimeException("Could not create ServerSocket ", e);
    }
    // Create a series of threads and start them.
    for (int i = 0; i < numThreads; i++) {
        new Handler(servSock, i).start();
    }
}

{'happened', 'crash', 'fails', 'something', 'bad'}
public void run() {
    /* Wait for a connection. Synchronized on the ServerSocket
             * while calling its accept() method.
             */
    while (true) {
        try {
            System.out.println(getName() + " waiting");
            Socket clientSocket;
            // Wait here for the next connection.
            synchronized (servSock) {
                clientSocket = servSock.accept();
            }
            System.out.println(getName() + " starting, IP=" + clientSocket.getInetAddress());
            BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            PrintStream os = new PrintStream(clientSocket.getOutputStream(), true);
            String line;
            while ((line = is.readLine()) != null) {
                os.print(line + "\r\n");
                os.flush();
            }
            System.out.println(getName() + " ENDED ");
            clientSocket.close();
        } catch (IOException ex) {
            System.out.println(getName() + ": IO Error on socket " + ex);
            return;
        }
    }
}

{'serversocket'}
/**
     * Main method, just creates a server and call its runServer().
     */
public static void main(String[] argv) throws Exception {
    System.out.println("DarwinSys JavaWeb Server 0.0 starting...");
    WebServer0 w = new WebServer0();
    // never returns!!
    w.runServer(HTTP);
}

{'runserver'}
/** Get the actual ServerSocket; deferred until after Constructor
     * so subclass can mess with ServerSocketFactory (e.g., to do SSL).
     * @param port The port number to listen on
     */
protected ServerSocket getServerSocket(int port) throws Exception {
    return new ServerSocket(port);
}

{'serversocket', 'serversocketfactory'}
/** RunServer accepts connections and passes each one to handler. */
public void runServer(int port) throws Exception {
    s = getServerSocket(port);
    while (true) {
        try {
            Socket us = s.accept();
            Handler(us);
        } catch (IOException e) {
            System.err.println(e);
            return;
        }
    }
}

{'runserver'}
/** Handler() handles one conversation with a Web client.
     * This is the only part of the program that "knows" HTTP.
     */
public void Handler(Socket s) {
    // inputStream, from Viewer
    BufferedReader is;
    // outputStream, to Viewer
    PrintWriter os;
    // what Viewer sends us.
    String request;
    try {
        String from = s.getInetAddress().toString();
        System.out.println("Accepted connection from " + from);
        is = new BufferedReader(new InputStreamReader(s.getInputStream()));
        request = is.readLine();
        System.out.println("Request: " + request);
        os = new PrintWriter(s.getOutputStream(), true);
        os.print("HTTP/1.0 200 Here is your data" + CRLF);
        os.print("Content-type: text/html" + CRLF);
        os.print("Server-name: DarwinSys NULL Java WebServer 0" + CRLF);
        String reply1 = "<html><head>" + "<title>Wrong System Reached</title></head>\n" + "<h1>Welcome, ";
        String reply2 = ", but...</h1>\n" + "<p>You have reached a desktop machine " + "that does not run a real Web service.\n" + "<p>Please pick another system!</p>\n" + "<p>Or view <a href=\"" + VIEW_SOURCE_URL + "\">" + "the WebServer0 source on github</a>.</p>\n" + "<hr/><em>Java-based WebServer0</em><hr/>\n" + "</html>\n";
        os.print("Content-length: " + (reply1.length() + from.length() + reply2.length()) + CRLF);
        os.print(CRLF);
        os.print(reply1 + from + reply2 + CRLF);
        os.flush();
        s.close();
    } catch (IOException e) {
        System.out.println("IOException " + e);
    }
    return;
}

{'outputstream', 'inputstream'}
/** Construct a DaytimeServer on the given port number */
public DaytimeServer(int port) {
    try {
        sock = new ServerSocket(port);
    } catch (IOException e) {
        System.err.println("I/O error in setup\n" + e);
        System.exit(1);
    }
}

{'daytimeserver'}
/** The main program that drives this network client.
     * @param argv[0] hostname, running daytime/udp server
     */
public static void main(String[] argv) throws IOException {
    if (argv.length < 1) {
        System.err.println("usage: java DayTimeUDP host");
        System.exit(1);
    }
    String host = argv[0];
    InetAddress servAddr = InetAddress.getByName(host);
    DatagramSocket sock = new DatagramSocket();
    //sock.connect(servAddr, DAYTIME_PORT);
    byte[] buffer = new byte[PACKET_SIZE];
    // The udp packet we will send and receive
    DatagramPacket packet = new DatagramPacket(buffer, PACKET_SIZE, servAddr, DAYTIME_PORT);
    /* Send empty max-length (-1 for null byte) packet to server */
    packet.setLength(PACKET_SIZE - 1);
    sock.send(packet);
    System.out.println("Sent request");
    // Receive a packet and print it.
    sock.receive(packet);
    System.out.println("Got packet of size " + packet.getLength());
    System.out.print("Date on " + host + " is " + new String(buffer, 0, packet.getLength()));
    sock.close();
}

{'servaddr'}
/** Construct the object that implements the remote server.
     * Called from main, after it has the SecurityManager in place.
     */
public TickerServerImpl() throws RemoteException {
    // sets up networking
    super();
}

{'securitymanager'}
public void run() {
    while (!done) {
        try {
            Thread.sleep(10 * 1000);
            System.out.println("Tick");
        } catch (InterruptedException unexpected) {
            System.out.println("WAHHH!");
            done = true;
        }
        Iterator it = list.iterator();
        while (it.hasNext()) {
            String mesg = ("Your stock price went " + (rand.nextFloat() > 0.5 ? "up" : "down") + "!");
            // If this fails, remove them from the list
            try {
                ((Client) it.next()).alert(mesg);
            } catch (RemoteException re) {
                System.out.println("Exception alerting client, removing it.");
                System.out.println(re);
                it.remove();
            }
        }
    }
}

{'user', 'given', 'send'}
public void actionPerformed(ActionEvent evt) {
    if (netConn == null) {
        showStatus("Connection failed, bye");
        return;
    }
    try {
        Date today = netConn.getRemoteDate();
        // XX use a DateFormat...
        showStatus(today.toString());
    } catch (Exception ex) {
        System.err.println("RemoteDate exception: " + ex.getMessage());
        showStatus("RemoteDate failed, see Java Console");
    }
}

{'dateformat'}
public void init() {
    try {
        netConn = (RemoteDate) Naming.lookup(RemoteDate.LOOKUPNAME);
    } catch (Exception e) {
        System.err.println("RemoteDate exception: " + e.getMessage());
        e.printStackTrace();
    }
    add(b = new Button("Get Date"));
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            if (netConn == null) {
                showStatus("Connection failed, bye");
                return;
            }
            try {
                Date today = netConn.getRemoteDate();
                // XX use a DateFormat...
                showStatus(today.toString());
            } catch (Exception ex) {
                System.err.println("RemoteDate exception: " + ex.getMessage());
                showStatus("RemoteDate failed, see Java Console");
            }
        }
    });
}

{'dateformat'}
public static void main(String[] args) {
    try {
        // Create an instance of the server object
        RemoteDateImpl im = new RemoteDateImpl();
        System.out.println("DateServer starting...");
        // Publish it in the RMI registry.
        // Of course you have to have rmiregistry or equivalent running!
        Naming.rebind(RemoteDate.LOOKUPNAME, im);
        System.out.println("DateServer ready.");
    } catch (Exception e) {
        System.err.println(e);
        System.exit(1);
    }
}

{'want', 'securitymanager', 'TIME', 'setsecuritymanager', 'downloading', 'rmisecuritymanager', 'class'}
public static void main(String[] args) {
    try {
        netConn = (RemoteDate) Naming.lookup(RemoteDate.LOOKUPNAME);
        Date today = netConn.getRemoteDate();
        // Could use a DateFormat...
        System.out.println(today.toString());
    } catch (Exception e) {
        System.err.println("RemoteDate exception: " + e.getMessage());
        e.printStackTrace();
    }
}

{'dateformat'}
/** Construct the object that implements the remote server.
     * Called from main, after it has the SecurityManager in place.
     */
public RemoteDateImpl() throws RemoteException {
    // sets up networking
    super();
}

{'securitymanager'}
BSFAction() {
    // Construct the Bean instance
    LabelText bean = new LabelText("Message to Python script");
    try {
        manager = new BSFManager();
        // register scripting language
        String[] fntypes = { ".py" };
        BSFManager.registerScriptingEngine("jpython", "org.apache.bsf.engines.jpython.JPythonEngine", fntypes);
        jpythonengine = manager.loadScriptingEngine("jpython");
        // Tell BSF about the bean.
        manager.declareBean("bean", bean, LabelText.class);
        // Read the script file into BSF
        language = BSFManager.getLangFromFilename(FILENAME);
        script = FileIO.readerToString(new FileReader(FILENAME));
    } catch (Exception ex) {
        System.err.println(ex.toString());
        return;
    }
    System.out.println("Scripting setup done, building GUI.");
    final JFrame jf = new JFrame(getClass().getName());
    Container cp = jf.getContentPane();
    cp.setLayout(new FlowLayout());
    // add the LabelText
    cp.add(bean);
    JButton b = new JButton("Click me!");
    // and the button under it.
    cp.add(b);
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            try {
                // When the button is pressed, run the script.
                System.out.println("Script output: -->");
                manager.exec(language, FILENAME, 0, 0, script);
                System.out.println("<-- End of Script output.");
            } catch (BSFException bse) {
                JOptionPane.showMessageDialog(jf, "ERROR: " + bse, "Script Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    });
    // A Quit button at the bottom
    JButton qb = new JButton("Quit");
    cp.add(qb);
    qb.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            System.exit(0);
        }
    });
    // Routine JFrame setup
    jf.pack();
    jf.setVisible(true);
}

{'jframe', 'labeltext'}
/** Construct a TeePrintStream given an existing PrintStream,
     * an opened OutputStream, and a boolean to control auto-flush.
     * This is the main constructor, to which others delegate via "this".
     */
public TeePrintStream(PrintStream orig, OutputStream os, boolean flush) throws IOException {
    super(os, true);
    fileName = UNKNOWN_NAME;
    parent = orig;
}

{'outputstream', 'printstream', 'teeprintstream'}
/** Construct a TeePrintStream given an existing PrintStream and
     * an opened OutputStream.
     */
public TeePrintStream(PrintStream orig, OutputStream os) throws IOException {
    this(orig, os, true);
}

{'printstream', 'outputstream', 'teeprintstream'}
/* Construct a TeePrintStream given an existing Stream and a filename.
     */
public TeePrintStream(PrintStream os, String fn) throws IOException {
    this(os, fn, true);
}

{'teeprintstream'}
/* Construct a TeePrintStream given an existing Stream, a filename,
     * and a boolean to control the flush operation.
     */
public TeePrintStream(PrintStream orig, String fn, boolean flush) throws IOException {
    this(orig, new FileOutputStream(fn), flush);
    fileName = fn;
}

{'teeprintstream'}
/** Construct from a Reader and a PrintWriter
     */
public SimpleCalcStreamTok(Reader in, PrintWriter out) throws IOException {
    this(in);
    setOutput(out);
}

{'printwriter'}
/** This constructor is required by most APIs  */
public MyData() {
// Nothing to do
}

{'apis'}
/** Read one real line. Provided as a convenience for the
     * subclasses, so they don't embarrass themselves trying to
     * call "super.readLine()" which isn't very practical...
     */
public String readPhysicalLine() throws IOException {
    return super.readLine();
}

{'readline'}
/** Construct a ContLineReader with the default input-buffer size. */
public ContLineReader(Reader in) {
    super(in);
}

{'contlinereader'}
/** Construct a ContLineReader using the given input-buffer size. */
public ContLineReader(Reader in, int sz) {
    super(in, sz);
}

{'contlinereader'}
/** Constructor: save filename, construct RandomAccessFile */
public ReadRandom(String fname) throws IOException {
    fileName = fname;
    seeker = new RandomAccessFile(fname, "r");
}

{'randomaccessfile'}
/** Construct a SimpleCalcScanner by name */
public SimpleCalcScanner(String fileName) throws IOException {
    this(new FileReader(fileName));
}

{'simplecalcscanner'}
/** Construct a SimpleCalcScanner from an open Reader */
public SimpleCalcScanner(Reader rdr) throws IOException {
    scan = new Scanner(rdr);
}

{'simplecalcscanner'}
/** Construct a SimpleCalcScanner from a Reader and a PrintWriter */
public SimpleCalcScanner(Reader rdr, PrintWriter pw) throws IOException {
    this(rdr);
    setWriter(pw);
}

{'printwriter', 'simplecalcscanner'}
/** Change the output to go to a new PrintWriter */
public void setWriter(PrintWriter pw) {
    out = pw;
}

{'printwriter'}
/** Construct a file scanner by existing Reader */
public ScanStringTok(Reader rdr) throws IOException {
    // being buffered...
    if (rdr instanceof LineNumberReader)
        is = (LineNumberReader) rdr;
    else
        is = new LineNumberReader(rdr);
}

{'level', 'point', 'adding', 'buffering', 'already', 'another'}
public static void main(String[] args) {
    // The arguments to all these format methods consist of
    // a format code String and 1 or more arguments.
    // Each format code consists of the following:
    // % - code lead-in
    // N$ - which parameter number (1-based) after the code - OPTIONAL
    // N - field width
    // L - format letter (d: decimal(int); f: float; s: general; many more)
    // For the full(!) story, see javadoc for java.util.Formatter.
    // Most general (cumbersome) way of proceding.
    Formatter fmtr = new Formatter();
    Object result = fmtr.format("%1$04d - the year of %2$f", 1956, Math.PI);
    System.out.println(result);
    // Shorter way using static String.format(), and
    // default parameter numbering.
    Object stringResult = String.format("%04d - the year of %f", 1956, Math.PI);
    System.out.println(stringResult);
    // A shorter way using PrintStream/PrintWriter.format, more in line with
    // other languages. But this way you must provide the newline delimiter 
    // using %n (do NOT use \n as that is platform-dependent!).
    System.out.printf("%04d - the year of %f%n", 1956, Math.PI);
    // Format doubles with more control
    System.out.printf("PI is approximately %4.2f%n", Math.PI);
}

{'printwriter', 'printstream'}
/** Simple main program, construct an UnZipper, process each
     * .ZIP file from argv[] through that object.
     */
public static void main(String[] argv) {
    UnZip u = new UnZip();
    for (int i = 0; i < argv.length; i++) {
        if ("-x".equals(argv[i])) {
            u.setMode(Mode.EXTRACT);
            continue;
        }
        String candidate = argv[i];
        // System.err.println("Trying path " + candidate);
        if (candidate.endsWith(".zip") || candidate.endsWith(".jar"))
            u.unZip(candidate);
        else
            System.err.println("Not a zip file? " + candidate);
    }
    System.err.println("All done!");
}

{'unzipper'}
/** Process one file from the zip, given its name.
     * Either print the name, or create the file on disk.
     */
protected void getFile(ZipEntry e) throws IOException {
    String zipName = e.getName();
    switch(mode) {
        case EXTRACT:
            if (zipName.startsWith("/")) {
                if (!warnedMkDir)
                    System.out.println("Ignoring absolute paths");
                warnedMkDir = true;
                zipName = zipName.substring(1);
            }
            // any directory entries, or put them in the wrong place.
            if (zipName.endsWith("/")) {
                return;
            }
            // Else must be a file; open the file for output
            // Get the directory part.
            int ix = zipName.lastIndexOf('/');
            if (ix > 0) {
                String dirName = zipName.substring(0, ix);
                if (!dirsMade.contains(dirName)) {
                    File d = new File(dirName);
                    // If it already exists as a dir, don't do anything
                    if (!(d.exists() && d.isDirectory())) {
                        // Try to create the directory, warn if it fails
                        System.out.println("Creating Directory: " + dirName);
                        if (!d.mkdirs()) {
                            System.err.println("Warning: unable to mkdir " + dirName);
                        }
                        dirsMade.add(dirName);
                    }
                }
            }
            System.err.println("Creating " + zipName);
            FileOutputStream os = new FileOutputStream(zipName);
            InputStream is = zippy.getInputStream(e);
            int n = 0;
            while ((n = is.read(b)) > 0) os.write(b, 0, n);
            is.close();
            os.close();
            break;
        case LIST:
            // Not extracting, just list
            if (e.isDirectory()) {
                System.out.println("Directory " + zipName);
            } else {
                System.out.println("File " + zipName);
            }
            break;
        default:
            throw new IllegalStateException("mode value (" + mode + ") bad");
    }
}

{'widely', 'used', 'since', 'every', 'creator'}
public static void main(String[] argv) throws IOException {
    String FILENAME = "file.txt.gz";
    // Since there are 4 constructor calls here, I wrote them out in full.
    // In real life you would probably nest these constructor calls.
    FileInputStream fin = new FileInputStream(FILENAME);
    GZIPInputStream gzis = new GZIPInputStream(fin);
    InputStreamReader xover = new InputStreamReader(gzis);
    BufferedReader is = new BufferedReader(xover);
    String line;
    // GZipInputStream "gunzip"s the data from the FileInputStream.
    while ((line = is.readLine()) != null) System.out.println("Read: " + line);
}

{'inputstreamreader', 'fileinputstream', 'conversion', 'bufferedreader', 'text', 'gzipinputstream', 'unicode', 'put'}
/** Get Marked parts of one file, given an open LineNumberReader.
     * This is the main operation of this class, and can be used
     * inside other programs or from the main() wrapper.
     */
public void process(String fileName, LineNumberReader is, PrintStream out) {
    int nLines = 0;
    try {
        String inputLine;
        while ((inputLine = is.readLine()) != null) {
            if (inputLine.trim().equals(START_MARK)) {
                if (printing)
                    // These go to stderr, so you can redirect the output
                    System.err.println("ERROR: START INSIDE START, " + fileName + ':' + is.getLineNumber());
                printing = true;
            } else if (inputLine.trim().equals(END_MARK)) {
                if (!printing)
                    System.err.println("ERROR: STOP WHILE STOPPED, " + fileName + ':' + is.getLineNumber());
                printing = false;
            } else if (printing) {
                if (number) {
                    out.print(nLines);
                    out.print(": ");
                }
                out.println(inputLine);
                ++nLines;
            }
        }
        is.close();
        // Must not close - caller may still need it.
        out.flush();
        if (nLines == 0)
            System.err.println("ERROR: No marks in " + fileName + "; no output generated!");
    } catch (IOException e) {
        System.out.println("IOException: " + e);
    }
}

{'linenumberreader'}
/** This simple main program looks after filenames and
     * opening files and such like for you, when GetMark is being
     * used standalone.
     * XXX TODO options parsing, allow include/exclude, number, etc.
     * to be set from the command line.
     */
public static void main(String[] av) {
    GetMark o = new GetMark();
    PrintStream pw = new PrintStream(System.out);
    if (av.length == 0) {
        o.process("standard input", new LineNumberReader(new InputStreamReader(System.in)), pw);
    } else {
        for (int i = 0; i < av.length; i++) try {
            o.process(av[i], new LineNumberReader(new FileReader(av[i])), pw);
        } catch (FileNotFoundException e) {
            System.err.println(e);
        }
    }
}

{'getmark'}
public static void main(String[] argv) throws IOException {
    // BEGIN main
    String LOGFILENAME = "error.log";
    System.setErr(new PrintStream(new FileOutputStream(LOGFILENAME)));
    System.out.println("Please look for errors in " + LOGFILENAME);
    // Now assume this is somebody else's code; you'll see it 
    //   writing to stderr...
    int[] a = new int[5];
    // here comes an ArrayIndexOutOfBoundsException
    a[10] = 0;
// END main
}

{'arrayindexoutofboundsexception'}
/** Read one (possibly continued) line, stripping out the '\'s that
     * mark the end of all but the last.
     */
public String readLine() throws IOException {
    String s;
    // number in firstLineNumber.
    if (prevLine != null) {
        s = prevLine;
        prevLine = null;
    } else {
        s = readPhysicalLine();
    }
    // save the line number of the first line.
    firstLineNumber = super.getLineNumber();
    // we are finished, so return it.
    if (!doContinue || s == null)
        return s;
    // Otherwise, start building a stringbuffer
    StringBuffer sb = new StringBuffer(s);
    // Read as many continued lines as there are, if any.
    while (true) {
        String nextPart = readPhysicalLine();
        if (nextPart == null) {
            // Return what we have so far.
            return sb.toString();
        }
        // If the next line begins with space, it's continuation
        if (nextPart.length() > 0 && Character.isWhitespace(nextPart.charAt(0))) {
            // and add line.
            sb.append(nextPart);
        } else {
            // else we just read too far, so put in "pushback" holder
            prevLine = nextPart;
            break;
        }
    }
    // return what's left
    return sb.toString();
}

{'within', 'non', 'eof', 'egad', 'saved', 'returned', 'firstlinenumber', 'possible', 'mode', 'previous', 'readphysicalline'}
/** Construct an IndentContLineReader with the default buffer size. */
public IndentContLineReader(Reader in) {
    super(in);
}

{'indentcontlinereader'}
/** Construct an IndentContLineReader using the given buffer size. */
public IndentContLineReader(Reader in, int sz) {
    super(in, sz);
}

{'indentcontlinereader'}
protected void doElement(Element p) {
    String tag = p.getTagName().toLowerCase();
    //
    if (tag.equals("head")) {
        System.err.println(">>>>Start HEAD");
    } else if (tag.equals("body")) {
        System.err.println(">>>>Start BODY");
    } else if (tag.equals("chapter")) {
        doChapter(p);
    //
    // PARAGRAPH TAGS
    // This is the application-specific bit of code.
    // SHOULD BE MAP RULES, NOT HARD-CODED.
    //
    } else if (tag.equals("title")) {
        doParagraph("ChapterTitle", p);
    } else if (tag.equals("simplesect")) {
        doParagraph("HeadA", p);
    } else if (tag.equals("sect1")) {
        doParagraph("HeadA", p);
    } else if (tag.equals("para")) {
        doParagraph("Body", p);
    } else if (tag.equals("sect2")) {
        doParagraph("HeadB", p);
    } else if (tag.equals("programlisting")) {
        doPre(p);
    } else if (tag.equals("graphic")) {
        doPre(p);
    } else if (tag.equals("runoutput")) {
        doRun(p);
    } else if (tag.equals("figure")) {
        doPre(p);
    //
    // STYLE TAGS
    //
    } else if (tag.equals("kb")) {
        // keyboard, map to code
        System.err.println("<KB> handler not written yet");
    } else if (tag.equals("bt")) {
        // book title, map to Citation
        System.err.println("<BT> handler not written yet");
    } else
        System.err.println("IGNORING UNHANDLED TAG " + tag + '(' + p.getClass() + '@' + p.hashCode() + ')');
}

{'structure'}
/** Run a java class' Main Program and capture the output.
     */
protected void doRun(Element p) {
    NamedNodeMap attrs = p.getAttributes();
    Node myClass;
    if ((myClass = attrs.getNamedItem("CLASS")) == null)
        throw new IllegalArgumentException("node " + p + "lacks required CLASS Attribute");
    String className = myClass.getNodeValue();
    try {
        // First, find the class.
        Class<?> c = Class.forName(className);
        // Create a dummy argv to pass it.
        String[] argv = new String[0];
        // Create the array of Argument Types
        Class<?>[] argTypes = { // array is Object!
        argv.getClass() };
        // Now find the method
        Method m = c.getMethod("main", argTypes);
        // Create the actual argument array
        Object passedArgv[] = { argv };
        // Now invoke the method.
        System.err.println("Invoking " + m + "...");
        m.invoke(null, passedArgv);
    } catch (Exception e) {
        System.err.println(e);
    }
}

{'classname', 'xx', 'makeupparagraph', 'example'}
protected void doCData(org.w3c.dom.CharacterData p) {
    String s = p.getData().trim();
    // System.err.println("doCData: String: " + s);
    if (// Sun's parser returns extra 1-space "Text"s
    s.length() == 0)
        return;
    pgfString(s);
}

{'docdata'}
protected void doChildren(Element p) {
    NodeList nodes = p.getChildNodes();
    int numElem = nodes.getLength();
    // System.err.println("Element has " + numElem + " children");
    for (int i = 0; i < numElem; i++) {
        Node n = nodes.item(i);
        if (n == null) {
            continue;
        }
        // System.err.println("NODE " + n.getNodeType());
        switch(n.getNodeType()) {
            case Node.TEXT_NODE:
                // System.err.println("\tCDATA: " + n.getNodeValue());
                doCData((CharacterData) n);
                p.removeChild(n);
                break;
            case Node.ELEMENT_NODE:
                // System.err.println("\tELEMENT<" + n.getNodeName() + ">");
                doChildren((Element) n);
                p.removeChild(n);
                break;
            default:
                System.err.println("Warning: unhandled child node " + n.getNodeType() + ": " + n.getClass());
                break;
        }
    }
}

{'getnodevalue', 'getnodetype', 'numelem', 'telement', 'tcdata', 'getnodename'}
/** Convert the file */
public void convert(boolean verbose) {
    try {
        if (verbose)
            System.err.println(">>>Parsing " + fileName + "...");
        // Make the document a URL so relative DTD works.
        //String uri = "file:" + new File(fileName).getAbsolutePath();
        InputStream uri = getClass().getResourceAsStream(fileName);
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(uri);
        if (verbose)
            System.err.println(">>>Walking " + fileName + "...");
        XmlFormWalker c = new GenMIF(doc, msg);
        c.convertAll();
    } catch (Exception ex) {
        System.err.println("+================================+");
        System.err.println("|         *Parse Error*          |");
        System.err.println("+================================+");
        System.err.println(ex.getClass());
        System.err.println(ex.getMessage());
        System.err.println("+================================+");
    }
    if (verbose)
        System.err.println(">>>Done " + fileName + "...");
}

{'filename', 'getabsolutepath'}
/** This is called by AWT after the native window peer is created,
         * and before paint() is called for the first time, so
         * is a good time to create images and the like.
         */
public void addNotify() {
    super.addNotify();
    offScreenImage = createImage(width, height);
    // assert (offScreenImage != null);
    pg = offScreenImage.getGraphics();
}

{'offscreenimage'}
public void actionPerformed(ActionEvent e) {
    if (targetURL != null) {
        // showStatus("Going to " + target);
        getAppletContext().showDocument(targetURL);
    }
}

{'showstatus'}
/** Called from the browser to set up. We want to throw various
     * kinds of exceptions but the API predefines that we don't, so we
     * limit ourselves to the ubiquitous IllegalArgumentException.
     */
public void init() {
    // System.out.println("In LinkButton::init");
    try {
        if ((targetName = getParameter(TARGET1)) == null)
            throw new IllegalArgumentException("TARGET parameter REQUIRED");
        if ((targetHost = getParameter(TARGET2)) == null)
            throw new IllegalArgumentException("TARGET parameter REQUIRED");
        String theURL = "mailto:" + targetName + "@" + targetHost;
        subject = getParameter("subject");
        if (subject != null)
            theURL += "?subject=" + subject;
        targetURL = new URL(theURL);
    } catch (MalformedURLException rsi) {
        throw new IllegalArgumentException("MalformedURLException " + rsi.getMessage());
    }
    // i.e., "Send feedback"
    label = getParameter("label");
    if (label == null)
        throw new IllegalArgumentException("LABEL is REQUIRED");
    // Now handle font stuff.
    fontName = getParameter("font");
    if (fontName == null)
        fontName = DEFAULTFONTNAME;
    String s;
    if ((s = getParameter("fontsize")) != null)
        fontSize = Integer.parseInt(s);
    if (fontName != null || fontSize != 0) {
        // System.out.println("Name " + fontName + ", size " + fontSize);
        theFont = new Font(fontName, Font.BOLD, fontSize);
    }
    Button b = new Button(label);
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            if (targetURL != null) {
                // showStatus("Going to " + target);
                getAppletContext().showDocument(targetURL);
            }
        }
    });
    if (theFont != null)
        b.setFont(theFont);
    add(b);
}

{'linkbutton', 'illegalargumentexception', 'showstatus', 'fontname'}
/** Give Parameter info to the AppletViewer, just for those
     * writing HTML without hardcopy documentation :-)
     */
public String[][] getParameterInfo() {
    String info[][] = { { "label", "string", "Text to display" }, { "fontname", "name", "Font to display it in" }, { "fontsize", "10-30?", "Size to display it at" }, { "username", "email-account", "Where do you want your mail to go today? Part 1" }, { "hostname", "host.domain", "Where do you want your mail to go today? Part 2" }, { "subject", "subject line", "What your Subject: field will be." } };
    return info;
}

{'download', 'mislead', 'file', 'warning', 'intentionally', 'run', 'lie', 'class', 'incautious', 'appletviewer', 'enough', 'spammer'}
/** Construct a MailComposeBean with no default recipient */
MailComposeBean(Container parent, String title, int height, int width) {
    this(parent, title, null, height, width);
}

{'mailcomposebean'}
/** Construct a MailComposeBean with no arguments (needed for Beans) */
MailComposeBean() {
    this(null, "Compose", null, 300, 200);
}

{'mailcomposebean'}
/** Constructor for MailComposeBean object.
     *
     * @param parent    Container parent. If JFrame or JInternalFrame,
     *                    will setvisible(false) and dispose() when
     *                    message has been sent. Not done if "null" or JPanel.
     * @param title        Title to display in the titlebar
     * @param recipient    Email address of recipient
     * @param height    Height of mail compose window
     * @param width        Width of mail compose window
     */
MailComposeBean(Container parent, String title, String recipient, int width, int height) {
    super();
    this.parent = parent;
    mywidth = width;
    myheight = height;
    // THE GUI
    Container cp = this;
    cp.setLayout(new BorderLayout());
    // Top is a JPanel for name, address, etc.
    // Center is the TextArea.
    // Bottom is a panel with Send and Cancel buttons.
    JPanel tp = new JPanel();
    tp.setLayout(new GridLayout(3, 2));
    cp.add(BorderLayout.NORTH, tp);
    tfs = new JTextField[MAXTF];
    tp.add(new JLabel("To: ", JLabel.RIGHT));
    tp.add(tfs[TO] = toTF = new JTextField(35));
    if (recipient != null)
        toTF.setText(recipient);
    toTF.requestFocus();
    tp.add(new JLabel("Subject: ", JLabel.RIGHT));
    tp.add(tfs[SUBJ] = subjectTF = new JTextField(35));
    subjectTF.requestFocus();
    tp.add(new JLabel("Cc: ", JLabel.RIGHT));
    tp.add(tfs[CC] = ccTF = new JTextField(35));
    // Center is the TextArea
    cp.add(BorderLayout.CENTER, msgText = new JTextArea(70, 10));
    msgText.setBorder(BorderFactory.createTitledBorder("Message Text"));
    // Bottom is the apply/cancel button
    JPanel bp = new JPanel();
    bp.setLayout(new FlowLayout());
    bp.add(sendButton = new JButton("Send"));
    sendButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            try {
                doSend();
            } catch (Exception err) {
                System.err.println("Error: " + err);
                JOptionPane.showMessageDialog(null, "Sending error:\n" + err.toString(), "Send failed", JOptionPane.ERROR_MESSAGE);
            }
        }
    });
    bp.add(cancelButton = new JButton("Cancel"));
    cancelButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            maybeKillParent();
        }
    });
    cp.add(BorderLayout.SOUTH, bp);
}

{'mailcomposebean', 'jframe', 'textarea', 'jinternalframe', 'jpanel'}
/** Do the work: send the mail to the SMTP server.
     *
     * ASSERT: must have set at least one recipient.
     */
public void doSend() {
    try {
        Mailer m = new Mailer();
        FileProperties props = new FileProperties(MailConstants.PROPS_FILE_NAME);
        String serverHost = props.getProperty(MailConstants.SEND_HOST);
        if (serverHost == null) {
            JOptionPane.showMessageDialog(parent, "\"" + MailConstants.SEND_HOST + "\" must be set in properties", "No server!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        m.setServer(serverHost);
        String tmp = props.getProperty(MailConstants.SEND_DEBUG);
        m.setVerbose(tmp != null && tmp.equals("true"));
        String myAddress = props.getProperty("Mail.address");
        if (myAddress == null) {
            JOptionPane.showMessageDialog(parent, "\"Mail.address\" must be set in properties", "No From: address!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        m.setFrom(myAddress);
        m.setToList(toTF.getText());
        m.setCcList(ccTF.getText());
        if (subjectTF.getText().length() != 0) {
            m.setSubject(subjectTF.getText());
        }
        // Now copy the text from the Compose TextArea.
        m.setBody(msgText.getText());
        // XXX I18N: use setBody(msgText.getText(), charset)
        // Finally, send the sucker!
        m.doSend();
        // Now hide the main window
        maybeKillParent();
    } catch (MessagingException me) {
        me.printStackTrace();
        while ((me = (MessagingException) me.getNextException()) != null) {
            me.printStackTrace();
        }
        JOptionPane.showMessageDialog(null, "Mail Sending Error:\n" + me.toString(), "Error", JOptionPane.ERROR_MESSAGE);
    } catch (Exception e) {
        JOptionPane.showMessageDialog(null, "Mail Sending Error:\n" + e.toString(), "Error", JOptionPane.ERROR_MESSAGE);
    }
}

{'setbcclist', 'bcctf', 'msgtext', 'textarea', 'setbody', 'gettext'}
public void valueChanged(TreeSelectionEvent evt) {
    // yes, repeat it.
    Object[] po = evt.getPath().getPath();
    // last node in path
    Object o = po[po.length - 1];
    if (o instanceof FolderNode) {
        // System.out.println("Select folder " + o.toString());
        return;
    }
    if (o instanceof MessageNode) {
        bodyText.setText("");
        try {
            Message m = ((MessageNode) o).m;
            bodyText.append("To: ");
            Object[] tos = m.getAllRecipients();
            for (Object to : tos) {
                bodyText.append(to.toString());
                bodyText.append(" ");
            }
            bodyText.append("\n");
            bodyText.append("Subject: " + m.getSubject() + "\n");
            bodyText.append("From: ");
            Object[] froms = m.getFrom();
            for (Object from : froms) {
                bodyText.append(from.toString());
                bodyText.append(" ");
            }
            bodyText.append("\n");
            bodyText.append("Date: " + m.getSentDate() + "\n");
            bodyText.append("\n");
            bodyText.append(m.getContent().toString());
            // Start reading at top of message(!)
            bodyText.setCaretPosition(0);
        } catch (Exception e) {
            bodyText.append(e.toString());
        }
    } else
        System.err.println("UNEXPECTED SELECTION: " + o.getClass());
}

{'tostring'}
/* Construct a mail reader bean with all values. */
public MailReaderBean(String protocol, String host, String user, String password, String rootName) throws Exception {
    super(VERTICAL_SPLIT);
    boolean recursive = false;
    // Start with a Mail Session object
    Session session = Session.getDefaultInstance(System.getProperties(), null);
    session.setDebug(false);
    // Get a Store object for the given protocol
    Store store = session.getStore(protocol);
    store.connect(host, user, password);
    // Get Folder object for root, and list it
    // If root name = "", getDefaultFolder(), else getFolder(root)
    FolderNode top;
    if (rootName.length() != 0) {
        // System.out.println("Getting folder " + rootName + ".");
        top = new FolderNode(store.getFolder(rootName));
    } else {
        // System.out.println("Getting default folder.");
        top = new FolderNode(store.getDefaultFolder());
    }
    if (top == null || !top.f.exists()) {
        System.out.println("Invalid folder " + rootName);
        return;
    }
    if (top.f.getType() == Folder.HOLDS_FOLDERS) {
        Folder[] fs = top.f.list();
        for (Folder f : fs) listFolder(top, new FolderNode(f), recursive);
    } else
        listFolder(top, top, false);
    // Now that (all) the foldernodes and treenodes are in,
    // construct a JTree object from the top of the list down,
    // make the JTree scrollable (put in JScrollPane),
    // and add it as the MailComposeBean's Northern child.
    JTree tree = new JTree(top);
    JScrollPane treeScroller = new JScrollPane(tree);
    treeScroller.setBackground(tree.getBackground());
    this.setTopComponent(treeScroller);
    // The Southern (Bottom) child is a textarea to display the msg.
    bodyText = new JTextArea(15, 80);
    this.setBottomComponent(new JScrollPane(bodyText));
    // Add a notification listener for the tree; this will
    // display the clicked-upon message
    TreeSelectionListener tsl = new TreeSelectionListener() {

        public void valueChanged(TreeSelectionEvent evt) {
            // yes, repeat it.
            Object[] po = evt.getPath().getPath();
            // last node in path
            Object o = po[po.length - 1];
            if (o instanceof FolderNode) {
                // System.out.println("Select folder " + o.toString());
                return;
            }
            if (o instanceof MessageNode) {
                bodyText.setText("");
                try {
                    Message m = ((MessageNode) o).m;
                    bodyText.append("To: ");
                    Object[] tos = m.getAllRecipients();
                    for (Object to : tos) {
                        bodyText.append(to.toString());
                        bodyText.append(" ");
                    }
                    bodyText.append("\n");
                    bodyText.append("Subject: " + m.getSubject() + "\n");
                    bodyText.append("From: ");
                    Object[] froms = m.getFrom();
                    for (Object from : froms) {
                        bodyText.append(from.toString());
                        bodyText.append(" ");
                    }
                    bodyText.append("\n");
                    bodyText.append("Date: " + m.getSentDate() + "\n");
                    bodyText.append("\n");
                    bodyText.append(m.getContent().toString());
                    // Start reading at top of message(!)
                    bodyText.setCaretPosition(0);
                } catch (Exception e) {
                    bodyText.append(e.toString());
                }
            } else
                System.err.println("UNEXPECTED SELECTION: " + o.getClass());
        }
    };
    tree.addTreeSelectionListener(tsl);
}

{'jtree', 'jscrollpane', 'rootname', 'mailcomposebean', 'tostring', 'getfolder', 'getdefaultfolder'}
public void uncaughtException(Thread t, final Throwable ex) {
    try {
        SwingUtilities.invokeAndWait(new Runnable() {

            public void run() {
                ErrorUtil.showExceptions(gui, ex);
            }
        });
    } catch (InvocationTargetException | InterruptedException e) {
        System.err.println("Sob! We failed: " + e);
    }
}

{'really', 'nothing'}
public static void main(String unused[]) throws Exception {
    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {

        public void uncaughtException(Thread t, final Throwable ex) {
            try {
                SwingUtilities.invokeAndWait(new Runnable() {

                    public void run() {
                        ErrorUtil.showExceptions(gui, ex);
                    }
                });
            } catch (InvocationTargetException | InterruptedException e) {
                System.err.println("Sob! We failed: " + e);
            }
        }
    });
    gui = new CheckOpenMailRelayGui();
    SwingUtilities.invokeLater(new Runnable() {

        @Override
        public void run() {
            // Can't do this on any non-EDT thread    
            gui.setVisible(true);
        }
    });
}

{'really', 'nothing'}
/** Construct a GUI and some I/O plumbing to get the output
     * of "TestOpenMailRelay" into the "results" textfield.
     */
public CheckOpenMailRelayGui() throws IOException {
    super("Tests for Open Mail Relays");
    runner = new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            goButton.setEnabled(false);
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    String host = hostTextField.getText().trim();
                    out.println("Trying " + host);
                    CheckOpenMailRelay.process(host, out);
                    goButton.setEnabled(true);
                }
            });
        }
    };
    JPanel p;
    Container cp = getContentPane();
    cp.add(BorderLayout.NORTH, p = new JPanel());
    // The entry label and text field.
    p.add(new JLabel("Host:"));
    p.add(hostTextField = new JTextField(10));
    hostTextField.addActionListener(runner);
    p.add(goButton = new JButton("Try"));
    goButton.addActionListener(runner);
    JButton cb;
    p.add(cb = new JButton("Clear Log"));
    cb.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent evt) {
            results.setText("");
        }
    });
    JButton sb;
    p.add(sb = new JButton("Save Log"));
    sb.setEnabled(false);
    results = new JTextArea(20, 60);
    // Add the text area to the main part of the window (CENTER).
    // Wrap it in a JScrollPane to make it scroll automatically.
    cp.add(BorderLayout.CENTER, new JScrollPane(results));
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    // end of GUI portion
    pack();
    out = new PrintStream(new TextAreaOutputStream(results));
}

{'jscrollpane', 'testopenmailrelay'}
/** Construct the MailClient JComponent a default Properties filename */
public MailClient() throws Exception {
    this(PROPS_FILE_NAME);
}

{'mailclient', 'jcomponent'}
/** Construct the MailClient JComponent with a Properties filename */
public MailClient(String propsFileName) throws Exception {
    super();
    // Construct and load the Properties for the mail reader and sender.
    Properties mailProps = new FileProperties(propsFileName);
    // Gather some key values
    String proto = mailProps.getProperty(RECV_PROTO);
    String user = mailProps.getProperty(RECV_USER);
    String pass = mailProps.getProperty(RECV_PASS);
    String host = mailProps.getProperty(RECV_HOST);
    if (proto == null)
        throw new IllegalArgumentException(RECV_PROTO + "==null");
    // Protocols other than "mbox" need a password.
    if (!proto.equals("mbox") && (pass == null || pass.equals("ASK"))) {
        String np;
        do {
            // Make JOptionPane prompt for password in no-echo.
            // Create "message" using JPanel, JLabel, & JPasswordField
            // Courtesy of Marc Loy.
            JPanel p = new JPanel();
            p.add(new JLabel("Password for " + proto + " user " + user + " on " + host));
            JPasswordField jpf = new JPasswordField(20);
            p.add(jpf);
            JOptionPane.showMessageDialog(null, p, "Password request", JOptionPane.QUESTION_MESSAGE);
            np = new String(jpf.getPassword());
        } while (np == null || (np != null && np.length() == 0));
        mailProps.setProperty(RECV_PASS, np);
    }
    // Dump them all into System.properties so other code can find.
    System.getProperties().putAll(mailProps);
    // Construct the GUI
    // System.out.println("Constructing GUI");
    setLayout(new BorderLayout());
    JTabbedPane tbp = new JTabbedPane();
    add(BorderLayout.CENTER, tbp);
    tbp.addTab("Reading", mrb = new MailReaderBean());
    tbp.addTab("Sending", mcb = new MailComposeFrame());
    tbp.addTab("Aliases", alb = new AliasBean());
    tbp.addTab("List sending", new JLabel("Under construction", JLabel.CENTER));
    add(BorderLayout.SOUTH, quitButton = new JButton("Exit"));
// System.out.println("Leaving Constructor");
}

{'jlabel', 'mailclient', 'jpanel', 'jpasswordfield', 'jcomponent', 'joptionpane'}
/** "main program" method - run the program */
public static void main(String[] av) throws Exception {
    final JFrame f = new JFrame("MailClient");
    // Start by checking that the javax.mail package is installed!
    try {
        Class.forName("javax.mail.Session");
    } catch (ClassNotFoundException cnfe) {
        JOptionPane.showMessageDialog(f, "Sorry, the javax.mail package was not found\n(" + cnfe + ")", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }
    // create a MailClient object
    MailClient comp;
    if (av.length == 0)
        comp = new MailClient();
    else
        comp = new MailClient(av[0]);
    f.getContentPane().add(comp);
    // Set up action handling for GUI
    comp.quitButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            f.setVisible(false);
            f.dispose();
            System.exit(0);
        }
    });
    f.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            f.setVisible(false);
            f.dispose();
            System.exit(0);
        }
    });
    f.pack();
    f.setVisible(true);
}

{'mailclient'}
/** Do the work: send the mail to the SMTP server.  */
public void doSend() throws IOException, MessagingException {
    // We need to pass info to the mail server as a Properties, since
    // JavaMail (wisely) allows room for LOTS of properties...
    FileProperties props = new FileProperties(MailConstants.PROPS_FILE_NAME);
    // Copy the value of Mail.send.host into mail.smtp.host
    props.setProperty("mail.smtp.host", props.getProperty(MailConstants.SEND_HOST));
    // Create the Session object
    session = Session.getDefaultInstance(props, null);
    // Verbose!
    session.setDebug(true);
    try {
        // create a message
        mesg = new MimeMessage(session);
        // From Address - this should come from a Properties...
        mesg.setFrom(new InternetAddress("nobody@host.domain"));
        // TO Address 
        InternetAddress toAddress = new InternetAddress(message_recip);
        mesg.addRecipient(Message.RecipientType.TO, toAddress);
        // CC Address
        InternetAddress ccAddress = new InternetAddress(message_cc);
        mesg.addRecipient(Message.RecipientType.CC, ccAddress);
        // The Subject
        mesg.setSubject(message_subject);
        // Now the message body.
        Multipart mp = new MimeMultipart();
        BodyPart textPart = new MimeBodyPart();
        // sets type to "text/plain"
        textPart.setText(message_body);
        BodyPart pixPart = new MimeBodyPart();
        pixPart.setContent(html_data, "text/html");
        // Collect the Parts into the MultiPart
        mp.addBodyPart(textPart);
        mp.addBodyPart(pixPart);
        // Put the MultiPart into the Message
        mesg.setContent(mp);
        // Finally, send the message!
        Transport.send(mesg);
    } catch (MessagingException ex) {
        System.err.println(ex);
        ex.printStackTrace(System.err);
    }
}

{'javamail'}
public static void main(String[] argv) throws Exception {
    String fileName = MailConstants.PROPS_FILE_NAME;
    String protocol = null;
    String host = null;
    String user = null;
    String password = null;
    String root = null;
    // If argc == 1, assume it's a Properties file.
    if (argv.length == 1) {
        fileName = argv[0];
        FileProperties fp = new FileProperties(fileName);
        fp.load();
        protocol = fp.getProperty(MailConstants.RECV_PROTO);
        host = fp.getProperty(MailConstants.RECV_HOST);
        user = fp.getProperty(MailConstants.RECV_USER);
        password = fp.getProperty(MailConstants.RECV_PASS);
        root = fp.getProperty(MailConstants.RECV_ROOT);
    } else // If not, assume listing all args in long form.
    if (argv.length == 5) {
        protocol = argv[0];
        host = argv[1];
        user = argv[2];
        password = argv[3];
        root = argv[4];
    } else // Otherwise give up.
    {
        System.err.println("Usage: MailLister protocol host user pw root");
        System.exit(0);
    }
    boolean recursive = false;
    // Start with a JavaMail Session object
    Session session = Session.getDefaultInstance(System.getProperties(), null);
    session.setDebug(false);
    // Get a Store object for the given protocol
    Store store = session.getStore(protocol);
    if (password.equals("*")) {
        final char[] passBytes = System.console().readPassword("Password:", (Object[]) null);
        password = new String(passBytes);
    }
    store.connect(host, user, password);
    // Get Folder object for root, and list it
    // If root name = "", getDefaultFolder(), else getFolder(root)
    Folder rf;
    if (root.length() != 0) {
        System.out.println("Getting folder " + root + ".");
        rf = store.getFolder(root);
    } else {
        System.out.println("Getting default folder.");
        rf = store.getDefaultFolder();
    }
    rf.open(Folder.READ_WRITE);
    if (rf.getType() == Folder.HOLDS_FOLDERS) {
        Folder[] fs = rf.list();
        for (Folder f : fs) {
            listFolder(f, "", recursive);
        }
    } else {
        listFolder(rf, "", false);
    }
}

{'javamail', 'getfolder', 'getdefaultfolder'}
/** To be useful here, a MailComposeBean has to be inside
     * its own little JInternalFrame. 
     */
public MailComposeBean newSend() {
    // Make the JInternalFrame wrapper
    JInternalFrame jf = new JInternalFrame();
    // Bake the actual Bean
    MailComposeBean newBean = new MailComposeBean(this, "Compose", 400, 250);
    // Arrange them on the diagonal.
    jf.setLocation(nx += 10, ny += 10);
    // Make the new Bean be the contents of the JInternalFrame
    jf.setContentPane(newBean);
    jf.pack();
    jf.toFront();
    // Add the JInternalFrame to the JDesktopPane
    dtPane.add(jf);
    return newBean;
}

{'mailcomposebean', 'jdesktoppane', 'jinternalframe'}
/* Construct a MailComposeFrame, with a Compose button. */
public MailComposeFrame() {
    setLayout(new BorderLayout());
    dtPane = new JDesktopPane();
    add(dtPane, BorderLayout.CENTER);
    newButton = new JButton("Compose");
    newButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            newSend();
        }
    });
    add(newButton, BorderLayout.SOUTH);
}

{'mailcomposeframe'}
/** Do the work: send the mail to the SMTP server.  */
public void doSend() {
    // We need to pass info to the mail server as a Properties, since
    // JavaMail (wisely) allows room for LOTS of properties...
    Properties props = new Properties();
    // Your LAN must define the local SMTP server as "mailhost"
    // for this simple-minded version to be able to send mail...
    props.put("mail.smtp.host", "mailhost");
    // Create the Session object
    session = Session.getDefaultInstance(props, null);
    // Verbose!
    session.setDebug(true);
    try {
        // create a message
        mesg = new MimeMessage(session);
        // From Address - this should come from a Properties...
        mesg.setFrom(new InternetAddress("nobody@host.domain"));
        // TO Address 
        InternetAddress toAddress = new InternetAddress(message_recip);
        mesg.addRecipient(Message.RecipientType.TO, toAddress);
        // CC Address
        InternetAddress ccAddress = new InternetAddress(message_cc);
        mesg.addRecipient(Message.RecipientType.CC, ccAddress);
        // The Subject
        mesg.setSubject(message_subject);
        // Now the message body.
        mesg.setText(message_body);
        // XXX I18N: use setText(msgText.getText(), charset)
        // Finally, send the message!
        Transport.send(mesg);
    } catch (MessagingException ex) {
        while ((ex = (MessagingException) ex.getNextException()) != null) {
            ex.printStackTrace();
        }
    }
}

{'gettext', 'javamail', 'msgtext', 'settext'}
public void process(Socket clntSock) {
    // what Viewer sends us.
    String request;
    RequestType methodType = RequestType.RQ_INVALID;
    try {
        System.out.println("Connection accepted from " + clntSock.getInetAddress());
        is = new BufferedReader(new InputStreamReader(clntSock.getInputStream()));
        // Must do before any chance of errorResponse being called!
        os = new PrintStream(clntSock.getOutputStream());
        request = is.readLine();
        if (request == null || request.length() == 0) {
            // No point nattering: the sock died, nobody will hear
            // us if we scream into cyberspace... 
            System.err.println("The sock has died...");
            return;
        }
        // Use a StringTokenizer to break the request into its three parts:
        // HTTP method, resource name, and HTTP version
        StringTokenizer st = new StringTokenizer(request);
        if (st.countTokens() != 3) {
            errorResponse(444, "Unparseable input " + request);
            clntSock.close();
            return;
        }
        String requestCommand = st.nextToken();
        requestURL = st.nextToken();
        String requestHTTPVersion = st.nextToken();
        System.out.println("Request: Command " + requestCommand + ", file " + requestURL + ", version " + requestHTTPVersion);
        // First, check that rqCode is either GET or HEAD or ...
        if ("get".equalsIgnoreCase(requestCommand))
            methodType = RequestType.RQ_GET;
        else if ("head".equalsIgnoreCase(requestCommand))
            methodType = RequestType.RQ_HEAD;
        else if ("post".equalsIgnoreCase(requestCommand))
            methodType = RequestType.RQ_POST;
        else {
            errorResponse(400, "invalid method: " + requestCommand);
            clntSock.close();
            return;
        }
        // Read headers, up to the null line before the body,
        // so the body can be read directly if it's a POST.
        Map<String, String> headersMap = new HashMap<String, String>();
        String hdrLine;
        while ((hdrLine = is.readLine()) != null && hdrLine.length() != 0) {
            int ix;
            if ((ix = hdrLine.indexOf(':')) != -1) {
                String hdrName = hdrLine.substring(0, ix);
                String hdrValue = hdrLine.substring(ix + 1).trim();
                Debug.println("hdr", hdrName + "," + hdrValue);
                headersMap.put(hdrName, hdrValue);
            } else {
                System.err.println("INVALID HEADER: " + hdrLine);
            }
        }
        if (methodType == RequestType.RQ_POST) {
            errorResponse(501, "Protocol not written yet");
            clntSock.close();
            return;
        }
        // Make a URL from the request
        URL url = new URL(requestURL);
        String protocol = url.getProtocol();
        if (!"http".equals(protocol)) {
            errorResponse(401, "protocol not supported: " + requestURL);
            clntSock.close();
            return;
        }
        returnURL(url, os);
        os.flush();
        clntSock.close();
        System.out.println("END OF REQUEST");
    } catch (FileNotFoundException e) {
        errorResponse(404, "Server can't find " + requestURL);
    } catch (IOException e) {
        errorResponse(500, "IO Error on proxy");
        System.out.println("IOException " + e);
        e.printStackTrace();
    }
}

{'errorresponse', 'rqcode', 'stringtokenizer'}
/** Default constructor */
protected UserDBJDBC() throws NamingException, SQLException, IOException {
    super();
    System.out.println("UserDBJDBC.<init> starting...");
    System.out.println("Loading Driver Class");
    try {
        Class.forName("org.hsqldb.jdbcDriver");
    } catch (ClassNotFoundException ex) {
        System.out.println("FAILED: " + ex.toString());
        throw new IllegalStateException(ex.toString());
    }
    Connection conn = DriverManager.getConnection("jdbc:hsqldb:/home/ian/src/jabadot/WEB-INF/jabadot", "jabadmin", "fredonia");
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("select * from users");
    while (rs.next()) {
        //name:password:fullname:City:Prov:Country:privs
        // Get the fields from the query.
        // Could be an Entity EJB with CMP: this is unnecessarily 
        // chummy with the SQL. See CreateUserDatabase.java for field#'s!
        int i = 1;
        String nick = rs.getString(i++).trim();
        String pass = rs.getString(i++).trim();
        // System.err.println(nick + " (" + pass + ")");
        String first = rs.getString(i++);
        String last = rs.getString(i++);
        String email = rs.getString(i++);
        String city = rs.getString(i++);
        String prov = rs.getString(i++);
        String ctry = rs.getString(i++);
        java.sql.Date credt = rs.getDate(i++);
        java.sql.Date lastlog = rs.getDate(i++);
        String skin = rs.getString(i++);
        boolean editPrivs = rs.getBoolean(i++);
        boolean adminPrivs = rs.getBoolean(i++);
        // Construct a user object from the fields
        // System.out.println("Constructing User object");
        User u = new User(nick, pass, first, last, email, prov, ctry, credt, lastlog, skin, editPrivs, adminPrivs);
        // System.out.println("Adding User object " + u + " to " + users);
        // Add it to the in-memory copy.
        users.add(u);
    // System.err.println("User " + nick + "; pass " + pass.charAt(0));
    }
    // All done with that resultset
    rs.close();
    stmt.close();
    // Set up the PreparedStatements now so we don't have to
    // re-create them each time needed.
    addUserStmt = conn.prepareStatement(SQL_INSERT_USER);
    setPasswordStatement = conn.prepareStatement("update users SET password = ? where name = ?");
    setLastLoginStmt = conn.prepareStatement("update users SET lastLogin = ? where name = ?");
    deleteUserStmt = conn.prepareStatement("delete from users where name = ?");
    conn.close();
}

{'createuserdatabase', 'charat', 'preparedstatements'}
public static void main(String[] av) {
    String dbURL = "jdbc:odbc:Companies";
    try {
        // Load the jdbc-odbc bridge driver
        Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
        // Enable logging
        DriverManager.setLogWriter(new PrintWriter((System.err)));
        System.out.println("Getting Connection");
        Connection conn = // user, passwd
        DriverManager.getConnection(dbURL, "ian", "");
        // If a SQLWarning object is available, print its
        // warning(s).  There may be multiple warnings chained.
        SQLWarning warn = conn.getWarnings();
        while (warn != null) {
            System.out.println("SQLState: " + warn.getSQLState());
            System.out.println("Message:  " + warn.getMessage());
            System.out.println("Vendor:   " + warn.getErrorCode());
            System.out.println("");
            warn = warn.getNextWarning();
        }
        // Do something with the connection here...
        // All done with that DB connection
        conn.close();
    } catch (ClassNotFoundException e) {
        System.out.println("Can't load driver " + e);
    } catch (SQLException e) {
        System.out.println("Database access failed " + e);
    }
}

{'sqlwarning'}
public static void main(String[] args) throws Exception {
    RowSet rs;
    RowSetFactory rsFactory = RowSetProvider.newFactory();
    rs = rsFactory.createCachedRowSet();
    rs.setUrl("jdbc:postgresql:tmclub");
    rs.setUsername("ian");
    rs.setPassword("secret");
    rs.setCommand("select * from members where name like ?");
    rs.setString(1, "I%");
    // This will cause the RowSet to connect, fetch its data, and
    // disconnect
    rs.execute();
    // Suppose we want to update data:
    while (rs.next()) {
        if (rs.getInt("id") == 42) {
            rs.setString(1, "Marvin");
            // Normal JDBC
            rs.updateRow();
            // This additional call tells the CachedRowSet to connect
            // to its database and send the updated data back.
            rs.updateRow();
        }
    }
    // If we're all done...
    rs.close();
}

{'client', 'time', 'rowset', 'cachedrowset', 'later', 'something', 'try'}
public static void main(String[] args) {
    try {
        // Get the connection
        Connection conn = ConnectionUtil.getConnection(args[0]);
        // Get a Database MetaData as a way of interrogating 
        // the names of the tables in this database.
        DatabaseMetaData meta = conn.getMetaData();
        System.out.println("We are using " + meta.getDatabaseProductName());
        System.out.println("Version is " + meta.getDatabaseProductVersion());
        int txisolation = meta.getDefaultTransactionIsolation();
        System.out.println("Database default transaction isolation is " + txisolation + " (" + transactionIsolationToString(txisolation) + ").");
        conn.close();
        System.out.println("All done!");
    } catch (SQLException ex) {
        System.out.println("Database access failed:");
        System.out.println(ex);
    }
}

{'metadata'}
/** Convert a TransactionIsolation int (defined in java.sql.Connection)
     * to the corresponding printable string.
     * 
     * XXX Remove from here once darwinsys.jar gets committed.
     */
public static String transactionIsolationToString(int txisolation) {
    switch(txisolation) {
        case Connection.TRANSACTION_NONE:
            // transactions not supported.
            return "TRANSACTION_NONE";
        case Connection.TRANSACTION_READ_UNCOMMITTED:
            // All three phenomena can occur
            return "TRANSACTION_NONE";
        case Connection.TRANSACTION_READ_COMMITTED:
            // phantom reads can occur.
            return "TRANSACTION_READ_COMMITTED";
        case Connection.TRANSACTION_REPEATABLE_READ:
            // phantom reads can occur.
            return "TRANSACTION_REPEATABLE_READ";
        case Connection.TRANSACTION_SERIALIZABLE:
            // All three phenomena prvented; slowest!
            return "TRANSACTION_SERIALIZABLE";
        default:
            throw new IllegalArgumentException(txisolation + " not a valid TX_ISOLATION");
    }
}

{'prevented', 'dirty', 'transactionisolation', 'non'}
/** Return true if the given file is accepted by this filter. */
public boolean accept(File f) {
    // ending in one of the extentions appear in the window.
    if (f.isDirectory()) {
        return true;
    } else if (f.isFile()) {
        for (String ext : exts) {
            if (f.getName().endsWith(ext))
                return true;
        }
    }
    // A file that didn't match, or a weirdo (e.g. UNIX device file?).
    return false;
}

{'trick', 'little'}
public JFrameFlowLayout() {
    Container cp = getContentPane();
    // Make sure it has a FlowLayout layoutmanager.
    cp.setLayout(new FlowLayout());
    // now add Components to "cp"...
    cp.add(new JLabel("Wonderful?"));
    cp.add(new JButton("Yes!"));
    pack();
}

{'flowlayout'}
public MacOsUiHints() {
    jf = new JFrame("MacOsUiHints");
    JButton button = new JButton("Exit");
    button.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent arg0) {
            System.exit(0);
        }
    });
    jf.getContentPane().add(button);
    JMenuBar mb = new JMenuBar();
    jf.setJMenuBar(mb);
    JMenu fileMenu = new JMenu("File");
    mb.add(fileMenu);
    fileMenu.add(new JMenuItem("Quit"));
    mb.add(new JMenu("Edit"));
    // Tester: see that Application->About produces our popup
    // Ditto for Preferences and Shutdown.
    // MacOSAppAdapter adapter =
    //   new MacOSAppAdapter(jf, abouter, prefser, printer, shutter);
    //adapter.register( );
    jf.setSize(300, 200);
}

{'macosappadapter'}
// BEGIN main
// gui/ThreadBasedCatcher.java
public static void main(String[] args) {
    new Thread(new Runnable() {

        public void run() {
            new ThreadBasedCatcher().setVisible(true);
        }
    }).start();
}

{'threadbasedcatcher'}
public void run() {
    // create a Frame, and "Component comp" to it.
    final JFrame f = new JFrame("CompRunner: " + args[0]);
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    Container cp = f.getContentPane();
    // Add the component under test
    cp.add(BorderLayout.CENTER, comp);
    // Set things reasonably sized.
    Dimension d = comp.getPreferredSize();
    if (d.width == 0 || d.height == 0) {
        // component doesn't have working getPreferredSize() yet, pick a size.
        f.setSize(300, 200);
    } else {
        f.pack();
    }
    f.setLocation(200, 200);
    f.setVisible(true);
}

{'getpreferredsize'}
/** "main program" method - construct and show */
@SuppressWarnings("unchecked")
public static void main(final String[] args) {
    if (args.length == 0) {
        System.err.println("Usage: CompRunner ComponentSubclass");
        System.exit(1);
    }
    String className = args[0];
    // create an instance of class named in "className", save in "Component comp".
    Class<Component> clazz = null;
    try {
        clazz = (Class<Component>) Class.forName(className);
    } catch (Exception e) {
        System.err.println("ERROR: " + className + " not valid; probably not on CLASSPATH");
        System.exit(1);
    }
    try {
        Object o = clazz.newInstance();
        if (!(o instanceof Component)) {
            System.err.println("ERROR: Class " + className + " is not a subclass of Component");
            System.exit(1);
        }
        comp = (Component) o;
    } catch (Exception e) {
        System.err.println(className + " got exception in construction or initialization");
        System.err.println(e.toString());
        System.exit(1);
    }
    // Java GUI events are not threadsafe, so start the GUI on the Event Thread
    EventQueue.invokeLater(new Runnable() {

        public void run() {
            // create a Frame, and "Component comp" to it.
            final JFrame f = new JFrame("CompRunner: " + args[0]);
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            Container cp = f.getContentPane();
            // Add the component under test
            cp.add(BorderLayout.CENTER, comp);
            // Set things reasonably sized.
            Dimension d = comp.getPreferredSize();
            if (d.width == 0 || d.height == 0) {
                // component doesn't have working getPreferredSize() yet, pick a size.
                f.setSize(300, 200);
            } else {
                f.pack();
            }
            f.setLocation(200, 200);
            f.setVisible(true);
        }
    });
}

{'classname', 'getpreferredsize'}
/** Construct the object including its GUI */
public JFrameDemo() {
    super("JFrameDemo");
    Container cp = getContentPane();
    cp.setLayout(new FlowLayout());
    cp.add(quitButton = new JButton("Exit"));
    // Set up so that "Close" will exit the program, 
    // not just close the JFrame.
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    // This "action handler" will be explained later in the chapter.
    quitButton.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            setVisible(false);
            dispose();
            System.exit(0);
        }
    });
    pack();
    setLocation(500, 400);
}

{'jframe'}
public static void main(String[] args) {
    JFrame jf = new JFrame("It Spins");
    Container cp = jf.getContentPane();
    cp.setLayout(new GridLayout(0, 1));
    // Create a JSpinner using one of the pre-defined SpinnerModels
    JSpinner dates = new JSpinner(new SpinnerDateModel());
    cp.add(dates);
    // Create a JSPinner using a SpinnerListModel. 
    String[] data = { "One", "Two", "Three" };
    JSpinner js = new JSpinner(new SpinnerListModel(data));
    cp.add(js);
    jf.setSize(100, 80);
    jf.setVisible(true);
}

{'spinnerlistmodel', 'jspinner', 'spinnermodels'}
/** Constructor */
public JFileChooserDemo(JFrame f) {
    final JFrame frame = f;
    final JFileChooser chooser = new JFileChooser();
    // If you want the user to select only directories, use this.
    // Default is to allow selection of files only.
    // Note if you set the selection mode to DIRECTORIES_ONLY,
    // it no longer displays any files, even with the file view.
    // chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
    // If want it to only show certain file types, use a FileFilter.
    // N.B. JFileFilter is not in javax.swing; it is my implementation
    // of interface javax.swing.filechooser.FileFilter, and is similar
    // to the ExtentionFilter in demo/jfc accompanying the J2SE SDK.
    JFileFilter filter = new JFileFilter();
    filter.addType("java");
    filter.addType("class");
    filter.addType("jar");
    filter.setDescription("Java-related files");
    chooser.addChoosableFileFilter(filter);
    JButton b = new JButton("Choose file...");
    add(b);
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            int returnVal = chooser.showOpenDialog(frame);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = chooser.getSelectedFile();
                System.out.println("You chose a " + (file.isFile() ? "file" : "directory") + " named: " + file.getPath());
            } else {
                System.out.println("You did not choose a filesystem object.");
            }
        }
    });
}

{'setfileselectionmode', 'jfilechooser', 'jfilefilter', 'filefilter', 'extentionfilter'}
/** Construct a program... */
public LNFSwitcher() {
    super();
    theFrame = new JFrame("LNF Switcher");
    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    cp = theFrame.getContentPane();
    cp.setLayout(new FlowLayout());
    ButtonGroup bg = new ButtonGroup();
    JRadioButton bJava = new JRadioButton("Java");
    bJava.addActionListener(new LNFSetter("javax.swing.plaf.metal.MetalLookAndFeel", bJava));
    bg.add(bJava);
    cp.add(bJava);
    JRadioButton bMSW = new JRadioButton("MS-Windows");
    bMSW.addActionListener(new LNFSetter("com.sun.java.swing.plaf.windows.WindowsLookAndFeel", bMSW));
    bg.add(bMSW);
    cp.add(bMSW);
    JRadioButton bMotif = new JRadioButton("Motif");
    bMotif.addActionListener(new LNFSetter("com.sun.java.swing.plaf.motif.MotifLookAndFeel", bMotif));
    bg.add(bMotif);
    cp.add(bMotif);
    JRadioButton bMac = new JRadioButton("Sun-MacOS");
    bMac.addActionListener(new LNFSetter("com.sun.java.swing.plaf.mac.MacLookAndFeel", bMac));
    bg.add(bMac);
    cp.add(bMac);
    String defaultLookAndFeel = UIManager.getSystemLookAndFeelClassName();
    // System.out.println(defaultLookAndFeel);
    JRadioButton bDefault = new JRadioButton("Default");
    bDefault.addActionListener(new LNFSetter(defaultLookAndFeel, bDefault));
    bg.add(bDefault);
    cp.add(bDefault);
    (previousButton = bDefault).setSelected(true);
    theFrame.pack();
}

{'defaultlookandfeel'}
/** Called when the button actually gets pressed. */
public void actionPerformed(ActionEvent e) {
    try {
        UIManager.setLookAndFeel(theLNFName);
        SwingUtilities.updateComponentTreeUI(theFrame);
        theFrame.pack();
    } catch (Exception evt) {
        JOptionPane.showMessageDialog(null, "setLookAndFeel didn't work: " + evt, "UI Failure", JOptionPane.INFORMATION_MESSAGE);
        previousButton.setSelected(true);
    }
    previousButton = thisButton;
}

{'reset', 'agree', 'gui'}
/**
     * Construct the GUI
     * @throws java.lang.IllegalArgumentException if constructed on a Sunday.
     */
public void JavadocDemo() {
    // We create and add a pushbutton here, 
    // but it doesn't do anything yet.
    Button b = new Button("Hello");
    // connect Button into component
    add(b);
    // Totally capricious example of what you should not do
    if (Calendar.getInstance().get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
        throw new IllegalArgumentException("Never On A Sunday");
    }
}

{'illegalargumentexception'}
/** Construct the GUI for an Applet Viewer */
AppletViewer(String appName) {
    super();
    this.appName = appName;
    f = new JFrame("AppletViewer");
    f.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            f.setVisible(false);
            f.dispose();
            System.exit(0);
        }
    });
    Container cp = f.getContentPane();
    cp.setLayout(new BorderLayout());
    // AppletStub and AppletContext.
    if (aa == null)
        aa = new AppletAdapter();
    // The AppletAdapter also gives us showStatus.
    // Therefore, must add() it very early on, since the Applet's
    // Constructor or its init() may use showStatus()
    cp.add(BorderLayout.SOUTH, aa);
    showStatus("Loading Applet " + appName);
    // sets ac and ai
    loadApplet(appName, WIDTH, HEIGHT);
    if (ai == null)
        return;
    // Now right away, tell the Applet how to find showStatus et al.
    ai.setStub(aa);
    // Connect the Applet to the Frame.
    cp.add(BorderLayout.CENTER, ai);
    Dimension d = ai.getSize();
    d.height += aa.getSize().height;
    f.setSize(d);
    // make the Frame and all in it appear
    f.setVisible(true);
    showStatus("Applet " + appName + " loaded");
    // Here we pretend to be a browser!
    ai.init();
    ai.start();
}

{'instantiate', 'appletcontext', 'appletstub', 'showstatus', 'appletadapter'}
/*
     * Load the Applet into memory. Should do caching.
     */
void loadApplet(String appletName, int w, int h) {
    // height =         ditto
    try {
        // get a Class object for the Applet subclass
        ac = Class.forName(appletName);
        // Construct an instance (as if using no-argument constructor)
        ai = (Applet) ac.newInstance();
    } catch (ClassNotFoundException e) {
        showStatus("Applet subclass " + appletName + " did not load");
        return;
    } catch (Exception e) {
        showStatus("Applet " + appletName + " did not instantiate");
        return;
    }
    ai.setSize(w, h);
}

{'appletname', 'html', 'extract', 'code', 'width', 'somehow'}
/** Construct the GUI for an Applet Status window */
AppletAdapter() {
    super();
    // Must do this very early on, since the Applet's
    // Constructor or its init() may use showStatus()
    add(status = new Label());
    // Give "status" the full width
    status.setSize(getSize().width, status.getSize().height);
    // now it can be said
    showStatus("AppletAdapter constructed");
}

{'showstatus'}
/** Called when the applet wants to be resized.  */
public void appletResize(int w, int h) {
// applet.setSize(w, h);
}

{'setsize'}
public static void main(String[] argv) {
    try {
        // or Class.forName("X");
        Class<?> clX = X.class;
        // To find a method we need the array of matching Class types.
        Class<?>[] argTypes = { int.class, String.class };
        // Now find a Method object for the given method.
        Method worker = clX.getMethod("work", argTypes);
        // To INVOKE the method, we need the invocation
        // arguments, as an Object array.
        Object[] theData = { 42, "Chocolate Chips" };
        // The obvious last step: invoke the method.
        // First arg is an instance, null if static method
        worker.invoke(new X(), theData);
    } catch (Exception e) {
        System.err.println("Invoke() failed: " + e);
    }
}

{'forname'}
/** This approach began as a contribution by Paul Kuit at
     * http://stackoverflow.com/questions/1456930/, but his only
     * handled single files in a directory in classpath, not in Jar files.
     * N.B. Does NOT handle system classes!
     * @param packageName
     * @return
     * @throws IOException
     */
public static String[] getPackageContent(String packageName) throws IOException {
    final String packageAsDirName = packageName.replace(".", "/");
    final List<String> list = new ArrayList<>();
    final Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(packageAsDirName);
    while (urls.hasMoreElements()) {
        URL url = urls.nextElement();
        // System.out.println("URL = " + url);
        String file = url.getFile();
        switch(url.getProtocol()) {
            case "file":
                // This is the easy case: "file" is 
                // the full path to the classpath directory
                File dir = new File(file);
                for (File f : dir.listFiles()) {
                    list.add(packageAsDirName + "/" + f.getName());
                }
                break;
            case "jar":
                // This is the harder case; "file" is of the form
                // "jar:/home/ian/bleah/darwinsys.jar!com/darwinsys/io"
                // for some jar file that contains at least one class from 
                // the given package.
                int colon = file.indexOf(':');
                int bang = file.indexOf('!');
                String jarFileName = file.substring(colon + 1, bang);
                JarFile jarFile = new JarFile(jarFileName);
                Enumeration<JarEntry> entries = jarFile.entries();
                while (entries.hasMoreElements()) {
                    JarEntry e = entries.nextElement();
                    String jarEntryName = e.getName();
                    if (!jarEntryName.endsWith("/") && jarEntryName.startsWith(packageAsDirName)) {
                        list.add(jarEntryName);
                    }
                }
                break;
            default:
                throw new IllegalStateException("Dunno what to do with URL " + url);
        }
    }
    return list.toArray(new String[] {});
}

{'packagename', 'ioexception'}
public static void main(String[] unused) throws NoSuchFieldException, IllegalAccessException {
    // Create instance of FindField
    FindField gf = new FindField();
    // Create instance of target class (YearHolder defined below).
    Object o = new YearHolder();
    // Use gf to extract a field from o.
    System.out.println("The value of 'currentYear' is: " + gf.intFieldValue(o, "currentYear"));
}

{'findfield', 'yearholder'}
/** Main processing of the current input source. */
protected void process() throws IOException {
    String line;
    // emit PostScript prologue, once.
    prologue();
    // emit top-of-page (ending previous)
    startPage();
    while ((line = br.readLine()) != null) {
        if (line.startsWith("\f") || line.trim().equals(".bp")) {
            startPage();
            continue;
        }
        doLine(line);
    }
    // finish last page, if not already done.
    if (lineNum != 0)
        System.out.println("showpage");
}

{'postscript'}
public static void main(String[] args) {
    try {
        Class.forName("javax.swing.JButton");
    } catch (ClassNotFoundException e) {
        String failure = "Sorry, but this version of MyApp needs \n" + "a Java Runtime with JFC/Swing components\n" + "having the final names (javax.swing.*)";
        System.err.println(failure);
    }
// No need to print anything here - the GUI should work...
}

{'mypanel', 'joptionpane', 'add', 'either', 'appear', 'label', 'better', 'new', 'make', 'something'}
/** Run the main loop of the Server. Each time a client connects,
     * the ServerSocket accept() returns a new Socket for I/O, and
     * we pass that to the Handler constructor, which creates a Thread,
     * which we start.
     */
void runServer() throws Exception {
    while (true) {
        final Socket clntSock = sock.accept();
        Thread t = new Thread() {

            public void run() {
                new Handler(Httpd.this).process(clntSock);
            }
        };
        t.start();
    }
}

{'serversocket'}
/** Main just constructs a ChatServer, which should never return */
public static void main(String[] argv) throws IOException {
    System.out.println("DarwinSys ChatServer 0.1 starting...");
    if (argv.length == 1 && argv[0].equals("-debug"))
        DEBUG = true;
    ChatServer w = new ChatServer();
    // should never return.
    w.runServer();
    System.out.println("**ERROR* ChatServer 0.1 quitting");
}

{'chatserver'}
/** Construct (and run!) a Chat Service 
     * @throws IOException
     */
ChatServer() throws IOException {
    clients = new ArrayList<>();
    servSock = new ServerSocket(ChatProtocol.PORTNUM);
    System.out.println("DarwinSys Chat Server Listening on port " + ChatProtocol.PORTNUM);
}

{'ioexception'}
/** Each ChatHandler is a Thread, so here's the run() method,
         * which handles this conversation.
         */
public void run() {
    String line;
    try {
        /*
                 * We should stay in this loop as long as the Client remains
                 * connected, so when this loop ends, we disconnect the client.
                 */
        while ((line = is.readLine()) != null) {
            char c = line.charAt(0);
            line = line.substring(1);
            switch(c) {
                case ChatProtocol.CMD_LOGIN:
                    if (!ChatProtocol.isValidLoginName(line)) {
                        send(CHATMASTER_ID, "LOGIN " + line + " invalid");
                        log("LOGIN INVALID from " + clientIP);
                        continue;
                    }
                    login = line;
                    broadcast(CHATMASTER_ID, login + " joins us, for a total of " + clients.size() + " users");
                    break;
                case ChatProtocol.CMD_MESG:
                    if (login == null) {
                        send(CHATMASTER_ID, "please login first");
                        continue;
                    }
                    int where = line.indexOf(ChatProtocol.SEPARATOR);
                    String recip = line.substring(0, where);
                    String mesg = line.substring(where + 1);
                    log("MESG: " + login + "-->" + recip + ": " + mesg);
                    ChatHandler cl = lookup(recip);
                    if (cl == null)
                        psend(CHATMASTER_ID, recip + " not logged in.");
                    else
                        cl.psend(login, mesg);
                    break;
                case ChatProtocol.CMD_QUIT:
                    broadcast(CHATMASTER_ID, "Goodbye to " + login + "@" + clientIP);
                    close();
                    // The end of this ChatHandler
                    return;
                case ChatProtocol.CMD_BCAST:
                    if (login != null)
                        broadcast(login, line);
                    else
                        log("B<L FROM " + clientIP);
                    break;
                default:
                    log("Unknown cmd " + c + " from " + login + "@" + clientIP);
            }
        }
    } catch (IOException e) {
        log("IO Exception: " + e);
    } finally {
        // the sock ended (darn it), so we're done, bye now
        System.out.println(login + SEP + "All Done");
        String message = "This should never appear.";
        synchronized (clients) {
            clients.remove(this);
            if (clients.size() == 0) {
                System.out.println(CHATMASTER_ID + SEP + "I'm so lonely I could cry...");
            } else if (clients.size() == 1) {
                message = "Hey, you're talking to yourself again";
            } else {
                message = "There are now " + clients.size() + " users";
            }
        }
        broadcast(CHATMASTER_ID, message);
    }
}

{'chathandler'}
/** Present this ChatHandler as a String */
public String toString() {
    return "ChatHandler[" + login + "]";
}

{'chathandler'}
static void testTwoCols() {
    final JFrame f = new JFrame("EntryLayout Demonstration");
    Container cp = f.getContentPane();
    double widths[] = { .33, .66 };
    cp.setLayout(new EntryLayout(widths));
    cp.add(new JLabel("Login:", SwingConstants.RIGHT));
    cp.add(new JTextField(10));
    cp.add(new JLabel("Password:", SwingConstants.RIGHT));
    cp.add(new JPasswordField(20));
    cp.add(new JLabel("Security Domain:", SwingConstants.RIGHT));
    cp.add(new JTextField(20));
    // cp.add(new JLabel("Monkey wrench in works"));
    f.pack();
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    f.setLocation(200, 200);
    f.setVisible(true);
}

{'jlabel'}
/** This is really a demo method, not a test, sorry. */
public void showReadingAMailMessageWithHeaders() throws IOException {
    // BEGIN main
    IndentContLineReader is = new IndentContLineReader(new StringReader(sampleTxt));
    String aLine;
    // Print Mail/News Header
    System.out.println("----- Message Header -----");
    while ((aLine = is.readLine()) != null && aLine.length() > 0) {
        System.out.println(is.getLineNumber() + ": " + aLine);
    }
    // Make "is" behave like normal BufferedReader
    is.setContinuationMode(false);
    System.out.println();
    // Print Message Body
    System.out.println("----- Message Body -----");
    while ((aLine = is.readLine()) != null) {
        System.out.println(is.getLineNumber() + ": " + aLine);
    }
    is.close();
// END main
}

{'bufferedreader'}
public static void main(String args[]) {
    try {
        // UIManager.setLookAndFeel("javax.swing.plaf.nimbus.NimbusLookAndFeel");
        ClassBrowser app = new ClassBrowser();
        app.setBounds(220, 30, 470, 600);
        app.setVisible(true);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}

{'setlookandfeel', 'uimanager', 'nimbuslookandfeel'}
public static void main(String[] args) {
    Thread primeNumberGenerator = new Thread(new WorkerThread());
    primeNumberGenerator.start();
    InputStreamReader in = new InputStreamReader(System.in);
    try {
        while (in.read() != '\n') {
        }
    } catch (IOException ex) {
        ex.printStackTrace();
    }
    primeNumberGenerator.interrupt();
    // }
    if (primeNumberGenerator.isInterrupted()) {
        System.out.println("\nNumber generation has " + "already been interrupted");
    } else {
        System.out.println("Number generator " + "is not currently running");
    }
    Thread lazyWorker = new Thread(new LazyWorker());
    lazyWorker.start();
    System.out.println("\nRunning lazy worker");
    try {
        Thread.sleep(100);
    } catch (InterruptedException ex) {
    }
    lazyWorker.interrupt();
}

{'following', 'checking', 'introduce', 'uncomment', 'status', 'delay', 'interruptedexception', 'line'}
public boolean shouldAccept(URI uri, HttpCookie cookie) {
    // return uri.getHost().equals("yahoo.com");
    return true;
}

{'gethost'}
void buildList() {
    listOfFamousQuotes = new ArrayList();
    listOfFamousQuotes.add("Where there is love there is life - Mahatma Gandhi");
    listOfFamousQuotes.add("A joke is a very serious thing - Winston Churchill");
    listOfFamousQuotes.add("In the end, everything is a gag - Charlie Chaplin");
// listOfFamousQuotes.add(100); // add this to generate runtime error
}

{'listoffamousquotes'}
public static void main(String args[]) {
    try {
        byte buffer[] = new byte[100];
        System.out.print("Enter your name: ");
        System.in.read(buffer);
        System.out.println("Hello " + new String(buffer));
    } catch (Exception e) {
    }
}

{'good', 'discus', 'practice', 'handling', 'chapter'}
public static void main(String[] args) {
    int m = 0, n = 0;
    System.out.println("Enter two characters without a space and hit return");
    try {
        m = System.in.read();
        n = System.in.read();
    } catch (Exception ex) {
    }
    System.out.println("Character " + (char) m + " has ASCII value = " + m);
    System.out.println("Character " + (char) n + " has ASCII value = " + n);
    System.out.printf("(%c > %c)returns ", m, n);
    System.out.println(m > n);
    System.out.printf("(%c < %c)returns ", m, n);
    System.out.println(m < n);
    System.out.printf("(%c >= %c)returns ", m, n);
    System.out.println(m >= n);
    System.out.printf("(%c <= %c)returns ", m, n);
    System.out.println(m <= n);
    System.out.printf("(%c != %c)returns ", m, n);
    System.out.println(m != n);
    System.out.printf("(%c == %c)returns ", m, n);
    System.out.println(m == n);
}

{'handler', 'provide'}
/**
   * Load the image.  Create a new image that is a grayer version of it, using
   * a FilteredImageSource, ImageProducer and a the GrayFilter class, below.
   */
public void init() {
    orig = this.getImage(this.getDocumentBase(), "cover.gif");
    ImageFilter filter = new GrayFilter();
    ImageProducer producer = new FilteredImageSource(orig.getSource(), filter);
    gray = this.createImage(producer);
}

{'imageproducer', 'filteredimagesource', 'grayfilter'}
public void init() {
    // Tell this applet what MouseListener and MouseMotionListener
    // objects to notify when mouse and mouse motion events occur.
    // Since we implement the interfaces ourself, our own methods are called.
    this.addMouseListener(this);
    this.addMouseMotionListener(this);
}

{'mouselistener', 'mousemotionlistener'}
// The other, unused methods of the MouseListener interface.
public void mouseReleased(MouseEvent e) {
    ;
}

{'mouselistener'}
// The other method of the MouseMotionListener interface.
public void mouseMoved(MouseEvent e) {
    ;
}

{'mousemotionlistener'}
public static void display(Throwable error) {
    ResourceBundle bundle;
    // If none, print the error in a non-localized way.
    try {
        bundle = ResourceBundle.getBundle("Errors");
    } catch (MissingResourceException e) {
        error.printStackTrace(System.err);
        return;
    }
    // Look up a localized message resource in that bundle, using the
    // classname of the error (or its superclasses) as the resource name.
    // If no resource was found, display the error without localization.
    String message = null;
    Class c = error.getClass();
    while ((message == null) && (c != Object.class)) {
        try {
            message = bundle.getString(c.getName());
        } catch (MissingResourceException e) {
            c = c.getSuperclass();
        }
    }
    if (message == null) {
        error.printStackTrace(System.err);
        return;
    }
    // Try to figure out the filename and line number of the
    // exception.  Output the error's stack trace into a string, and
    // use the heuristic that the first line number that appears in
    // the stack trace is after the first or  second colon.  We assume that
    // this stack frame is the first one the programmer has any control
    // over, and so report it as the location of the exception.
    String filename = "";
    int linenum = 0;
    try {
        // Output stream into a string.
        StringWriter sw = new StringWriter();
        // PrintWriter wrapper.
        PrintWriter out = new PrintWriter(sw);
        // Print stacktrace.
        error.printStackTrace(out);
        // Get it as a string.
        String trace = sw.toString();
        // Look for first colon.
        int pos = trace.indexOf(':');
        if (// If the error has a message
        error.getMessage() != null)
            // look for second colon.
            pos = trace.indexOf(':', pos + 1);
        // Look for end of line number.
        int pos2 = trace.indexOf(')', pos);
        // Get linenum.
        linenum = Integer.parseInt(trace.substring(pos + 1, pos2));
        // Back to start of filename.
        pos2 = trace.lastIndexOf('(', pos);
        // Get filename.
        filename = trace.substring(pos2 + 1, pos);
    }// Ignore exceptions.
     catch (Exception e) {
        ;
    }
    // Set up an array of arguments to use with the message
    String errmsg = error.getMessage();
    Object[] args = { ((errmsg != null) ? errmsg : ""), error.getClass().getName(), filename, new Integer(linenum), new Date() };
    // Finally, display the localized error message, using
    // MessageFormat.format() to substitute the arguments into the message.
    System.out.println(MessageFormat.format(message, args));
}

{'messageformat', 'printwriter'}
public static void main(String[] args) throws IOException {
    // Get set up to read lines of text from the user
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    for (; ; ) {
        // Loop forever
        // Print a prompt
        System.out.print("> ");
        // Read a line
        String line = in.readLine();
        if (// If EOF or "quit" then...
        (line == null) || line.equals("quit"))
            // ... break out of the loop
            break;
        // Convert to a StringBuffer
        StringBuffer buf = new StringBuffer(line);
        for (// For each character...
        int i = 0; // For each character...
        i < buf.length(); // For each character...
        i++) //   read, encode, put it back
        buf.setCharAt(i, rot13(buf.charAt(i)));
        // Print encoded line
        System.out.println(buf);
    }
}

{'stringbuffer'}
/**
   * The static method that does the deletion.  Invoked by main(), and designed
   * for use by other programs as well.  It first makes sure that the 
   * specified file or directory is deleteable before attempting to delete it.
   * If there is a problem, it throws an IllegalArgumentException.
   */
public static void delete(String filename) {
    // Create a File object to represent the filename
    File f = new File(filename);
    // Make sure the file or directory exists and isn't write protected
    if (!f.exists())
        fail("Delete: no such file or directory: " + filename);
    if (!f.canWrite())
        fail("Delete: write protected: " + filename);
    // If it is a directory, make sure it is empty
    if (f.isDirectory()) {
        String[] files = f.list();
        if (files.length > 0)
            fail("Delete: directory not empty: " + filename);
    }
    // If we passed all the tests, then attempt to delete it
    boolean success = f.delete();
    // directory deletion always fails 
    if (!success)
        fail("Delete: deletion failed");
}

{'illegalargumentexception', 'reason', 'linux', 'bug', 'unknown', 'example', 'work', 'java'}
// A simple test program for the UniversalActionListener
public static void main(String[] args) throws NoSuchMethodException {
    // Create window.
    Frame f = new Frame("UniversalActionListener Test");
    // Set layout manager.
    f.setLayout(new FlowLayout());
    // Create buttons.
    Button b1 = new Button("tick");
    Button b2 = new Button("tock");
    Button b3 = new Button("Close Window");
    // Add them to window.
    f.add(b1);
    // Add them to window.
    f.add(b2);
    // Add them to window.
    f.add(b3);
    // Specify what the buttons do.  Invoke a named method with
    // the UniversalActionListener object.
    b1.addActionListener(new UniversalActionListener(b1, "setLabel", "tock"));
    b1.addActionListener(new UniversalActionListener(b2, "setLabel", "tick"));
    b1.addActionListener(new UniversalActionListener(b3, "hide", null));
    b2.addActionListener(new UniversalActionListener(b1, "setLabel", "tick"));
    b2.addActionListener(new UniversalActionListener(b2, "setLabel", "tock"));
    b2.addActionListener(new UniversalActionListener(b3, "show", null));
    b3.addActionListener(new UniversalActionListener(f, "dispose", null));
    // Set window size.
    f.pack();
    // And pop it up.
    f.show();
}

{'universalactionlistener'}
/**
   * This ItemListener method uses various File methods to obtain information
   * about a file or directory. Then it displays that info in the details box.
   **/
public void itemStateChanged(ItemEvent e) {
    // minus 1 for Up To Parent entry
    int i = list.getSelectedIndex() - 1;
    if (i < 0)
        return;
    // Get the selected entry 
    String filename = files[i];
    // Convert to a File
    File f = new File(currentDir, filename);
    if (// Confirm that it exists
    !f.exists())
        throw new IllegalArgumentException("FileLister: " + "no such file or directory");
    // Get the details about the file or directory, concatenate to a string
    String info = filename;
    if (f.isDirectory())
        info += File.separator;
    info += " " + f.length() + " bytes ";
    info += dateFormatter.format(new java.util.Date(f.lastModified()));
    if (f.canRead())
        info += " Read";
    if (f.canWrite())
        info += " Write";
    // And display the details string
    details.setText(info);
}

{'itemlistener'}
/**
   * This ActionListener method is invoked when the user double-clicks on an 
   * entry or clicks on one of the buttons.  If they double-click on a file,
   * create a FileViewer to display that file.  If they double-click on a
   * directory, call the listDirectory() method to display that directory
   **/
public void actionPerformed(ActionEvent e) {
    if (e.getSource() == close)
        this.dispose();
    else if (e.getSource() == up) {
        up();
    } else if (e.getSource() == list) {
        // Double click on an item
        // Check which item
        int i = list.getSelectedIndex();
        if (// Handle first Up To Parent item
        i == 0)
            // Handle first Up To Parent item
            up();
        else {
            // Otherwise, get filename
            String name = files[i - 1];
            // Convert to a File
            File f = new File(currentDir, name);
            String fullname = f.getAbsolutePath();
            if (// List a directory
            f.isDirectory())
                // List a directory
                listDirectory(fullname);
            else
                // or display a file
                new FileViewer(fullname).show();
        }
    }
}

{'actionlistener', 'listdirectory', 'fileviewer'}
/**
   * A main() method so FileLister can be run standalone.
   * Parse command line arguments and create the FileLister object.
   * If an extension is specified, create a FilenameFilter for it.
   * If no directory is specified, use the current directory.
   */
public static void main(String args[]) throws IOException {
    FileLister f;
    // The filter, if any
    FilenameFilter filter = null;
    // The specified dir, or the current dir
    String directory = null;
    // Loop through args array, parsing arguments
    for (int i = 0; i < args.length; i++) {
        if (args[i].equals("-e")) {
            if (++i >= args.length)
                usage();
            // final for use in anon. class below
            final String suffix = args[i];
            // This class is a simple FilenameFilter.  It defines the
            // accept() method required to determine whether a specified
            // file should be listed.  A file will be listed if its name
            // ends with the specified extension, or if it is a directory.
            filter = new FilenameFilter() {

                public boolean accept(File dir, String name) {
                    if (name.endsWith(suffix))
                        return true;
                    else
                        return (new File(dir, name)).isDirectory();
                }
            };
        } else {
            if (// If dir already specified, fail.
            directory != null)
                // If dir already specified, fail.
                usage();
            else
                directory = args[i];
        }
    }
    // if no directory specified, use the current directoy
    if (directory == null)
        directory = System.getProperty("user.dir");
    // Create the FileLister object, with directory and filter specified.
    f = new FileLister(directory, filter);
    // Arrange for the application to exit when the FileLister window closes
    f.addWindowListener(new WindowAdapter() {

        public void windowClosed(WindowEvent e) {
            System.exit(0);
        }
    });
    // And pop up the FileLister.
    f.show();
}

{'filenamefilter', 'filelister'}
/**
   * The static method that actually performs the file copy.
   * Before copying the file, however, it performs a lot of tests to make
   * sure everything is as it should be.
   */
public static void copy(String from_name, String to_name) throws IOException {
    // Get File objects from Strings
    File from_file = new File(from_name);
    File to_file = new File(to_name);
    // First make sure the source file exists, is a file, and is readable.
    if (!from_file.exists())
        abort("FileCopy: no such source file: " + from_name);
    if (!from_file.isFile())
        abort("FileCopy: can't copy directory: " + from_name);
    if (!from_file.canRead())
        abort("FileCopy: source file is unreadable: " + from_name);
    // as the destination file name
    if (to_file.isDirectory())
        to_file = new File(to_file, from_file.getName());
    // exist, make sure the directory exists and is writeable.
    if (to_file.exists()) {
        if (!to_file.canWrite())
            abort("FileCopy: destination file is unwriteable: " + to_name);
        // Ask whether to overwrite it
        System.out.print("Overwrite existing file " + to_name + "? (Y/N): ");
        System.out.flush();
        // Get the user's response.
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String response = in.readLine();
        // Check the response.  If not a Yes, abort the copy.
        if (!response.equals("Y") && !response.equals("y"))
            abort("FileCopy: existing file was not overwritten.");
    } else {
        // if file doesn't exist, check if directory exists and is writeable.
        // If getParent() returns null, then the directory is the current dir.
        // so look up the user.dir system property to find out what that is.
        // Get the destination directory
        String parent = to_file.getParent();
        // or CWD
        if (parent == null)
            parent = System.getProperty("user.dir");
        // Convert it to a file.
        File dir = new File(parent);
        if (!dir.exists())
            abort("FileCopy: destination directory doesn't exist: " + parent);
        if (dir.isFile())
            abort("FileCopy: destination is not a directory: " + parent);
        if (!dir.canWrite())
            abort("FileCopy: destination directory is unwriteable: " + parent);
    }
    // If we've gotten this far, then everything is okay.
    // So we copy the file, a buffer of bytes at a time.
    // Stream to read from source
    FileInputStream from = null;
    // Stream to write to destination
    FileOutputStream to = null;
    try {
        // Create input stream
        from = new FileInputStream(from_file);
        // Create output stream
        to = new FileOutputStream(to_file);
        // A buffer to hold file contents
        byte[] buffer = new byte[4096];
        // How many bytes in buffer
        int bytes_read;
        // loop.  This is a common I/O programming idiom.
        while (// Read bytes until EOF
        (bytes_read = from.read(buffer)) != -1) //   write bytes 
        to.write(buffer, 0, bytes_read);
    } finally // Always close the streams, even if exceptions were thrown
    {
        if (from != null)
            try {
                from.close();
            } catch (IOException e) {
                ;
            }
        if (to != null)
            try {
                to.close();
            } catch (IOException e) {
                ;
            }
    }
}

{'chunk', 'overwriting', 'reach', 'assignment', 'end', 'looping', 'use', 'getparent', 'combination', 'comparison', 'note'}
/** The DrawableRect constructor just invokes the Rect() constructor */
public DrawableRect(int x1, int y1, int x2, int y2) {
    super(x1, y1, x2, y2);
}

{'drawablerect'}
/** This is the new method defined by DrawableRect */
public void draw(java.awt.Graphics g) {
    g.drawRect(x1, y1, (x2 - x1), (y2 - y1));
}

{'drawablerect'}
/** Draw the circle at its current position, using double-buffering */
public void paint(Graphics g) {
    // Draw into the off-screen buffer.
    // Note, we could do even better clipping by setting the clip rectangle
    // of bufferGraphics to be the same as that of g.
    // In Java 1.1:  bufferGraphics.setClip(g.getClip());
    bufferGraphics.setColor(this.getBackground());
    // clear the buffer
    bufferGraphics.fillRect(0, 0, size.width, size.height);
    bufferGraphics.setColor(Color.red);
    // draw the circle
    bufferGraphics.fillOval(x - r, y - r, r * 2, r * 2);
    // Then copy the off-screen buffer onto the screen
    g.drawImage(buffer, 0, 0, this);
}

{'setclip', 'buffergraphics', 'getclip'}
/**
     * This protected method requests a Pipe threads to create and return
     * a PipedReader thread so that another Pipe thread can connect to it.
     **/
protected PipedReader getReader() {
    if (in == null)
        in = new PipedReader();
    return in;
}

{'pipedreader'}
/** 
     * To create a ReaderPipeSource, specify the Reader that data comes from
     * and the Pipe sink that it should be sent to.
     **/
public ReaderPipeSource(Pipe sink, Reader in) throws IOException {
    super(sink);
    this.in = in;
}

{'readerpipesource'}
/**
     * This method overrides the getReader() method of Pipe.  Because this
     * is a source thread, this method should never be called.  To make sure
     * that it is never called, we throw an Error if it is.
     **/
protected PipedReader getReader() {
    throw new Error("Can't connect to a ReaderPipeSource!");
}

{'getreader'}
/**
     * To create a WriterPipeSink, just specify what Writer characters 
     * from the pipe should be written to
     **/
public WriterPipeSink(Writer out) throws IOException {
    // Create a terminal Pipe with no sink attached.
    super();
    this.out = out;
}

{'writerpipesink'}
/** 
     * Create a GrepFilter, will search its input for the specified pattern
     * and send the results to the specified Pipe.
     **/
public GrepFilter(Pipe sink, String pattern) throws IOException {
    super(sink);
    this.pattern = pattern;
}

{'grepfilter'}
/** 
     * Do the filtering, using a GrepReader to filter lines read from
     * the Reader, and using a PrintWriter to send those lines back out
     * to the Writer.
     **/
public void filter(Reader in, Writer out) throws IOException {
    GrepReader gr = new GrepReader(new BufferedReader(in), pattern);
    PrintWriter pw = new PrintWriter(out);
    String line;
    while ((line = gr.readLine()) != null) pw.println(line);
}

{'printwriter', 'grepreader'}
/**
     * Read characters from the reader, one at a time (using a BufferedReader
     * for efficiency).  Output printable ASCII characters unfiltered.  For
     * other characters, output the \U Unicode encoding.
     **/
public void filter(Reader r, Writer w) throws IOException {
    BufferedReader in = new BufferedReader(r);
    PrintWriter out = new PrintWriter(new BufferedWriter(w));
    int c;
    while ((c = in.read()) != -1) {
        // Just output ASCII characters
        if (((c >= ' ') && (c <= '~')) || (c == '\t') || (c == '\n') || (c == '\r'))
            out.write(c);
        else // And encode the others
        {
            String hex = Integer.toHexString(c);
            switch(hex.length()) {
                case 1:
                    out.print("\\u000" + hex);
                    break;
                case 2:
                    out.print("\\u00" + hex);
                    break;
                case 3:
                    out.print("\\u0" + hex);
                    break;
                default:
                    out.print("\\u" + hex);
                    break;
            }
        }
    }
    // flush the output buffer we create
    out.flush();
}

{'bufferedreader'}
/** Create a Frame, Menu, and Scribble component */
public SerializedScribble() {
    // Create the window.
    super("SerialziedScribble");
    final Scribble scribble;
    // Create a bigger scribble area.
    scribble = new Scribble(this, 300, 300);
    // Add it to the ScrollPane.
    this.add(scribble, "Center");
    // Create a menubar.
    MenuBar menubar = new MenuBar();
    // Add it to the frame.
    this.setMenuBar(menubar);
    // Create a File menu.
    Menu file = new Menu("File");
    // Add to menubar.
    menubar.add(file);
    // Create three menu items, with menu shortcuts, and add to the menu.
    MenuItem load, save, quit;
    file.add(load = new MenuItem("Load"));
    file.add(save = new MenuItem("Save"));
    // Put a separator in the menu
    file.addSeparator();
    file.add(quit = new MenuItem("Quit"));
    // Create and register action listener objects for the three menu items.
    load.addActionListener(new // Open a new window
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            scribble.load();
        }
    });
    save.addActionListener(new // Close this window.
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            scribble.save();
        }
    });
    quit.addActionListener(new // Quit the program.
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    // Another event listener, this one to handle window close requests.
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
    // Set the window size and pop it up.
    this.pack();
    this.show();
}

{'scrollpane'}
/**
     * Prompt the user for a filename, and save the scribble in that file.
     * Serialize the vector of lines with an ObjectOutputStream.
     * Compress the serialized objects with a GZIPOutputStream.
     * Write the compressed, serialized data to a file with a FileOutputStream.
     * Don't forget to flush and close the stream.
     **/
public void save() {
    // Create a file dialog to query the user for a filename.
    FileDialog f = new FileDialog(frame, "Save Scribble", FileDialog.SAVE);
    // Display the dialog and block.
    f.show();
    // Get the user's response
    String filename = f.getFile();
    if (filename != null) {
        // If user didn't click "Cancel".
        try {
            // Create the necessary output streams to save the scribble.
            // Save to file
            FileOutputStream fos = new FileOutputStream(filename);
            // Compressed
            GZIPOutputStream gzos = new GZIPOutputStream(fos);
            // Save objects
            ObjectOutputStream out = new ObjectOutputStream(gzos);
            // Write the entire Vector of scribbles
            out.writeObject(lines);
            // Always flush the output.
            out.flush();
            // And close the stream.
            out.close();
        }// Print out exceptions.  We should really display them in a dialog...
         catch (IOException e) {
            System.out.println(e);
        }
    }
}

{'fileoutputstream', 'objectoutputstream', 'gzipoutputstream'}
/**
     * Prompt for a filename, and load a scribble from that file.
     * Read compressed, serialized data with a FileInputStream.
     * Uncompress that data with a GZIPInputStream.
     * Deserialize the vector of lines with a ObjectInputStream.
     * Replace current data with new data, and redraw everything.
     **/
public void load() {
    // Create a file dialog to query the user for a filename.
    FileDialog f = new FileDialog(frame, "Load Scribble", FileDialog.LOAD);
    // Display the dialog and block.
    f.show();
    // Get the user's response
    String filename = f.getFile();
    if (filename != null) {
        // If user didn't click "Cancel".
        try {
            // Create necessary input streams
            // Read from file
            FileInputStream fis = new FileInputStream(filename);
            // Uncompress
            GZIPInputStream gzis = new GZIPInputStream(fis);
            // Read objects
            ObjectInputStream in = new ObjectInputStream(gzis);
            // Read in an object.  It should be a vector of scribbles
            Vector newlines = (Vector) in.readObject();
            // Close the stream.
            in.close();
            // Set the Vector of lines.
            lines = newlines;
            // And redisplay the scribble.
            repaint();
        }// Print out exceptions.  We should really display them in a dialog...
         catch (Exception e) {
            System.out.println(e);
        }
    }
}

{'fileinputstream', 'objectinputstream', 'gzipinputstream'}
/**
   * The constructor builds a very simple test GUI, and registers this object
   * as the ActionListener for the buttons 
   **/
public StringCutAndPaste() {
    // Use a nice font
    this.setFont(new Font("SansSerif", Font.PLAIN, 14));
    // Set up the Cut button
    Button cut = new Button("Cut");
    cut.addActionListener(this);
    cut.setActionCommand("cut");
    this.add(cut, "West");
    // Set up the Paste button
    Button paste = new Button("Paste");
    paste.addActionListener(this);
    paste.setActionCommand("paste");
    this.add(paste, "East");
    // Set up the text field that they both operate on
    field = new TextField();
    this.add(field, "North");
}

{'actionlistener'}
/**
   * This method takes the current contents of the text field, creates a
   * StringSelection object to represent that string, and puts the 
   * StringSelection onto the clipboard
   **/
public void cut() {
    // Get the currently displayed value
    String s = field.getText();
    // Create a StringSelection object to represent it.
    // This is a big convenience, because StringSelection implements both
    // the Transferable interface and the ClipboardOwner.  We don't have
    // to deal with either of them.
    StringSelection ss = new StringSelection(s);
    // Now set the StringSelection object as the contents of the clipboard
    // Also set it as the owner of the clipboard.
    this.getToolkit().getSystemClipboard().setContents(ss, ss);
}

{'stringselection', 'clipboardowner'}
/**
   * This method does the reverse.  It gets the contents of the clipboard,
   * then asks for them to be converted to a string, then displays the
   * string.
   **/
public void paste() {
    // Get the clipboard
    Clipboard c = this.getToolkit().getSystemClipboard();
    // Get the contents of the clipboard, as a Transferable object
    Transferable t = c.getContents(this);
    // string DataFlavor.  Then display that string in the field.
    try {
        String s = (String) t.getTransferData(DataFlavor.stringFlavor);
        field.setText(s);
    }// If anything goes wrong with the transfer, just beep and do nothing.
     catch (Exception e) {
        this.getToolkit().beep();
        return;
    }
}

{'form', 'using', 'predefined', 'dataflavor', 'ask'}
/** The factorial() method, using BigIntegers cached in a Vector */
public static synchronized BigInteger factorial(int x) {
    if (x < 0)
        throw new IllegalArgumentException("x must be non-negative.");
    for (int size = table.size(); size <= x; size++) {
        BigInteger lastfact = (BigInteger) table.elementAt(size - 1);
        BigInteger nextfact = lastfact.multiply(BigInteger.valueOf(size));
        table.addElement(nextfact);
    }
    return (BigInteger) table.elementAt(x);
}

{'bigintegers'}
/** Initialize the applet */
public void init() {
    // Look up the name of the image, relative to a base URL, and load it.
    // Note the use of three Applet methods in this one line.
    image = this.getImage(this.getDocumentBase(), this.getParameter("image"));
    // Lookup and parse a list of rectangular areas and the URLs they map to.
    // The convenience routine getRectangleParameter() is defined below.
    rects = new Vector();
    ImagemapRectangle r;
    for (int i = 0; (r = getRectangleParameter("rect" + i)) != null; i++) rects.addElement(r);
    // Look up a sound to play when the user clicks one of those areas.
    sound = this.getAudioClip(this.getDocumentBase(), this.getParameter("sound"));
    // Specify an "event listener" object to respond to mouse button
    // presses and releases.  Note that this is the Java 1.1 event model.
    // Note that it also uses a Java 1.1 inner class, defined below.
    this.addMouseListener(new Listener());
}

{'getrectangleparameter'}
/** Called when a mouse button is released. */
public void mouseReleased(MouseEvent e) {
    // mouse is still inside it, ask the browser to go to the URL.
    if (lastrect != null) {
        Graphics g = Applet.this.getGraphics();
        g.setXORMode(Color.red);
        g.drawRect(lastrect.x, lastrect.y, lastrect.width, lastrect.height);
        // Clear the message.
        Applet.this.showStatus("");
        ImagemapRectangle r = findrect(e);
        if (// If still in the same rectangle
        (r != null) && (r == lastrect))
            // Go to the URL
            Applet.this.getAppletContext().showDocument(r.url);
        lastrect = null;
    }
}

{'unhighlight'}
/** A default constructor that creates a ColumnLayout using 5-pixel
   *  margin width and height, 5-pixel spacing, and left alignment */
public ColumnLayout() {
    this(5, 5, 5, LEFT);
}

{'columnlayout'}
// Other LayoutManager(2) methods that are unused by this class
public void addLayoutComponent(String constraint, Component comp) {
}

{'layoutmanager'}
public static void main(String args[]) {
    try {
        // Get the port to listen on
        int port = Integer.parseInt(args[0]);
        // Create a ServerSocket to listen on that port.
        ServerSocket ss = new ServerSocket(port);
        // Now enter an infinite loop, waiting for connections and handling them.
        for (; ; ) {
            // Wait for a client to connect.  The method will block, and when it
            // returns the socket will be already connected to the client
            Socket client = ss.accept();
            // Get input and output streams to talk to the client from the socket
            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
            PrintWriter out = new PrintWriter(new OutputStreamWriter(client.getOutputStream()));
            // Start sending our reply, using the HTTP 1.0 protocol
            // Version & status code
            out.println("HTTP/1.0 200 ");
            // The type of data we send
            out.println("Content-Type: text/plain");
            // End of response headers
            out.println();
            out.flush();
            // Now, read the HTTP request from the client, and send it right
            // back to the client as part of the body of our response.
            // The client doesn't disconnect, so we never get an EOF.
            // It does sends an empty line at the end of the headers, though.  
            // So when we see the empty line, we stop reading.  This means we 
            // don't mirror the contents of POST requests, for example.
            String line;
            while ((line = in.readLine()) != null) {
                if (line.length() == 0)
                    break;
                out.println(line);
            }
            // Close the streams and socket, breaking the connection to the client
            out.close();
            in.close();
            client.close();
        }
    // Loop again, waiting for the next connection
    }// If anything goes wrong, print an error message
     catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java HttpMirror <port>");
    }
}

{'serversocket'}
public static void main(String[] args) {
    // The JDBC connection to the database server
    Connection c = null;
    try {
        // Look for the properties file DB.props in the same directory as
        // this program.  It will contain default values for the various
        // parameters needed to connect to a database
        Properties p = new Properties();
        try {
            p.load(GetDBInfo.class.getResourceAsStream("DB.props"));
        } catch (Exception e) {
        }
        // Get default values from the properties file
        // Name of driver class
        String driver = p.getProperty("driver");
        // JDBC URL for server
        String server = p.getProperty("server", "");
        // db user name
        String user = p.getProperty("user", "");
        // db account password
        String password = p.getProperty("password", "");
        // These variables don't have defaults
        // The db name (to be appended to server URL)
        String database = null;
        // The optional name of a table in the db
        String table = null;
        // Parse the command-line arguments to override the default values above
        for (int i = 0; i < args.length; i++) {
            if (// -d <driver>
            args[i].equals("-d"))
                // -d <driver>
                driver = args[++i];
            else if (// -s <server>
            args[i].equals("-s"))
                // -s <server>
                server = args[++i];
            else if (// -u <user>
            args[i].equals("-u"))
                // -u <user>
                user = args[++i];
            else if (// -p <password>
            args[i].equals("-p"))
                // -p <password>
                password = args[++i];
            else if (// <dbname>
            database == null)
                // <dbname>
                database = args[i];
            else if (// <tablename>
            table == null)
                // <tablename>
                table = args[i];
            else
                throw new IllegalArgumentException("Unknown argument: " + args[i]);
        }
        // If not, we have no idea what to connect to, and cannot continue.
        if ((server.length() == 0) && (database.length() == 0))
            throw new IllegalArgumentException("No database or server specified.");
        // Load the db driver, if any was specified.
        if (driver != null)
            Class.forName(driver);
        // Now attempt to open a connection to the specified database on
        // the specified server, using the specified name and password
        c = DriverManager.getConnection(server + database, user, password);
        // Get the DatabaseMetaData object for the connection.  This is the
        // object that will return us all the data we're interested in here.
        DatabaseMetaData md = c.getMetaData();
        // Display information about the server, the driver, etc.
        System.out.println("DBMS: " + md.getDatabaseProductName() + " " + md.getDatabaseProductVersion());
        System.out.println("JDBC Driver: " + md.getDriverName() + " " + md.getDriverVersion());
        System.out.println("Database: " + md.getURL());
        System.out.println("User: " + md.getUserName());
        // returned in a ResultSet, just like query results are.
        if (table == null) {
            System.out.println("Tables:");
            ResultSet r = md.getTables("", "", "%", null);
            while (r.next()) System.out.println("\t" + r.getString(3));
        } else // Otherwise, list all columns of the specified table.
        // Again, information about the columns is returned in a ResultSet
        {
            System.out.println("Columns of " + table + ": ");
            ResultSet r = md.getColumns("", "", table, "%");
            while (r.next()) System.out.println("\t" + r.getString(4) + " : " + r.getString(6));
        }
    }// Print an error message if anything goes wrong.
     catch (Exception e) {
        System.err.println(e);
        if (e instanceof SQLException)
            System.err.println(((SQLException) e).getSQLState());
        System.err.println("Usage: java GetDBInfo [-d <driver] [-s <dbserver>]\n" + "\t[-u <username>] [-p <password>] <dbname>");
    } finally // Always remember to close the Connection object when we're done!
    {
        try {
            c.close();
        } catch (Exception e) {
        }
    }
}

{'sure', 'defined', 'named', 'resultset', 'databasemetadata', 'least', 'make', 'note', 'specify'}
public static void main(String[] args) {
    // Create Rect objects
    Rect r1 = new Rect(1, 1, 4, 4);
    Rect r2 = new Rect(2, 3, 5, 6);
    // Invoke Rect methods
    Rect u = r1.union(r2);
    Rect i = r2.intersection(r1);
    if (// Use Rect fields and invoke a method
    u.isInside(r2.x1, r2.y1))
        System.out.println("(" + r2.x1 + "," + r2.y1 + ") is inside the union");
    // These string concatenations implicitly call the Rect.toString() method
    System.out.println(r1 + " union " + r2 + " = " + u);
    System.out.println(r1 + " intersect " + r2 + " = " + i);
}

{'tostring'}
public static void main(String[] args) {
    try {
        // If the user specified a mailhost, tell the system about it.
        if (args.length >= 1)
            System.getProperties().put("mail.host", args[0]);
        // A Reader stream to read from the console
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        // Ask the user for the from, to, and subject lines
        System.out.print("From: ");
        String from = in.readLine();
        System.out.print("To: ");
        String to = in.readLine();
        System.out.print("Subject: ");
        String subject = in.readLine();
        // Establish a network connection for sending mail
        // Create a mailto: URL 
        URL u = new URL("mailto:" + to);
        // Create a URLConnection for it
        URLConnection c = u.openConnection();
        // Specify no input from this URL
        c.setDoInput(false);
        // Specify we'll do output
        c.setDoOutput(true);
        // Tell the user what's happening
        System.out.println("Connecting...");
        // Tell them right now
        System.out.flush();
        // Connect to mail host
        c.connect();
        PrintWriter // Get output stream to mail host
        out = new PrintWriter(new OutputStreamWriter(c.getOutputStream()));
        // Write out mail headers.  Don't let users fake the From address
        out.println("From: \"" + from + "\" <" + System.getProperty("user.name") + "@" + InetAddress.getLocalHost().getHostName() + ">");
        out.println("To: " + to);
        out.println("Subject: " + subject);
        // blank line to end the list of headers
        out.println();
        // Now ask the user to enter the body of the message
        System.out.println("Enter the message. " + "End with a '.' on a line by itself.");
        // Read message line by line and send it out.
        String line;
        for (; ; ) {
            line = in.readLine();
            if ((line == null) || line.equals("."))
                break;
            out.println(line);
        }
        // Close the stream to terminate the message 
        out.close();
        // Tell the user it was successfully sent.
        System.out.println("Message sent.");
        System.out.flush();
    } catch (// Handle any exceptions, print error message.
    Exception // Handle any exceptions, print error message.
    e) {
        System.err.println(e);
        System.err.println("Usage: java SendMail [<mailhost>]");
    }
}

{'urlconnection'}
// as its own WindowListener object
public CloseableFrame() {
    this.addWindowListener(this);
}

{'windowlistener'}
// These are the methods of the WindowListener object.  Only 
// windowClosing() is implemented
public void windowClosing(WindowEvent e) {
    this.dispose();
}

{'windowclosing'}
public static void main(String[] args) {
    try {
        // Set the standard RMI security manager so that we can safely load
        // untrusted RemoteBank stub code over the network.
        System.setSecurityManager(new RMISecurityManager());
        // Figure out what RemoteBank to connect to by reading a system
        // property (specified on the command line with a -D option to java)
        // or, if it is not defined, use a default URL.  Note that by default
        // this client tries to connect to a server on the local machine
        String url = System.getProperty("bank", "rmi:///FirstRemote");
        // Now look up that RemoteBank server using the Naming object, which
        // contacts the rmiregistry server.  Given the url, this call returns
        // a RemoteBank object whose methods may be invoked remotely
        RemoteBank bank = (RemoteBank) Naming.lookup(url);
        // Convert the user's command to lower case
        String cmd = args[0].toLowerCase();
        // Now, go test the command against a bunch of possible options
        if (cmd.equals("open")) {
            // Open an account
            bank.openAccount(args[1], args[2]);
            System.out.println("Account opened.");
        } else if (cmd.equals("close")) {
            // Close an account
            FunnyMoney money = bank.closeAccount(args[1], args[2]);
            // Note that FunnyMoney currency is denominated in wooden nickels
            System.out.println(money.amount + " wooden nickels returned to you.");
            System.out.println("Thanks for banking with us.");
        } else if (cmd.equals("deposit")) {
            // Deposit money
            FunnyMoney money = new FunnyMoney(Integer.parseInt(args[3]));
            bank.deposit(args[1], args[2], money);
            System.out.println("Deposited " + money.amount + " wooden nickels.");
        } else if (cmd.equals("withdraw")) {
            // Withdraw money
            FunnyMoney money = bank.withdraw(args[1], args[2], Integer.parseInt(args[3]));
            System.out.println("Withdrew " + money.amount + " wooden nickels.");
        } else if (cmd.equals("balance")) {
            // Check account balance
            int amt = bank.getBalance(args[1], args[2]);
            System.out.println("You have " + amt + " wooden nickels in the bank.");
        } else if (cmd.equals("history")) {
            // Get transaction history
            Vector transactions = bank.getTransactionHistory(args[1], args[2]);
            for (int i = 0; i < transactions.size(); i++) System.out.println(transactions.elementAt(i));
        } else
            System.out.println("Unknown command");
    }// Catch and display RMI exceptions
     catch (RemoteException e) {
        System.err.println(e);
    }// Catch and display Banking related exceptions
     catch (BankingException e) {
        System.err.println(e.getMessage());
    }// Other exceptions are probably user syntax errors, so show usage.
     catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java [-Dbank=<url>] Bank$Client " + "<cmd> <name> <password> [<amount>]");
        System.err.println("where cmd is: open, close, deposit, " + "withdraw, balance, history");
    }
}

{'funnymoney', 'remotebank'}
public static void main(String[] args) {
    // Try to compute a factorial.  If something goes wrong, handle it below.
    try {
        int x = Integer.parseInt(args[0]);
        System.out.println(x + "! = " + Factorial4.factorial(x));
    }// The user forgot to specify an argument.  Thrown if args[0] is undefined.
     catch (ArrayIndexOutOfBoundsException e) {
        System.out.println("You must specify an argument");
        System.out.println("Usage: java FactComputer <number>");
    }// The argument is not a number.  Thrown by Integer.parseInt().
     catch (NumberFormatException e) {
        System.out.println("The argument you specify must be an integer");
    }// The argument is < 0.  Thrown by Factorial4.factorial()
     catch (IllegalArgumentException e) {
        System.out.println("Bad argument: " + e.getMessage());
    }
}

{'method', 'sent', 'display', 'parseint'}
/** Display the image in a variety of ways */
public void paint(Graphics g) {
    // Display original image
    g.drawString("Original image:", 20, 20);
    // Old version of drawImage()
    g.drawImage(i, 110, 10, this);
    // Display scaled images
    g.drawString("Scaled Images:", 20, 120);
    // New version
    g.drawImage(i, 20, 130, 40, 150, 0, 0, 100, 100, this);
    g.drawImage(i, 60, 130, 100, 170, 0, 0, 100, 100, this);
    g.drawImage(i, 120, 130, 200, 210, 0, 0, 100, 100, this);
    g.drawImage(i, 220, 80, 370, 230, 0, 0, 100, 100, this);
    // Display cropped images
    g.drawString("Cropped Images:", 20, 250);
    g.drawImage(i, 20, 260, 70, 310, 0, 0, 50, 50, this);
    g.drawImage(i, 80, 260, 130, 310, 25, 25, 75, 75, this);
    g.drawImage(i, 140, 260, 190, 310, 50, 50, 100, 100, this);
    // Display flipped images
    g.drawString("Flipped Images:", 20, 330);
    g.drawImage(i, 20, 340, 120, 440, 100, 0, 0, 100, this);
    g.drawImage(i, 130, 340, 230, 440, 0, 100, 100, 0, this);
    g.drawImage(i, 240, 340, 340, 440, 100, 100, 0, 0, this);
    // Do all three
    g.drawString("Scaled, Cropped, and Flipped:", 20, 460);
    g.drawImage(i, 20, 470, 170, 550, 90, 70, 10, 20, this);
}

{'drawimage'}
/** The main method parses arguments and passes them to runServer */
public static void main(String[] args) throws IOException {
    try {
        // Check the number of arguments
        if (args.length != 3)
            throw new IllegalArgumentException("Wrong number of arguments.");
        // Get the command-line arguments: the host and port we are proxy for
        // and the local port that we listen for connections on
        String host = args[0];
        int remoteport = Integer.parseInt(args[1]);
        int localport = Integer.parseInt(args[2]);
        // Print a start-up message
        System.out.println("Starting proxy for " + host + ":" + remoteport + " on port " + localport);
        // And start running the server
        // never returns
        runServer(host, remoteport, localport);
    } catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java SimpleProxyServer " + "<host> <remoteport> <localport>");
    }
}

{'runserver'}
public void run() {
    int bytes_read;
    try {
        while ((bytes_read = from_client.read(request)) != -1) {
            to_server.write(request, 0, bytes_read);
            to_server.flush();
        }
    } catch (IOException e) {
    }
    // server-to-client loop in the main thread exit.
    try {
        to_server.close();
    } catch (IOException e) {
    }
}

{'cause', 'connection', 'u', 'closed', 'also'}
/**
   * This method runs a single-threaded proxy server for 
   * host:remoteport on the specified local port.  It never returns.
   **/
public static void runServer(String host, int remoteport, int localport) throws IOException {
    // Create a ServerSocket to listen for connections with
    ServerSocket ss = new ServerSocket(localport);
    // Create buffers for client-to-server and server-to-client communication.
    // We make one final so it can be used in an anonymous class below.
    // Note the assumptions about the volume of traffic in each direction...
    final byte[] request = new byte[1024];
    byte[] reply = new byte[4096];
    // This is a server that never returns, so enter an infinite loop.
    while (true) {
        // Variables to hold the sockets to the client and to the server.
        Socket client = null, server = null;
        try {
            // Wait for a connection on the local port
            client = ss.accept();
            // Get client streams.  Make them final so they can
            // be used in the anonymous thread below.
            final InputStream from_client = client.getInputStream();
            final OutputStream to_client = client.getOutputStream();
            // client, disconnect, then continue waiting for another connection.
            try {
                server = new Socket(host, remoteport);
            } catch (IOException e) {
                PrintWriter out = new PrintWriter(new OutputStreamWriter(to_client));
                out.println("Proxy server cannot connect to " + host + ":" + remoteport + ":\n" + e);
                out.flush();
                client.close();
                continue;
            }
            // Get server streams.
            final InputStream from_server = server.getInputStream();
            final OutputStream to_server = server.getOutputStream();
            // Make a thread to read the client's requests and pass them to the 
            // server.  We have to use a separate thread because requests and
            // responses may be asynchronous.
            Thread t = new Thread() {

                public void run() {
                    int bytes_read;
                    try {
                        while ((bytes_read = from_client.read(request)) != -1) {
                            to_server.write(request, 0, bytes_read);
                            to_server.flush();
                        }
                    } catch (IOException e) {
                    }
                    // server-to-client loop in the main thread exit.
                    try {
                        to_server.close();
                    } catch (IOException e) {
                    }
                }
            };
            // Start the client-to-server request thread running
            t.start();
            // Meanwhile, in the main thread, read the server's responses
            // and pass them back to the client.  This will be done in
            // parallel with the client-to-server request thread above.
            int bytes_read;
            try {
                while ((bytes_read = from_server.read(reply)) != -1) {
                    to_client.write(reply, 0, bytes_read);
                    to_client.flush();
                }
            } catch (IOException e) {
            }
            // The server closed its connection to us, so close our 
            // connection to our client.  This will make the other thread exit.
            to_client.close();
        } catch (IOException e) {
            System.err.println(e);
        } finally // Close the sockets no matter what happens each time through the loop.
        {
            try {
                if (server != null)
                    server.close();
                if (client != null)
                    client.close();
            } catch (IOException e) {
            }
        }
    }
}

{'send', 'serversocket', 'error', 'also', 'cause', 'real'}
/**
   * The GUI constructor does all the work of creating the GUI and setting
   * up event listeners.  Note the use of local and anonymous classes.
   */
public ScribbleGUI(Scribble5 application) {
    // Create the window
    super("Scribble");
    // Remember the application reference
    app = application;
    // Create three buttons
    Button clear = new Button("Clear");
    Button print = new Button("Print");
    Button quit = new Button("Quit");
    // Set a LayoutManager, and add the buttons to the window.
    this.setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 5));
    this.add(clear);
    this.add(print);
    this.add(quit);
    // Here's a local class used for action listeners for the buttons
    class ScribbleActionListener implements ActionListener {

        private String command;

        public ScribbleActionListener(String cmd) {
            command = cmd;
        }

        public void actionPerformed(ActionEvent e) {
            app.doCommand(command);
        }
    }
    // Define action listener adapters that connect the  buttons to the app
    clear.addActionListener(new ScribbleActionListener("clear"));
    print.addActionListener(new ScribbleActionListener("print"));
    quit.addActionListener(new ScribbleActionListener("quit"));
    // Handle the window close request similarly
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            app.doCommand("quit");
        }
    });
    // High-level action events are passed to the application, but we
    // still handle scribbling right here.  Register a MouseListener object.
    this.addMouseListener(new MouseAdapter() {

        public void mousePressed(MouseEvent e) {
            lastx = e.getX();
            lasty = e.getY();
        }
    });
    // Define, instantiate and register a MouseMotionListener object
    this.addMouseMotionListener(new MouseMotionAdapter() {

        public void mouseDragged(MouseEvent e) {
            Graphics g = getGraphics();
            int x = e.getX(), y = e.getY();
            g.setColor(Color.black);
            g.drawLine(lastx, lasty, x, y);
            lastx = x;
            lasty = y;
        }
    });
    // Finally, set the size of the window, and pop it up
    this.setSize(400, 400);
    this.show();
}

{'layoutmanager', 'mouselistener', 'mousemotionlistener'}
public void init() {
    MouseListener ml = new MyMouseListener(this);
    MouseMotionListener mml = new MyMouseMotionListener(this);
    // Tell this component what MouseListener and MouseMotionListener
    // objects to notify when mouse and mouse motion events occur.
    this.addMouseListener(ml);
    this.addMouseMotionListener(mml);
}

{'mouselistener', 'mousemotionlistener'}
/** 
   * An accessor method.  Returns the real part of the complex number.
   * Note that there is no setReal() method to set the real part.  This means
   * that the ComplexNumber class is "immutable".
   **/
public double real() {
    return x;
}

{'complexnumber', 'setreal'}
/** 
   * This method converts a ComplexNumber to a string.  This is a method of
   * Object that we override so that complex numbers can be meaningfully
   * converted to strings, and so they can conveniently be printed out with
   * System.out.println() and related methods
   **/
public String toString() {
    return "{" + x + "," + y + "}";
}

{'complexnumber'}
/** 
   * This is a static class method.  It takes two complex numbers, adds them, 
   * and returns the result as a third number.  Because it is static, there is
   * no "current instance" or "this" object.  Use it like this:
   * ComplexNumber c = ComplexNumber.add(a, b);
   **/
public static ComplexNumber add(ComplexNumber a, ComplexNumber b) {
    return new ComplexNumber(a.x + b.x, a.y + b.y);
}

{'complexnumber'}
/**
   * This is a non-static instance method by the same name.  It adds the
   * specified complex number to the current complex number.  Use it like this:
   * ComplexNumber c = a.add(b);
   **/
public ComplexNumber add(ComplexNumber a) {
    return new ComplexNumber(this.x + a.x, this.y + a.y);
}

{'complexnumber'}
/** Create a Frame, Menu, and ScrollPane for the scribble component */
public ScribbleCutAndPaste() {
    // Create the window
    super("ScribbleCutAndPaste");
    // Count it
    num_windows++;
    // Create scribble area and add to the frame
    ScribblePanel scribble = new ScribblePanel(this, 400, 300);
    this.add(scribble, "Center");
    // Set up a menubar
    // Create menubar
    MenuBar menubar = new MenuBar();
    // Add it to the frame
    this.setMenuBar(menubar);
    // Create a File menu
    Menu file = new Menu("File");
    // Add to menubar
    menubar.add(file);
    // Create three menu items, with menu shortcuts, and add to the menu
    MenuItem n, c, q;
    file.add(n = new MenuItem("New Window", new MenuShortcut(KeyEvent.VK_N)));
    file.add(c = new MenuItem("Close Window", new MenuShortcut(KeyEvent.VK_W)));
    file.addSeparator();
    file.add(q = new MenuItem("Quit", new MenuShortcut(KeyEvent.VK_Q)));
    // Create and register action listener objects for the three menu items
    n.addActionListener(new // Open a new window
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            new ScribbleCutAndPaste();
        }
    });
    c.addActionListener(new // Close this window
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            close();
        }
    });
    q.addActionListener(new // Quit the program
    ActionListener() {

        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    // Another event listener, this one to handle window close requests
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            close();
        }
    });
    // Set the window size and pop it up
    this.pack();
    this.show();
}

{'scrollpane'}
/** 
     * Specifies how big the component would like to be.  It always returns the
     * preferred size passed to the ScribblePanel() constructor 
     **/
public Dimension getPreferredSize() {
    return new Dimension(width, height);
}

{'scribblepanel'}
/** This is the ActionListener method invoked by the popup menu items */
public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("clear"))
        clear();
    else if (command.equals("cut"))
        cut();
    else if (command.equals("copy"))
        copy();
    else if (command.equals("paste"))
        paste();
}

{'actionlistener'}
/** 
     * Copy the current scribble and store it in a SimpleSelection object
     * (defined below).  Then put that object on the clipboard for pasting.
     **/
public void copy() {
    // Get system clipboard
    Clipboard c = this.getToolkit().getSystemClipboard();
    // Copy and save the scribble in a Transferable object
    SimpleSelection s = new SimpleSelection(lines.clone(), dataFlavor);
    // Put that object on the clipboard
    c.setContents(s, s);
}

{'simpleselection'}
/** 
     * Ask for the Transferable contents of the system clipboard.
     * Then ask that Transferable object for the scribble data it represents.  
     * If either step fails, beep!
     **/
public void paste() {
    // Get clipboard
    Clipboard c = this.getToolkit().getSystemClipboard();
    // Get its contents
    Transferable t = c.getContents(this);
    if (t == null) {
        // If there is nothing to paste, beep
        this.getToolkit().beep();
        return;
    }
    try {
        // Ask for clipboard contents to be converted to our data flavor.
        // This will throw an exception if our flavor is not supported.
        Vector newlines = (Vector) t.getTransferData(dataFlavor);
        // Add all those pasted lines to our scribble.
        for (int i = 0; i < newlines.size(); i++) lines.addElement(newlines.elementAt(i));
        // And redraw the whole thing
        repaint();
    } catch (UnsupportedFlavorException e) {
        this.getToolkit().beep();
    } catch (Exception e) {
        this.getToolkit().beep();
    }
}

{'go', 'type', 'wrong', 'anything', 'else'}
/** 
       * This is the ClipboardOwner method.  Called when the data is no
       * longer on the clipboard.  In this case, we don't need to do much. 
       **/
public void lostOwnership(Clipboard c, Transferable t) {
    selection = null;
}

{'clipboardowner'}
public void print() {
    // Obtain NumberFormat and DateFormat objects to format our data.
    NumberFormat number = NumberFormat.getInstance();
    NumberFormat price = NumberFormat.getCurrencyInstance();
    NumberFormat percent = NumberFormat.getPercentInstance();
    DateFormat shortdate = DateFormat.getDateInstance(DateFormat.SHORT);
    DateFormat fulldate = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
    // Print some introductory data.
    System.out.println("Portfolio value at " + fulldate.format(lastQuoteTime) + ":");
    System.out.println("Symbol\tShares\tBought On\tAt\t" + "Quote\tChange");
    // Then display the table using the format() methods of the Format objects.
    for (int i = 0; i < positions.length; i++) {
        System.out.print(positions[i].name + "\t");
        System.out.print(number.format(positions[i].shares) + "\t");
        System.out.print(shortdate.format(positions[i].purchased) + "\t");
        System.out.print(price.format(positions[i].bought) + "\t");
        System.out.print(price.format(positions[i].current) + "\t");
        double change = (positions[i].current - positions[i].bought) / positions[i].bought;
        System.out.println(percent.format(change));
    }
}

{'numberformat', 'dateformat'}
/** The main method: create an EventTester frame, and pop it up */
public static void main(String[] args) {
    EventTester2 et = new EventTester2();
    et.setSize(500, 400);
    et.show();
}

{'eventtester'}
/**
   * Display mouse events that don't involve mouse motion.
   * The mousemods() method prints modifiers, and is defined below.
   * The other methods return additional information about the mouse event.
   * showLine() displays a line of text in the window.  It is defined
   * at the end of this class, along with the paint() method.
   */
public void processMouseEvent(MouseEvent e) {
    String type = null;
    switch(e.getID()) {
        case MouseEvent.MOUSE_PRESSED:
            type = "MOUSE_PRESSED";
            break;
        case MouseEvent.MOUSE_RELEASED:
            type = "MOUSE_RELEASED";
            break;
        case MouseEvent.MOUSE_CLICKED:
            type = "MOUSE_CLICKED";
            break;
        case MouseEvent.MOUSE_ENTERED:
            type = "MOUSE_ENTERED";
            break;
        case MouseEvent.MOUSE_EXITED:
            type = "MOUSE_EXITED";
            break;
    }
    showLine(mousemods(e) + type + ": [" + e.getX() + "," + e.getY() + "] " + "num clicks = " + e.getClickCount() + (e.isPopupTrigger() ? "; is popup trigger" : ""));
}

{'showline'}
/**
   * Display mouse moved and dragged mouse event.  Note that MouseEvent
   * is the only event type that has two methods, two EventListener interfaces
   * and two adapter classes to handle two distinct categories of events.
   * Also, as seen in init(), mouse motion events must be requested
   * separately from other mouse event types.
   */
public void processMouseMotionEvent(MouseEvent e) {
    String type = null;
    switch(e.getID()) {
        case MouseEvent.MOUSE_MOVED:
            type = "MOUSE_MOVED";
            break;
        case MouseEvent.MOUSE_DRAGGED:
            type = "MOUSE_DRAGGED";
            break;
    }
    showLine(mousemods(e) + type + ": [" + e.getX() + "," + e.getY() + "] " + "num clicks = " + e.getClickCount() + (e.isPopupTrigger() ? "; is popup trigger" : ""));
}

{'eventlistener', 'mouseevent'}
/** Return a string representation of the modifiers for a MouseEvent.
   *  Note that the methods called here are inherited from InputEvent.
   */
protected String mousemods(MouseEvent e) {
    int mods = e.getModifiers();
    String s = "";
    if (e.isShiftDown())
        s += "Shift ";
    if (e.isControlDown())
        s += "Ctrl ";
    if ((mods & InputEvent.BUTTON1_MASK) != 0)
        s += "Button 1 ";
    if ((mods & InputEvent.BUTTON2_MASK) != 0)
        s += "Button 2 ";
    if ((mods & InputEvent.BUTTON3_MASK) != 0)
        s += "Button 3 ";
    return s;
}

{'mouseevent', 'inputevent'}
/**
   * Display keyboard events.
   * Note that there are three distinct types of key events, and that
   * key events are reported by key code and/or Unicode character.
   * KEY_PRESSED and KEY_RELEASED events are generated for all key strokes.
   * KEY_TYPED events are only generated when a key stroke produces a
   * Unicode character; these events do not report a key code.
   * If isActionKey() returns true, then the key event reports only
   * a key code, because the key that was pressed or released (such as a
   * function key) has no corresponding Unicode character.
   * Key codes can be interpreted by using the many VK_ constants defined
   * by the KeyEvent class, or they can be converted to strings using
   * the static getKeyText() method as we do here.
   */
public void processKeyEvent(KeyEvent e) {
    String eventtype, modifiers, code, character;
    switch(e.getID()) {
        case KeyEvent.KEY_PRESSED:
            eventtype = "KEY_PRESSED";
            break;
        case KeyEvent.KEY_RELEASED:
            eventtype = "KEY_RELEASED";
            break;
        case KeyEvent.KEY_TYPED:
            eventtype = "KEY_TYPED";
            break;
        default:
            eventtype = "UNKNOWN";
    }
    // Convert the list of modifier keys to a string
    modifiers = KeyEvent.getKeyModifiersText(e.getModifiers());
    // Get string and numeric versions of the key code, if any.
    if (e.getID() == KeyEvent.KEY_TYPED)
        code = "";
    else
        code = "Code=" + KeyEvent.getKeyText(e.getKeyCode()) + " (" + e.getKeyCode() + ")";
    // Get string and numeric versions of the Unicode character, if any.
    if (e.isActionKey())
        character = "";
    else
        character = "Character=" + e.getKeyChar() + " (Unicode=" + ((int) e.getKeyChar()) + ")";
    // Display it all.
    showLine(eventtype + ": " + modifiers + " " + code + " " + character);
}

{'getkeytext', 'keyevent', 'isactionkey'}
/** Display Window events.  Note the special handling of WINDOW_CLOSING */
public void processWindowEvent(WindowEvent e) {
    switch(e.getID()) {
        case WindowEvent.WINDOW_OPENED:
            showLine("WINDOW_OPENED");
            break;
        case WindowEvent.WINDOW_CLOSED:
            showLine("WINDOW_CLOSED");
            break;
        case WindowEvent.WINDOW_CLOSING:
            showLine("WINDOW_CLOSING");
            break;
        case WindowEvent.WINDOW_ICONIFIED:
            showLine("WINDOW_ICONIFIED");
            break;
        case WindowEvent.WINDOW_DEICONIFIED:
            showLine("WINDOW_DEICONIFIED");
            break;
        case WindowEvent.WINDOW_ACTIVATED:
            showLine("WINDOW_ACTIVATED");
            break;
        case WindowEvent.WINDOW_DEACTIVATED:
            showLine("WINDOW_DEACTIVATED");
            break;
    }
    // sure the user has time to read it.
    if (e.getID() == WindowEvent.WINDOW_CLOSING) {
        showLine("WINDOW_CLOSING event received.");
        showLine("Application will exit in 5 seconds");
        update(this.getGraphics());
        try {
            Thread.sleep(5000);
        } catch (InterruptedException ie) {
            ;
        }
        System.exit(0);
    }
}

{'requested', 'quit', 'RANK', 'program', 'close', 'visible', 'force', 'message', 'make'}
public void init() {
    // Define, instantiate and register a MouseListener object
    this.addMouseListener(new MouseAdapter() {

        public void mousePressed(MouseEvent e) {
            last_x = e.getX();
            last_y = e.getY();
        }
    });
    // Define, instantiate and register a MouseMotionListener object
    this.addMouseMotionListener(new MouseMotionAdapter() {

        public void mouseDragged(MouseEvent e) {
            Graphics g = getGraphics();
            int x = e.getX(), y = e.getY();
            g.setColor(Color.black);
            g.drawLine(last_x, last_y, x, y);
            last_x = x;
            last_y = y;
        }
    });
    // Create a clear button
    Button b = new Button("Clear");
    // Define, instantiate, and register a listener to handle button presses
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            // clear the scribble
            Graphics g = getGraphics();
            g.setColor(getBackground());
            g.fillRect(0, 0, getSize().width, getSize().height);
        }
    });
    // And add the button to the applet
    this.add(b);
}

{'mouselistener', 'mousemotionlistener'}
public InfoDialog(Frame parent, String title, String message) {
    // Create a non-modal dialog with the specified title and parent
    super(parent, title, false);
    // Create and use a BorderLayout manager with 15 pixel spacing
    this.setLayout(new BorderLayout(15, 15));
    // Create the message component and add it to the window
    // MultiLineLabel is a custom component defined later in this chapter
    label = new MultiLineLabel(message, 20, 20);
    this.add("Center", label);
    // Create an Okay button in a Panel; add the Panel to the window
    // Use a FlowLayout to center the button in the panel and give it margins.
    // Note the nested use of containers and layout managers.
    button = new Button("Okay");
    Panel p = new Panel();
    p.setLayout(new FlowLayout(FlowLayout.CENTER, 15, 15));
    p.add(button);
    this.add("South", p);
    // Set the dialog size to the preferred size of its components
    this.pack();
}

{'flowlayout', 'multilinelabel', 'borderlayout'}
/**
   * A main method that demonstrates how to use this class, and allows testing
   */
public static void main(String[] args) {
    // Create, size, and show a frame because dialogs require a frame parent.
    Frame f = new Frame("InfoDialog Test");
    // Use setSize() in Java 1.1
    f.resize(100, 100);
    f.show();
    // Create an instance of InfoDialog, with title and message specified
    InfoDialog d = new InfoDialog(f, "InfoDialog Test", "This demo was written by David Flanagan\n" + "Copyright (c) 1997 O'Reilly & Associates");
    // And pop it up.  It will pop itself down automatically.
    d.show();
}

{'setsize', 'infodialog'}
/** Get the RemoteMudPerson object for the named person. */
public RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson;

{'remotemudperson'}
/** Open an account */
public synchronized void openAccount(String name, String password) throws RemoteException, BankingException {
    // First, check if there is already an account with that name
    Statement s = null;
    try {
        s = db.createStatement();
        s.executeQuery("SELECT * FROM accounts WHERE name='" + name + "'");
        ResultSet r = s.getResultSet();
        if (r.next())
            throw new BankingException("Account already exists.");
        // If it doesn't exist, go ahead and create it
        // Also, create a table for the transaction history of this account and
        // insert an initial transaction into it.
        s = db.createStatement();
        s.executeUpdate("INSERT INTO accounts VALUES ('" + name + "', '" + password + "', 0)");
        s.executeUpdate("CREATE TABLE " + name + "_history (msg VARCHAR(80))");
        s.executeUpdate("INSERT INTO " + name + "_history " + "VALUES ('Account opened at " + new Date() + "')");
        // And if we've been successful so far, commit these updates,
        // ending the atomic transaction.  All the methods below also use this
        // atomic transaction commit/rollback scheme
        db.commit();
    } catch (SQLException e) {
        try {
            db.rollback();
        } catch (Exception e2) {
        }
        throw new BankingException("SQLException: " + e.getMessage() + ": " + e.getSQLState());
    } finally // No matter what happens, don't forget to close the DB Statement
    {
        try {
            s.close();
        } catch (Exception e) {
        }
    }
}

{'removing', 'database', 'sqlexception', 'thrown', 'end', 'pas', 'body', 'prior', 'bankingexception'}
/**
   * This main() method is the standalone program that figures out what
   * database to connect to with what driver, connects to the database,
   * creates a RemoteDBBankServer object, and registers it with the registry,
   * making it available for client use
   **/
public static void main(String[] args) {
    try {
        // Create a new Properties object.  Attempt to initialize it from
        // the BankDB.props file or the file optionally specified on the 
        // command line, ignoring errors.
        Properties p = new Properties();
        try {
            p.load(new FileInputStream(args[0]));
        } catch (Exception e) {
            try {
                p.load(new FileInputStream("BankDB.props"));
            } catch (Exception e2) {
            }
        }
        // The BankDB.props file (or file specified on the command line)
        // must contain properties "driver" and "database", and may optionally
        // contain properties "user" and  "password".
        String driver = p.getProperty("driver");
        String database = p.getProperty("database");
        String user = p.getProperty("user", "");
        String password = p.getProperty("password", "");
        // Load the database driver class
        Class.forName(driver);
        // Connect to the database that stores our accounts
        Connection db = DriverManager.getConnection(database, user, password);
        // Configure the database to allow multiple queries and updates
        // to be grouped into atomic transactions
        db.setAutoCommit(false);
        db.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        // Create a server object that uses our database connection
        RemoteDBBankServer bank = new RemoteDBBankServer(db);
        // Read a system property to figure out how to name this server.
        // Use "SecondRemote" as the default.
        String name = System.getProperty("bankname", "SecondRemote");
        // Register the server with the name
        Naming.rebind(name, bank);
        // And tell everyone that we're up and running.
        System.out.println(name + " is open and ready for customers.");
    } catch (Exception e) {
        System.err.println(e);
        if (e instanceof SQLException)
            System.err.println("SQL State: " + ((SQLException) e).getSQLState());
        System.err.println("Usage: java [-Dbankname=<name>] RemoteDBBankServer " + "[<dbpropsfile>]");
        System.exit(1);
    }
}

{'secondremote', 'bankdb', 'remotedbbankserver'}
/**
   * The main program.  It expects two or three arguments:
   *   0) the name of the host on which the mud server is running
   *   1) the name of the MUD on that host
   *   2) the name of a place within that MUD to start at (optional).
   *
   * It uses the Naming.lookup() method to obtain a RemoteMudServer object
   * for the named MUD on the specified host.  Then it uses the getEntrance()
   * or getNamedPlace() method of RemoteMudServer to obtain the starting
   * RemoteMudPlace object.  It prompts the user for a their name and 
   * description, and creates a MudPerson object.  Finally, it passes
   * the person and the place to runMud() to begin interaction with the MUD.
   **/
public static void main(String[] args) {
    try {
        // Each MUD is uniquely identified by a 
        String hostname = args[0];
        //   host and a MUD name.
        String mudname = args[1];
        // Each place within a MUD has a unique name
        String placename = null;
        if (args.length > 2)
            placename = args[2];
        // Set the RMI security manager so that untrusted stub objects loaded 
        // over the network can't cause havoc.
        System.setSecurityManager(new RMISecurityManager());
        // Look up the RemoteMudServer object for the named MUD using
        // the default registry on the specified host.  Note the use of
        // the Mud.mudPrefix constant to help prevent naming conflicts
        // in the registry.
        RemoteMudServer server = (RemoteMudServer) Naming.lookup("rmi://" + hostname + "/" + Mud.mudPrefix + mudname);
        // If the user did not specify a place in the mud, use getEntrance()
        // to get the initial place.  Otherwise, call getNamedPlace() to find
        // the initial place.
        RemoteMudPlace location = null;
        if (placename == null)
            location = server.getEntrance();
        else
            location = (RemoteMudPlace) server.getNamedPlace(placename);
        // Greet the user and ask for their name and description.
        // This relies on getLine() and getMultiLine() defined below.
        System.out.println("Welcome to " + mudname);
        String name = getLine("Enter your name: ");
        String description = getMultiLine("Please describe what " + "people see when they look at you:");
        // Define an output stream that the MudPerson object will use to
        // display messages sent to it to the user.  We'll use the console.
        PrintWriter myout = new PrintWriter(new OutputStreamWriter(System.out));
        // Create a MudPerson object to represent the user in the MUD.
        // Use the specified name and description, and the output stream.
        MudPerson me = new MudPerson(name, description, myout);
        // Lower this thread's priority one notch so that broadcast messages
        // can appear even when we're blocking for I/O.  This is necessary
        // on the Linux platform, but may not be necessary on all platforms.
        int pri = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(pri - 1);
        // Finally, put the MudPerson into the RemoteMudPlace, and start
        // prompting the user for commands.
        runMud(location, me);
    }// If anything goes wrong, print a message and exit.
     catch (Exception e) {
        System.out.println(e);
        System.out.println("Usage: java MudClient <host> <mud> [<place>]");
        System.exit(1);
    }
}

{'remotemudserver', 'remotemudplace', 'mudprefix', 'mudperson', 'getentrance', 'getmultiline', 'getnamedplace', 'runmud', 'getline'}
/**
   * This method is the main loop of the MudClient.  It places the person
   * into the place (using the enter() method of RemoteMudPlace).  Then it
   * calls the look() method to describe the place to the user, and enters a
   * command loop to prompt the user for a command and process the command
   **/
public static void runMud(RemoteMudPlace entrance, MudPerson me) throws RemoteException {
    // The current place
    RemoteMudPlace location = entrance;
    // The person's name
    String myname = me.getName();
    // The name of the current place
    String placename = null;
    // The name of the mud of that place
    String mudname = null;
    try {
        // Enter the MUD
        location.enter(me, myname, myname + " has entered the MUD.");
        // Figure out where we are (for the prompt)
        mudname = location.getServer().getMudName();
        placename = location.getPlaceName();
        // Describe the place to the user
        look(location);
    } catch (Exception e) {
        System.out.println(e);
        System.exit(1);
    }
    // could go wrong each time through the loop.
    for (; ; ) {
        // Loop until the user types "quit"
        try {
            // generated indirectly by the last command a chance to appear.
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
            }
            // Display a prompt, and get the user's input
            String line = getLine(mudname + '.' + placename + "> ");
            // Break the input into a command and an argument that consists 
            // of the rest of the line.  Convert the command to lowercase.
            String cmd, arg;
            int i = line.indexOf(' ');
            if (i == -1) {
                cmd = line;
                arg = null;
            } else {
                cmd = line.substring(0, i).toLowerCase();
                arg = line.substring(i + 1);
            }
            if (arg == null)
                arg = "";
            // LOOK: Describe the place and its things, people, and exits
            if (cmd.equals("look"))
                look(location);
            else // EXAMINE: Describe a named thing
            if (cmd.equals("examine"))
                System.out.println(location.examineThing(arg));
            else // DESCRIBE: Describe a named person
            if (cmd.equals("describe")) {
                try {
                    RemoteMudPerson p = location.getPerson(arg);
                    System.out.println(p.getDescription());
                } catch (RemoteException e) {
                    System.out.println(arg + " is having technical difficulties.  " + "No description is available.");
                }
            } else // GO: Go in a named direction
            if (cmd.equals("go")) {
                location = location.go(me, arg);
                mudname = location.getServer().getMudName();
                placename = location.getPlaceName();
                look(location);
            } else // SAY: Say something to everyone 
            if (cmd.equals("say"))
                location.speak(me, arg);
            else // DO: Do something that will be described to everyone
            if (cmd.equals("do"))
                location.act(me, arg);
            else // TALK: Say something to one named person
            if (cmd.equals("talk")) {
                try {
                    RemoteMudPerson p = location.getPerson(arg);
                    String msg = getLine("What do you want to say?: ");
                    p.tell(myname + " says \"" + msg + "\"");
                } catch (RemoteException e) {
                    System.out.println(arg + " is having technical difficulties.  " + "Can't talk to them.");
                }
            } else // CHANGE: Change my own description 
            if (cmd.equals("change"))
                me.setDescription(getMultiLine("Describe yourself for others: "));
            else // CREATE: Create a new thing in this place
            if (cmd.equals("create")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("name expected");
                String desc = getMultiLine("Please describe the " + arg + ": ");
                location.createThing(me, arg, desc);
            } else // DESTROY: Destroy a named thing
            if (cmd.equals("destroy"))
                location.destroyThing(me, arg);
            else // the exit specified in the argument.
            if (cmd.equals("open")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                String name = getLine("What is the name of place there?: ");
                String back = getLine("What is the direction from " + "there back to here?: ");
                String desc = getMultiLine("Please describe " + name + ":");
                location.createPlace(me, arg, back, name, desc);
            } else // uni-directionally, and does not destroy a place.
            if (cmd.equals("close")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                location.close(me, arg);
            } else // that may be in another MUD running on another host
            if (cmd.equals("link")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                String host = getLine("What host are you linking to?: ");
                String mud = getLine("What is the name of the MUD on that host?: ");
                String place = getLine("What is the place name in that MUD?: ");
                location.linkTo(me, arg, host, mud, place);
                System.out.println("Don't forget to make a link from there " + "back to here!");
            } else // if the password is correct
            if (cmd.equals("dump")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("filename expected");
                String password = getLine("Password: ");
                location.getServer().dump(password, arg);
            } else // QUIT: Quit the game
            if (cmd.equals("quit")) {
                try {
                    location.exit(me, myname + " has quit.");
                } catch (Exception e) {
                }
                System.out.println("Bye.");
                System.out.flush();
                System.exit(0);
            } else // HELP: Print out a big help message
            if (cmd.equals("help")) {
                String help = "Commands are:\n" + "look: Look around\n" + "examine <thing>: examine the named thing in more detail\n" + "describe <person>: describe the named person\n" + "go <direction>: go in the named direction (i.e. a named exit)\n" + "say <message>: say something to everyone\n" + "do <message>: tell everyone that you are doing something\n" + "talk <person>: talk to one person.  Will prompt for message\n" + "change: change how you are described.  Will prompt for input\n" + "create <thing>: create a new thing.  Prompts for description \n" + "destroy <thing>: destroy a thing.\n" + "open <direction>: create an adjoining place. Prompts for input\n" + "close <direction>: close an exit from this place.\n" + "link <direction>: create an exit to an existing place,\n" + "     perhaps on another server.  Will prompt for input.\n" + "dump <filename>: save server state.  Prompts for password\n" + "quit: leave the Mud\n" + "help: display this message";
                System.out.println(help);
            } else
                // Otherwise, this is an unrecognized command.
                System.out.println("Unknown command.  Try 'help'.");
        }// Handle the many possible types of MudException
         catch (MudException e) {
            if (e instanceof NoSuchThing)
                System.out.println("There isn't any such thing here.");
            else if (e instanceof NoSuchPerson)
                System.out.println("There isn't anyone by that name here.");
            else if (e instanceof NoSuchExit)
                System.out.println("There isn't an exit in that direction.");
            else if (e instanceof NoSuchPlace)
                System.out.println("There isn't any such place.");
            else if (e instanceof ExitAlreadyExists)
                System.out.println("There is already an exit in that direction.");
            else if (e instanceof PlaceAlreadyExists)
                System.out.println("There is already a place with that name.");
            else if (e instanceof LinkFailed)
                System.out.println("That exit is not functioning.");
            else if (e instanceof BadPassword)
                System.out.println("Invalid password.");
            else if (e instanceof NotThere)
                System.out.println("You can't do that when you're not there.");
            else if (e instanceof AlreadyThere)
                System.out.println("You can't go there; you're already there.");
        }// Handle RMI exceptions
         catch (RemoteException e) {
            System.out.println("The MUD is having technical difficulties.");
            System.out.println("Perhaps the server has crashed:");
            System.out.println(e);
        }// Handle everything else that could go wrong.
         catch (Exception e) {
            System.out.println("Syntax or other error:");
            System.out.println(e);
            System.out.println("Try using the 'help' command.");
        }
    }
}

{'file', 'pause', 'covering', 'object', 'follows', 'huge', 'printing', 'bit', 'mudclient', 'begin', 'output', 'block', 'bottom', 'additional', 'occur', 'repeated', 'processing', 'mudexception', 'statement', 'remotemudplace', 'simply', 'happen', 'give', 'supported', 'connect', 'connects', 'invoke', 'note'}
/** 
   * This convenience method is used in several places in the
   * runMud() method above.  It displays the name and description of
   * the current place (including the name of the mud the place is in), 
   * and also displays the list of things, people, and exits in
   * the current place.
   **/
public static void look(RemoteMudPlace p) throws RemoteException, MudException {
    // Mud name
    String mudname = p.getServer().getMudName();
    // Place name
    String placename = p.getPlaceName();
    // Place description
    String description = p.getDescription();
    // List of things here
    Vector things = p.getThings();
    // List of people here
    Vector names = p.getNames();
    // List of exits from here
    Vector exits = p.getExits();
    // Print it all out
    System.out.println("You are in: " + placename + " of the Mud: " + mudname);
    System.out.println(description);
    System.out.print("Things here: ");
    for (int i = 0; i < things.size(); i++) {
        // Display list of things
        if (i > 0)
            System.out.print(", ");
        System.out.print(things.elementAt(i));
    }
    System.out.print("\nPeople here: ");
    for (int i = 0; i < names.size(); i++) {
        // Display list of people
        if (i > 0)
            System.out.print(", ");
        System.out.print(names.elementAt(i));
    }
    System.out.print("\nExits are: ");
    for (int i = 0; i < exits.size(); i++) {
        // Display list of exits
        if (i > 0)
            System.out.print(", ");
        System.out.print(exits.elementAt(i));
    }
    // Blank line
    System.out.println();
    // Make it appear now!
    System.out.flush();
}

{'runmud'}
/**
   * A convenience method for getting multi-line input from the user.
   * It prompts for the input, displays instructions, and guarantees that
   * the input is not empty.  It also allows the user to enter the name of
   * a file from which text will be read.
   **/
public static String getMultiLine(String prompt) {
    String text = "";
    for (; ; ) {
        // We'll break out of this loop when we get non-empty input
        try {
            // The stream to read from 
            BufferedReader br = in;
            // Display the prompt
            System.out.println(prompt);
            // Display some instructions
            System.out.println("You can enter multiple lines.  " + "End with a '.' on a line by itself.\n" + "Or enter a '<<' followed by a filename");
            // Make the prompt and instructions appear now.
            System.out.flush();
            // Read lines
            String line;
            while ((line = br.readLine()) != null) {
                // Or until a dot by itself
                if (line.equals("."))
                    break;
                // from the console.
                if (line.trim().startsWith("<<")) {
                    String filename = line.trim().substring(2).trim();
                    br = new BufferedReader(new FileReader(filename));
                    // Don't count the << line as part of the input
                    continue;
                } else
                    // Add the line to the collected input
                    text += line + "\n";
            }
            // user and go back to the prompt and the instructions.
            if (text.length() > 0)
                return text;
            else
                System.out.println("Please enter at least one line.");
        }// display the error and loop again, displaying prompt and instructions
         catch (Exception e) {
            System.out.println(e);
        }
    }
}

{'otherwise', 'instead', 'eof', 'reading', 'io', 'got', 'example', 'specified', 'chastise'}
/** 
   * This method computes a pseudo-random integer between 0 and specified
   * maximum.  It uses randomFloat() above.
   **/
public int randomInt(int max) {
    return Math.round(max * randomFloat());
}

{'randomfloat'}
/**
   * This is a very simple sorting algorithm that is not very efficient
   * when sorting large numbers of things
   **/
public static void sort(double[] nums) {
    // to the first unsorted position in the array.
    for (int i = 0; i < nums.length; i++) {
        // holds the index of the smallest element
        int min = i;
        // find the smallest one between i and the end of the array
        for (int j = i; j < nums.length; j++) {
            if (nums[j] < nums[min])
                min = j;
        }
        // Now swap the smallest one with element i.  
        // This leaves all elements between 0 and i sorted.
        double tmp;
        tmp = nums[i];
        nums[i] = nums[min];
        nums[min] = tmp;
    }
}

{'loop', 'time', 'go', 'move', 'remaining'}
/**
   * Given a fully-qualified classname, this method stores the package name
   * in the package table (if it is not already there), stores the class name
   * in the class table, and then uses the Java Reflection API to look up all
   * methods and fields of the class, and stores those in the member table.
   **/
public static void storeClass(String name) throws SQLException, ClassNotFoundException {
    String packagename, classname;
    // Dynamically load the class.
    Class c = Class.forName(name);
    // Display output so the user knows that the program is progressing
    System.out.println("Storing data for: " + name);
    // Figure out the packagename and the classname
    int pos = name.lastIndexOf('.');
    if (pos == -1) {
        packagename = "";
        classname = name;
    } else {
        packagename = name.substring(0, pos);
        classname = name.substring(pos + 1);
    }
    // Figure out what the package id is.  If there is one, then this package
    // has already been stored in the database.  Otherwise, assign an id, 
    // and store it and the packagename in the db.
    Integer pid;
    // Check hashtable
    pid = (Integer) package_to_id.get(packagename);
    if (pid == null) {
        // Assign an id
        pid = new Integer(++packageId);
        // Remember it in the hashtable
        package_to_id.put(packagename, pid);
        // Set args to PreparedStatement
        insertpackage.setInt(1, packageId);
        insertpackage.setString(2, packagename);
        // Insert the package into db
        insertpackage.executeUpdate();
    }
    // Now, store the classname in the class table of the database.
    // This record includes the package id, so that the class is linked to 
    // the package that contains it.  To store the class, we set arguments
    // to the PreparedStatement, then execute that statement
    // Set class identifier
    insertclass.setInt(1, ++classId);
    // Set package identifier
    insertclass.setInt(2, pid.intValue());
    // Set class name
    insertclass.setString(3, classname);
    // Insert the class record
    insertclass.executeUpdate();
    // Now, get a list of all non-private methods of the class, and
    // insert those into the "members" table of the database.  Each
    // record includes the class id of the containing class, and also
    // a value that indicates that these are methods, not fields.
    // Get a list of methods
    Method[] methods = c.getDeclaredMethods();
    for (int i = 0; i < methods.length; i++) {
        // For all non-private
        if (Modifier.isPrivate(methods[i].getModifiers()))
            continue;
        // Set the class id
        insertmember.setInt(1, classId);
        // Set the method name
        insertmember.setString(2, methods[i].getName());
        // It is not a field
        insertmember.setInt(3, 0);
        // Insert the record
        insertmember.executeUpdate();
    }
    // Do the same thing for the non-private fields of the class
    // Get a list of fields
    Field[] fields = c.getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
        // For each non-private
        if (Modifier.isPrivate(fields[i].getModifiers()))
            continue;
        // Set the class id
        insertmember.setInt(1, classId);
        // Set the field name
        insertmember.setString(2, fields[i].getName());
        // It is a field
        insertmember.setInt(3, 1);
        // Insert the record
        insertmember.executeUpdate();
    }
}

{'preparedstatement'}
/**
   * Start a MUD from scratch, with the given name and password.  Create
   * an initial MudPlace object as the entrance, giving it the specified
   * name and description.
   **/
public MudServer(String mudname, String password, String placename, String description) throws RemoteException {
    this.mudname = mudname;
    this.password = password;
    this.places = new Hashtable();
    // Create the entrance place
    try {
        this.entrance = new MudPlace(this, placename, description);
    }// Should never happen
     catch (PlaceAlreadyExists e) {
    }
}

{'mudplace'}
/**
   * This remote method returns a RemoteMudPlace object for the named place.
   * In this sense, a MudServer acts as like an RMI Registry object, returning
   * remote objects looked up by name.  It is simpler to do it this way than
   * to use an actual Registry object.  If the named place does not exist,
   * it throws a NoSuchPlace exception
   **/
public RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace {
    RemoteMudPlace p = (RemoteMudPlace) places.get(name);
    if (p == null)
        throw new NoSuchPlace();
    return p;
}

{'remotemudplace', 'mudserver', 'nosuchplace'}
/**
   * Define a new placename to place mapping in our hashtable.  
   * This is not a remote method.  The MudPlace() constructor calls it
   * to register the new place it is creating.
   **/
public void setPlaceName(RemoteMudPlace place, String name) throws PlaceAlreadyExists {
    if (places.containsKey(name))
        throw new PlaceAlreadyExists();
    places.put(name, place);
}

{'mudplace'}
/**
   * This main() method defines the standalone program that starts up a MUD
   * server.  If invoked with a single argument, it treats that argument as
   * the name of a file containing the serialized and compressed state of an
   * existing MUD, and recreates it.  Otherwise, it expects four command-line
   * arguments: the name of the MUD, the password, the name of the entrance
   * place for the MUD, and a description of that entrance place.
   * Besides creating the MudServer object, this program sets an appropriate
   * security manager, and uses the default rmiregistry to register the
   * the MudServer under its given name.
   **/
public static void main(String[] args) {
    try {
        MudServer server;
        if (args.length == 1) {
            // Read the MUD state in from a file
            FileInputStream f = new FileInputStream(args[0]);
            ObjectInputStream in = new ObjectInputStream(new GZIPInputStream(f));
            server = (MudServer) in.readObject();
        } else
            // Otherwise, create an initial MUD from scratch
            server = new MudServer(args[0], args[1], args[2], args[3]);
        System.setSecurityManager(new RMISecurityManager());
        Naming.rebind(Mud.mudPrefix + server.mudname, server);
    }// Display an error message if anything goes wrong.
     catch (Exception e) {
        System.out.println(e);
        System.out.println("Usage: java MudServer <savefile>\n" + "   or: java MudServer <mudname> <password> " + "<placename> <description>");
        System.exit(1);
    }
}

{'mudserver'}
public static void main(String[] args) {
    // JDBC connection to the database
    Connection c = null;
    try {
        // Some default values
        // The name to look up
        String target = null;
        // List members or lookup name?
        boolean list = false;
        // The properties file of db parameters
        String propfile = "APIDB.props";
        // Parse the command-line arguments
        for (int i = 0; i < args.length; i++) {
            if (args[i].equals("-l"))
                list = true;
            else if (args[i].equals("-p"))
                propfile = args[++i];
            else if (target != null)
                throw new IllegalArgumentException("Unexpected argument: " + args[i]);
            else
                target = args[i];
        }
        if (target == null)
            throw new IllegalArgumentException("No target specified");
        // Now determine the values needed to set up the database connection
        // The program attempts to read a property file named "APIDB.props",
        // or optionally specified with the -p argument.  This property file
        // may contain "driver", "database", "user", and "password" properties
        // that specify the necessary values for connecting to the db.
        // If the properties file does not exist, or does not contain the named
        // properties, defaults will be used.
        // Empty properties
        Properties p = new Properties();
        try // Try to load props
        {
            p.load(new FileInputStream(propfile));
        } catch (Exception e) {
        }
        // Read values from Properties file, using defaults if not found.
        // These defaults will probably not work for you!
        String driver = p.getProperty("driver", "postgres95.PGDriver");
        String database = p.getProperty("database", "jdbc:postgres95:///APIDB");
        String user = p.getProperty("user", "");
        String password = p.getProperty("password", "");
        // Load the database driver
        Class.forName(driver);
        // And set up a connection to the specified database
        c = DriverManager.getConnection(database, user, password);
        // Tell it we will not do any updates.  This hint may improve efficiency.
        c.setReadOnly(true);
        // member, class, or package.
        if (list)
            list(c, target);
        else
            lookup(c, target);
    }// a SQLException is thrown, display the extra state message it includes.
     catch (Exception e) {
        System.out.println(e);
        if (e instanceof SQLException)
            System.out.println(((SQLException) e).getSQLState());
        System.out.println("Usage: java LookupAPI [-l] [-p <propfile>] target");
    } finally // Always close the DB connection when we're done with it.
    {
        try {
            c.close();
        } catch (Exception e) {
        }
    }
}

{'option', 'given', 'sqlexception', 'otherwise', 'anything', 'match', 'wrong', 'print', 'go'}
/** Use the URLConnection class to get info about the URL */
public static void printinfo(URL url) throws IOException {
    // Get URLConnection from the URL
    URLConnection c = url.openConnection();
    // Open a connection to the URL
    c.connect();
    // Display some information about the URL contents
    System.out.println("  Content Type: " + c.getContentType());
    System.out.println("  Content Encoding: " + c.getContentEncoding());
    System.out.println("  Content Length: " + c.getContentLength());
    System.out.println("  Date: " + new Date(c.getDate()));
    System.out.println("  Last Modified: " + new Date(c.getLastModified()));
    System.out.println("  Expiration: " + new Date(c.getExpiration()));
    // If it is an HTTP connection, display some additional information.
    if (c instanceof HttpURLConnection) {
        HttpURLConnection h = (HttpURLConnection) c;
        System.out.println("  Request Method: " + h.getRequestMethod());
        System.out.println("  Response Message: " + h.getResponseMessage());
        System.out.println("  Response Code: " + h.getResponseCode());
    }
}

{'urlconnection'}
/** 
   * This is the implementation of the no-op read() method of FilterReader.
   * It calls in.read() to get a buffer full of characters, then strips
   * out the HTML tags.  (in is a protected field of the superclass).
   **/
public int read(char[] buf, int from, int len) throws IOException {
    // how many characters have been read
    int numchars = 0;
    // all out, leaving us with zero characters to return.
    while (numchars == 0) {
        // Read characters
        numchars = in.read(buf, from, len);
        // Check for EOF and handle it.
        if (numchars == -1)
            return -1;
        // Loop through the characters we read, stripping out HTML tags.
        // Characters not in tags are copied over any previous tags in the buffer
        // Index of last non-HTML char
        int last = from;
        for (int i = from; i < from + numchars; i++) {
            if (!intag) {
                // If not in an HTML tag
                if (//   check for start of a tag
                buf[i] == '<')
                    //   check for start of a tag
                    intag = true;
                else
                    //   and copy the character
                    buf[last++] = buf[i];
            } else // Else, check for end of tag
            if (buf[i] == '>')
                intag = false;
        }
        // Figure out how many characters remain
        numchars = last - from;
    }
    // Then return that number.
    return numchars;
}

{'might', 'bunch', 'filterreader'}
/** Print out the scribble */
void print() {
    // Obtain a PrintJob and a Graphics object to use with it
    Toolkit toolkit = this.getToolkit();
    PrintJob job = toolkit.getPrintJob(this, "PrintScribble", printprefs);
    // If the user clicked Cancel in the print dialog
    if (job == null)
        return;
    Graphics g = job.getGraphics();
    // Give the output a larger top and left margin.  Otherwise it will
    // be scrunched up in the upper-left corner of the page.
    g.translate(100, 100);
    // Draw a border around the output area.
    Dimension size = this.getSize();
    g.drawRect(-1, -1, size.width + 1, size.height + 1);
    // Set a clipping region so our scribbles don't go outside the border
    // On-screen this happens automatically, but not on paper.
    g.setClip(0, 0, size.width, size.height);
    // Print this component and all components it contains
    // Use print() if you don't want the button to show
    this.printAll(g);
    // Finish up.
    // End the page
    g.dispose();
    // End the job
    job.end();
}

{'printjob'}
/** The main method.  Create a PrintScribble() object and away we go! */
public static void main(String[] args) {
    PrintScribble s = new PrintScribble();
}

{'printscribble'}
/** 
   * This remote method returns a RemoteMudPerson object corresponding to
   * the specified name, or throws an exception if no such person is here 
   **/
public RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson {
    synchronized (names) {
        // What about when there are 2 of the same name?
        int i = names.indexOf(name);
        if (i == -1)
            throw new NoSuchPerson();
        return (RemoteMudPerson) people.elementAt(i);
    }
}

{'remotemudperson'}
/** 
   * This remote method moves the specified RemoteMudPerson from this place
   * in the named direction (i.e. through the named exit) to whatever place
   * is there.  It throws exceptions if the specified person isn't in this
   * place to begin with, or if they are already in the place through the exit
   * or if the exit doesn't exist, or if the exit links to another MUD server
   * and the server is not functioning.
   **/
public RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed {
    // Make sure the direction is valid, and get destination if it is
    Object destination;
    synchronized (exits) {
        int i = exits.indexOf(direction);
        if (i == -1)
            throw new NoSuchExit();
        destination = destinations.elementAt(i);
    }
    // If destination is a string, it is a place on another server, so connect 
    // to that server.  Otherwise, it is a place already on this server.  
    // Throw an exception if we can't connect to the server.
    RemoteMudPlace newplace;
    if (destination instanceof String) {
        try {
            String t = (String) destination;
            int pos = t.indexOf('@');
            String url = t.substring(0, pos);
            String placename = t.substring(pos + 1);
            RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);
            newplace = s.getNamedPlace(placename);
        } catch (Exception e) {
            throw new LinkFailed();
        }
    } else
        // If the destination is not a string, then it is a Place
        newplace = (RemoteMudPlace) destination;
    // Make sure the person is here and get their name.  
    // Throw an exception if they are not here
    String name = verifyPresence(who);
    // Move the person out of here, and tell everyone who remains about it.
    this.exit(who, name + " has gone " + direction);
    // Put the person into the new place.  
    // Send a message to everyone already in that new place
    String fromwhere;
    if (// going to a local place
    newplace instanceof MudPlace)
        fromwhere = placename;
    else
        fromwhere = server.getMudName() + "." + placename;
    newplace.enter(who, name, name + " has arrived from: " + fromwhere);
    // know where they are now at.
    return newplace;
}

{'remotemudplace', 'remotemudperson', 'client'}
/**
   * Create a new place in this MUD, with the specified name an description. 
   * The new place is accessible from this place through
   * the specified exit, and this place is accessible from the new place 
   * through the specified entrance.  The creator must be in this place
   * in order to create a exit from this place.
   **/
public void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists {
    // Verify that the creator is actually here in this place
    String creatorname = verifyPresence(creator);
    synchronized (exits) {
        // Check that the exit doesn't already exist.
        if (exits.indexOf(exit) != -1)
            throw new ExitAlreadyExists();
        // Create the new place, registering its name with the server
        MudPlace destination = new MudPlace(server, name, description);
        // Link from there back to here
        destination.exits.addElement(entrance);
        destination.destinations.addElement(this);
        // And link from here to there
        exits.addElement(exit);
        destinations.addElement(destination);
    }
    // Let everyone know about the new exit, and the new place beyond
    tellEveryone(creatorname + " has created a new place: " + exit);
}

{'time', 'allow', 'client', 'change'}
/**
   * Create a new exit from this mud, linked to a named place in a named
   * MUD on a named host (this can also be used to link to a named place in 
   * the current MUD, of course).  Because of the possibilities of deadlock,
   * this method only links from here to there; it does not create a return
   * exit from there to here.  That must be done with a separate call.
   **/
public void linkTo(RemoteMudPerson linker, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace {
    // Verify that the linker is actually here 
    String name = verifyPresence(linker);
    // Check that the link target actually exists.  Throw NoSuchPlace if not.
    // Note that NoSuchPlace may also mean "NoSuchMud" or "MudNotResponding".
    String url = "rmi://" + hostname + '/' + Mud.mudPrefix + mudname;
    try {
        RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);
        RemoteMudPlace destination = s.getNamedPlace(placename);
    } catch (Exception e) {
        throw new NoSuchPlace();
    }
    synchronized (exits) {
        // Check that the exit doesn't already exist.
        if (exits.indexOf(exit) != -1)
            throw new ExitAlreadyExists();
        // Add the exit, to the list of exit names
        exits.addElement(exit);
        // And add the destination to the list of destinations.  Note that
        // the destination is stored as a string rather than as a RemoteMudPlace.
        // This is because if the remote server goes down then comes back up
        // again, a RemoteMudPlace is not valid, but the string still is.
        destinations.addElement(url + '@' + placename);
    }
    // Let everyone know about the new exit and where it leads
    tellEveryone(name + " has linked " + exit + " to " + "'" + placename + "' in MUD '" + mudname + "' on host " + hostname);
}

{'remotemudplace', 'nosuchmud', 'nosuchplace', 'mudnotresponding'}
/** 
   * This method puts a person into this place, assigning them the
   * specified name, and displaying a message to anyone else who is in
   * that place.  This method is called by go(), and the client should
   * call it to initially place a person into the MUD.  Once the person
   * is in the MUD, however, the client should restrict them to using go()
   * and should not allow them to call this method directly.
   * If there have been networking problems, a client might call this method
   * to restore a person to this place, in case they've been bumped out.
   * (A person will be bumped out of a place if the server tries to send
   * a message to them and gets a RemoteException.)
   **/
public void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere {
    // Send the message to everyone who is already here.
    if (message != null)
        tellEveryone(message);
    // Add the person to this place.
    synchronized (names) {
        if (people.indexOf(who) != -1)
            throw new AlreadyThere();
        names.addElement(name);
        people.addElement(who);
    }
}

{'remoteexception'}
public void run() {
    // Loop through the recipients
    for (int i = 0; i < recipients.size(); i++) {
        RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);
        // Try to send the message to each one.
        try {
            person.tell(message);
        }// failed, and silently remove them from this place.
         catch (RemoteException e) {
            try {
                MudPlace.this.exit(person, null);
            } catch (Exception ex) {
            }
        }
    }
}

{'assume', 'fails', 'client', 'network'}
/** 
   * Create and start a thread that sends out a message everyone in this place.
   * If it gets a RemoteException talking to a person, it silently removes 
   * that person from this place.  This is not a remote method, but is used
   * internally by a number of remote methods.
   **/
protected void tellEveryone(final String message) {
    // If there is no-one here, don't bother sending the message!
    if (people.size() == 0)
        return;
    // Make a copy of the people here now.  The message is sent asynchronously
    // and the list of people in the room may change before the message is
    // sent to everyone.
    final Vector recipients = (Vector) people.clone();
    // Create and start a thread to send the message, using an anonymous
    // class.  We do this because sending the message to everyone in this 
    // place might take some time, (particularly on a slow or flaky network) 
    // and we don't want to wait.
    new Thread() {

        public void run() {
            // Loop through the recipients
            for (int i = 0; i < recipients.size(); i++) {
                RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);
                // Try to send the message to each one.
                try {
                    person.tell(message);
                }// failed, and silently remove them from this place.
                 catch (RemoteException e) {
                    try {
                        MudPlace.this.exit(person, null);
                    } catch (Exception ex) {
                    }
                }
            }
        }
    }.start();
}

{'remoteexception', 'assume', 'fails', 'client'}
/**
   * This convenience method checks whether the specified person is here.
   * If so, it returns their name.  If not it throws a NotThere exception
   **/
protected String verifyPresence(RemoteMudPerson who) throws NotThere {
    int i = people.indexOf(who);
    if (i == -1)
        throw new NotThere();
    else
        return (String) names.elementAt(i);
}

{'notthere'}
/**
   * The real constructor.  Create a FileViewer object to display the
   * specified file from the specified directory 
   **/
public FileViewer(String directory, String filename) {
    // Create the (closeable) frame
    super();
    // Create a TextArea to display the contents of the file in
    textarea = new TextArea("", 24, 80);
    textarea.setFont(new Font("MonoSpaced", Font.PLAIN, 12));
    textarea.setEditable(false);
    this.add("Center", textarea);
    // Create a bottom panel to hold a couple of buttons in
    Panel p = new Panel();
    p.setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 5));
    this.add(p, "South");
    // Create the buttons and arrange to handle button clicks
    Font font = new Font("SansSerif", Font.BOLD, 14);
    Button openfile = new Button("Open File");
    Button close = new Button("Close");
    openfile.addActionListener(this);
    openfile.setActionCommand("open");
    openfile.setFont(font);
    close.addActionListener(this);
    close.setActionCommand("close");
    close.setFont(font);
    p.add(openfile);
    p.add(close);
    this.pack();
    // Figure out the directory, from filename or current dir, if necessary
    if (directory == null) {
        File f;
        if ((filename != null) && (f = new File(filename)).isAbsolute()) {
            directory = f.getParent();
            filename = f.getName();
        } else
            directory = System.getProperty("user.dir");
    }
    // Remember the directory, for FileDialog
    this.directory = directory;
    // Now load and display the file
    setFile(directory, filename);
}

{'fileviewer', 'filedialog'}
/**
   * Load and display the specified file (if any) from the specified directory
   **/
public void setFile(String directory, String filename) {
    if ((filename == null) || (filename.length() == 0))
        return;
    File f;
    FileReader in = null;
    // use a FileReader instead of a FileInputStream.
    try {
        // Create a file object
        f = new File(directory, filename);
        // Create a char stream to read  it
        in = new FileReader(f);
        // Check file size
        int size = (int) f.length();
        // Allocate an array big enough for it
        char[] data = new char[size];
        // How many chars read so far?
        int chars_read = 0;
        while (// Loop until we've read it all
        chars_read < size) chars_read += in.read(data, chars_read, size - chars_read);
        // Display chars in TextArea
        textarea.setText(new String(data));
        // Set the window title
        this.setTitle("FileViewer: " + filename);
    }// Display messages if something goes wrong
     catch (IOException e) {
        textarea.setText(e.getClass().getName() + ": " + e.getMessage());
        this.setTitle("FileViewer: " + filename + ": I/O Exception");
    } finally // Always be sure to close the input stream!
    {
        try {
            if (in != null)
                in.close();
        } catch (IOException e) {
        }
    }
}

{'content', 'fileinputstream', 'since', 'reading', 'filereader'}
/**
   * The FileViewer can be used by other classes, or it can be
   * used standalone with this main() method.
   **/
public static void main(String[] args) throws IOException {
    // Create a FileViewer object
    Frame f = new FileViewer((args.length == 1) ? args[0] : null);
    // Arrange to exit when the FileViewer window closes
    f.addWindowListener(new WindowAdapter() {

        public void windowClosed(WindowEvent e) {
            System.exit(0);
        }
    });
    // And pop the window up
    f.show();
}

{'fileviewer'}
/**
   * Sort a portion of an array of strings, using the collation order of
   * the specified locale.   If up is true, sort ascending, otherwise, sort
   * descending.  If ignorecase is true, ignore the capitalization of letters
   **/
public static void sort(String[] a, int from, int to, boolean up, boolean ignorecase, Locale locale) {
    // Don't sort if we don't have to
    if ((a == null) || (a.length < 2))
        return;
    // The java.text.Collator object does internationalized string compares
    // Create one for the specified, or the default locale.
    Collator c;
    if (locale == null)
        c = Collator.getInstance();
    else
        c = Collator.getInstance(locale);
    // using the default American English locale.
    if (ignorecase)
        c.setStrength(Collator.SECONDARY);
    // Use the Collator object to create an array of CollationKey objects that
    // correspond to each of the strings.  
    // Comparing CollationKeys is much quicker than comparing Strings
    CollationKey[] b = new CollationKey[a.length];
    for (int i = 0; i < a.length; i++) b[i] = c.getCollationKey(a[i]);
    // Now define a Comparer object to compare collation keys, using an
    // anonymous class.
    Comparer comp = new Comparer() {

        public int compare(Object a, Object b) {
            return ((CollationKey) a).compareTo((CollationKey) b);
        }
    };
    // Finally, sort the array of CollationKey objects, rearranging the 
    // original array of strings in exactly the same way.
    sort(b, a, from, to, up, comp);
}

{'option', 'note', 'seem', 'account', 'taken', 'whether', 'correctly', 'case', 'work', 'jdk', 'collationkeys', 'collationkey', 'specify'}
/** This is the test program.  It sorts complex numbers in various ways. */
public static void main(String[] args) {
    // Define an array of SortableComplexNumber objects.  Initialize it
    // to contain random complex numbers.
    SortableComplexNumber[] a = new SortableComplexNumber[5];
    for (int i = 0; i < a.length; i++) a[i] = new SortableComplexNumber(Math.random() * 10, Math.random() * 10);
    // Now sort it using the SortableComplexNumber compareTo() method, which
    // sorts by magnitude, and print the results out.
    System.out.println("Sorted by magnitude:");
    Sorter.sort(a);
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
    // Sort the complex numbers again, using a Comparer object that
    // compares them based on the sum of their real and imaginary parts
    System.out.println("Sorted by sum of real and imaginary parts:");
    Sorter.sort(a, new Sorter.Comparer() {

        public int compare(Object a, Object b) {
            ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;
            return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));
        }
    });
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
    // Sort them again using a Comparer object that compares their real
    // parts, and then their imaginary parts
    System.out.println("Sorted descending by real part, then imaginary:");
    Sorter.sort(a, 0, a.length - 1, false, new Sorter.Comparer() {

        public int compare(Object a, Object b) {
            ComplexNumber i = (ComplexNumber) a, j = (ComplexNumber) b;
            double result = i.real() - j.real();
            if (result == 0)
                result = i.imaginary() - j.imaginary();
            return sign(result);
        }
    });
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
}

{'compareto', 'sortablecomplexnumber'}
/** Read the basename and num_frames parameters.
   *  Then read in the images, using the specified base name.
   *  For example, if basename is images/anim, read images/anim0,
   *  images/anim1, etc.  These are relative to the current document URL.
   */
public void init() {
    String basename = this.getParameter("basename");
    try {
        num_frames = Integer.parseInt(this.getParameter("num_frames"));
    } catch (NumberFormatException e) {
        num_frames = 0;
    }
    // getImage() creates an Image object from a URL specification,
    // but it doesn't actually load the images; that is done  asynchronously.
    // Store all the images in a MediaTracker so we can block until
    // they have all loaded.  This method must return promptly, so we don't
    // wait for them to load here.
    tracker = new MediaTracker(this);
    frames = new Image[num_frames];
    for (int i = 0; i < num_frames; i++) {
        frames[i] = this.getImage(this.getDocumentBase(), basename + i);
        // Add image to tracker, assigning an ID
        tracker.addImage(frames[i], i);
    }
}

{'getimage', 'mediatracker'}
/** This is the body of the thread--the method that does the animation. */
public void run() {
    // First, wait until all images have loaded completely.
    for (int i = 0; i < num_frames; i++) {
        this.showStatus("Loading frame: " + i);
        // one we passed to addImage().
        try {
            tracker.waitForID(i);
        } catch (InterruptedException e) {
            ;
        }
        // Check for errors loading it.  Display an error message if necessary
        if (tracker.isErrorID(i)) {
            this.showStatus("Error loading frame " + i + "; quitting.");
            return;
        }
    }
    // Done loading all frames
    this.showStatus("Loading frames: done.");
    // Now do the animation: increment the framenumber, redraw, pause
    while (true) {
        if (++framenum >= frames.length)
            framenum = 0;
        repaint();
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            ;
        }
    }
}

{'specified', 'addimage', 'argument', 'block'}
/** 
   * Close the named account.  This method is synchronized to make it 
   * thread safe, since it manipulates the accounts hashtable.
   **/
public synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {
    Account acct;
    acct = verify(name, password);
    accounts.remove(name);
    // have to obtain a lock on that account to be thread safe.
    synchronized (acct) {
        int balance = acct.balance;
        acct.balance = 0;
        return new FunnyMoney(balance);
    }
}

{'RANK', 'transaction', 'changing'}
/** Deposit the specified FunnyMoney to the named account */
public void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {
    Account acct = verify(name, password);
    synchronized (acct) {
        acct.balance += money.amount;
        acct.transactions.addElement("Deposited " + money.amount + " on " + new Date());
    }
}

{'funnymoney'}
/**
   * The main program that runs this RemoteBankServer.
   * Create a RemoteBankServer object and give it a name in the registry.
   * Read a system property to determine the name, but use "FirstRemote"
   * as the default name.  This is all that is necessary to set up the
   * service.  RMI takes care of the rest.
   **/
public static void main(String[] args) {
    try {
        // Create a bank server object
        RemoteBankServer bank = new RemoteBankServer();
        // Figure out what to name it
        String name = System.getProperty("bankname", "FirstRemote");
        // Name it that
        Naming.rebind(name, bank);
        // Tell the world we're up and running
        System.out.println(name + " is open and ready for customers.");
    } catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java [-Dbankname=<name>] RemoteBankServer");
        System.exit(1);
    }
}

{'might', 'remotebankserver', 'force', 'thread', 'firstremote'}
public YesNoDialog(Frame parent, String title, String message, String yes_label, String no_label, String cancel_label) {
    // Create a modal dialog with the specified title and parent
    super(parent, title, true);
    // Specify a LayoutManager for it
    this.setLayout(new BorderLayout(15, 15));
    // Put the message label in the middle of the window.
    // Note: MultiLineLabel is a custom component defined later in the chapter
    this.add("Center", new MultiLineLabel(message, 20, 20));
    // Create an action listener for use by the buttons of the dialog.
    // When a button is pressed, this listener first closes the dialog box.
    // Then, it passes the event on to the listeners registered for the
    // dialog box, after changing the event source from the individual button
    // to the dialog box itself.  Since events are immutable, it must create
    // a new ActionEvent object in order to change the source.  It passes
    // this new event to the listeners by calling actionPerformed() on the
    // AWTEventMulticaster object stored in the listeners field (see below).
    ActionListener listener = new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            // pop down dialog
            YesNoDialog.this.dispose();
            if (// notify all registered listeners
            listeners != null)
                listeners.actionPerformed(new ActionEvent(YesNoDialog.this, e.getID(), e.getActionCommand()));
        }
    };
    // Create a panel for the dialog buttons and put it at the bottom
    // of the dialog.  Specify a FlowLayout layout manager for it.
    Panel buttonbox = new Panel();
    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));
    this.add("South", buttonbox);
    // and action command for each, and adding them to the buttonbox
    if (yes_label != null) {
        // if a label was specified...
        //   create button
        Button yes = new Button(yes_label);
        //   set action command
        yes.setActionCommand("yes");
        //   set listener
        yes.addActionListener(listener);
        //   add button to the panel
        buttonbox.add(yes);
    }
    if (no_label != null) {
        Button no = new Button(no_label);
        no.setActionCommand("no");
        no.addActionListener(listener);
        buttonbox.add(no);
    }
    if (cancel_label != null) {
        Button cancel = new Button(cancel_label);
        cancel.setActionCommand("cancel");
        cancel.addActionListener(listener);
        buttonbox.add(cancel);
    }
    // Finally, set the dialog to its preferred size.
    this.pack();
}

{'flowlayout', 'layoutmanager', 'actionevent', 'actionperformed', 'specifying', 'multilinelabel', 'awteventmulticaster'}
/** Register an action listener to be notified when a button is pressed
   *  AWTEventMulticaster makes this easy. */
public void addActionListener(ActionListener l) {
    listeners = AWTEventMulticaster.add(listeners, l);
}

{'awteventmulticaster'}
/**
   * A main method that demonstrates how to use this class, and allows testing
   */
public static void main(String[] args) {
    // Create, size, and show a frame because dialogs require a frame parent.
    Frame f = new Frame("InfoDialog Test");
    f.setSize(100, 100);
    f.show();
    // Create an instance of InfoDialog, with title and message specified
    YesNoDialog d = new YesNoDialog(f, "YesNoDialog Test", "There are unsaved files.\n" + "Do you want to save them before quitting?", "Yes, save and quit", "No, quit without saving", "Cancel; don't quit");
    // Register an action listener for the dialog.  This one just prints
    // the results out to the console.
    d.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            System.out.println("The user pressed: " + e.getActionCommand());
        }
    });
    // Now pop the dialog up.  It will pop itself down automatically.
    d.show();
}

{'infodialog'}
/**
   * The main() method.  If this program is invoked as an application, this
   * method will create the necessary window, add the applet to it, and
   * call init(), below.  Note that Frame uses a PanelLayout by default.
   */
public static void main(String[] args) {
    // Create a window
    Frame f = new Frame();
    // Create the applet panel
    Applet a = new StandaloneScribble();
    // Add applet to window
    f.add(a, "Center");
    // Initialize the applet
    a.init();
    // Set the size of the window
    f.setSize(400, 400);
    // Make the window visible
    f.show();
    f.addWindowListener(new // Handle window close requests
    WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
}

{'panellayout'}
/**
   * The init() method.  If the program is invoked as an applet, the browser
   * allocates screen space for it and calls this method to set things up
   */
public void init() {
    // Define, instantiate and register a MouseListener object
    this.addMouseListener(new MouseAdapter() {

        public void mousePressed(MouseEvent e) {
            lastx = e.getX();
            lasty = e.getY();
        }
    });
    // Define, instantiate and register a MouseMotionListener object
    this.addMouseMotionListener(new MouseMotionAdapter() {

        public void mouseDragged(MouseEvent e) {
            Graphics g = getGraphics();
            int x = e.getX(), y = e.getY();
            g.setColor(Color.black);
            g.drawLine(lastx, lasty, x, y);
            lastx = x;
            lasty = y;
        }
    });
    // Create a clear button
    Button b = new Button("Clear");
    // Define, instantiate, and register a listener to handle button presses
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            // clear the scribble
            Graphics g = getGraphics();
            g.setColor(getBackground());
            g.fillRect(0, 0, getSize().width, getSize().height);
        }
    });
    // And add the button to the applet
    this.add(b);
}

{'mouselistener', 'mousemotionlistener'}
/**
   * This method computes a digital signature for the current state of the
   * object, excluding the signature-related state of this class.
   * That is, the signature is based only on the state of the subclasses.
   * The arguments specify who is signing the object, and what digital 
   * signature algorithm to use.
   * 
   * Note that no other threads should be modifying the object while
   * this computation is being performed.  If a subclass will be used in a 
   * multi-threaded environment, this means that methods of the subclass
   * that modify its state should be synchronized like this one is.
   **/
public synchronized void sign(String signername, String algorithm) throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    // Save the arguments for use by verify()
    this.signername = signername;
    this.algorithm = algorithm;
    // Get a Signature object to compute the signature with
    Signature s = Signature.getInstance(algorithm);
    // Get a Signer object representing the signer
    Signer signer = (Signer) IdentityScope.getSystemScope().getIdentity(signername);
    // Initialize the Signature object using the PrivateKey of the Signer
    s.initSign(signer.getPrivateKey());
    // Create an ObjectOutputStream that writes its output to a 
    // ByteArrayStream.  This is how we capture the state of the object
    // so that it can be signed.
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    ObjectOutputStream out = new ObjectOutputStream(bout);
    // Now serialize the object, capturing its state.  We have to set a flag
    // before we do this, so that the signer name, algorithm, and signature
    // itself are not included in this serialized state.  See writeObject()
    // below to see how this works.
    signing = true;
    out.writeObject(this);
    signing = false;
    // Now tell the Signature object about the bytes of serialized state
    // that were stored by the ByteArrayOutputStream
    s.update(bout.toByteArray());
    // And finally, compute the signature
    this.signature = s.sign();
}

{'writeobject', 'objectoutputstream', 'bytearraystream', 'bytearrayoutputstream', 'privatekey'}
/**
   * This method verifies the signature of any SignedObject subclass.
   * It works much like the sign() method, and is also synchronized.
   **/
public synchronized boolean verify() throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException {
    // Make sure the object is actually signed.
    if (signature == null)
        throw new SignatureException("Object is not signed");
    // Get the signature, signer and public key, and initialize, like above,
    // except that this time use a PublicKey instead of a PrivateKey
    Signature s = Signature.getInstance(algorithm);
    Identity signer = (Identity) IdentityScope.getSystemScope().getIdentity(signername);
    s.initVerify(signer.getPublicKey());
    // Create streams and capture the current state of the object 
    // (excluding the signature bytes themselves) in a byte array
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    ObjectOutputStream out = new ObjectOutputStream(bout);
    signing = true;
    out.writeObject(this);
    signing = false;
    // Pass state of the object to the Signature, and verify the stored
    // signature bytes against that state.  Return the result of verification.
    s.update(bout.toByteArray());
    return s.verify(this.signature);
}

{'publickey', 'signedobject', 'privatekey'}
/** The constructor.  Initialize the SignedString */
public SignedStringServer(SignedString s) throws RemoteException {
    this.s = s;
}

{'signedstring'}
public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException, NotBoundException {
    // Look up the server
    RemoteSignedString rss = (RemoteSignedString) Naming.lookup("rmi://" + ((args.length > 0) ? args[0] : "") + "/SignedStringServer");
    // Invoke a remote method of the server to get a SignedString
    SignedString ss = rss.getString();
    // Now verify the signature on that SignedString.
    if (ss.verify())
        System.out.println("Verified SignedString: " + ss.s);
    else
        System.out.println("SignedString failed verification");
}

{'signedstring'}
/**
   * This is the convenience routine for adding menu items to a menu pane.
   * It works for pulldown or popup menu panes, since PopupMenu extends Menu.
   */
protected static void createMenuItems(Menu pane, ActionListener listener, String[] labels, String[] commands, int[] shortcuts) {
    for (int i = 0; i < labels.length; i++) {
        MenuItem mi = new MenuItem(labels[i]);
        mi.addActionListener(listener);
        if ((commands != null) && (commands[i] != null))
            mi.setActionCommand(commands[i]);
        if ((shortcuts != null) && (shortcuts[i] != 0))
            mi.setShortcut(new MenuShortcut(shortcuts[i]));
        pane.add(mi);
    }
}

{'popupmenu'}
/**
   * This is the method defined by the ActionListener interface.  All
   * the menu item commands are handled here because the applet was specified
   * as the listener for all menu items.  Note the use of getActionCommand()
   * to determine the command string registered with the individual items.
   */
public void actionPerformed(ActionEvent e) {
    String cmd = e.getActionCommand();
    if (// Don't do this in an applet
    cmd.equals("quit"))
        // Don't do this in an applet
        System.exit(0);
    else if (// defined below
    cmd.equals("clear"))
        // defined below
        clear();
    else if (cmd.equals("about"))
        /* not yet implemented */
        ;
    else if (cmd.equals("red"))
        color = Color.red;
    else if (cmd.equals("green"))
        color = Color.green;
    else if (cmd.equals("blue"))
        color = Color.blue;
    else if (cmd.equals("black"))
        color = color.black;
}

{'actionlistener', 'getactioncommand'}
/** Clear the applet area.  Used by actionPerformed() above */
protected void clear() {
    Graphics g = this.getGraphics();
    g.setColor(this.getBackground());
    g.fillRect(0, 0, this.getSize().width, this.getSize().height);
}

{'actionperformed'}
public static void main(String[] args) {
    try {
        // Install the Security manager
        System.setSecurityManager(new ServiceSecurityManager());
        // Create the ClassLoader that we'll use to load Service classes.
        // The classes should be stored in (or beneath) the directory specified
        // as the first command-line argument
        LocalClassLoader loader = new LocalClassLoader(args[0]);
        // Create a Server object that does no logging and
        // has a limit of five concurrent connections at once.
        Server server = new Server(null, 5);
        // Parse the argument list, which should contain Service name/port pairs.
        // For each pair, load the named Service using the class loader, then
        // instantiate it with newInstance(), then tell the server to start
        // running it.
        int i = 1;
        while (i < args.length) {
            // dynamic load
            Class serviceClass = loader.loadClass(args[i++]);
            // instantiate
            Service service = (Service) serviceClass.newInstance();
            // get port
            int port = Integer.parseInt(args[i++]);
            // run service
            server.addService(service, port);
        }
    } catch (// Display a message if anything goes wrong
    Exception // Display a message if anything goes wrong
    e) {
        System.err.println(e);
        System.err.println("Usage: java SafeServer " + "<servicedir> <servicename> <port>\n" + "\t\t[<servicename> <port> ... ]");
        System.exit(1);
    }
}

{'newinstance', 'classloader'}
/**
     * This is the basic method that tests whether there is a class loaded
     * by a ClassLoader anywhere on the stack.  If so, it means that that
     * untrusted code is trying to perform some kind of sensitive operation.
     * We prevent it from performing that operation by throwing an exception.
     * trusted() is called by most of the check...() methods below.
     **/
protected void trusted() {
    if (inClassLoader())
        throw new SecurityException();
}

{'classloader'}
/**
     * Here's another variant.  It denies access if a loaded class attempts
     * the operation directly or through one level of indirection.  It is used
     * to prevent loaded code from calling Runtime.load(), or 
     * System.loadLibrary() (which calls Runtime.load()).
     **/
protected void trustedOrIndirect2() {
    int depth = classLoaderDepth();
    if ((depth == 3) || (depth == 4))
        throw new SecurityException();
}

{'loadlibrary'}
/**
     * These are all the specific checks that a security manager can
     * perform.  They all just call one of the methods above and throw a
     * SecurityException if the operation is not allowed.  This 
     * SecurityManager subclass is perhaps a little too restrictive.  For
     * example, it doesn't allow loaded code to read *any* system properties,
     * even though some of them are quite harmless.
     **/
public void checkCreateClassLoader() {
    trustedOrIndirect();
}

{'securityexception', 'securitymanager'}
/** 
     * This is the one SecurityManager method that is different from the
     * others.  It indicates whether a top-level window should display an
     * "untrusted" warning.  The window is always allowed to be created, so
     * this method is not normally meant to throw an exception.  It should
     * return true if the window does not need to display the warning, and
     * false if it does.  In this example, however, our text-based Service
     * classes should never need to create windows, so we will actually
     * throw an exception to prevent any windows from being opened.
     **/
public boolean checkTopLevelWindow(Object window) {
    trusted();
    return true;
}

{'securitymanager'}
/**
     * This is one abstract method of ClassLoader that all subclasses must
     * define.  Its job is to load an array of bytes from somewhere and to
     * pass them to defineClass().  If the resolve argument is true, it must
     * also call resolveClass(), which will do things like verify the presence
     * of the superclass.  Because of this second step, this method may be
     * called to load superclasses that are system classes, and it must take 
     * this into account.
     **/
public Class loadClass(String classname, boolean resolve) throws ClassNotFoundException {
    try {
        // Our ClassLoader superclass has a built-in cache of classes it has
        // already loaded.  So, first check the cache.
        Class c = findLoadedClass(classname);
        // a system class (i.e. from the CLASSPATH) and ignore any errors
        if (c == null) {
            try {
                c = findSystemClass(classname);
            } catch (Exception e) {
            }
        }
        // ".class" extension.
        if (c == null) {
            // Figure out the filename
            String filename = classname.replace('.', File.separatorChar) + ".class";
            // Create a File object.  Interpret the filename relative to the
            // directory specified for this ClassLoader.
            File f = new File(directory, filename);
            // Get the length of the class file, allocate an array of bytes for
            // it, and read it in all at once.
            int length = (int) f.length();
            byte[] classbytes = new byte[length];
            DataInputStream in = new DataInputStream(new FileInputStream(f));
            in.readFully(classbytes);
            in.close();
            // Now call an inherited method to convert those bytes into a Class
            c = defineClass(classname, classbytes, 0, length);
        }
        // method.
        if (resolve)
            resolveClass(c);
        // And we're done.  Return the Class object we've loaded.
        return c;
    }// If anything goes wrong, throw a ClassNotFoundException error
     catch (Exception e) {
        throw new ClassNotFoundException(e.toString());
    }
}

{'form', 'able', 'independent', 'created', 'either', 'classnotfoundexception', 'adding', 'resolveclass', 'since', 'beneath', 'defineclass', 'attempt', 'name', 'classloader', 'dot', 'replacing', 'got', 'platform'}
public static void main(String[] args) {
    String from = null, to = null;
    String infile = null, outfile = null;
    for (int i = 0; i < args.length; i++) {
        // All legal args require another.
        if (i == args.length - 1)
            usage();
        if (args[i].equals("-from"))
            from = args[++i];
        else if (args[i].equals("-to"))
            to = args[++i];
        else if (args[i].equals("-in"))
            infile = args[++i];
        else if (args[i].equals("-out"))
            outfile = args[++i];
        else
            usage();
    }
    try // Attempt conversion.
    {
        convert(infile, outfile, from, to);
    } catch (// Handle possible exceptions.
    Exception // Handle possible exceptions.
    e) {
        LocalizedError.display(e);
        System.exit(1);
    }
}

{'defined', 'argument', 'end', 'command', 'chapter', 'parse', 'line'}
public static void convert(String infile, String outfile, String from, String to) throws IOException, UnsupportedEncodingException {
    // Set up byte streams.
    InputStream in;
    if (infile != null)
        in = new FileInputStream(infile);
    else
        in = System.in;
    OutputStream out;
    if (outfile != null)
        out = new FileOutputStream(outfile);
    else
        out = System.out;
    // Use default encoding if no encoding is specified.
    if (from == null)
        from = System.getProperty("file.encoding");
    if (to == null)
        to = System.getProperty("file.encoding");
    // Set up character streams.
    Reader r = new BufferedReader(new InputStreamReader(in, from));
    Writer w = new BufferedWriter(new OutputStreamWriter(out, to));
    // Copy characters from input to output.  The InputStreamReader converts
    // from the input encoding to Unicode, and the OutputStreamWriter converts
    // from Unicode to the output encoding.  Characters that cannot be
    // represented in the output encoding are output as '?'
    char[] buffer = new char[4096];
    int len;
    while (// Read a block of input.
    (len = r.read(buffer)) != -1) // And write it out.
    w.write(buffer, 0, len);
    // Close the input.
    r.close();
    // Flush and close output.
    w.flush();
    w.close();
}

{'inputstreamreader', 'outputstreamwriter'}
/** This method returns the average of all numbers passed to addDatum() */
public double getAverage() {
    return sum / n;
}

{'adddatum'}
/** This method returns the number of numbers passed to addDatum() */
public double getNum() {
    return n;
}

{'adddatum'}
/** This method returns the sum of all numbers passed to addDatum() */
public double getSum() {
    return sum;
}

{'adddatum'}
public void init() {
    // Create and specify a BorderLayout layout manager that leaves
    // 10 pixels of horizontal and vertical space between components
    this.setLayout(new BorderLayout(10, 10));
    for (int i = 0; i < 5; i++) {
        // Swap the order of these arguments in Java 1.1
        this.add(borders[i], new Button(borders[i]));
    }
}

{'borderlayout'}
public void run() {
    // Lock resource 1
    synchronized (resource1) {
        System.out.println("Thread 1: locked resource 1");
        // trying to force deadlock to happen here...
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
        }
        // Now wait 'till we can get a lock on resource 2
        synchronized (resource2) {
            System.out.println("Thread 1: locked resource 2");
        }
    }
}

{'thing', 'file', 'pause', 'bit', 'want', 'give', 'basically', 'simulating', 'chance', 'something', 'asynchronous'}
public void run() {
    // This thread locks resource 2 right away
    synchronized (resource2) {
        System.out.println("Thread 2: locked resource 2");
        // Then it pauses, for the same reason as the first thread does
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
        }
        // thread can run, and the program freezes up.
        synchronized (resource1) {
            System.out.println("Thread 2: locked resource 1");
        }
    }
}

{'wait', 'hold', 'release', 'get', 'till', 'impasse', 'neither'}
public static void main(String[] args) {
    // These are the two resource objects we'll try to get locks for
    final Object resource1 = "resource1";
    final Object resource2 = "resource2";
    // Here's the first thread.  It tries to lock resource1 then resource2
    Thread t1 = new Thread() {

        public void run() {
            // Lock resource 1
            synchronized (resource1) {
                System.out.println("Thread 1: locked resource 1");
                // trying to force deadlock to happen here...
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                }
                // Now wait 'till we can get a lock on resource 2
                synchronized (resource2) {
                    System.out.println("Thread 1: locked resource 2");
                }
            }
        }
    };
    // Here's the second thread.  It tries to lock resource2 then resource1
    Thread t2 = new Thread() {

        public void run() {
            // This thread locks resource 2 right away
            synchronized (resource2) {
                System.out.println("Thread 2: locked resource 2");
                // Then it pauses, for the same reason as the first thread does
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                }
                // thread can run, and the program freezes up.
                synchronized (resource1) {
                    System.out.println("Thread 2: locked resource 1");
                }
            }
        }
    };
    // Start the two threads. If all goes as planned, deadlock will occur, 
    // and the program will never exit.
    t1.start();
    t2.start();
}

{'thing', 'file', 'want', 'bit', 'hold', 'give', 'release', 'basically', 'simulating', 'chance', 'impasse', 'neither', 'something', 'asynchronous'}
/** Create the whole GUI, and set up event listeners */
public AllComponents(String title) {
    // set frame title.
    super(title);
    // Arrange to detect window close events
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
    // Set a default font
    this.setFont(new Font("SansSerif", Font.PLAIN, 12));
    // Create the menubar.  Tell the frame about it.
    MenuBar menubar = new MenuBar();
    this.setMenuBar(menubar);
    // Create the file menu.  Add to menubar.
    Menu file = new Menu("File");
    menubar.add(file);
    // Create two items for the file menu, setting their label, shortcut,
    // action command and listener.  Add them to File menu.
    // Note that we use the frame itself as the action listener
    MenuItem open = new MenuItem("Open", new MenuShortcut(KeyEvent.VK_O));
    open.setActionCommand("open");
    open.addActionListener(this);
    file.add(open);
    MenuItem quit = new MenuItem("Quit", new MenuShortcut(KeyEvent.VK_Q));
    quit.setActionCommand("quit");
    quit.addActionListener(this);
    file.add(quit);
    // Create Help menu; add an item; add to menubar
    // Display the help menu in a special reserved place.
    Menu help = new Menu("Help");
    menubar.add(help);
    menubar.setHelpMenu(help);
    // Create and add an item to the Help menu
    MenuItem about = new MenuItem("About", new MenuShortcut(KeyEvent.VK_A));
    about.setActionCommand("about");
    about.addActionListener(this);
    help.add(about);
    // Now that we've done the menu, we can begin work on the contents of
    // the frame.  Assign a BorderLayout manager with margins for this frame.
    this.setLayout(new BorderLayout(10, 10));
    // Create two panels to contain two columns of components.  Use our custom
    // ColumnLayout layout manager for each.  Add them on the west and
    // center of the frame's border layout
    Panel column1 = new Panel();
    column1.setLayout(new ColumnLayout(5, 10, 2, ColumnLayout.LEFT));
    this.add(column1, "West");
    Panel column2 = new Panel();
    column2.setLayout(new ColumnLayout(5, 10, 2, ColumnLayout.LEFT));
    this.add(column2, "Center");
    // Create a panel to contain the buttons at the bottom of the window
    // Give it a FlowLayout layout manager, and add it along the south border
    Panel buttonbox = new Panel();
    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 100, 10));
    this.add(buttonbox, "South");
    // Create pushbuttons and add them to the buttonbox
    Button okay = new Button("Okay");
    Button cancel = new Button("Cancel");
    buttonbox.add(okay);
    buttonbox.add(cancel);
    // Handle events on the buttons
    ActionListener buttonlistener = new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            textarea.append("You clicked: " + ((Button) e.getSource()).getLabel() + "\n");
        }
    };
    okay.addActionListener(buttonlistener);
    cancel.addActionListener(buttonlistener);
    // Now start filling the left column.
    // Create a 1-line text field and add to left column, with a label
    TextField textfield = new TextField(15);
    column1.add(new Label("Name:"));
    column1.add(textfield);
    // Handle events on the TextField
    textfield.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            textarea.append("Your name is: " + ((TextField) e.getSource()).getText() + "\n");
        }
    });
    textfield.addTextListener(new TextListener() {

        public void textValueChanged(TextEvent e) {
            textarea.append("You have typed: " + ((TextField) e.getSource()).getText() + "\n");
        }
    });
    // Create a dropdown list or option menu of choices
    Choice choice = new Choice();
    choice.addItem("red");
    choice.addItem("green");
    choice.addItem("blue");
    column1.add(new Label("Favorite color:"));
    column1.add(choice);
    // Handle events on this choice
    choice.addItemListener(new ItemListener() {

        public void itemStateChanged(ItemEvent e) {
            textarea.append("Your favorite color is: " + e.getItem() + "\n");
        }
    });
    // Create checkboxes, and group them in a CheckboxGroup to give them
    // "radio button" behavior.
    CheckboxGroup checkbox_group = new CheckboxGroup();
    Checkbox[] checkboxes = new Checkbox[3];
    checkboxes[0] = new Checkbox("vanilla", checkbox_group, false);
    checkboxes[1] = new Checkbox("chocolate", checkbox_group, true);
    checkboxes[2] = new Checkbox("strawberry", checkbox_group, false);
    column1.add(new Label("Favorite flavor:"));
    for (int i = 0; i < checkboxes.length; i++) column1.add(checkboxes[i]);
    // Handle events on the checkboxes
    ItemListener checkbox_listener = new ItemListener() {

        public void itemStateChanged(ItemEvent e) {
            textarea.append("Your favorite flavor is: " + ((Checkbox) e.getItemSelectable()).getLabel() + "\n");
        }
    };
    for (int i = 0; i < checkboxes.length; i++) checkboxes[i].addItemListener(checkbox_listener);
    // Create a list of choices.
    List list = new List(4, true);
    list.addItem("Java");
    list.addItem("C");
    list.addItem("C++");
    list.addItem("Smalltalk");
    list.addItem("Lisp");
    list.addItem("Modula-3");
    list.addItem("Forth");
    column1.add(new Label("Favorite languages:"));
    column1.add(list);
    // Handle events on this list
    list.addItemListener(new ItemListener() {

        public void itemStateChanged(ItemEvent e) {
            textarea.append("Your favorite languages are: ");
            String[] languages = ((List) e.getItemSelectable()).getSelectedItems();
            for (int i = 0; i < languages.length; i++) {
                if (i > 0)
                    textarea.append(",");
                textarea.append(languages[i]);
            }
            textarea.append("\n");
        }
    });
    // Create a multi-line text area in column 2
    textarea = new TextArea(6, 40);
    textarea.setEditable(false);
    column2.add(new Label("Messages"));
    column2.add(textarea);
    // Create a scrollpane that displays portions of a larger component
    ScrollPane scrollpane = new ScrollPane();
    scrollpane.setSize(300, 150);
    column2.add(new Label("Scrolling Window"));
    column2.add(scrollpane);
    // Create a custom MultiLineLabel with a really big font and make it
    // a child of the ScrollPane container
    String message = "/*************************************************\n" + " * AllComponents.java                            *\n" + " * Written by David Flanagan                     *\n" + " * Copyright (c) 1997 by O'Reilly & Associates   *\n" + " *                                               *\n" + " *************************************************/\n";
    MultiLineLabel biglabel = new MultiLineLabel(message);
    biglabel.setFont(new Font("Monospaced", Font.BOLD + Font.ITALIC, 24));
    scrollpane.add(biglabel);
}

{'flowlayout', 'multilinelabel', 'checkboxgroup', 'borderlayout', 'columnlayout'}
/**
   * When you create a new HTMLWriter, it pops up a new, blank, Web browser
   * window to display the output in.  You must specify the applet
   * (this specifies the main browser window) and the desired size
   * for the new window.
   **/
public HTMLWriter(Applet applet, int width, int height) {
    // Verify that we can find the JSObject class we need.  Warn if not.
    try {
        Class c = Class.forName("netscape.javascript.JSObject");
    } catch (ClassNotFoundException e) {
        throw new NoClassDefFoundError("HTMLWriter requires " + "Netscape Navigator 4.0 or higher");
    }
    // Get a reference to the main browser window from the applet.
    main_window = JSObject.getWindow(applet);
    // Create a new window to display output in.
    window = (JSObject) main_window.eval("self.open(''," + "'HTMLWriter" + window_num++ + "'," + "'menubar,status,resizable,scrollbars," + "width=" + width + ",height=" + height + "')");
    // Obtain the Document object of this new window, and open it.
    document = (JSObject) window.getMember("document");
    document.call("open", null);
}

{'htmlwriter', 'jsobject'}
/**
   * This is the write() method required for all Writer subclasses.
   * Writer defines all its other write() methods in terms of this one.
   **/
public void write(char[] buf, int offset, int length) {
    // has been closed, or if the code is not running in Navigator.
    if ((window == null) || (document == null))
        return;
    // If the window has been closed by the user, do nothing
    if (((Boolean) window.getMember("closed")).booleanValue())
        return;
    // Otherwise, create a string from the specified bytes
    String s = new String(buf, offset, length);
    // And pass it to the JS document.write() method to output the HTML
    document.call("write", new String[] { s });
}

{'stream', 'occurs'}
/**
   * There is no general way to force JavaScript to flush all pending output,
   * so this method does nothing.  To flush, output a <P> tag or some other
   * HTML tag that forces a line break in the output.
   **/
public void flush() {
}

{'javascript'}
/**
   * When the stream is closed, close the JavaScript Document object
   * (But don't close the window yet.)
   **/
public void close() {
    document.call("close", null);
    document = null;
}

{'javascript'}
/**
   * If the browser window is still open, close it.
   * This method is unique to HTMLWriter.  
   **/
public void closeWindow() {
    if (document != null)
        close();
    if (!((Boolean) window.getMember("closed")).booleanValue())
        window.call("close", null);
    window = null;
}

{'htmlwriter'}
/** When the applet starts, read and display specified URL */
public void init() {
    try {
        // Get the URL specified in the <PARAM> tag
        URL url = new URL(this.getDocumentBase(), this.getParameter("url"));
        // Get a stream to read its contents
        Reader in = new InputStreamReader(url.openStream());
        // Create an HTMLWriter stream for out output
        out = new HTMLWriter(this, 400, 200);
        // Read buffers of characters and output them to the HTMLWriter 
        char[] buffer = new char[4096];
        int numchars;
        while ((numchars = in.read(buffer)) != -1) out.write(buffer, 0, numchars);
        // Close the streams
        in.close();
        out.close();
    } catch (IOException e) {
    }
}

{'htmlwriter'}
/**
   * This program creates a manifest file for the specified files, or verifies
   * an existing manifest file.  By default the manifest file is named
   * MANIFEST, but the -m option can be used to override this.  The -v
   * option specifies that the manifest should be verified.  Verification is
   * also the default option if no files are specified.
   **/
public static void main(String[] args) {
    try {
        // Set the default values of the command-line arguments
        // Verify manifest or create one?
        boolean verify = false;
        // Manifest file name
        String manifestfile = "MANIFEST";
        // Algorithm for message digests
        String digestAlgorithm = "MD5";
        // Signer.  No signature by default
        String signername = null;
        // Algorithm for digital signatures
        String signatureAlgorithm = "DSA";
        // The list of files to digest
        Vector filelist = new Vector();
        // Parse the command-line arguments, overriding the defaults above
        for (int i = 0; i < args.length; i++) {
            if (args[i].equals("-v"))
                verify = true;
            else if (args[i].equals("-m"))
                manifestfile = args[++i];
            else if (args[i].equals("-da") && !verify)
                digestAlgorithm = args[++i];
            else if (args[i].equals("-s") && !verify)
                signername = args[++i];
            else if (args[i].equals("-sa") && !verify)
                signatureAlgorithm = args[++i];
            else if (!verify)
                filelist.addElement(args[i]);
            else
                throw new IllegalArgumentException(args[i]);
        }
        // Otherwise, create a new manifest for the specified files
        if (verify || (filelist.size() == 0))
            verify(manifestfile);
        else
            create(manifestfile, digestAlgorithm, signername, signatureAlgorithm, filelist);
    }// If anything goes wrong, display the exception, and print a usage message
     catch (Exception e) {
        System.err.println("\n" + e);
        System.err.println("Usage: java Manifest [-v] [-m <manifestfile>]\n" + "   or: java Manifest " + "[-m <manifestfile>] [-da <digest algorithm>]\n" + "\t\t[-s <signer>] [-sa <signature algorithm>] " + "files...");
    }
}

{'given'}
/**
   * This method verifies the digital signature of the named manifest
   * file, if it has one, and if that verification succeeds, it verifies
   * the message digest of each file in filelist that is also named in the
   * manifest.  This method can throw a bunch of exceptions
   **/
public static void verify(String manifestfile) throws NoSuchAlgorithmException, SignatureException, InvalidKeyException, IOException {
    Properties manifest = new Properties();
    manifest.load(new FileInputStream(manifestfile));
    String digestAlgorithm = manifest.getProperty("__META.DIGESTALGORITHM");
    String signername = manifest.getProperty("__META.SIGNER");
    String signatureAlgorithm = manifest.getProperty("__META.SIGNATUREALGORITHM");
    String hexsignature = manifest.getProperty("__META.SIGNATURE");
    // Get a list of filenames in the manifest.  Use an Enumeration to
    // get them into a Vector, then allocate an array and copy them into that.
    Vector filelist = new Vector();
    Enumeration names = manifest.propertyNames();
    while (names.hasMoreElements()) {
        String s = (String) names.nextElement();
        if (!s.startsWith("__META"))
            filelist.addElement(s);
    }
    String[] files = new String[filelist.size()];
    filelist.copyInto(files);
    // verify that signature first
    if (signername != null) {
        System.out.print("Verifying digital signature...");
        System.out.flush();
        // To verify the signature, we must process the files in exactly the
        // same order we did when we created the signature.  We guarantee
        // this order by sorting the filenames.
        Sorter.sortAscii(files);
        // Get the Signer identity, create a Signature object, and initialize
        // it for signature verification, using the signer's public key
        Identity signer = (Identity) IdentityScope.getSystemScope().getIdentity(signername);
        Signature signature = Signature.getInstance(signatureAlgorithm);
        signature.initVerify(signer.getPublicKey());
        // verifying the signature as it was done when creating the signature.
        for (int i = 0; i < files.length; i++) {
            signature.update(files[i].getBytes());
            signature.update(hexDecode(manifest.getProperty(files[i])));
        }
        // is not verified, print an error message and exit.
        if (!signature.verify(hexDecode(hexsignature))) {
            System.out.println("\nManifest has an invalid digital signature");
            System.exit(0);
        }
        // Tell the user we're done with this lengthy computation
        System.out.println("verified.");
    }
    // Tell the user we're starting the next phase of verification
    System.out.print("Verifying file message digests");
    System.out.flush();
    // Get a MessageDigest object to compute digests
    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
    // Loop through all files
    for (int i = 0; i < files.length; i++) {
        // Look up the encoded digest from the manifest file
        String hexdigest = manifest.getProperty(files[i]);
        // Compute the digest for the file.
        byte[] digest;
        try {
            digest = getFileDigest(files[i], md);
        } catch (IOException e) {
            System.out.println("\nSkipping " + files[i] + ": " + e);
            continue;
        }
        // from the manifest.  If they are not equal, print an error message.
        if (!hexdigest.equals(hexEncode(digest)))
            System.out.println("\nFile '" + files[i] + "' failed verification.");
        // Send one dot of output for each file we process.  Since computing
        // message digests takes some time, this lets the user know that the
        // program is functioning and making progress
        System.out.print(".");
        System.out.flush();
    }
    // And tell the user we're done with verification.
    System.out.println("done.");
}

{'computed', 'sorted', 'important', 'messagedigest', 'known', 'contained', 'metadata', 'pas', 'compare', 'read'}
/**
   * This convenience method is used by both create() and verify().  It
   * reads the contents of a named file and computes a message digest
   * for it, using the specified MessageDigest object.
   **/
public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {
    // Make sure there is nothing left behind in the MessageDigest
    md.reset();
    // Create a stream to read from the file and compute the digest
    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);
    // the update() method of the MessageDigest
    while (in.read(buffer) != -1) /* do nothing */
    ;
    // Finally, compute and return the digest value.
    return md.digest();
}

{'everything', 'messagedigest', 'end', 'discarding', 'pass', 'digestinputstream', 'automatically'}
/** 
   * This constructor creates the frame, menubar, and scrollbar
   * that work along with the UnicodePanel class, defined below
   **/
public UnicodeDisplay(String name) {
    super(name);
    this.setLayout(new BorderLayout());
    // Create the panel
    p = new UnicodePanel();
    // Initialize it
    p.setBase((char) (page * 0x100));
    // Center it
    this.add(p, "Center");
    // Create and set up a scrollbar, and put it on the right
    b = new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 0xFF);
    b.setUnitIncrement(1);
    b.setBlockIncrement(0x10);
    b.addAdjustmentListener(new AdjustmentListener() {

        public void adjustmentValueChanged(AdjustmentEvent e) {
            page = e.getValue();
            p.setBase((char) (page * 0x100));
        }
    });
    this.add(b, "East");
    // Set things up so we respond to window close requests
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            UnicodeDisplay.this.dispose();
            System.exit(0);
        }
    });
    // Handle Page Up and Page Down and the up and down arrow keys
    this.addKeyListener(new KeyAdapter() {

        public void keyPressed(KeyEvent e) {
            int code = e.getKeyCode();
            int oldpage = page;
            if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {
                if (e.isShiftDown())
                    page -= 0x10;
                else
                    page -= 1;
                if (page < 0)
                    page = 0;
            } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {
                if (e.isShiftDown())
                    page += 0x10;
                else
                    page += 1;
                if (page > 0xff)
                    page = 0xff;
            }
            if (page != oldpage) {
                // if anything has changed...
                // update the display
                p.setBase((char) (page * 0x100));
                // and update scrollbar to match
                b.setValue(page);
            }
        }
    });
    // Set up a menu system to change fonts.  Use a convenience method.
    MenuBar menubar = new MenuBar();
    this.setMenuBar(menubar);
    menubar.add(makemenu("Font Family", new String[] { "Serif", "SansSerif", "Monospaced" }, this));
    menubar.add(makemenu("Font Style", new String[] { "Plain", "Italic", "Bold", "BoldItalic" }, this));
}

{'unicodepanel'}
/**
   * The constructor for this class has a bunch of arguments:  
   * The frame argument is required for all printing in Java.
   * The jobname appears left justified at the top of each printed page.
   * The font size is specified in points, as on-screen font sizes are.
   * The margins are specified in inches (or fractions of inches).
   **/
public HardcopyWriter(Frame frame, String jobname, int fontsize, double leftmargin, double rightmargin, double topmargin, double bottommargin) throws HardcopyWriter.PrintCanceledException {
    // Get the PrintJob object with which we'll do all the printing.
    // The call is synchronized on the static printprops object, which 
    // means that only one print dialog can be popped up at a time.
    // If the user clicks Cancel in the print dialog, throw an exception.
    // get Toolkit from Frame
    Toolkit toolkit = frame.getToolkit();
    synchronized (printprops) {
        job = toolkit.getPrintJob(frame, jobname, printprops);
    }
    if (job == null)
        throw new PrintCanceledException("User cancelled print request");
    // query the page size
    pagesize = job.getPageDimension();
    // query the page resolution
    pagedpi = job.getPageResolution();
    // we've got to fake them.
    if (System.getProperty("os.name").regionMatches(true, 0, "windows", 0, 7)) {
        // Use screen dpi, which is what the PrintJob tries to emulate, anyway
        pagedpi = toolkit.getScreenResolution();
        System.out.println(pagedpi);
        // Assume a 8.5" x 11" page size.  A4 paper users have to change this.
        pagesize = new Dimension((int) (8.5 * pagedpi), 11 * pagedpi);
        System.out.println(pagesize);
        // We also have to adjust the fontsize.  It is specified in points, 
        // (1 point = 1/72 of an inch) but Windows measures it in pixels.
        fontsize = fontsize * pagedpi / 72;
        System.out.println(fontsize);
        System.out.flush();
    }
    // Compute coordinates of the upper-left corner of the page.
    // I.e. the coordinates of (leftmargin, topmargin).  Also compute
    // the width and height inside of the margins.
    x0 = (int) (leftmargin * pagedpi);
    y0 = (int) (topmargin * pagedpi);
    width = pagesize.width - (int) ((leftmargin + rightmargin) * pagedpi);
    height = pagesize.height - (int) ((topmargin + bottommargin) * pagedpi);
    // Get body font and font size
    font = new Font("Monospaced", Font.PLAIN, fontsize);
    metrics = toolkit.getFontMetrics(font);
    lineheight = metrics.getHeight();
    lineascent = metrics.getAscent();
    // Assumes a monospaced font!
    charwidth = metrics.charWidth('0');
    // Now compute columns and lines will fit inside the margins
    chars_per_line = width / charwidth;
    lines_per_page = height / lineheight;
    // Get header font information
    // And compute baseline of page header: 1/8" above the top margin
    headerfont = new Font("SansSerif", Font.ITALIC, fontsize);
    headermetrics = toolkit.getFontMetrics(headerfont);
    headery = y0 - (int) (0.125 * pagedpi) - headermetrics.getHeight() + headermetrics.getAscent();
    // Compute the date/time string to display in the page header
    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT);
    df.setTimeZone(TimeZone.getDefault());
    time = df.format(new Date());
    // save name
    this.jobname = jobname;
    // save font size
    this.fontsize = fontsize;
}

{'bug', 'workaround', 'getpageresolution', 'printjob', 'work', 'getpagedimension'}
/**
   * This is the write() method of the stream.  All Writer subclasses 
   * implement this.  All other versions of write() are variants of this one
   **/
public void write(char[] buffer, int index, int len) {
    synchronized (this.lock) {
        // Loop through all the characters passed to us
        for (int i = index; i < index + len; i++) {
            // If we haven't begun a page (or a new page), do that now.
            if (page == null)
                newpage();
            // unless it is a \n immediately after a \r.
            if (buffer[i] == '\n') {
                if (!last_char_was_return)
                    newline();
                continue;
            }
            if (buffer[i] == '\r') {
                newline();
                last_char_was_return = true;
                continue;
            } else
                last_char_was_return = false;
            // If it some other non-printing character, ignore it.
            if (Character.isWhitespace(buffer[i]) && !Character.isSpaceChar(buffer[i]) && (buffer[i] != '\t'))
                continue;
            // If no more characters will fit on the line, start a new line.
            if (charnum >= chars_per_line) {
                newline();
                // and start a new page, if necessary
                if (page == null)
                    newpage();
            }
            // printer uses we need to position each character individually.
            if (Character.isSpaceChar(buffer[i]))
                charnum++;
            else if (buffer[i] == '\t')
                charnum += 8 - (charnum % 8);
            else {
                page.drawChars(buffer, i, 1, x0 + charnum * charwidth, y0 + (linenum * lineheight) + lineascent);
                charnum++;
            }
        }
    }
}

{'inefficient', 'number', 'otherwise', 'fontmetrics', 'tab', 'match', 'time', 'without', 'begin', 'skip', 'terminator', 'output', 'print', 'exactly'}
/** 
   * This is the flush() method that all Writer subclasses must implement.
   * There is no way to flush a PrintJob without prematurely printing the
   * page, so we don't do anything.
   **/
public void flush() {
/* do nothing */
}

{'printjob'}
/**
   * This is the close() method that all Writer subclasses must implement.
   * Print the pending page (if any) and terminate the PrintJob.
   */
public void close() {
    synchronized (this.lock) {
        // Send page to the printer
        if (page != null)
            page.dispose();
        // Terminate the job
        job.end();
    }
}

{'printjob'}
/** Print the demo page */
public void printDemoPage() {
    // Create the HardcopyWriter, using a 10 point font and 3/4" margins.
    HardcopyWriter hw;
    try {
        hw = new HardcopyWriter(this, "Demo Page", 14, .75, .75, .75, .75);
    } catch (HardcopyWriter.PrintCanceledException e) {
        return;
    }
    // Send output to it through a PrintWriter stream
    PrintWriter out = new PrintWriter(hw);
    // Figure out the size of the page
    int rows = hw.getLinesPerPage(), cols = hw.getCharactersPerLine();
    // Mark upper left and upper-right corners
    out.print("+");
    for (int i = 0; i < cols - 2; i++) out.print(" ");
    out.print("+");
    // Display a title
    hw.setFontStyle(Font.BOLD + Font.ITALIC);
    out.println("\n\n\n\t\tHardcopy Writer Demo Page\n\n\n\n\n");
    // Demonstrate font styles
    hw.setFontStyle(Font.BOLD);
    out.println("Font Styles:");
    int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC, Font.ITALIC + Font.BOLD };
    for (int i = 0; i < styles.length; i++) {
        hw.setFontStyle(styles[i]);
        out.println("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
        out.println("1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\`'\"_~|");
    }
    hw.setFontStyle(Font.PLAIN);
    out.println("\n\n");
    // Demonstrate tab stops
    hw.setFontStyle(Font.BOLD);
    out.println("Tab Stops:");
    hw.setFontStyle(Font.PLAIN);
    out.println("          1         2         3         4         5");
    out.println("01234567890123456789012345678901234567890123456789012345");
    out.println("^\t^\t^\t^\t^\t^\t^");
    out.println("\n\n");
    // Output some information about page dimensions and resolution
    hw.setFontStyle(Font.BOLD);
    out.println("Dimensions:");
    hw.setFontStyle(Font.PLAIN);
    out.println("\tResolution: " + hw.pagedpi + " dots per inch");
    out.println("\tPage width (pixels): " + hw.pagesize.width);
    out.println("\tPage height (pixels): " + hw.pagesize.height);
    out.println("\tWidth inside margins (pixels): " + hw.width);
    out.println("\tHeight inside margins (pixels): " + hw.height);
    out.println("\tCharacters per line: " + cols);
    out.println("\tLines per page: " + rows);
    // Skip down to the bottom of the page
    for (int i = 0; i < rows - 37; i++) out.println();
    // And mark the lower left and lower right
    out.print("+");
    for (int i = 0; i < cols - 2; i++) out.print(" ");
    out.print("+");
    // Close the output stream, forcing the page to be printed
    out.close();
}

{'printwriter', 'hardcopywriter'}
/**
   * This method is called by a layout manager when it wants to
   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is
   * the preferred version of this method.  We use this deprecated version
   * so that this component can interoperate with 1.0 components.
   */
public Dimension preferredSize() {
    if (!measured)
        measure();
    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);
}

{'getpreferredsize'}
/**
   * This method is called when the layout manager wants to know
   * the bare minimum amount of space we need to get by.
   * For Java 1.1, we'd use getMinimumSize().
   */
public Dimension minimumSize() {
    return preferredSize();
}

{'getminimumsize'}
/**
   * This method draws the label (same method that applets use).
   * Note that it handles the margins and the alignment, but that
   * it doesn't have to worry about the color or font--the superclass
   * takes care of setting those in the Graphics object we're passed.
   */
public void paint(Graphics g) {
    int x, y;
    // use getSize() in Java 1.1
    Dimension size = this.size();
    if (!measured)
        measure();
    y = line_ascent + (size.height - num_lines * line_height) / 2;
    for (int i = 0; i < num_lines; i++, y += line_height) {
        switch(alignment) {
            default:
            case LEFT:
                x = margin_width;
                break;
            case CENTER:
                x = (size.width - line_widths[i]) / 2;
                break;
            case RIGHT:
                x = size.width - margin_width - line_widths[i];
                break;
        }
        g.drawString(lines[i], x, y);
    }
}

{'getsize'}
/** This internal method breaks a specified label up into an array of lines.
   *  It uses the StringTokenizer utility class. */
protected synchronized void newLabel() {
    StringTokenizer t = new StringTokenizer(label, "\n");
    num_lines = t.countTokens();
    lines = new String[num_lines];
    line_widths = new int[num_lines];
    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();
}

{'stringtokenizer'}
/**
   * This is the filter: call our superclass's readLine() to get the
   * actual lines, but only return lines that contain the pattern.
   * When the superclass readLine() returns null (EOF), we return null.
   **/
public final String readLine() throws IOException {
    String line;
    do {
        line = super.readLine();
    } while ((line != null) && line.indexOf(pattern) == -1);
    return line;
}

{'readline'}
// Default constructor: YesNoDialogCustomizer() { super(); }
// The bean box calls this method to tell us what object to customize.
// This method will always be called before the customizer is displayed,
// so it is safe to create the customizer GUI here.
public void setObject(Object o) {
    // save the object we're customizing
    bean = (YesNoDialog) o;
    // Put a label at the top of the panel.
    this.setLayout(new BorderLayout());
    this.add(new Label("Enter the message to appear in the dialog:"), "North");
    // And a big text area below it for entering the dialog message.
    message = new TextArea(bean.getMessage());
    message.addTextListener(this);
    // TextAreas don't know how big they want to be.  You must tell them.
    message.setSize(400, 200);
    this.add(message, "Center");
    // Then add a row of textfields for entering the button labels.
    // The row container
    Panel buttonbox = new Panel();
    // Equally spaced items
    buttonbox.setLayout(new GridLayout(1, 0, 25, 10));
    // Put row on bottom
    this.add(buttonbox, "South");
    // Now go create three TextFields to put in this row.  But actually
    // position a Label above each, so create an container for each
    // TextField+Label combination.
    // Array of TextFields.
    fields = new TextComponent[3];
    String[] labels = new String[] { // Labels for each.
    "Yes Button Label", "No Button Label", "Cancel Button Label" };
    String[] values = new String[] { // Initial values of each.
    bean.getYesLabel(), bean.getNoLabel(), bean.getCancelLabel() };
    for (int i = 0; i < 3; i++) {
        // Create a container.
        Panel p = new Panel();
        // Give it a BorderLayout.
        p.setLayout(new BorderLayout());
        // Put a label on the top.
        p.add(new Label(labels[i]), "North");
        // Create the text field.
        fields[i] = new TextField(values[i]);
        // Put it below the label.
        p.add(fields[i], "Center");
        // Set the event listener.
        fields[i].addTextListener(this);
        // Add container to row.
        buttonbox.add(p);
    }
}

{'textfield', 'borderlayout', 'textareas'}
/** This is a convenience routine for creating PropertyDescriptor objects */
public static PropertyDescriptor property(String name, String description) throws IntrospectionException {
    PropertyDescriptor p = new PropertyDescriptor(name, YesNoDialog.class);
    p.setShortDescription(description);
    return p;
}

{'propertydescriptor'}
/** This method returns an array of PropertyDescriptor objects that specify
   *  additional information about the properties supported by the bean.
   *  By explicitly specifying property descriptors, we are able to provide
   *  simple help strings for each property; these would not be available to
   *  the beanbox through simple introspection.  We are also able to register
   *  special property editors for two of the properties
   */
public PropertyDescriptor[] getPropertyDescriptors() {
    try {
        PropertyDescriptor[] props = { property("title", "The string that appears in the dialog title bar"), property("message", "The string that appears in the dialog body"), property("yesLabel", "The label for the 'Yes' button, if any"), property("noLabel", "The label for the 'No' button, if any"), property("cancelLabel", "The label for the 'Cancel' button, if any"), property("alignment", "The alignment of the message text"), property("font", "The font to use for message and buttons"), property("background", "The background color for the dialog"), property("foreground", "The text color for message and buttons") };
        props[1].setPropertyEditorClass(YesNoDialogMessageEditor.class);
        props[5].setPropertyEditorClass(YesNoDialogAlignmentEditor.class);
        return props;
    } catch (IntrospectionException e) {
        return super.getPropertyDescriptors();
    }
}

{'propertydescriptor'}
/** This is a convenience method for creating MethodDescriptors.  Note that
   *  it assumes we are talking about methods with no arguments */
public static MethodDescriptor method(String name, String description) throws NoSuchMethodException, SecurityException {
    Method m = YesNoDialog.class.getMethod(name, new Class[] {});
    MethodDescriptor md = new MethodDescriptor(m);
    md.setShortDescription(description);
    return md;
}

{'methoddescriptors'}
/** This method makes the bean display the dialog box */
public void display() {
    // Create a frame with the specified title.  It would be nice to
    // use a Dialog, but that needs to be passed a Frame argument, and
    // the BDK beanbox tool only seems to work with no-argument methods.
    final Frame frame = new Frame(title);
    // Specify a LayoutManager for it.
    frame.setLayout(new BorderLayout(15, 15));
    // Specify font and colors, if any are specified.
    if (font != null)
        frame.setFont(font);
    if (background != null)
        frame.setBackground(background);
    if (foreground != null)
        frame.setForeground(foreground);
    // Put the message label in the middle of the window.
    frame.add("Center", new MultiLineLabel(message, 20, 20, alignment));
    // Create an action listener for use by the buttons of the dialog.
    // When a button is pressed, this listener first closes the dialog box.
    // Then, it creates an AnswerEvent object that corresponds to the
    // button that was pressed, and send that new event to all registered
    // listeners, using the fireEvent() method defined above.
    ActionListener listener = new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            // pop down window
            frame.dispose();
            if (listeners != null) {
                // notify any registered listeners
                String cmd = e.getActionCommand();
                int type;
                if (cmd.equals("yes"))
                    type = AnswerEvent.YES;
                else if (cmd.equals("no"))
                    type = AnswerEvent.NO;
                else
                    type = AnswerEvent.CANCEL;
                fireEvent(new AnswerEvent(YesNoDialog.this, type));
            }
        }
    };
    // Create a panel for the dialog buttons and put it at the bottom
    // of the dialog.  Specify a FlowLayout layout manager for it.
    Panel buttonbox = new Panel();
    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));
    frame.add("South", buttonbox);
    // and action command for each, and adding them to the buttonbox
    if ((yesLabel != null) && (yesLabel.length() > 0)) {
        // Create button.
        Button yes = new Button(yesLabel);
        // Set action command.
        yes.setActionCommand("yes");
        // Set listener.
        yes.addActionListener(listener);
        // Add button to the panel.
        buttonbox.add(yes);
    }
    if ((noLabel != null) && (noLabel.length() > 0)) {
        Button no = new Button(noLabel);
        no.setActionCommand("no");
        no.addActionListener(listener);
        buttonbox.add(no);
    }
    if ((cancelLabel != null) && (cancelLabel.length() > 0)) {
        Button cancel = new Button(cancelLabel);
        cancel.setActionCommand("cancel");
        cancel.addActionListener(listener);
        buttonbox.add(cancel);
    }
    // Finally, set the dialog to its preferred size and display it.
    frame.pack();
    frame.show();
}

{'flowlayout', 'answerevent', 'fireevent', 'layoutmanager', 'specifying'}
/**
   * A main method that demonstrates how to use this class, and allows testing
   */
public static void main(String[] args) {
    // Create an instance of InfoDialog, with title and message specified:
    YesNoDialog d = new YesNoDialog("YesNoDialog Test", "There are unsaved files.\n" + "Do you want to save them before quitting?", "Yes, save and quit", "No, quit without saving", "Cancel; don't quit", YesNoDialog.CENTER);
    // Register an action listener for the dialog.  This one just prints
    // the results out to the console.
    d.addAnswerListener(new AnswerListener() {

        public void yes(AnswerEvent e) {
            System.out.println("Yes");
        }

        public void no(AnswerEvent e) {
            System.out.println("No");
        }

        public void cancel(AnswerEvent e) {
            System.out.println("Cancel");
        }
    });
    // Now pop the dialog up.  It will pop itself down automatically.
    d.display();
}

{'infodialog'}
/**
   * This method is called by a layout manager when it wants to
   * know how big we'd like to be.  In Java 1.1, getPreferredSize() is
   * the preferred version of this method.  We use this deprecated version
   * so that this component can interoperate with 1.0 components.
   */
public Dimension preferredSize() {
    if (!measured)
        measure();
    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);
}

{'getpreferredsize'}
/**
   * This method is called when the layout manager wants to know
   * the bare minimum amount of space we need to get by.
   * For Java 1.1, we'd use getMinimumSize().
   */
public Dimension minimumSize() {
    return preferredSize();
}

{'getminimumsize'}
/**
   * This method draws the label (same method that applets use).
   * Note that it handles the margins and the alignment, but that
   * it doesn't have to worry about the color or font--the superclass
   * takes care of setting those in the Graphics object we're passed.
   */
public void paint(Graphics g) {
    int x, y;
    // use getSize() in Java 1.1
    Dimension size = this.size();
    if (!measured)
        measure();
    y = line_ascent + (size.height - num_lines * line_height) / 2;
    for (int i = 0; i < num_lines; i++, y += line_height) {
        switch(alignment) {
            default:
            case LEFT:
                x = margin_width;
                break;
            case CENTER:
                x = (size.width - line_widths[i]) / 2;
                break;
            case RIGHT:
                x = size.width - margin_width - line_widths[i];
                break;
        }
        g.drawString(lines[i], x, y);
    }
}

{'getsize'}
/** This internal method breaks a specified label up into an array of lines.
   *  It uses the StringTokenizer utility class. */
protected synchronized void newLabel() {
    StringTokenizer t = new StringTokenizer(label, "\n");
    num_lines = t.countTokens();
    lines = new String[num_lines];
    line_widths = new int[num_lines];
    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();
}

{'stringtokenizer'}
// Return the custom editor.  This just creates and returns a TextArea
// to edit the multi-line text.  But it also registers a listener on the
// text area to update the value as the user types and to fire the
// property change events that property editors are required to fire.
public Component getCustomEditor() {
    final TextArea t = new TextArea(value);
    // TextArea doesn't have a preferred size, so set one
    t.setSize(300, 150);
    t.addTextListener(new TextListener() {

        public void textValueChanged(TextEvent e) {
            value = t.getText();
            listeners.firePropertyChange(null, null, null);
        }
    });
    return t;
}

{'textarea'}
/** Zip the contents of the directory, and save it in the zipfile */
public static void zipDirectory(String dir, String zipfile) throws IOException, IllegalArgumentException {
    // Check that the directory is a directory, and get its contents
    File d = new File(dir);
    if (!d.isDirectory())
        throw new IllegalArgumentException("Compress: not a directory:  " + dir);
    String[] entries = d.list();
    // Create a buffer for copying 
    byte[] buffer = new byte[4096];
    int bytes_read;
    // Create a stream to compress data and write it to the zipfile
    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile));
    // Loop through all entries in the directory
    for (int i = 0; i < entries.length; i++) {
        File f = new File(d, entries[i]);
        // Don't zip sub-directories
        if (f.isDirectory())
            continue;
        // Stream to read file
        FileInputStream in = new FileInputStream(f);
        // Make a ZipEntry
        ZipEntry entry = new ZipEntry(f.getPath());
        // Store entry in zipfile
        out.putNextEntry(entry);
        while (// Copy bytes to zipfile
        (bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);
        // Close input stream
        in.close();
    }
    // When we're done with the whole loop, close the output stream
    out.close();
}

{'zipentry'}
public static void main(String[] args) {
    // We will compute all primes less than the supplied command line argument
    // Or, if no argument, all primes less than 100
    // Assign a default value
    int max = 100;
    try // Try to parse user-supplied arg
    {
        max = Integer.parseInt(args[0]);
    }// Silently ignore exceptions.
     catch (Exception e) {
    }
    // Create an array that specifies whether each number is prime or not.
    boolean[] isprime = new boolean[max + 1];
    // Assume that all numbers are primes, until proven otherwise.
    for (int i = 0; i <= max; i++) isprime[i] = true;
    // However, we know that 0 and 1 are not primes.  Make a note of it.
    isprime[0] = isprime[1] = false;
    // To compute all primes less than max, we need to rule out
    // multiples of all integers less than the square root of max.
    // See java.lang.Math class
    int n = (int) Math.ceil(Math.sqrt(max));
    //   ruled out by one of the prime factors of i, so we can skip this case.
    for (int i = 0; i <= n; i++) {
        if (// If i is a prime, 
        isprime[i])
            for (// loop through its multiples
            int j = 2 * i; // loop through its multiples
            j <= max; // loop through its multiples
            j = j + i) // noting they are not prime.
            isprime[j] = false;
    }
    // Now go look for the largest prime:
    int largest;
    // empty loop body
    for (largest = max; !isprime[largest]; largest--) ;
    // Output the result
    System.out.println("The largest prime less than or equal to " + max + " is " + largest);
}

{'indicate', 'already', 'none'}
/**
   * This is the Server() constructor.  It must be passed a stream 
   * to send log output to (may be null), and the limit on the number of
   * concurrent connections.  It creates and starts a ConnectionManager 
   * thread which enforces this limit on connections.
   **/
public Server(OutputStream logStream, int maxConnections) {
    setLogStream(logStream);
    log("Starting server");
    threadGroup = new ThreadGroup("Server");
    connectionManager = new ConnectionManager(threadGroup, maxConnections);
    connectionManager.start();
    services = new Hashtable();
}

{'connectionmanager'}
/**
     * The Listener constructor creates a thread for itself in the specified
     * threadgroup.  It creates a ServerSocket to listen for connections
     * on the specified port.  It arranges for the ServerSocket to be
     * interruptible, so that services can be removed from the server.
     **/
public Listener(ThreadGroup group, int port, Service service) throws IOException {
    super(group, "Listener:" + port);
    listen_socket = new ServerSocket(port);
    // give the socket a non-zero timeout so accept() can be interrupted
    listen_socket.setSoTimeout(600000);
    this.port = port;
    this.service = service;
}

{'serversocket'}
/**
     * A Listener is a Thread, and this is its body.
     * Wait for connection requests, accept them, and pass the socket on
     * to the ConnectionManager object of this server
     **/
public void run() {
    while (!stop) {
        // loop until we're asked to stop.
        try {
            Socket client = listen_socket.accept();
            connectionManager.addConnection(client, service);
        } catch (InterruptedIOException e) {
        } catch (IOException e) {
            log(e);
        }
    }
}

{'connectionmanager'}
/** 
     * Create a ConnectionManager in the specified thread group to enforce
     * the specified maximum connection limit.  Make it a daemon thread so
     * the interpreter won't wait around for it to exit.
     **/
public ConnectionManager(ThreadGroup group, int maxConnections) {
    super(group, "ConnectionManager");
    this.setDaemon(true);
    this.maxConnections = maxConnections;
    connections = new Vector(maxConnections);
    log("Starting connection manager.  Max connections: " + maxConnections);
}

{'connectionmanager'}
/**
     * A Connection object calls this method just before it exits.
     * This method uses notify() to tell the ConnectionManager thread
     * to wake up and delete the thread that has exited.
     **/
public synchronized void endConnection() {
    this.notify();
}

{'connectionmanager'}
/**
     * The ConnectionManager is a thread, and this is the body of that
     * thread.  While the ConnectionManager methods above are called by other
     * threads, this method is run in its own thread.  The job of this thread
     * is to keep the list of connections up to date by removing connections
     * that are no longer alive.  It uses wait() to block until notify()'d by
     * the endConnection() method.
     **/
public void run() {
    while (true) {
        // Check through the list of connections, removing dead ones
        for (int i = 0; i < connections.size(); i++) {
            Connection c = (Connection) connections.elementAt(i);
            if (!c.isAlive()) {
                connections.removeElementAt(i);
                log("Connection to " + c.client.getInetAddress().getHostAddress() + ":" + c.client.getPort() + " closed.");
            }
        }
        // When we wake up we'll check the list of connections again.
        try {
            synchronized (this) {
                this.wait();
            }
        } catch (InterruptedException e) {
        }
    }
}

{'endconnection', 'connectionmanager', 'infinite', 'exited', 'loop'}
/**
     * This constructor just saves some state and calls the superclass
     * constructor to create a thread to handle the connection.  Connection
     * objects are created by Listener threads.  These threads are part of
     * the server's ThreadGroup, so all Connection threads are part of that
     * group, too.
     **/
public Connection(Socket client, Service service) {
    super("Server.Connection:" + client.getInetAddress().getHostAddress() + ":" + client.getPort());
    this.client = client;
    this.service = service;
}

{'threadgroup'}
/**
     * This is the body of each and every Connection thread.
     * All it does is pass the client input and output streams to the 
     * serve() method of the specified Service object.  That method
     * is responsible for reading from and writing to those streams to
     * provide the actual service.  Recall that the Service object has been
     * passed from the Server.addService() method to a Listener object
     * to the ConnectionManager.addConnection() to this Connection object,
     * and is now finally getting used to provide the service.
     * Note that just before this thread exits it calls the 
     * ConnectionManager.endConnection() method to wake up the 
     * ConnectionManager thread so that it can remove this Connection
     * from its list of active connections.
     **/
public void run() {
    try {
        InputStream in = client.getInputStream();
        OutputStream out = client.getOutputStream();
        service.serve(in, out);
    } catch (IOException e) {
        log(e);
    } finally {
        connectionManager.endConnection();
    }
}

{'endconnection', 'connectionmanager', 'addservice', 'addconnection'}
/**
     * This is the serve method that provides the service.  It reads a line 
     * the client, and uses java.util.StringTokenizer to parse it into
     * commands and arguments.  It does various things depending on the 
     * command.
     **/
public void serve(InputStream i, OutputStream o) throws IOException {
    // Setup the streams
    BufferedReader in = new BufferedReader(new InputStreamReader(i));
    PrintWriter out = new PrintWriter(new OutputStreamWriter(o));
    String line;
    // Has the user has given the password yet?
    boolean authorized = false;
    int num;
    // synchronized block to prevent a race condition.
    synchronized (this) {
        if (connected) {
            out.println("ONLY ONE CONTROL CONNECTION ALLOWED AT A TIME.");
            out.close();
            return;
        } else
            connected = true;
    }
    for (; ; ) {
        // infinite loop
        // Display a prompt
        out.print("> ");
        // Make it appear right away
        out.flush();
        // Get the user's input
        line = in.readLine();
        // Quit if we get EOF.
        if (line == null)
            break;
        try {
            // Use a StringTokenizer to parse the user's command
            StringTokenizer t = new StringTokenizer(line);
            // if input was blank line
            if (!t.hasMoreTokens())
                continue;
            // Get the first word of the input and convert to lower case
            String command = t.nextToken().toLowerCase();
            // appropriate thing for each command
            if (command.equals("password")) {
                // Password command
                // Get the next word of input
                String p = t.nextToken();
                if (p.equals(this.password)) {
                    // Does it equal the password
                    // Say so
                    out.println("OK");
                    // Grant authorization
                    authorized = true;
                } else
                    // Otherwise fail
                    out.println("INVALID PASSWORD");
            } else if (command.equals("add")) {
                // Check whether password has been given
                if (!authorized)
                    out.println("PASSWORD REQUIRED");
                else {
                    // Get the name of the service and try to dynamically load
                    // and instantiate it.  Exceptions will be handled below
                    String serviceName = t.nextToken();
                    Class serviceClass = Class.forName(serviceName);
                    Service service;
                    try {
                        service = (Service) serviceClass.newInstance();
                    } catch (NoSuchMethodError e) {
                        throw new IllegalArgumentException("Service must have a " + "no-argument constructor");
                    }
                    int port = Integer.parseInt(t.nextToken());
                    // If no exceptions occurred, add the service
                    server.addService(service, port);
                    // acknowledge
                    out.println("SERVICE ADDED");
                }
            } else if (command.equals("remove")) {
                // Remove service command
                if (!authorized)
                    out.println("PASSWORD REQUIRED");
                else {
                    // get port
                    int port = Integer.parseInt(t.nextToken());
                    // remove the service on it
                    server.removeService(port);
                    // acknowledge
                    out.println("SERVICE REMOVED");
                }
            } else if (command.equals("max")) {
                // Set max connection limit
                if (!authorized)
                    out.println("PASSWORD REQUIRED");
                else {
                    // get limit
                    int max = Integer.parseInt(t.nextToken());
                    // set limit
                    server.connectionManager.setMaxConnections(max);
                    // acknowledge
                    out.println("MAX CONNECTIONS CHANGED");
                }
            } else if (command.equals("status")) {
                // Status Display command
                if (!authorized)
                    out.println("PASSWORD REQUIRED");
                else {
                    // Display a list of all services currently running
                    Enumeration keys = server.services.keys();
                    while (keys.hasMoreElements()) {
                        Integer port = (Integer) keys.nextElement();
                        Listener listener = (Listener) server.services.get(port);
                        out.println("SERVICE " + listener.service.getClass().getName() + " ON PORT " + port);
                    }
                    // Display a list of all current connections
                    server.connectionManager.printConnections(out);
                    // Display the current connection limit
                    out.println("MAX CONNECTIONS: " + server.connectionManager.maxConnections);
                }
            } else if (command.equals("help")) {
                // Help command
                // Display command syntax.  Password not required
                out.println("COMMANDS:\n" + "\tpassword <password>\n" + "\tadd <service> <port>\n" + "\tremove <port>\n" + "\tmax <max-connections>\n" + "\tstatus\n" + "\thelp\n" + "\tquit");
            } else if (// Quit command.  Exit.
            command.equals("quit"))
                // Quit command.  Exit.
                break;
            else
                // Unknown command error
                out.println("UNRECOGNIZED COMMAND");
        } catch (Exception e) {
            out.println("EXCEPTION WHILE PARSING OR EXECUTING COMMAND:");
            out.println(e);
        }
    }
    // Finally, when the loop command loop ends, close the streams
    // and set our connected flag to false so that other clients can
    // now connect.
    out.close();
    in.close();
    connected = false;
}

{'detail', 'stringtokenizer', 'possible', 'already', 'compare', 'message'}
public static void main(String[] args) {
    // Our JDBC connection to the database server
    Connection conn = null;
    try {
        String driver = null, url = null, user = "", password = "";
        // Parse all the command-line arguments
        for (int n = 0; n < args.length; n++) {
            if (args[n].equals("-d"))
                driver = args[++n];
            else if (args[n].equals("-u"))
                user = args[++n];
            else if (args[n].equals("-p"))
                password = args[++n];
            else if (url == null)
                url = args[n];
            else
                throw new IllegalArgumentException("Unknown argument.");
        }
        // The only required argument is the database URL.
        if (url == null)
            throw new IllegalArgumentException("No database specified");
        // to register itself with the DriverManager.
        if (driver != null)
            Class.forName(driver);
        // Now open a connection the specified database, using the user-specified
        // username and password, if any.  The driver manager will try all of
        // the DB drivers it knows about to try to parse the URL and connect to
        // the DB server.
        conn = DriverManager.getConnection(url, user, password);
        // Now create the statement object we'll use to talk to the DB
        Statement s = conn.createStatement();
        // Get a stream to read from the console
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        // Loop forever, reading the user's queries and executing them
        while (true) {
            // prompt the user
            System.out.print("sql> ");
            // make the prompt appear immediately
            System.out.flush();
            // get a line of input from the user
            String sql = in.readLine();
            // Quit when the user types "quit".
            if ((sql == null) || sql.equals("quit"))
                break;
            // Ignore blank lines
            if (sql.length() == 0)
                continue;
            // Now, attempt to execute the user's line of SQL and display results.
            try {
                // We don't know if this is a query or some kind of update, so we
                // use execute() instead of executeQuery() or executeUpdate()
                // If the return value is true, it was a query, else an update
                boolean status = s.execute(sql);
                // Loop until there are no more results to return
                do {
                    if (status) {
                        // statement was a query that returns a ResultSet
                        // Get the set of results and display them
                        ResultSet rs = s.getResultSet();
                        printResultsTable(rs, System.out);
                    } else {
                        // If the SQL command that was executed was some kind of update
                        // rather than a query, then it doesn't return a ResultSet.
                        // Instead, we just print the number of rows that were affected.
                        int numUpdates = s.getUpdateCount();
                        System.out.println("Ok. " + numUpdates + " rows affected.");
                    }
                    // Now go see if there are even more results, and
                    // continue the results display loop if there are.
                    status = s.getMoreResults();
                // With some buggy JDBC drivers, this condition causes an infinite
                // loop with SQL updates. If that happens, change to: while(status); 
                } while (status || s.getUpdateCount() != -1);
            }// returned by getSQLState()
             catch (SQLException e) {
                System.err.println("SQLException: " + e.getMessage() + ":" + e.getSQLState());
            } finally // Each time through this loop, check to see if any warnings were
            // issued.  Note that there can be a whole chain of warnings.
            {
                // print out any warnings that occurred
                for (SQLWarning w = conn.getWarnings(); w != null; w = w.getNextWarning()) System.err.println("WARNING: " + w.getMessage() + ":" + w.getSQLState());
            }
        }
    }// connection setup, etc.  For SQLExceptions, print the details.
     catch (Exception e) {
        System.err.println(e);
        if (e instanceof SQLException)
            System.err.println("SQL State: " + ((SQLException) e).getSQLState());
        System.err.println("Usage: java ExecuteSQL [-d <driver>] [-u <user>] " + "[-p <password>] <database URL>");
    } finally // Be sure to always close the database connection when we exit, whether
    // we exit because the user types 'quit' or because of an exception thrown
    // while setting things up.  Closing this connection also implicitly
    // closes any open statements and result sets associated with it.
    {
        try {
            conn.close();
        } catch (Exception e) {
        }
    }
}

{'sqlexception', 'parsing', 'sqlexceptions', 'error', 'executeupdate', 'give', 'load', 'handle', 'classname', 'drivermanager', 'occur', 'resultset', 'general', 'executequery', 'opportunity', 'specific', 'dynamically', 'getsqlstate'}
/**
   * This method attempts to output the contents of a ResultSet in a 
   * textual table.  It relies on the ResultSetMetaData class, but a fair
   * bit of the code is simple string manipulation.
   **/
static void printResultsTable(ResultSet rs, OutputStream output) throws SQLException {
    // Set up the output stream
    PrintWriter out = new PrintWriter(new OutputStreamWriter(output));
    // Get some "meta data" (column names, etc.) about the results
    ResultSetMetaData metadata = rs.getMetaData();
    // Variables to hold important data about the table to be displayed
    // how many columns
    int numcols = metadata.getColumnCount();
    // the column labels
    String[] labels = new String[numcols];
    // the width of each
    int[] colwidths = new int[numcols];
    // start position of each
    int[] colpos = new int[numcols];
    // total width of table
    int linewidth;
    // Figure out how wide the columns are, where each one begins, 
    // how wide each row of the table will be, etc.
    // for the initial '|'.
    linewidth = 1;
    for (int i = 0; i < numcols; i++) {
        // for each column
        // save its position
        colpos[i] = linewidth;
        // get its label 
        labels[i] = metadata.getColumnLabel(i + 1);
        // Get the column width.  If the db doesn't report one, guess
        // 30 characters.  Then check the length of the label, and use
        // it if it is larger than the column width
        int size = metadata.getColumnDisplaySize(i + 1);
        // some drivers return -1...
        if (size == -1)
            size = 30;
        int labelsize = labels[i].length();
        if (labelsize > size)
            size = labelsize;
        // save the column the size  
        colwidths[i] = size + 1;
        // increment total size
        linewidth += colwidths[i] + 2;
    }
    // Create a horizontal divider line we use in the table.
    // Also create a blank line that is the initial value of each 
    // line of the table
    StringBuffer divider = new StringBuffer(linewidth);
    StringBuffer blankline = new StringBuffer(linewidth);
    for (int i = 0; i < linewidth; i++) {
        divider.insert(i, '-');
        blankline.insert(i, " ");
    }
    // Put special marks in the divider line at the column positions
    for (int i = 0; i < numcols; i++) divider.setCharAt(colpos[i] - 1, '+');
    divider.setCharAt(linewidth - 1, '+');
    // Begin the table output with a divider line
    out.println(divider);
    // The next line of the table contains the column labels.
    // Begin with a blank line, and put the column names and column
    // divider characters "|" into it.  overwrite() is defined below.
    StringBuffer line = new StringBuffer(blankline.toString());
    line.setCharAt(0, '|');
    for (int i = 0; i < numcols; i++) {
        int pos = colpos[i] + 1 + (colwidths[i] - labels[i].length()) / 2;
        overwrite(line, pos, labels[i]);
        overwrite(line, colpos[i] + colwidths[i], " |");
    }
    // Then output the line of column labels and another divider
    out.println(line);
    out.println(divider);
    // we did for the column labels above.
    while (rs.next()) {
        line = new StringBuffer(blankline.toString());
        line.setCharAt(0, '|');
        for (int i = 0; i < numcols; i++) {
            Object value = rs.getObject(i + 1);
            overwrite(line, colpos[i] + 1, value.toString().trim());
            overwrite(line, colpos[i] + colwidths[i], " |");
        }
        out.println(line);
    }
    // Finally, end the table with one last divider line.
    out.println(divider);
    out.flush();
}

{'resultsetmetadata', 'getobject', 'time', 'loop', 'obtain', 'much', 'resultset', 'using'}
/** Same as getBounds(), but with floating-point coordinates */
public Rectangle2D getBounds2D() {
    return new Rectangle2D.Double(centerX - outerRadius, centerY - outerRadius, outerRadius * 2, outerRadius * 2);
}

{'getbounds'}
/**
     * This method is the heart of all Shape implementations.  It returns a
     * PathIterator that describes the shape in terms of the line and curve
     * segments that comprise it.  Our iterator implementation approximates
     * the shape of the spiral using line segments only.  We pass in a
     * "flatness" argument that tells it how good the approximation must be.
     * (smaller numbers mean a better approximation).
     */
public PathIterator getPathIterator(AffineTransform at) {
    return new SpiralIterator(at, outerRadius / 500.0);
}

{'pathiterator'}
/**
     * Return a PathIterator that describes the shape in terms of line
     * segments only, with an approximation quality specified by flatness.
     **/
public PathIterator getPathIterator(AffineTransform at, double flatness) {
    return new SpiralIterator(at, flatness);
}

{'pathiterator'}
/** 
	 * All PathIterators have a "winding rule" that helps to specify what
	 * is the inside of a area and what is the outside.  If you fill a
	 * spiral (which you're not supposed to do) the winding rule returned
	 * here yields better results than the alternative, WIND_EVEN_ODD
	 **/
public int getWindingRule() {
    return WIND_NON_ZERO;
}

{'pathiterators'}
/** This is the main Paint method;  all it does is return a PaintContext */
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {
    return new RandomPaintContext();
}

{'paintcontext'}
/**
	 * This is the main method of PaintContext.  It must return a Raster
	 * that contains fill data for the specified rectangle.  For this 
	 * implementation, we just fill with a random solid color each time.
	 * Instead of setting pixels at the Raster level, we instead 
	 * manipulate a BufferedImage using the Graphics.fillRect() method.
	 * Note that we never create an image larger than we need.
	 **/
public Raster getRaster(int x, int y, int w, int h) {
    // Create an initial image or a larger image as needed
    if ((image == null) || (image.getWidth() < w) || (image.getHeight() < h)) {
        image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        imageGraphics = image.createGraphics();
    }
    // Choose and use a random color
    imageGraphics.setColor(new Color(randomizer.nextInt(256), randomizer.nextInt(256), randomizer.nextInt(256)));
    // Fill a rectangle of the specified size with that color
    imageGraphics.fillRect(0, 0, w, h);
    // Then extract the corresponding Raster from the image and return
    rect.x = 0;
    rect.y = 0;
    rect.width = w;
    rect.height = h;
    return image.getData(rect);
}

{'bufferedimage', 'paintcontext', 'fillrect'}
/** Called when the PaintContext is no longer needed. */
public void dispose() {
    imageGraphics.dispose();
    image = null;
    imageGraphics = null;
}

{'paintcontext'}
/** This is the main Paint method;  all it does is return a PaintContext */
public PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) {
    return new GenericPaintContext(xform);
}

{'paintcontext'}
public GenericPaintContext(AffineTransform userToDevice) {
    // Our color model packs ARGB values into a single int
    model = new DirectColorModel(32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
    // can compute the user space coordinates of each device pixel
    try {
        AffineTransform deviceToUser = userToDevice.createInverse();
        origin = deviceToUser.transform(new Point(0, 0), null);
        unitVectorX = deviceToUser.deltaTransform(new Point(1, 0), null);
        unitVectorY = deviceToUser.deltaTransform(new Point(0, 1), null);
    } catch (NoninvertibleTransformException e) {
        origin = new Point(0, 0);
        unitVectorX = new Point(1, 0);
        unitVectorY = new Point(0, 1);
    }
}

{'figure', 'reverse', 'use', 'convert', 'invert', 'transformation', 'need', 'specified'}
/**
	 * This is the main method of PaintContext.  It must return a Raster
	 * that contains fill data for the specified rectangle.  It creates a
	 * raster of the specified size, and loops through the device pixels.
	 * For each one, it converts the coordinates to user space, then calls
	 * the computeRed(), computeGreen() and computeBlue() methods to
	 * obtain the appropriate color for the device pixel.
	 **/
public Raster getRaster(int x, int y, int w, int h) {
    WritableRaster raster = model.createCompatibleWritableRaster(w, h);
    int[] colorComponents = new int[4];
    for (int j = 0; j < h; j++) {
        // Loop through rows of raster
        int deviceY = y + j;
        for (int i = 0; i < w; i++) {
            // Loop through columns
            int deviceX = x + i;
            // Convert device coordinate to user-space coordinate
            double userX = origin.getX() + deviceX * unitVectorX.getX() + deviceY * unitVectorY.getX();
            double userY = origin.getY() + deviceX * unitVectorX.getY() + deviceY * unitVectorY.getY();
            // Compute the color components of the pixel
            colorComponents[0] = computeRed(userX, userY);
            colorComponents[1] = computeGreen(userX, userY);
            colorComponents[2] = computeBlue(userX, userY);
            colorComponents[3] = computeAlpha(userX, userY);
            // Set the color of the pixel
            raster.setPixel(i, j, colorComponents);
        }
    }
    return raster;
}

{'computeblue', 'computegreen', 'computered', 'paintcontext'}
/** Called when the PaintContext is no longer needed. */
public void dispose() {
}

{'paintcontext'}
// From GraphicsExample
public String getName() {
    return "Stroking";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
// From GraphicsExample
public String getName() {
    return "Shapes";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
// From GraphicsExample
public String getName() {
    return "Custom Strokes";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
public Shape createStrokedShape(Shape shape) {
    // Start off by stroking the shape with a thin line.  Store the
    // resulting shape in a GeneralPath object so we can add to it.
    GeneralPath strokedShape = new GeneralPath(new BasicStroke(1.0f).createStrokedShape(shape));
    // Use a PathIterator object to iterate through each of the line and
    // curve segments of the shape.  For each one, mark the endpoint and
    // control points (if any) by adding a rectangle to the GeneralPath
    float[] coords = new float[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
        int type = i.currentSegment(coords);
        Shape s = null, s2 = null, s3 = null;
        switch(type) {
            case PathIterator.SEG_CUBICTO:
                // falls through
                markPoint(strokedShape, coords[4], coords[5]);
            case PathIterator.SEG_QUADTO:
                // falls through
                markPoint(strokedShape, coords[2], coords[3]);
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                // falls through
                markPoint(strokedShape, coords[0], coords[1]);
            case PathIterator.SEG_CLOSE:
                break;
        }
    }
    return strokedShape;
}

{'pathiterator', 'generalpath'}
/** Add a small square centered at (x,y) to the specified path */
void markPoint(GeneralPath path, float x, float y) {
    // Begin a new sub-path
    path.moveTo(x - radius, y - radius);
    // Add a line segment to it
    path.lineTo(x + radius, y - radius);
    // Add a second line segment
    path.lineTo(x + radius, y + radius);
    // And a third
    path.lineTo(x - radius, y + radius);
    // Go back to last moveTo position
    path.closePath();
}

{'moveto'}
// From GraphicsExample
public String getName() {
    return "AntiAliasing";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
/** This method is invoked by the Print menu item */
public void print(final GraphicsExample example) {
    // Start off by getting a printer job to do the printing
    PrinterJob job = PrinterJob.getPrinterJob();
    // Wrap the example in a Printable object (defined below)
    // and tell the PrinterJob that we want to print it
    job.setPrintable(new PrintableExample(example));
    // Display the print dialog to the user
    if (job.printDialog()) {
        // If they didn't cancel it, then tell the job to start printing
        try {
            job.print();
        } catch (PrinterException e) {
            System.out.println("Couldn't print: " + e.getMessage());
        }
    }
}

{'printerjob'}
/**
	 * This method is called by the PrinterJob to print the example
	 **/
public int print(Graphics g, PageFormat pf, int pageIndex) {
    // Tell the PrinterJob that there is only one page
    if (pageIndex != 0)
        return NO_SUCH_PAGE;
    // The PrinterJob supplies us a Graphics object to draw with.
    // Anything drawn with this object will be sent to the printer.
    // The Graphics object can safely be cast to a Graphics2D object.
    Graphics2D g2 = (Graphics2D) g;
    // Translate to skip the left and top margins.
    g2.translate(pf.getImageableX(), pf.getImageableY());
    // Figure out how big the printable area is, and how big
    // the example is.
    double pageWidth = pf.getImageableWidth();
    double pageHeight = pf.getImageableHeight();
    double exampleWidth = example.getWidth();
    double exampleHeight = example.getHeight();
    // Scale the example if needed
    double scalex = 1.0, scaley = 1.0;
    if (exampleWidth > pageWidth)
        scalex = pageWidth / exampleWidth;
    if (exampleHeight > pageHeight)
        scaley = pageHeight / exampleHeight;
    double scalefactor = Math.min(scalex, scaley);
    if (scalefactor != 1)
        g2.scale(scalefactor, scalefactor);
    // Finally, call the draw() method of the example, passing in
    // the Graphics2D object for the printer
    example.draw(g2, GraphicsExampleFrame.this);
    // Tell the PrinterJob that we successfully printed the page
    return PAGE_EXISTS;
}

{'printerjob'}
/** 
     * The main program.  Use Java reflection to load and instantiate
     * the specified GraphicsExample classes, then create a
     * GraphicsExampleFrame to display them.
     **/
public static void main(String[] args) {
    GraphicsExample[] examples = new GraphicsExample[args.length];
    // Loop through the command line arguments
    for (int i = 0; i < args.length; i++) {
        // The class name of the requested example
        String classname = args[i];
        // If no package is specified, assume it is in this package
        if (classname.indexOf('.') == -1)
            classname = "com.davidflanagan.examples.graphics." + args[i];
        // Try to instantiate the named GraphicsExample class
        try {
            Class exampleClass = Class.forName(classname);
            examples[i] = (GraphicsExample) exampleClass.newInstance();
        } catch (// unknown class
        ClassNotFoundException // unknown class
        e) {
            System.err.println("Couldn't find example: " + classname);
            System.exit(1);
        } catch (// wrong type of class
        ClassCastException // wrong type of class
        e) {
            System.err.println("Class " + classname + " is not a GraphicsExample");
            System.exit(1);
        } catch (// class doesn't have a public constructor
        Exception // class doesn't have a public constructor
        e) {
            System.err.println("Couldn't instantiate example: " + classname);
            System.exit(1);
        }
    }
    // Now create a window to display the examples in, and make it visible
    GraphicsExampleFrame f = new GraphicsExampleFrame(examples);
    f.pack();
    f.setVisible(true);
}

{'graphicsexample', 'instantiationexception', 'graphicsexampleframe', 'illegalaccessexception'}
public Hypnosis(double x, double y, double r1, double r2, double a1, double a2, float linewidth, int delay, double deltaA, double deltaX, double deltaY) {
    this.x = x;
    this.y = y;
    this.r1 = r1;
    this.r2 = r2;
    this.a1 = a1;
    this.a2 = a2;
    this.linewidth = linewidth;
    this.deltaA = deltaA;
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    // Set up a timer to call actionPerformed() every delay milliseconds
    timer = new Timer(delay, this);
    // Create a buffer for double-buffering
    buffer = new BufferedImage((int) (2 * r2 + linewidth), (int) (2 * r2 + linewidth), BufferedImage.TYPE_INT_RGB);
    // Create a Graphics object for the buffer, and set the linewidth
    // and request antialiasing when drawing with it
    osg = buffer.createGraphics();
    osg.setStroke(new BasicStroke(linewidth, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
    osg.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
}

{'actionperformed'}
/** 
     * This method implements the ActionListener interface.  Our Timer object
     * calls this method periodically.  It updates the position and angles
     * of the spiral and requests a redraw.  Instead of redrawing the entire
     * component, however, this method requests a redraw only for the 
     * area that has changed.
     **/
public void actionPerformed(ActionEvent e) {
    // Ask to have the old bounding box of the spiral redrawn.
    // Nothing else has anything drawn in it, so it doesn't need a redraw
    repaint((int) (x - r2 - linewidth), (int) (y - r2 - linewidth), (int) (2 * (r2 + linewidth)), (int) (2 * (r2 + linewidth)));
    // Now animate: update the position and angles of the spiral
    // Bounce if we've hit an edge
    Rectangle bounds = getBounds();
    if ((x - r2 + deltaX < 0) || (x + r2 + deltaX > bounds.width))
        deltaX = -deltaX;
    if ((y - r2 + deltaY < 0) || (y + r2 + deltaY > bounds.height))
        deltaY = -deltaY;
    // Move the center of the spiral
    x += deltaX;
    y += deltaY;
    // Increment the start and end angles;
    a1 += deltaA;
    a2 += deltaA;
    if (a1 > 2 * Math.PI) {
        // Don't let them get too big
        a1 -= 2 * Math.PI;
        a2 -= 2 * Math.PI;
    }
    // Now ask to have the new bounding box of the spiral redrawn.  This
    // rectangle will be intersected with the redraw rectangle requested
    // above, and only the combined region will be redrawn
    repaint((int) (x - r2 - linewidth), (int) (y - r2 - linewidth), (int) (2 * (r2 + linewidth)), (int) (2 * (r2 + linewidth)));
}

{'actionlistener'}
// From GraphicsExample
public String getName() {
    return "LineStyles";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return 450;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return 180;
}

{'graphicsexample'}
/** This method draws the example figure */
public void draw(Graphics2D g, Component c) {
    // Use anti-aliasing to avoid "jaggies" in the lines
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    // Define the shape to draw
    GeneralPath shape = new GeneralPath();
    // start at point 0
    shape.moveTo(xpoints[0], ypoints[0]);
    // draw a line to point 1
    shape.lineTo(xpoints[1], ypoints[1]);
    // and then on to point 2
    shape.lineTo(xpoints[2], ypoints[2]);
    // Move the origin to the right and down, creating a margin
    g.translate(20, 40);
    // Now loop, drawing our shape with the three different line styles
    for (int i = 0; i < linestyles.length; i++) {
        // Draw a gray line
        g.setColor(Color.gray);
        // Select the line style to use
        g.setStroke(linestyles[i]);
        // Draw the shape
        g.draw(shape);
        // Now use black
        g.setColor(Color.black);
        // And the thin dashed line
        g.setStroke(thindashed);
        // And draw the shape again.
        g.draw(shape);
        // This accentuates the cap and join styles we're demonstrating
        for (int j = 0; j < xpoints.length; j++) g.fillRect(xpoints[j] - 2, ypoints[j] - 2, 5, 5);
        // Label the cap style
        g.drawString(capNames[i], 5, 105);
        // Label the join style
        g.drawString(joinNames[i], 5, 120);
        // Move over to the right before looping again
        g.translate(150, 0);
    }
}

{'highlight', 'vertex', 'location'}
// From GraphicsExample
public String getName() {
    return "Transforms";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return 750;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return 250;
}

{'graphicsexample'}
/** 
     * This constructor sets up the Shape and AffineTransform objects we need
     **/
public Transforms() {
    // Create a shape to draw
    GeneralPath path = new GeneralPath();
    path.append(new Line2D.Float(0.0f, 0.0f, 0.0f, 100.0f), false);
    path.append(new Line2D.Float(-10.0f, 50.0f, 10.0f, 50.0f), false);
    path.append(new Polygon(new int[] { -5, 0, 5 }, new int[] { 5, 0, 5 }, 3), false);
    // Remember this shape
    this.shape = path;
    // Set up some transforms to alter the shape
    this.transforms = new AffineTransform[6];
    // 1) the identity transform
    transforms[0] = new AffineTransform();
    // 2) A scale tranform: 3/4 size
    transforms[1] = AffineTransform.getScaleInstance(0.75, 0.75);
    // 3) A shearing transform
    transforms[2] = AffineTransform.getShearInstance(-0.4, 0.0);
    // 4) A 30 degree clockwise rotation about the origin of the shape
    transforms[3] = AffineTransform.getRotateInstance(Math.PI * 2 / 12);
    // 5) A 180 degree rotation about the midpoint of the shape
    transforms[4] = AffineTransform.getRotateInstance(Math.PI, 0.0, 50.0);
    // 6) A combination transform
    transforms[5] = AffineTransform.getScaleInstance(0.5, 1.5);
    transforms[5].shear(0.0, 0.4);
    // 90 degrees
    transforms[5].rotate(Math.PI / 2, 0.0, 50.0);
    // Define names for the transforms
    transformLabels = new String[] { "identity", "scale", "shear", "rotate", "rotate", "combo" };
}

{'affinetransform'}
/** Draw the applet.  The interesting code is in fillGradient() below */
public void paint(Graphics g) {
    // display the gradient
    fillGradient(this, g, startColor, endColor);
    // set a font
    g.setFont(bigFont);
    // light blue
    g.setColor(new Color(100, 100, 200));
    // draw something interesting
    g.drawString("Colors!", 100, 100);
}

{'fillgradient'}
// These are basic GraphicsExample methods
public String getName() {
    return "Composite Effects";
}

{'graphicsexample'}
/** Draw the example */
public void draw(Graphics2D g, Component c) {
    // fill the background 
    g.setPaint(new Color(175, 175, 175));
    g.fillRect(0, 0, getWidth(), getHeight());
    // Set text attributes
    g.setColor(Color.black);
    g.setFont(new Font("SansSerif", Font.BOLD, 12));
    // Draw the unmodified image
    g.translate(10, 10);
    g.drawImage(cover, 0, 0, c);
    g.drawString("SRC_OVER", 0, COVERHEIGHT + 15);
    // Draw the cover again, using AlphaComposite to make the opaque
    // colors of the image 50% translucent
    g.translate(COVERWIDTH + 10, 0);
    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));
    g.drawImage(cover, 0, 0, c);
    // Restore the pre-defined default Composite for the screen, so
    // opaque colors stay opaque.
    g.setComposite(AlphaComposite.SrcOver);
    // Label the effect
    g.drawString("SRC_OVER, 50%", 0, COVERHEIGHT + 15);
    // Now get an offscreen image to work with.  In order to achieve
    // certain compositing effects, the drawing surface must support
    // transparency. Onscreen drawing surfaces cannot, so we have to do the
    // compositing in an offscreen image that is specially created to have
    // an "alpha channel", then copy the final result to the screen.
    BufferedImage offscreen = new BufferedImage(COVERWIDTH, COVERHEIGHT, BufferedImage.TYPE_INT_ARGB);
    // First, fill the image with a color gradient background that varies
    // left-to-right from opaque to transparent yellow
    Graphics2D osg = offscreen.createGraphics();
    osg.setPaint(new GradientPaint(0, 0, Color.yellow, COVERWIDTH, 0, new Color(255, 255, 0, 0)));
    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);
    // Now copy the cover image on top of this, but use the DstOver rule
    // which draws it "underneath" the existing pixels, and allows the
    // image to show depending on the transparency of those pixels.
    osg.setComposite(AlphaComposite.DstOver);
    osg.drawImage(cover, 0, 0, c);
    // And display this composited image on the screen.  Note that the
    // image is opaque and that none of the screen background shows through
    g.translate(COVERWIDTH + 10, 0);
    g.drawImage(offscreen, 0, 0, c);
    g.drawString("DST_OVER", 0, COVERHEIGHT + 15);
    // Now start over and do a new effect with the off-screen image.
    // First, fill the offscreen image with a new color gradient.  We
    // don't care about the colors themselves; we just want the
    // translucency of the background to vary.  We use opaque black to
    // transparent black. Note that since we've already used this offscreen
    // image, we set the composite to Src, we can fill the image and
    // ignore anything that is already there.
    osg.setComposite(AlphaComposite.Src);
    osg.setPaint(new GradientPaint(0, 0, Color.black, COVERWIDTH, COVERHEIGHT, new Color(0, 0, 0, 0)));
    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);
    // Now set the compositing type to SrcIn, so colors come from the 
    // source, but translucency comes from the destination
    osg.setComposite(AlphaComposite.SrcIn);
    // Draw our loaded image into the off-screen image, compositing it.
    osg.drawImage(cover, 0, 0, c);
    // And then copy our off-screen image to the screen.  Note that the
    // image is translucent and some of the image shows through.
    g.translate(COVERWIDTH + 10, 0);
    g.drawImage(offscreen, 0, 0, c);
    g.drawString("SRC_IN", 0, COVERHEIGHT + 15);
    // If we do the same thing but use SrcOut, then the resulting image 
    // will have the inverted translucency values of the destination
    osg.setComposite(AlphaComposite.Src);
    osg.setPaint(new GradientPaint(0, 0, Color.black, COVERWIDTH, COVERHEIGHT, new Color(0, 0, 0, 0)));
    osg.fillRect(0, 0, COVERWIDTH, COVERHEIGHT);
    osg.setComposite(AlphaComposite.SrcOut);
    osg.drawImage(cover, 0, 0, c);
    g.translate(COVERWIDTH + 10, 0);
    g.drawImage(offscreen, 0, 0, c);
    g.drawString("SRC_OUT", 0, COVERHEIGHT + 15);
    // Here's a cool effect; it has nothing to do with compositing, but
    // uses an arbitrary shape to clip the image.  It uses Area to combine
    // shapes into more complicated ones.
    g.translate(COVERWIDTH + 10, 0);
    // Save current clipping region
    Shape savedClip = g.getClip();
    // Create a shape to use as the new clipping region.  
    // Begin with an ellipse
    Area clip = new Area(new Ellipse2D.Float(0, 0, COVERWIDTH, COVERHEIGHT));
    // Intersect with a rectangle, truncating the ellipse.
    clip.intersect(new Area(new Rectangle(5, 5, COVERWIDTH - 10, COVERHEIGHT - 10)));
    // Then subtract an ellipse from the bottom of the truncated ellipse.
    clip.subtract(new Area(new Ellipse2D.Float(COVERWIDTH / 2 - 40, COVERHEIGHT - 20, 80, 40)));
    // Use the resulting shape as the new clipping region
    g.clip(clip);
    // Then draw the image through this clipping region
    g.drawImage(cover, 0, 0, c);
    // Restore the old clipping region so we can label the effect
    g.setClip(savedClip);
    g.drawString("Clipping", 0, COVERHEIGHT + 15);
}

{'srcin', 'srcout', 'dstover', 'alphacomposite'}
// From GraphicsExample
public String getName() {
    return "Paints";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
/** Draw the example */
public void draw(Graphics2D g, Component c) {
    // Paint the entire background using a GradientPaint.
    // The background color varies diagonally from deep red to pale blue
    g.setPaint(new GradientPaint(0, 0, new Color(150, 0, 0), WIDTH, HEIGHT, new Color(200, 200, 255)));
    // fill the background
    g.fillRect(0, 0, WIDTH, HEIGHT);
    // Use a different GradientPaint to draw a box.
    // This one alternates between deep opaque green and transparent green.
    // Note: the 4th arg to Color() constructor specifies color opacity
    g.setPaint(new GradientPaint(0, 0, new Color(0, 150, 0), 20, 20, new Color(0, 150, 0, 0), true));
    // use wide lines
    g.setStroke(new BasicStroke(15));
    // draw the box
    g.drawRect(25, 25, WIDTH - 50, HEIGHT - 50);
    // The glyphs of fonts can be used as Shape objects, which enables
    // us to use Java2D techniques with letters Just as we would with
    // any other shape.  Here we get some letter shapes to draw.
    // a basic font
    Font font = new Font("Serif", Font.BOLD, 10);
    Font // a scaled up version
    bigfont = font.deriveFont(AffineTransform.getScaleInstance(30.0, 30.0));
    GlyphVector gv = bigfont.createGlyphVector(g.getFontRenderContext(), "JAV");
    // Shape of letter J
    Shape jshape = gv.getGlyphOutline(0);
    // Shape of letter A
    Shape ashape = gv.getGlyphOutline(1);
    // Shape of letter V
    Shape vshape = gv.getGlyphOutline(2);
    // We're going to outline the letters with a 5-pixel wide line
    g.setStroke(new BasicStroke(5.0f));
    // We're going to fake shadows for the letters using the
    // following Paint and AffineTransform objects
    // Translucent black
    Paint shadowPaint = new Color(0, 0, 0, 100);
    AffineTransform shadowTransform = // Shear to the right
    AffineTransform.getShearInstance(-1.0, 0.0);
    // Scale height by 1/2
    shadowTransform.scale(1.0, 0.5);
    // Move to the baseline of our first letter
    g.translate(65, 270);
    // Draw the shadow of the J shape
    g.setPaint(shadowPaint);
    // Compensate for the descender of the J
    g.translate(15, 20);
    // transform the J into the shape of its shadow, and fill it
    g.fill(shadowTransform.createTransformedShape(jshape));
    // Undo the translation above
    g.translate(-15, -20);
    // Now fill the J shape with a solid (and opaque) color
    // Fill with solid, opaque blue
    g.setPaint(Color.blue);
    // Fill the shape
    g.fill(jshape);
    // Switch to solid black
    g.setPaint(Color.black);
    // And draw the outline of the J
    g.draw(jshape);
    // Now draw the A shadow
    // Move to the right
    g.translate(75, 0);
    // Set shadow color
    g.setPaint(shadowPaint);
    // draw shadow
    g.fill(shadowTransform.createTransformedShape(ashape));
    // Draw the A shape using a solid transparent color
    // Transparent green as paint
    g.setPaint(new Color(0, 255, 0, 125));
    // Fill the shape
    g.fill(ashape);
    // Switch to solid back
    g.setPaint(Color.black);
    // Draw the outline
    g.draw(ashape);
    // Move to the right and draw the shadow of the letter V
    g.translate(175, 0);
    g.setPaint(shadowPaint);
    g.fill(shadowTransform.createTransformedShape(vshape));
    // We're going to fill the next letter using a TexturePaint, which
    // repeatedly tiles an image. The first step is to obtain the image.
    // We could load it from an image file, but here we create it 
    // ourselves by drawing a into an off-screen image.  Note that we use
    // a GradientPaint to fill the off-screen image, so the fill pattern
    // combines features of both Paint classes.
    BufferedImage // Create an image
    tile = new BufferedImage(50, 50, BufferedImage.TYPE_INT_RGB);
    // Get its Graphics for drawing
    Graphics2D tg = tile.createGraphics();
    tg.setColor(Color.pink);
    // Fill tile background with pink
    tg.fillRect(0, 0, 50, 50);
    tg.setPaint(new // diagonal gradient
    GradientPaint(// diagonal gradient
    40, // diagonal gradient
    0, // diagonal gradient
    Color.green, 0, 40, // green to gray
    Color.gray));
    // Draw a circle with this gradient
    tg.fillOval(5, 5, 40, 40);
    // Use this new tile to create a TexturePaint and fill the letter V
    g.setPaint(new TexturePaint(tile, new Rectangle(0, 0, 50, 50)));
    // Fill letter shape
    g.fill(vshape);
    // Switch to solid black
    g.setPaint(Color.black);
    // Draw outline of letter
    g.draw(vshape);
    // Move to the right and draw the shadow of the final A
    g.translate(160, 0);
    g.setPaint(shadowPaint);
    g.fill(shadowTransform.createTransformedShape(ashape));
    // For the last letter, use a custom Paint class to fill with a 
    // complex mathematically defined pattern.  The GenericPaint
    // class is defined later in the chapter.
    g.setPaint(new GenericPaint() {

        public int computeRed(double x, double y) {
            return 128;
        }

        public int computeGreen(double x, double y) {
            return (int) ((Math.sin(x / 7) + Math.cos(y / 5) + 2) / 4 * 255);
        }

        public int computeBlue(double x, double y) {
            return ((int) (x * y)) % 256;
        }

        public int computeAlpha(double x, double y) {
            return ((int) x % 25 * 8 + 50) + ((int) y % 25 * 8 + 50);
        }
    });
    // Fill letter A
    g.fill(ashape);
    // Revert to solid black
    g.setPaint(Color.black);
    // Draw the outline of the A
    g.draw(ashape);
}

{'affinetransform', 'texturepaint', 'gradientpaint', 'genericpaint'}
// This method is called whenever the applet needs to be drawn or redrawn
public void paint(Graphics g) {
    // Specify the font we'll be using throughout
    g.setFont(font);
    // Draw a background by tiling an image tile() is defined below
    tile(g, this, background);
    // Draw a line
    // Specify the drawing color
    g.setColor(outline);
    // Draw a line from (25,10) to (150,80)
    g.drawLine(25, 10, 150, 80);
    // Draw some text.  See the centerText() method below.
    centerText("drawLine()", null, g, textcolor, 25, 10, 150, 80);
    // Draw and fill an arc
    g.setColor(fill);
    g.fillArc(225, 10, 150, 80, 90, 135);
    g.setColor(outline);
    g.drawArc(225, 10, 150, 80, 90, 135);
    centerText("fillArc()", "drawArc()", g, textcolor, 225, 10, 150, 80);
    // Draw and fill a rectangle
    g.setColor(fill);
    g.fillRect(25, 110, 150, 80);
    g.setColor(outline);
    g.drawRect(25, 110, 150, 80);
    centerText("fillRect()", "drawRect()", g, textcolor, 25, 110, 150, 80);
    // Draw and fill a rounded rectangle
    g.setColor(fill);
    g.fillRoundRect(225, 110, 150, 80, 20, 20);
    g.setColor(outline);
    g.drawRoundRect(225, 110, 150, 80, 20, 20);
    centerText("fillRoundRect()", "drawRoundRect()", g, textcolor, 225, 110, 150, 80);
    // Draw and fill an oval
    g.setColor(fill);
    g.fillOval(25, 210, 150, 80);
    g.setColor(outline);
    g.drawOval(25, 210, 150, 80);
    centerText("fillOval()", "drawOval()", g, textcolor, 25, 210, 150, 80);
    // Define an octagon using arrays of X and Y coordinates
    int numpoints = 8;
    int[] xpoints = new int[numpoints + 1];
    int[] ypoints = new int[numpoints + 1];
    for (int i = 0; i < numpoints; i++) {
        double angle = 2 * Math.PI * i / numpoints;
        xpoints[i] = (int) (300 + 75 * Math.cos(angle));
        ypoints[i] = (int) (250 - 40 * Math.sin(angle));
    }
    // Draw and fill the polygon
    g.setColor(fill);
    g.fillPolygon(xpoints, ypoints, numpoints);
    g.setColor(outline);
    g.drawPolygon(xpoints, ypoints, numpoints);
    centerText("fillPolygon()", "drawPolygon()", g, textcolor, 225, 210, 150, 80);
    // Draw a 3D rectangle (clear an area for it first)
    g.setColor(fill);
    g.fillRect(20, 305, 160, 90);
    g.draw3DRect(25, 310, 150, 80, true);
    g.draw3DRect(26, 311, 148, 78, true);
    g.draw3DRect(27, 312, 146, 76, true);
    centerText("draw3DRect()", "x 3", g, textcolor, 25, 310, 150, 80);
    // Draw an image (centered within an area)
    int w = image.getWidth(this);
    int h = image.getHeight(this);
    g.drawImage(image, 225 + (150 - w) / 2, 310 + (80 - h) / 2, this);
    centerText("drawImage()", null, g, textcolor, 225, 310, 150, 80);
}

{'centertext'}
// Utility method to tile an image on the background of the component 
protected void tile(Graphics g, Component c, Image i) {
    // Use bounds() instead of getBounds() if you want
    // compatibility with Java 1.0 and old browsers like Netscape 3
    // How big is the component?
    Rectangle r = c.getBounds();
    // How big is the image?
    int iw = i.getWidth(c);
    int ih = i.getHeight(c);
    if ((iw <= 0) || (ih <= 0))
        return;
    for (// Loop horizontally
    int x = 0; // Loop horizontally
    x < r.width; // Loop horizontally
    x += iw) for (// Loop vertically
    int y = 0; // Loop vertically
    y < r.height; // Loop vertically
    y += ih) // Draw the image
    g.drawImage(i, x, y, c);
}

{'getbounds'}
// Utility method to center two lines of text in a rectangle.
// Relies on the FontMetrics obtained in the init() method.
protected void centerText(String s1, String s2, Graphics g, Color c, int x, int y, int w, int h) {
    // How tall is the font?
    int height = metrics.getHeight();
    // Where is the font baseline?
    int ascent = metrics.getAscent();
    int width1 = 0, width2 = 0, x0 = 0, x1 = 0, y0 = 0, y1 = 0;
    // How wide are the strings?
    width1 = metrics.stringWidth(s1);
    if (s2 != null)
        width2 = metrics.stringWidth(s2);
    // Center the strings horizontally
    x0 = x + (w - width1) / 2;
    x1 = x + (w - width2) / 2;
    if (// Center one string vertically
    s2 == null)
        y0 = y + (h - height) / 2 + ascent;
    else {
        // Center two strings vertically
        y0 = y + (h - (int) (height * 2.2)) / 2 + ascent;
        y1 = y0 + (int) (height * 1.2);
    }
    // Set the color
    g.setColor(c);
    // Draw the strings
    g.drawString(s1, x0, y0);
    if (s2 != null)
        g.drawString(s2, x1, y1);
}

{'fontmetrics'}
// From GraphicsExample
public String getName() {
    return "Image Processing";
}

{'graphicsexample'}
// From GraphicsExample
public int getWidth() {
    return WIDTH;
}

{'graphicsexample'}
// From GraphicsExample
public int getHeight() {
    return HEIGHT;
}

{'graphicsexample'}
/** Draw the example */
public void draw(Graphics2D g, Component c) {
    // Create a BufferedImage big enough to hold the Image loaded
    // in the constructor.  Then copy that image into the new
    // BufferedImage object so that we can process it.
    BufferedImage bimage = new BufferedImage(image.getWidth(c), image.getHeight(c), BufferedImage.TYPE_INT_RGB);
    Graphics2D ig = bimage.createGraphics();
    // copy the image
    ig.drawImage(image, 0, 0, c);
    // Set some default graphics attributes
    // 12pt bold text
    g.setFont(new Font("SansSerif", Font.BOLD, 12));
    // Draw in green
    g.setColor(Color.green);
    // Set some margins
    g.translate(10, 10);
    // Loop through the filters
    for (int i = 0; i < filters.length; i++) {
        // draw the image as processed by the filter
        if (filters[i] == null)
            g.drawImage(bimage, 0, 0, c);
        else
            g.drawImage(filters[i].filter(bimage, null), 0, 0, c);
        // Label the image
        g.drawString(filterNames[i], 0, 205);
        // Move over
        g.translate(137, 0);
        // Move down after 4
        if (i % 4 == 3)
            g.translate(-137 * 4, 215);
    }
}

{'original', 'bufferedimage', 'otherwise'}
/** The DrawableRect constructor just invokes the Rect() constructor */
public DrawableRect(int x1, int y1, int x2, int y2) {
    super(x1, y1, x2, y2);
}

{'drawablerect'}
/** This is the new method defined by DrawableRect */
public void draw(java.awt.Graphics g) {
    g.drawRect(x1, y1, (x2 - x1), (y2 - y1));
}

{'drawablerect'}
public static void main(String[] args) {
    // Create Rect objects
    Rect r1 = new Rect(1, 1, 4, 4);
    Rect r2 = new Rect(2, 3, 5, 6);
    // Invoke Rect methods
    Rect u = r1.union(r2);
    Rect i = r2.intersection(r1);
    if (// Use Rect fields and invoke a method
    u.isInside(r2.x1, r2.y1))
        System.out.println("(" + r2.x1 + "," + r2.y1 + ") is inside the union");
    // These lines implicitly call the Rect.toString() method
    System.out.println(r1 + " union " + r2 + " = " + u);
    System.out.println(r1 + " intersect " + r2 + " = " + i);
}

{'tostring'}
/** 
     * An accessor method.  Returns the real part of the complex number.
     * Note that there is no setReal() method to set the real part.  This means
     * that the ComplexNumber class is "immutable".
     **/
public double real() {
    return x;
}

{'complexnumber', 'setreal'}
/** 
     * This method converts a ComplexNumber to a string.  This is a method of
     * Object that we override so that complex numbers can be meaningfully
     * converted to strings, and so they can conveniently be printed out with
     * System.out.println() and related methods
     **/
public String toString() {
    return "{" + x + "," + y + "}";
}

{'complexnumber'}
/** 
     * This is a static class method.  It takes two complex numbers, adds
     * them, and returns the result as a third number.  Because it is static,
     * there is no "current instance" or "this" object.  Use it like this:
     * ComplexNumber c = ComplexNumber.add(a, b);
     **/
public static ComplexNumber add(ComplexNumber a, ComplexNumber b) {
    return new ComplexNumber(a.x + b.x, a.y + b.y);
}

{'complexnumber'}
/**
     * This is a non-static instance method by the same name.  It adds the
     * specified complex number to the current complex number.  Use it like
     * this:
     * ComplexNumber c = a.add(b);
     **/
public ComplexNumber add(ComplexNumber a) {
    return new ComplexNumber(this.x + a.x, this.y + a.y);
}

{'complexnumber'}
/** 
     * This method computes a pseudo-random integer between 0 and specified
     * maximum.  It uses randomFloat() above.
     **/
public int randomInt(int max) {
    return Math.round(max * randomFloat());
}

{'randomfloat'}
/**
     * Sort a portion of an array of strings, using the collation order of
     * the specified locale.   If up is true, sort ascending, otherwise, sort
     * descending.  If ignorecase is true, ignore the capitalization of letters
     **/
public static void sort(String[] a, int from, int to, boolean up, boolean ignorecase, Locale locale) {
    // Don't sort if we don't have to
    if ((a == null) || (a.length < 2))
        return;
    // The java.text.Collator object does internationalized string compares
    // Create one for the specified, or the default locale.
    Collator c;
    if (locale == null)
        c = Collator.getInstance();
    else
        c = Collator.getInstance(locale);
    // using the default American English locale.
    if (ignorecase)
        c.setStrength(Collator.SECONDARY);
    // Use the Collator object to create an array of CollationKey objects 
    // that correspond to each of the strings.  
    // Comparing CollationKeys is much quicker than comparing Strings
    CollationKey[] b = new CollationKey[a.length];
    for (int i = 0; i < a.length; i++) b[i] = c.getCollationKey(a[i]);
    // Now define a Comparer object to compare collation keys, using an
    // anonymous class.
    Comparer comp = new Comparer() {

        public int compare(Object a, Object b) {
            return ((CollationKey) a).compareTo((CollationKey) b);
        }
    };
    // Finally, sort the array of CollationKey objects, rearranging the 
    // original array of strings in exactly the same way.
    sort(b, a, from, to, up, comp);
}

{'option', 'note', 'seem', 'considered', 'whether', 'correctly', 'case', 'work', 'jdk', 'collationkeys', 'collationkey', 'specify'}
/** A a test program that sorts complex numbers in various ways. */
public static void main(String[] args) {
    // Define an array of SortableComplexNumber objects.  Initialize it
    // to contain random complex numbers.
    SortableComplexNumber[] a = new SortableComplexNumber[5];
    for (int i = 0; i < a.length; i++) a[i] = new SortableComplexNumber(Math.random() * 10, Math.random() * 10);
    // Now sort it using the SortableComplexNumber compareTo() method, 
    // which sorts by magnitude, and print the results out.
    System.out.println("Sorted by magnitude:");
    Sorter.sort(a);
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
    // Sort the complex numbers again, using a Comparer object that
    // compares them based on the sum of their real and imaginary parts
    System.out.println("Sorted by sum of real and imaginary parts:");
    Sorter.sort(a, new Sorter.Comparer() {

        public int compare(Object a, Object b) {
            ComplexNumber i = (ComplexNumber) a;
            ComplexNumber j = (ComplexNumber) b;
            return sign((i.real() + i.imaginary()) - (j.real() + j.imaginary()));
        }
    });
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
    // Sort them again using a Comparer object that compares their real
    // parts, and then their imaginary parts
    System.out.println("Sorted descending by real, then imaginary:");
    Sorter.sort(a, 0, a.length - 1, false, new Sorter.Comparer() {

        public int compare(Object a, Object b) {
            ComplexNumber i = (ComplexNumber) a;
            ComplexNumber j = (ComplexNumber) b;
            double result = i.real() - j.real();
            if (result == 0)
                result = i.imaginary() - j.imaginary();
            return sign(result);
        }
    });
    for (int i = 0; i < a.length; i++) System.out.println(a[i]);
}

{'compareto', 'sortablecomplexnumber'}
/** This method returns the average of all numbers passed to addDatum() */
public double getAverage() {
    return sum / n;
}

{'adddatum'}
/** This method returns the number of numbers passed to addDatum() */
public double getNum() {
    return n;
}

{'adddatum'}
/** This method returns the sum of all numbers passed to addDatum() */
public double getSum() {
    return sum;
}

{'adddatum'}
/** This is the ActionListener method invoked by the popup menu items */
public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("clear"))
        clear();
    else if (command.equals("cut"))
        cut();
    else if (command.equals("copy"))
        copy();
    else if (command.equals("paste"))
        paste();
}

{'actionlistener'}
/** 
     * The user invokes this method through the popup menu.
     * First, ask for the Transferable contents of the system clipboard.
     * Then ask that Transferable object for the scribble data it represents.
     * Try using both data flavors supported by the Scribble class.
     * If it doesn't work, beep to tell the user it failed.
     **/
public void paste() {
    // Get clipboard
    Clipboard c = this.getToolkit().getSystemClipboard();
    // Get its contents
    Transferable t = c.getContents(this);
    // Now try to get a Scribble object from the transferrable
    Scribble pastedScribble = null;
    try {
        pastedScribble = (Scribble) t.getTransferData(Scribble.scribbleDataFlavor);
    } catch (// UnsupportedFlavor, NullPointer, etc.
    Exception // UnsupportedFlavor, NullPointer, etc.
    e) {
        try {
            String s = (String) t.getTransferData(DataFlavor.stringFlavor);
            pastedScribble = Scribble.parse(s);
        } catch (Exception e2) {
            this.getToolkit().beep();
            return;
        }
    }
    // If we get here, we've retrieved a Scribble object from the clipboard
    // Add it to the current scribble, and ask to be redrawn
    scribble.append(pastedScribble);
    repaint();
}

{'converting', 'asking', 'numberformat', 'give', 'unsupportedflavor', 'nullpointer', 'got', 'instead'}
/** 
     * This method implements the ClipboardOwner interface.  We specify a
     * ClipboardOwner when we copy a Scribble to the clipboard.  This method
     * will be invoked when something else is copied to the clipboard, and
     * bumps our data off the clipboard.  When this method is invoked we no
     * longer have to maintain our copied Scribble object, since it is no
     * longer available to be pasted.  Often, a component will highlight a
     * selected object while it is on the clipboard, and will use this method
     * to un-highlight the object when it is no longer on the clipboard.
     **/
public void lostOwnership(Clipboard c, Transferable t) {
    selection = null;
}

{'clipboardowner'}
/**
     * The constructor builds a very simple test GUI, and registers this object
     * as the ActionListener for the buttons 
     **/
public SimpleCutAndPaste() {
    // Window title
    super("SimpleCutAndPaste");
    // Use a big font
    this.setFont(new Font("SansSerif", Font.PLAIN, 18));
    // Set up the Cut button
    Button copy = new Button("Copy");
    copy.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            copy();
        }
    });
    this.add(copy, "West");
    // Set up the Paste button
    Button paste = new Button("Paste");
    paste.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            paste();
        }
    });
    this.add(paste, "East");
    // Set up the text field that they both operate on
    field = new TextField();
    this.add(field, "North");
}

{'actionlistener'}
/**
     * This method takes the current contents of the text field, creates a
     * StringSelection object to represent that string, and puts the 
     * StringSelection onto the clipboard
     **/
public void copy() {
    // Get the currently displayed value
    String s = field.getText();
    // Create a StringSelection object to represent the text.
    // StringSelection is a pre-defined class that implements
    // Transferable and ClipboardOwner for us. 
    StringSelection ss = new StringSelection(s);
    // Now set the StringSelection object as the contents of the clipboard
    // Also specify that we're the clipboard owner
    this.getToolkit().getSystemClipboard().setContents(ss, this);
    // Highlight the text to indicate it is on the clipboard.
    field.selectAll();
}

{'stringselection', 'clipboardowner'}
/**
     * This method implements the ClipboardOwner interface.  It is called when
     * something else is placed on the clipboard.
     **/
public void lostOwnership(Clipboard c, Transferable t) {
    // Un-highlight the text field, since we don't "own" the clipboard
    // anymore, and the text is no longer available to be pasted.
    field.select(0, 0);
}

{'clipboardowner'}
/** The constructor: set up drag-and-drop stuff */
public ScribbleDragAndDrop() {
    // Give ourselves a nice default border.
    // We'll change this border during drag-and-drop.
    setBorder(normalBorder);
    // Register listeners to handle drawing
    addMouseListener(this);
    addMouseMotionListener(this);
    // Create a DragSource and DragGestureRecognizer to listen for drags
    // The DragGestureRecognizer will notify the DragGestureListener
    // when the user tries to drag an object
    dragSource = DragSource.getDefaultDragSource();
    // What component
    dragSource.createDefaultDragGestureRecognizer(// What component
    this, // What drag types?
    DnDConstants.ACTION_COPY_OR_MOVE, // the listener
    this);
    // Create and set up a DropTarget that will listen for drags and
    // drops over this component, and will notify the DropTargetListener
    DropTarget dropTarget = new // component to monitor
    DropTarget(// component to monitor
    this, // listener to notify
    this);
    // Tell the component about it.
    this.setDropTarget(dropTarget);
}

{'droptarget', 'droptargetlistener', 'dragsource', 'draggesturelistener', 'draggesturerecognizer'}
/**
     * This method, and the following four methods are from the MouseListener
     * interface.  If we're in drawing mode, this method handles mouse down
     * events and starts a new scribble.
     **/
public void mousePressed(MouseEvent e) {
    if (dragMode)
        return;
    currentScribble = new Scribble();
    scribbles.add(currentScribble);
    currentScribble.moveto(e.getX(), e.getY());
}

{'mouselistener'}
/**
     * This method and mouseMoved() below are from the MouseMotionListener
     * interface.  If we're in drawing mode, this method adds a new point
     * to the current scribble and requests a redraw
     **/
public void mouseDragged(MouseEvent e) {
    if (dragMode)
        return;
    currentScribble.lineto(e.getX(), e.getY());
    repaint();
}

{'mousemotionlistener', 'mousemoved'}
/**
     * This method implements the DragGestureListener interface.  It will be
     * invoked when the DragGestureRecognizer thinks that the user has 
     * initiated a drag.  If we're not in drawing mode, then this method will
     * try to figure out which Scribble object is being dragged, and will
     * initiate a drag on that object.
     **/
public void dragGestureRecognized(DragGestureEvent e) {
    // Don't drag if we're not in drag mode
    if (!dragMode)
        return;
    // Figure out where the drag started
    MouseEvent inputEvent = (MouseEvent) e.getTriggerEvent();
    int x = inputEvent.getX();
    int y = inputEvent.getY();
    // Figure out which scribble was clicked on, if any by creating a 
    // small rectangle around the point and testing for intersection.
    Rectangle r = new Rectangle(x - LINEWIDTH, y - LINEWIDTH, LINEWIDTH * 2, LINEWIDTH * 2);
    int numScribbles = scribbles.size();
    for (int i = 0; i < numScribbles; i++) {
        // Loop through the scribbles
        Scribble s = (Scribble) scribbles.get(i);
        if (s.intersects(r)) {
            // The user started the drag on top of this scribble, so 
            // start to drag it.
            // First, remember which scribble is being dragged, so we can 
            // delete it later (if this is a move rather than a copy)
            beingDragged = s;
            // Next, create a copy that will be the one dragged
            Scribble dragScribble = (Scribble) s.clone();
            // Adjust the origin to the point the user clicked on.
            dragScribble.translate(-x, -y);
            // Choose a cursor based on the type of drag the user initiated
            Cursor cursor;
            switch(e.getDragAction()) {
                case DnDConstants.ACTION_COPY:
                    cursor = DragSource.DefaultCopyDrop;
                    break;
                case DnDConstants.ACTION_MOVE:
                    cursor = DragSource.DefaultMoveDrop;
                    break;
                default:
                    // We only support move and copys
                    return;
            }
            // cursor.  If so, create an image of the scribble to drag
            if (dragSource.isDragImageSupported()) {
                Rectangle scribbleBox = dragScribble.getBounds();
                Image dragImage = this.createImage(scribbleBox.width, scribbleBox.height);
                Graphics2D g = (Graphics2D) dragImage.getGraphics();
                // transparent background
                g.setColor(new Color(0, 0, 0, 0));
                g.fillRect(0, 0, scribbleBox.width, scribbleBox.height);
                g.setColor(Color.black);
                g.setStroke(linestyle);
                g.translate(-scribbleBox.x, -scribbleBox.y);
                g.draw(dragScribble);
                Point hotspot = new Point(-scribbleBox.x, -scribbleBox.y);
                // Now start dragging, using the image.
                e.startDrag(cursor, dragImage, hotspot, dragScribble, this);
            } else {
                // Or start the drag without an image
                e.startDrag(cursor, dragScribble, this);
            }
            // After we've started dragging one scribble, stop looking
            return;
        }
    }
}

{'allow', 'along', 'system', 'draggesturerecognizer', 'draggesturelistener', 'u'}
/**
     * This method, and the four unused methods that follow it implement the
     * DragSourceListener interface.  dragDropEnd() is invoked when the user
     * drops the scribble she was dragging.  If the drop was successful, and
     * if the user did a "move" rather than a "copy", then we delete the
     * dragged scribble from the list of scribbles to draw.
     **/
public void dragDropEnd(DragSourceDropEvent e) {
    if (!e.getDropSuccess())
        return;
    int action = e.getDropAction();
    if (action == DnDConstants.ACTION_MOVE) {
        scribbles.remove(beingDragged);
        beingDragged = null;
        repaint();
    }
}

{'dragdropend', 'dragsourcelistener'}
/**
     * This method is invoked when the user first drags something over us.
     * If we understand the data type being dragged, then call acceptDrag()
     * to tell the system that we're receptive.  Also, we change our border
     * as a "drag under" effect to signal that we can accept the drop.
     **/
public void dragEnter(DropTargetDragEvent e) {
    if (e.isDataFlavorSupported(Scribble.scribbleDataFlavor) || e.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        e.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);
        this.setBorder(dropBorder);
    }
}

{'acceptdrag'}
/** 
     * This is the key method of DropTargetListener.  It is invoked when the
     * user drops something on us.
     **/
public void drop(DropTargetDropEvent e) {
    // Restore the default border
    this.setBorder(normalBorder);
    // If we supports our data flavors, accept the drop, otherwise reject.
    if (e.isDataFlavorSupported(Scribble.scribbleDataFlavor) || e.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
    } else {
        e.rejectDrop();
        return;
    }
    // We've accepted the drop, so now we attempt to get the dropped data
    // from the Transferable object.
    // Holds the dropped data
    Transferable t = e.getTransferable();
    // This will hold the Scribble object
    Scribble droppedScribble;
    // First, try to get the data directly as a scribble object
    try {
        droppedScribble = (Scribble) t.getTransferData(Scribble.scribbleDataFlavor);
    } catch (// unsupported flavor, IO exception, etc.
    Exception // unsupported flavor, IO exception, etc.
    ex) {
        try {
            String s = (String) t.getTransferData(DataFlavor.stringFlavor);
            droppedScribble = Scribble.parse(s);
        } catch (Exception ex2) {
            e.dropComplete(false);
            return;
        }
    }
    // If we get here, we've got the Scribble object
    // Where did the drop happen?
    Point p = e.getLocation();
    // Move it there
    droppedScribble.translate(p.getX(), p.getY());
    // add to display list
    scribbles.add(droppedScribble);
    // ask for redraw
    repaint();
    // signal success!
    e.dropComplete(true);
}

{'droptargetlistener', 'failed', 'whether', 'system', 'still', 'tell', 'understand', 'work', 'check'}
// These are unused DropTargetListener methods
public void dragOver(DropTargetDragEvent e) {
}

{'droptargetlistener'}
/** 
     * Begin a new polyline at (x,y).  Note the use of Double.NaN in the
     * points array to mark the beginning of a new polyline
     **/
public void moveto(double x, double y) {
    if (numPoints + 3 > points.length)
        reallocate();
    // Mark this as the beginning of a new line
    points[numPoints++] = Double.NaN;
    // The rest of this method is just like lineto();
    lineto(x, y);
}

{'nan'}
/** 
     * Create a new Scribble object and initialize it by parsing a string of
     * coordinate data in the format produced by toString()
     **/
public static Scribble parse(String s) throws NumberFormatException {
    StringTokenizer st = new StringTokenizer(s);
    Scribble scribble = new Scribble();
    while (st.hasMoreTokens()) {
        String t = st.nextToken();
        if (t.charAt(0) == 'm') {
            scribble.moveto(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()));
        } else {
            scribble.lineto(Double.parseDouble(t), Double.parseDouble(st.nextToken()));
        }
    }
    return scribble;
}

{'tostring'}
/**
     * Determine if the scribble intersects the specified rectangle by testing
     * each line segment individually 
     **/
public boolean intersects(Rectangle2D r) {
    if (numPoints < 4)
        return false;
    int i = 0;
    double x1, y1, x2 = 0.0, y2 = 0.0;
    while (i < numPoints) {
        if (Double.isNaN(points[i])) {
            // If we're beginning a new line
            // Skip the NaN
            i++;
            x2 = points[i++];
            y2 = points[i++];
        } else {
            x1 = x2;
            y1 = y2;
            x2 = points[i++];
            y2 = points[i++];
            if (r.intersectsLine(x1, y1, x2, y2))
                return true;
        }
    }
    return false;
}

{'nan'}
/**
     * Return a PathIterator object that tells Java2D how to draw this scribble
     **/
public PathIterator getPathIterator(AffineTransform at) {
    return new ScribbleIterator(at);
}

{'pathiterator'}
/**
     * Return a PathIterator that doesn't include curves.  Ours never does.
     **/
public PathIterator getPathIterator(AffineTransform at, double flatness) {
    return getPathIterator(at);
}

{'pathiterator'}
public void init() throws ServletException {
    // Read initialization parameters from the web.xml file
    ServletConfig config = getServletConfig();
    String driverClassName = config.getInitParameter("driverClassName");
    String url = config.getInitParameter("url");
    String username = config.getInitParameter("username");
    String password = config.getInitParameter("password");
    // If anything goes wrong, log it, wrap the exception and re-throw it
    try {
        Class.forName(driverClassName);
        db = DriverManager.getConnection(url, username, password);
    } catch (Exception e) {
        log("Can't create DB connection", e);
        throw new ServletException("Query: can't initialize: " + e.getMessage(), e);
    }
}

{'database', 'establish', 'use', 'params'}
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // We're outputting HTML
    response.setContentType("text/html");
    // Where to output it to
    PrintWriter out = response.getWriter();
    // Output document header and a form for entering SQL queries
    // When the form is submitted, this servlet is reloaded
    out.println("<head><title>DB Query</title></head>\n" + "<body bgcolor=white><h1>DB Query</h1>\n" + "<form><b>Query: </b><input name='q'>" + "<input type=submit></form>");
    // See if a query was specified in this request.
    String query = request.getParameter("q");
    if (query != null) {
        // display the query text as a page heading
        out.println("<h1>" + query + "</h1>");
        // Now try to execute the query and display the results in a table
        // An object to execute the query
        Statement statement = null;
        try {
            // Create a statement to use
            statement = db.createStatement();
            // Use it to execute the specified query, and get result set
            ResultSet results = statement.executeQuery(query);
            // Ask for extra information about the results
            ResultSetMetaData metadata = results.getMetaData();
            // How many columns are there in the results?
            int numcols = metadata.getColumnCount();
            // Begin a table, and output a header row of column names
            out.println("<table border=2><tr>");
            for (int i = 0; i < numcols; i++) out.print("<th>" + metadata.getColumnLabel(i + 1) + "</th>");
            out.println("</tr>");
            // Now loop through the "rows" of the result set
            while (results.next()) {
                // For each row, display the the values for each column
                out.print("<tr>");
                for (int i = 0; i < numcols; i++) out.print("<td>" + results.getObject(i + 1) + "</td>");
                out.println("</tr>");
            }
            // end the table
            out.println("</table>");
        } catch (SQLException e) {
            out.println("SQL Error: " + e.getMessage());
        } finally {
            // Whatever happens, always close the Statement object
            try {
                statement.close();
            } catch (Exception e) {
            }
        }
    }
    // Now, display the number of hits on this page by invoking the
    // Counter servlet and including its output in this page.
    // This is done with a RequestDispatcher object.
    RequestDispatcher dispatcher = request.getRequestDispatcher("/servlet/counter");
    if (dispatcher != null) {
        out.println("<br>Page hits:");
        // Add a request attribute that tells the servlet what to count.
        // Use the attribute name defined by the Counter servlet, and
        // use the name of this class as a unique counter name.
        request.setAttribute(Counter.ATTRIBUTE_NAME, Query.class.getName());
        // Tell the dispatcher to invoke its servlet and include the output
        dispatcher.include(request, response);
    }
    // Finally, end the HTML output
    out.println("</body>");
}

{'anything', 'wrong', 'user', 'requestdispatcher', 'go', 'correct', 'usually'}
// doPost just invokes doGet
public void doPost(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {
    doGet(request, response);
}

{'doget', 'dopost'}
// This method is invoked when the servlet is the subject of an HTTP GET
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // See if the username is specified in the request
    String name = request.getParameter("username");
    // and associates a HttpSession object with each session.
    if (name == null)
        name = (String) request.getSession().getAttribute("username");
    // If the username is not found in either place, use a default name.
    if (name == null)
        name = "World";
    // Specify the type of output we produce.  If this servlet is
    // included from within another servlet or JSP page, this setting
    // will be ignored.
    response.setContentType("text/html");
    // Get an stream that we can write the output to
    PrintWriter out = response.getWriter();
    // And, finally, do our output.
    out.println("Hello " + name + "!");
}

{'httpsession', 'container', 'web', 'server', 'look', 'tracking', 'performs', 'automatically'}
// This method is called when the web server first instantiates this
// servlet.  It reads initialization parameters (which are configured
// at deployment time in the web.xml file), and loads the initial state
// of the counter variables from a file.
public void init() throws ServletException {
    ServletConfig config = getServletConfig();
    try {
        // Get the save file.
        countfile = new File(config.getInitParameter("countfile"));
        // How often should we save our state while running?
        saveInterval = Integer.parseInt(config.getInitParameter("saveInterval"));
        // The state couldn't have changed before now.
        lastSaveTime = System.currentTimeMillis();
        // Now read in the count data
        loadState();
    } catch (Exception e) {
        throw new ServletException("Can't init Counter servlet: " + e.getMessage(), e);
    }
}

{'wrong', 'go', 'wrap', 'rethrow', 'something'}
/**
     * This method is called when the servlet is invoked.  It looks for a
     * request parameter named "counter", and uses its value as the name of
     * the counter variable to increment.  If it doesn't find the request
     * parameter, then it uses the URL of the request as the name of the
     * counter.  This is useful when the servlet is mapped to a URL suffix.
     * This method also checks how much time has elapsed since it last saved
     * its state, and saves the state again if necessary.  This prevents it
     * from losing too much data if the server crashes or shuts down without
     * calling the destroy() method.
     **/
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Get the name of the counter as a request parameter
    String counterName = request.getParameter(PARAMETER_NAME);
    // is included by another servlet
    if (counterName == null)
        counterName = (String) request.getAttribute(ATTRIBUTE_NAME);
    // If it wasn't a parameter or attribute, use the request URL.
    if (counterName == null)
        counterName = request.getRequestURI();
    // What is the current count?
    Integer count;
    // prevents them from updating the counts hashtable at the same time
    synchronized (counts) {
        // Get the counter value from the hashtable
        count = (Integer) counts.get(counterName);
        // Increment the counter, or if it is new, log and start it at 1
        if (count != null)
            count = new Integer(count.intValue() + 1);
        else {
            // If this is a counter we haven't used before, send a message
            // to the log file, just so we can track what we're counting
            log("Starting new counter: " + counterName);
            // Start counting at 1!
            count = new Integer(1);
        }
        // Store the incremented (or new) counter value into the hashtable
        counts.put(counterName, count);
        // server crashes unexpectedly.  
        if (System.currentTimeMillis() - lastSaveTime > saveInterval) {
            saveState();
            lastSaveTime = System.currentTimeMillis();
        }
    }
    // End of synchronized block
    // Finally, output the counter value.  Since this servlet is usually
    // included within the output of other servlets, we don't bother
    // setting the content type.
    PrintWriter out = response.getWriter();
    out.print(count);
}

{'synchronization', 'TIME', 'whether', 'm', 'running', 'multiple', 'saveinterval', 'code', 'passed', 'see', 'even', 'different', 'happens', 'u', 'thread', 'millisecond'}
/**
     * This inherited method is always the first property setter invoked
     * by the JSP container.  We don't care about the page context here, but
     * use this method to set the default values of the various properties.
     * They are initialized here in case the JSP container wants to reuse
     * this Tag object on multiple pages.
     **/
public void setPageContext(PageContext context) {
    // Important!  Let the superclass save the page context object.
    // We'll need it in doStartTag() below.
    super.setPageContext(context);
    // Now set default values for all the other properties
    align = "center";
    title = null;
    titleColor = "white";
    titleAlign = "left";
    color = "lightblue";
    borderColor = "black";
    margin = "20";
    borderWidth = "4";
}

{'dostarttag'}
/**
     * This method is called when a <decor:box> tag is encountered.  Any
     * attributes will first be processed by calling the setter methods above.
     **/
public int doStartTag() throws JspException {
    try {
        // Get the output stream from the PageContext object, which
        // will have been passed to the setPageContext() method.
        JspWriter out = pageContext.getOut();
        // Output the HTML tags necessary to display the box. The <div>
        // handles the alignment, and the <table> creates the border.
        out.print("<div align='" + align + "'>" + "<table bgcolor='" + borderColor + "' " + "border='0' cellspacing='0' " + "cellpadding='" + borderWidth + "'>");
        // If there is a title, display it as a cell of the outer table
        if (title != null)
            out.print("<tr><td align='" + titleAlign + "'>" + "<font face='helvetica' size='+1' " + "color='" + titleColor + "'><b>" + title + "</b></font></td></tr>");
        // Now begin an inner table that has a different color than 
        // the border.
        out.print("<tr><td><table bgcolor='" + color + "' " + "border='0' cellspacing='0' " + "cellpadding='" + margin + "'><tr><td>");
    } catch (IOException e) {
        throw new JspException(e.getMessage());
    }
    // This return value tells the JSP class to process the body of the tag
    return EVAL_BODY_INCLUDE;
}

{'pagecontext', 'setpagecontext', 'jspexception', 'printwriter', 'ioexceptions', 'wrap', 'unlike', 'jspwriter'}
/**
     * This method is called when the closing </decor:box> tag is encountered
     **/
public int doEndTag() throws JspException {
    // Catch IOExceptions and rethrow them as JspExceptions
    try {
        JspWriter out = pageContext.getOut();
        out.println("</td></tr></table></td></tr></table></div>");
    } catch (IOException e) {
        throw new JspException(e.getMessage());
    }
    // This return value says to continue processing the JSP page.
    return EVAL_PAGE;
}

{'close', 'output', 'jspexceptions', 'html', 'ioexceptions'}
// These are the getter and setter methods for the favoriteColor property
public String getFavoriteColor() {
    return favorite;
}

{'favoritecolor'}
// Part of HttpSessionBindingListener; we don't care about it here
public void valueBound(HttpSessionBindingEvent e) {
}

{'httpsessionbindinglistener'}
/**
     * The program.  The first argument must be -e, -d, or -g to encrypt,
     * decrypt, or generate a key.  The second argument is the name of a file
     * from which the key is read or to which it is written for -g.  The
     * -e and -d arguments cause the program to read from standard input and
     * encrypt or decrypt to standard output.
     **/
public static void main(String[] args) {
    try {
        // encryption.  If not, explicitly install the SunJCE provider.
        try {
            Cipher c = Cipher.getInstance("DESede");
        } catch (Exception e) {
            System.err.println("Installing SunJCE provider.");
            Provider sunjce = new com.sun.crypto.provider.SunJCE();
            Security.addProvider(sunjce);
        }
        // This is where we'll read the key from or write it to
        File keyfile = new File(args[1]);
        // Now check the first arg to see what we're going to do
        if (args[0].equals("-g")) {
            // Generate a key
            System.out.print("Generating key. This may take some time...");
            System.out.flush();
            SecretKey key = generateKey();
            writeKey(key, keyfile);
            System.out.println("done.");
            System.out.println("Secret key written to " + args[1] + ". Protect that file carefully!");
        } else if (args[0].equals("-e")) {
            // Encrypt stdin to stdout
            SecretKey key = readKey(keyfile);
            encrypt(key, System.in, System.out);
        } else if (args[0].equals("-d")) {
            // Decrypt stdin to stdout
            SecretKey key = readKey(keyfile);
            decrypt(key, System.in, System.out);
        }
    } catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java " + TripleDES.class.getName() + " -d|-e|-g <keyfile>");
    }
}

{'tripledes', 'installed', 'jre', 'whether', 'probably', 'listing', 'lib', 'therefore', 'home', 'mean', 'permanently'}
/** Generate a secret TripleDES encryption/decryption key */
public static SecretKey generateKey() throws NoSuchAlgorithmException {
    // Get a key generator for Triple DES (a.k.a DESede)
    KeyGenerator keygen = KeyGenerator.getInstance("DESede");
    // Use it to generate a key
    return keygen.generateKey();
}

{'tripledes', 'desede'}
/** Save the specified TripleDES SecretKey to the specified file */
public static void writeKey(SecretKey key, File f) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    // Convert the secret key to an array of bytes like this
    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance("DESede");
    DESedeKeySpec keyspec = (DESedeKeySpec) keyfactory.getKeySpec(key, DESedeKeySpec.class);
    byte[] rawkey = keyspec.getKey();
    // Write the raw key to the file
    FileOutputStream out = new FileOutputStream(f);
    out.write(rawkey);
    out.close();
}

{'tripledes', 'secretkey'}
/** Read a TripleDES secret key from the specified file */
public static SecretKey readKey(File f) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {
    // Read the raw bytes from the keyfile
    DataInputStream in = new DataInputStream(new FileInputStream(f));
    byte[] rawkey = new byte[(int) f.length()];
    in.readFully(rawkey);
    in.close();
    // Convert the raw bytes to a secret key like this
    DESedeKeySpec keyspec = new DESedeKeySpec(rawkey);
    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance("DESede");
    SecretKey key = keyfactory.generateSecret(keyspec);
    return key;
}

{'tripledes'}
/** 
     * Use the specified TripleDES key to encrypt bytes from the input stream
     * and write them to the output stream.  This method uses 
     * CipherOutputStream to perform the encryption and write bytes at the
     * same time.
     **/
public static void encrypt(SecretKey key, InputStream in, OutputStream out) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IOException {
    // Create and initialize the encryption engine
    Cipher cipher = Cipher.getInstance("DESede");
    cipher.init(Cipher.ENCRYPT_MODE, key);
    // Create a special output stream to do the work for us
    CipherOutputStream cos = new CipherOutputStream(out, cipher);
    // Read from the input and write to the encrypting output stream
    byte[] buffer = new byte[2048];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        cos.write(buffer, 0, bytesRead);
    }
    cos.close();
    // For extra security, don't leave any plaintext hanging around memory.
    java.util.Arrays.fill(buffer, (byte) 0);
}

{'tripledes', 'cipheroutputstream'}
/** 
     * Use the specified TripleDES key to decrypt bytes ready from the input 
     * stream and write them to the output stream.  This method uses 
     * uses Cipher directly to show how it can be done without 
     * CipherInputStream and CipherOutputStream.
     **/
public static void decrypt(SecretKey key, InputStream in, OutputStream out) throws NoSuchAlgorithmException, InvalidKeyException, IOException, IllegalBlockSizeException, NoSuchPaddingException, BadPaddingException {
    // Create and initialize the decryption engine
    Cipher cipher = Cipher.getInstance("DESede");
    cipher.init(Cipher.DECRYPT_MODE, key);
    // Read bytes, decrypt, and write them out.
    byte[] buffer = new byte[2048];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        out.write(cipher.update(buffer, 0, bytesRead));
    }
    // Write out the final bunch of decrypted bytes
    out.write(cipher.doFinal());
    out.flush();
}

{'tripledes', 'cipheroutputstream', 'cipherinputstream'}
public static void main(String[] args) {
    try {
        // one with the -Djava.security.manager argument
        if (System.getSecurityManager() == null) {
            System.out.println("Establishing a security manager");
            System.setSecurityManager(new SecurityManager());
        }
        // Create a Server object
        Server server = new Server(null, 5);
        // Create the ClassLoader that we'll use to load Service classes.
        // The classes should be stored in the JAR file or the directory
        // specified as a URL by the first command-line argument
        URL serviceURL = new URL(args[0]);
        ClassLoader loader = new java.net.URLClassLoader(new URL[] { serviceURL });
        // Parse the argument list, which should contain Service name/port
        // pairs.  For each pair, load the named Service using the class
        // loader, then instantiate it with newInstance(), then tell the
        // server to start running it.
        int i = 1;
        while (i < args.length) {
            // Dynamically load the Service class using the class loader
            Class serviceClass = loader.loadClass(args[i++]);
            // Dynamically instantiate the class.  
            Server.Service service = (Server.Service) serviceClass.newInstance();
            // Parse the port #
            int port = Integer.parseInt(args[i++]);
            // Run service
            server.addService(service, port);
        }
    } catch (// Display a message if anything goes wrong
    Exception // Display a message if anything goes wrong
    e) {
        System.err.println(e);
        System.err.println("Usage: java " + SafeServer.class.getName() + " <url> <servicename> <port>\n" + "\t[<servicename> <port> ... ]");
        System.exit(1);
    }
}

{'install', 'user', 'newinstance', 'already', 'classloader'}
public static void main(String[] args) throws Exception {
    // Set the default values of the command-line arguments
    // Verify manifest or create one?
    boolean verify = false;
    // Manifest file name
    String manifestfile = "MANIFEST";
    // Algorithm for message digests
    String digestAlgorithm = "MD5";
    // Signer. No sig. by default
    String signername = null;
    // Algorithm for digital sig.
    String signatureAlgorithm = "DSA";
    // Private keys are protected
    String password = null;
    // Where are keys stored
    File keystoreFile = null;
    // What kind of keystore
    String keystoreType = null;
    // How to access keystore
    String keystorePassword = null;
    // The files to digest
    List filelist = new ArrayList();
    // Parse the command-line arguments, overriding the defaults above
    for (int i = 0; i < args.length; i++) {
        if (args[i].equals("-v"))
            verify = true;
        else if (args[i].equals("-m"))
            manifestfile = args[++i];
        else if (args[i].equals("-da") && !verify)
            digestAlgorithm = args[++i];
        else if (args[i].equals("-s") && !verify)
            signername = args[++i];
        else if (args[i].equals("-sa") && !verify)
            signatureAlgorithm = args[++i];
        else if (args[i].equals("-p"))
            password = args[++i];
        else if (args[i].equals("-keystore"))
            keystoreFile = new File(args[++i]);
        else if (args[i].equals("-keystoreType"))
            keystoreType = args[++i];
        else if (args[i].equals("-keystorePassword"))
            keystorePassword = args[++i];
        else if (!verify)
            filelist.add(args[i]);
        else
            throw new IllegalArgumentException(args[i]);
    }
    // If certain arguments weren't supplied, get default values.
    if (keystoreFile == null) {
        File dir = new File(System.getProperty("user.home"));
        keystoreFile = new File(dir, ".keystore");
    }
    if (keystoreType == null)
        keystoreType = KeyStore.getDefaultType();
    if (keystorePassword == null)
        keystorePassword = password;
    if (!verify && signername != null && password == null) {
        System.out.println("Use -p to specify a password.");
        return;
    }
    // Get the keystore we'll use for signing or verifying signatures
    // If no password was provided, then assume we won't be dealing with 
    // signatures, and skip the keystore.
    KeyStore keystore = null;
    if (keystorePassword != null) {
        keystore = KeyStore.getInstance(keystoreType);
        InputStream in = new BufferedInputStream(new FileInputStream(keystoreFile));
        keystore.load(in, keystorePassword.toCharArray());
    }
    // Otherwise, create a new manifest for the specified files
    if (verify || (filelist.size() == 0))
        verify(manifestfile, keystore);
    else
        create(manifestfile, digestAlgorithm, signername, signatureAlgorithm, keystore, password, filelist);
}

{'given'}
/**
     * This method creates a manifest file with the specified name, for
     * the specified vector of files, using the named message digest
     * algorithm.  If signername is non-null, it adds a digital signature
     * to the manifest, using the named signature algorithm.  This method can
     * throw a bunch of exceptions.
     **/
public static void create(String manifestfile, String digestAlgorithm, String signername, String signatureAlgorithm, KeyStore keystore, String password, List filelist) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException, KeyStoreException, UnrecoverableKeyException, IOException {
    // For computing a signature, we have to process the files in a fixed,
    // repeatable order, so sort them alphabetically.
    Collections.sort(filelist);
    int numfiles = filelist.size();
    Properties manifest = new Properties(), metadata = new Properties();
    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
    Signature signature = null;
    byte[] digest;
    // If a signer name was specified, then prepare to sign the manifest
    if (signername != null) {
        // Get a Signature object
        signature = Signature.getInstance(signatureAlgorithm);
        // Look up the private key of the signer from the keystore
        PrivateKey key = (PrivateKey) keystore.getKey(signername, password.toCharArray());
        // No prepare to create a signature for the specified signer
        signature.initSign(key);
    }
    // Now, loop through the files, in a well-known alphabetical order
    System.out.print("Computing message digests");
    for (int i = 0; i < numfiles; i++) {
        String filename = (String) filelist.get(i);
        // Compute the digest for each, and skip files that don't exist.
        try {
            digest = getFileDigest(filename, md);
        } catch (IOException e) {
            System.err.println("\nSkipping " + filename + ": " + e);
            continue;
        }
        // and of the digest as part of the data to sign.
        if (signature != null) {
            signature.update(filename.getBytes());
            signature.update(digest);
        }
        // Store the filename and the encoded digest bytes in the manifest
        manifest.put(filename, hexEncode(digest));
        System.out.print('.');
        System.out.flush();
    }
    // If a signer was specified, compute signature for the manifest
    byte[] signaturebytes = null;
    if (signature != null) {
        System.out.print("done\nComputing digital signature...");
        System.out.flush();
        // Compute the digital signature by encrypting a message digest of
        // all the bytes passed to the update() method using the private
        // key of the signer.  This is a time consuming operation.
        signaturebytes = signature.sign();
    }
    // Tell the user what comes next
    System.out.print("done\nWriting manifest...");
    System.out.flush();
    // Store some metadata about this manifest, including the name of the
    // message digest algorithm it uses
    metadata.put("__META.DIGESTALGORITHM", digestAlgorithm);
    // If we're signing the manifest, store some more metadata
    if (signername != null) {
        // Store the name of the signer
        metadata.put("__META.SIGNER", signername);
        // Store the name of the algorithm
        metadata.put("__META.SIGNATUREALGORITHM", signatureAlgorithm);
        // And generate the signature, encode it, and store it
        metadata.put("__META.SIGNATURE", hexEncode(signaturebytes));
    }
    // Now, save the manifest data and the metadata to the manifest file
    FileOutputStream f = new FileOutputStream(manifestfile);
    manifest.store(f, "Manifest message digests");
    metadata.store(f, "Manifest metadata");
    System.out.println("done");
}

{'use'}
/**
     * This method verifies the digital signature of the named manifest
     * file, if it has one, and if that verification succeeds, it verifies
     * the message digest of each file in filelist that is also named in the
     * manifest.  This method can throw a bunch of exceptions
     **/
public static void verify(String manifestfile, KeyStore keystore) throws NoSuchAlgorithmException, SignatureException, InvalidKeyException, KeyStoreException, IOException {
    Properties manifest = new Properties();
    manifest.load(new FileInputStream(manifestfile));
    String digestAlgorithm = manifest.getProperty("__META.DIGESTALGORITHM");
    String signername = manifest.getProperty("__META.SIGNER");
    String signatureAlgorithm = manifest.getProperty("__META.SIGNATUREALGORITHM");
    String hexsignature = manifest.getProperty("__META.SIGNATURE");
    // Get a list of filenames in the manifest.  
    List files = new ArrayList();
    Enumeration names = manifest.propertyNames();
    while (names.hasMoreElements()) {
        String s = (String) names.nextElement();
        if (!s.startsWith("__META"))
            files.add(s);
    }
    int numfiles = files.size();
    // If we've got a signature but no keystore, warn the user
    if (signername != null && keystore == null)
        System.out.println("Can't verify digital signature without " + "a keystore.");
    // verify that signature first
    if (signername != null && keystore != null) {
        System.out.print("Verifying digital signature...");
        System.out.flush();
        // To verify the signature, we must process the files in exactly
        // the same order we did when we created the signature.  We
        // guarantee this order by sorting the filenames.
        Collections.sort(files);
        // Create a Signature object to do signature verification with.
        // Initialize it with the signer's public key from the keystore
        Signature signature = Signature.getInstance(signatureAlgorithm);
        PublicKey publickey = keystore.getCertificate(signername).getPublicKey();
        signature.initVerify(publickey);
        // signature.
        for (int i = 0; i < numfiles; i++) {
            String filename = (String) files.get(i);
            signature.update(filename.getBytes());
            signature.update(hexDecode(manifest.getProperty(filename)));
        }
        // signature is not verified, print an error message and exit.
        if (!signature.verify(hexDecode(hexsignature))) {
            System.out.println("\nManifest has an invalid signature");
            System.exit(0);
        }
        // Tell the user we're done with this lengthy computation
        System.out.println("verified.");
    }
    // Tell the user we're starting the next phase of verification
    System.out.print("Verifying file message digests");
    System.out.flush();
    // Get a MessageDigest object to compute digests
    MessageDigest md = MessageDigest.getInstance(digestAlgorithm);
    // Loop through all files
    for (int i = 0; i < numfiles; i++) {
        String filename = (String) files.get(i);
        // Look up the encoded digest from the manifest file
        String hexdigest = manifest.getProperty(filename);
        // Compute the digest for the file.
        byte[] digest;
        try {
            digest = getFileDigest(filename, md);
        } catch (IOException e) {
            System.out.println("\nSkipping " + filename + ": " + e);
            continue;
        }
        // message.
        if (!hexdigest.equals(hexEncode(digest)))
            System.out.println("\nFile '" + filename + "' failed verification.");
        // Send one dot of output for each file we process.  Since
        // computing message digests takes some time, this lets the user
        // know that the program is functioning and making progress
        System.out.print(".");
        System.out.flush();
    }
    // And tell the user we're done with verification.
    System.out.println("done.");
}

{'computed', 'sorted', 'creating', 'important', 'messagedigest', 'known', 'use', 'contained', 'metadata', 'pas', 'compare', 'read'}
/**
     * This convenience method is used by both create() and verify().  It
     * reads the contents of a named file and computes a message digest
     * for it, using the specified MessageDigest object.
     **/
public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {
    // Make sure there is nothing left behind in the MessageDigest
    md.reset();
    // Create a stream to read from the file and compute the digest
    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);
    // the update() method of the MessageDigest
    while (in.read(buffer) != -1) /* do nothing */
    ;
    // Finally, compute and return the digest value.
    return md.digest();
}

{'everything', 'messagedigest', 'end', 'discarding', 'pass', 'digestinputstream', 'automatically'}
/** 
     * This main method creates and starts two threads in addition to the 
     * initial thread that the interpreter creates to invoke the main() method.
     **/
public static void main(String[] args) {
    // Create the first thread: an instance of this class.  Its body is
    // the run() method above
    ThreadDemo thread1 = new ThreadDemo();
    // Create the second thread by passing a Runnable object to the 
    // Thread() construtor.  The body of this thread is the run() method
    // of the anonymous Runnable object below.
    Thread thread2 = new Thread(new Runnable() {

        public void run() {
            for (int i = 0; i < 5; i++) compute();
        }
    });
    // Set the priorities of these two threads, if any are specified
    if (args.length >= 1)
        thread1.setPriority(Integer.parseInt(args[0]));
    if (args.length >= 2)
        thread2.setPriority(Integer.parseInt(args[1]));
    // Start the two threads running
    thread1.start();
    thread2.start();
    // Java interpreter.  Now that thread does some stuff, too.
    for (int i = 0; i < 5; i++) compute();
// We could wait for the threads to stop running with these lines
// But they aren't necessary here, so we don't bother.
// try {
//     thread1.join();
//     thread2.join();
// } catch (InterruptedException e) {}
// The Java VM exits only when the main() method returns, and when all
// threads stop running (except for daemon threads--see setDaemon()).
}

{'created', 'interruptedexception', 'setdaemon'}
/** This is the dummy method our threads all call */
static synchronized void compute() {
    // Figure out how many times we've been called by the current thread
    Integer n = (Integer) numcalls.get();
    if (n == null)
        n = new Integer(1);
    else
        n = new Integer(n.intValue() + 1);
    numcalls.set(n);
    // Display the name of the thread, and the number of times called
    System.out.println(Thread.currentThread().getName() + ": " + n);
    // Do a long computation, simulating a "compute-bound" thread
    for (int i = 0, j = 0; i < 1000000; i++) j += i;
    // delays by causing it to sleep for a random amount of time:
    try {
        // Stop running for a random number of milliseconds
        Thread.sleep((int) (Math.random() * 100 + 1));
    } catch (InterruptedException e) {
    }
    // Each thread politely offers the other threads a chance to run.
    // This is important so that a compute-bound thread does not "starve"
    // other threads of equal priority.
    Thread.yield();
}

{'simulate', 'alternatively', 'subject', 'network'}
/** The main constructor: the internal thread is a daemon if specified */
public Timer(boolean isDaemon) {
    // TimerThread is defined below
    timer = new TimerThread(isDaemon);
    // Start the thread running
    timer.start();
}

{'timerthread'}
// This is the body of the thread
public void run() {
    // Is there a task to run right now?
    TimerTask readyToRun = null;
    // The thread loops until the stopped flag is set to true.
    while (!stopped) {
        // If there is a task that is ready to run, then run it!
        if (readyToRun != null) {
            if (readyToRun.cancelled) {
                // If it was cancelled, skip.
                readyToRun = null;
                continue;
            }
            // Run the task.
            readyToRun.run();
            // again, then insert it back into the set of tasks.
            if (readyToRun.reschedule())
                schedule(readyToRun);
            // We've run it, so there is nothing to run now
            readyToRun = null;
            // Go back to top of the loop to see if we've been stopped
            continue;
        }
        // Now acquire a lock on the set of tasks
        synchronized (tasks) {
            // how many ms 'till the next execution?
            long timeout;
            if (tasks.isEmpty()) {
                // If there aren't any tasks
                // Wait 'till notified of a new task
                timeout = 0;
            } else {
                // If there are scheduled tasks, then get the first one
                // Since the set is sorted, this is the next one.
                TimerTask t = (TimerTask) tasks.first();
                // How long 'till it is next run?
                timeout = t.nextTime - System.currentTimeMillis();
                // Check whether it needs to run now
                if (timeout <= 0) {
                    // Save it as ready to run
                    readyToRun = t;
                    // Remove it from the set
                    tasks.remove(t);
                    // we run the task
                    continue;
                }
            }
            // called when something new is added to the set of tasks.
            try {
                tasks.wait(timeout);
            } catch (InterruptedException e) {
            }
        // When we wake up, go back up to the top of the while loop
        }
    }
}

{'break', 'section', 'want', 'ask', 'notify'}
public void run() {
    // Lock resource 1
    synchronized (resource1) {
        System.out.println("Thread 1: locked resource 1");
        // deadlock to happen here...
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
        }
        // Now wait 'till we can get a lock on resource 2
        synchronized (resource2) {
            System.out.println("Thread 1: locked resource 2");
        }
    }
}

{'thing', 'file', 'pause', 'bit', 'want', 'trying', 'give', 'basically', 'simulating', 'force', 'chance', 'something', 'asynchronous'}
public void run() {
    // This thread locks resource 2 right away
    synchronized (resource2) {
        System.out.println("Thread 2: locked resource 2");
        // Then it pauses, just like the first thread.
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
        }
        // thread can run, and the program freezes up.
        synchronized (resource1) {
            System.out.println("Thread 2: locked resource 1");
        }
    }
}

{'wait', 'hold', 'release', 'get', 'till', 'impasse', 'neither'}
public static void main(String[] args) {
    // These are the two resource objects we'll try to get locks for
    final Object resource1 = "resource1";
    final Object resource2 = "resource2";
    // Here's the first thread.  It tries to lock resource1 then resource2
    Thread t1 = new Thread() {

        public void run() {
            // Lock resource 1
            synchronized (resource1) {
                System.out.println("Thread 1: locked resource 1");
                // deadlock to happen here...
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                }
                // Now wait 'till we can get a lock on resource 2
                synchronized (resource2) {
                    System.out.println("Thread 1: locked resource 2");
                }
            }
        }
    };
    // Here's the second thread.  It tries to lock resource2 then resource1
    Thread t2 = new Thread() {

        public void run() {
            // This thread locks resource 2 right away
            synchronized (resource2) {
                System.out.println("Thread 2: locked resource 2");
                // Then it pauses, just like the first thread.
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                }
                // thread can run, and the program freezes up.
                synchronized (resource1) {
                    System.out.println("Thread 2: locked resource 1");
                }
            }
        }
    };
    // Start the two threads. If all goes as planned, deadlock will occur, 
    // and the program will never exit.
    t1.start();
    t2.start();
}

{'thing', 'file', 'want', 'bit', 'trying', 'hold', 'give', 'release', 'basically', 'simulating', 'force', 'chance', 'impasse', 'neither', 'something', 'asynchronous'}
/**
     * The main() method create a simple graphical user interface to display
     * the threads in.  This allows us to see the "event dispatch thread" used
     * by AWT and Swing.
     **/
public static void main(String[] args) {
    // Create a simple Swing GUI
    JFrame frame = new JFrame("ThreadLister Demo");
    JTextArea textarea = new JTextArea();
    frame.getContentPane().add(new JScrollPane(textarea), BorderLayout.CENTER);
    frame.setSize(500, 400);
    frame.setVisible(true);
    // Get the threadlisting as a string using a StringWriter stream
    // To capture the listing 
    StringWriter sout = new StringWriter();
    PrintWriter out = new PrintWriter(sout);
    // List threads to stream
    ThreadLister.listAllThreads(out);
    out.close();
    // Get listing as a string
    String threadListing = sout.toString();
    // Finally, display the thread listing in the GUI
    textarea.setText(threadListing);
}

{'stringwriter'}
public void run() {
    char[] buffer = new char[1024];
    int chars_read;
    try {
        // Read characters until the stream closes
        while ((chars_read = from_server.read(buffer)) != -1) {
            // faster than the network is, which is good enough
            for (int i = 0; i < chars_read; i++) {
                if (buffer[i] == '\n')
                    to_user.println();
                else
                    to_user.print(buffer[i]);
            }
            to_user.flush();
        }
    } catch (IOException e) {
        to_user.println(e);
    }
    // When the server closes the connection, the loop above
    // will end.  Tell the user what happened, and call
    // System.exit(), causing the main thread to exit along
    // with this one.
    to_user.println("Connection closed by server.");
    System.exit(0);
}

{'converting', 'array', 'efficient', 'probably', 'terminator', 'could', 'local', 'platform', 'line'}
public static void main(String[] args) throws IOException {
    try {
        // Check the number of arguments
        if (args.length != 2)
            throw new IllegalArgumentException("Wrong number of args");
        // Parse the host and port specifications
        String host = args[0];
        int port = Integer.parseInt(args[1]);
        // Connect to the specified host and port
        Socket s = new Socket(host, port);
        // Set up streams for reading from and writing to the server.
        // The from_server stream is final for use in the inner class below
        final Reader from_server = new InputStreamReader(s.getInputStream());
        PrintWriter to_server = new PrintWriter(s.getOutputStream());
        // Set up streams for reading from and writing to the console
        // The to_user stream is final for use in the anonymous class below
        BufferedReader from_user = new BufferedReader(new InputStreamReader(System.in));
        // Pass true for auto-flush on println()
        final PrintWriter to_user = new PrintWriter(System.out, true);
        // Tell the user that we've connected
        to_user.println("Connected to " + s.getInetAddress() + ":" + s.getPort());
        // Create a thread that gets output from the server and displays 
        // it to the user.  We use a separate thread for this so that we
        // can receive asynchronous output
        Thread t = new Thread() {

            public void run() {
                char[] buffer = new char[1024];
                int chars_read;
                try {
                    // Read characters until the stream closes
                    while ((chars_read = from_server.read(buffer)) != -1) {
                        // faster than the network is, which is good enough
                        for (int i = 0; i < chars_read; i++) {
                            if (buffer[i] == '\n')
                                to_user.println();
                            else
                                to_user.print(buffer[i]);
                        }
                        to_user.flush();
                    }
                } catch (IOException e) {
                    to_user.println(e);
                }
                // When the server closes the connection, the loop above
                // will end.  Tell the user what happened, and call
                // System.exit(), causing the main thread to exit along
                // with this one.
                to_user.println("Connection closed by server.");
                System.exit(0);
            }
        };
        // We set the priority of the server-to-user thread above to be
        // one level higher than the main thread.  We shouldn't have to do
        // this, but on some operating systems, output sent to the console
        // doesn't appear when a thread at the same priority level is
        // blocked waiting for input from the console.
        t.setPriority(Thread.currentThread().getPriority() + 1);
        // Now start the server-to-user thread
        t.start();
        // In parallel, read the user's input and pass it on to the server.
        String line;
        while ((line = from_user.readLine()) != null) {
            to_server.print(line + "\n");
            to_server.flush();
        }
        // If the user types a Ctrl-D (Unix) or Ctrl-Z (Windows) to end
        // their input, we'll get an EOF, and the loop above will exit.
        // When this happens, we stop the server-to-user thread and close
        // the socket.
        s.close();
        to_user.println("Connection closed by client.");
        System.exit(0);
    }// If anything goes wrong, print an error message
     catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java GenericClient <hostname> <port>");
    }
}

{'converting', 'array', 'efficient', 'probably', 'terminator', 'local', 'could', 'platform'}
public static void main(String args[]) {
    try {
        // Get the port to listen on
        int port = Integer.parseInt(args[0]);
        // Create a ServerSocket to listen on that port.
        ServerSocket ss = new ServerSocket(port);
        // Now enter an infinite loop, waiting for & handling connections.
        for (; ; ) {
            // Wait for a client to connect.  The method will block;
            // when it returns the socket will be connected to the client
            Socket client = ss.accept();
            // Get input and output streams to talk to the client 
            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
            PrintWriter out = new PrintWriter(client.getOutputStream());
            // Start sending our reply, using the HTTP 1.0 protocol
            // Version & status code
            out.print("HTTP/1.0 200 \n");
            // The type of data
            out.print("Content-Type: text/plain\n");
            // End of headers
            out.print("\n");
            // Now, read the HTTP request from the client, and send it
            // right back to the client as part of the body of our
            // response.  The client doesn't disconnect, so we never get
            // an EOF.  It does sends an empty line at the end of the
            // headers, though.  So when we see the empty line, we stop
            // reading.  This means we don't mirror the contents of POST
            // requests, for example.  Note that the readLine() method 
            // works with Unix, Windows, and Mac line terminators.
            String line;
            while ((line = in.readLine()) != null) {
                if (line.length() == 0)
                    break;
                out.print(line + "\n");
            }
            // Close socket, breaking the connection to the client, and
            // closing the input and output streams
            // Flush and close the output stream
            out.close();
            // Close the input stream
            in.close();
            // Close the socket itself
            client.close();
        }
    // Now loop again, waiting for the next connection
    }// If anything goes wrong, print an error message
     catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java HttpMirror <port>");
    }
}

{'serversocket', 'readline'}
public static void main(String[] args) {
    try {
        // If the user specified a mailhost, tell the system about it.
        if (args.length >= 1)
            System.getProperties().put("mail.host", args[0]);
        // A Reader stream to read from the console
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        // Ask the user for the from, to, and subject lines
        System.out.print("From: ");
        String from = in.readLine();
        System.out.print("To: ");
        String to = in.readLine();
        System.out.print("Subject: ");
        String subject = in.readLine();
        // Establish a network connection for sending mail
        // Create a mailto: URL 
        URL u = new URL("mailto:" + to);
        // Create its URLConnection
        URLConnection c = u.openConnection();
        // Specify no input from it
        c.setDoInput(false);
        // Specify we'll do output
        c.setDoOutput(true);
        // Tell the user
        System.out.println("Connecting...");
        // Tell them right now
        System.out.flush();
        // Connect to mail host
        c.connect();
        PrintWriter // Get output stream to host
        out = new PrintWriter(new OutputStreamWriter(c.getOutputStream()));
        // Write out mail headers.  Don't let users fake the From address
        out.print("From: \"" + from + "\" <" + System.getProperty("user.name") + "@" + InetAddress.getLocalHost().getHostName() + ">\n");
        out.print("To: " + to + "\n");
        out.print("Subject: " + subject + "\n");
        // blank line to end the list of headers
        out.print("\n");
        // Now ask the user to enter the body of the message
        System.out.println("Enter the message. " + "End with a '.' on a line by itself.");
        // Read message line by line and send it out.
        String line;
        for (; ; ) {
            line = in.readLine();
            if ((line == null) || line.equals("."))
                break;
            out.print(line + "\n");
        }
        // Close (and flush) the stream to terminate the message 
        out.close();
        // Tell the user it was successfully sent.
        System.out.println("Message sent.");
    } catch (// Handle any exceptions, print error message.
    Exception // Handle any exceptions, print error message.
    e) {
        System.err.println(e);
        System.err.println("Usage: java SendMail [<mailhost>]");
    }
}

{'urlconnection'}
/** The main method parses arguments and passes them to runServer */
public static void main(String[] args) throws IOException {
    try {
        // Check the number of arguments
        if (args.length != 3)
            throw new IllegalArgumentException("Wrong number of args.");
        // Get the command-line arguments: the host and port we are proxy
        // for and the local port that we listen for connections on.
        String host = args[0];
        int remoteport = Integer.parseInt(args[1]);
        int localport = Integer.parseInt(args[2]);
        // Print a start-up message
        System.out.println("Starting proxy for " + host + ":" + remoteport + " on port " + localport);
        // And start running the server
        // never returns
        runServer(host, remoteport, localport);
    } catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java SimpleProxyServer " + "<host> <remoteport> <localport>");
    }
}

{'runserver'}
public void run() {
    int bytes_read;
    try {
        while ((bytes_read = from_client.read(request)) != -1) {
            to_server.write(request, 0, bytes_read);
            to_server.flush();
        }
    } catch (IOException e) {
    }
    // server-to-client loop in the main thread exit.
    try {
        to_server.close();
    } catch (IOException e) {
    }
}

{'cause', 'connection', 'u', 'closed', 'also'}
/**
     * This method runs a single-threaded proxy server for 
     * host:remoteport on the specified local port.  It never returns.
     **/
public static void runServer(String host, int remoteport, int localport) throws IOException {
    // Create a ServerSocket to listen for connections with
    ServerSocket ss = new ServerSocket(localport);
    // Create buffers for client-to-server and server-to-client transfer.
    // We make one final so it can be used in an anonymous class below.
    // Note the assumptions about the volume of traffic in each direction.
    final byte[] request = new byte[1024];
    byte[] reply = new byte[4096];
    // This is a server that never returns, so enter an infinite loop.
    while (true) {
        // Variables to hold the sockets to the client and to the server.
        Socket client = null, server = null;
        try {
            // Wait for a connection on the local port
            client = ss.accept();
            // Get client streams.  Make them final so they can
            // be used in the anonymous thread below.
            final InputStream from_client = client.getInputStream();
            final OutputStream to_client = client.getOutputStream();
            // client, disconnect, and continue waiting for connections.
            try {
                server = new Socket(host, remoteport);
            } catch (IOException e) {
                PrintWriter out = new PrintWriter(to_client);
                out.print("Proxy server cannot connect to " + host + ":" + remoteport + ":\n" + e + "\n");
                out.flush();
                client.close();
                continue;
            }
            // Get server streams.
            final InputStream from_server = server.getInputStream();
            final OutputStream to_server = server.getOutputStream();
            // Make a thread to read the client's requests and pass them
            // to the server.  We have to use a separate thread because
            // requests and responses may be asynchronous.
            Thread t = new Thread() {

                public void run() {
                    int bytes_read;
                    try {
                        while ((bytes_read = from_client.read(request)) != -1) {
                            to_server.write(request, 0, bytes_read);
                            to_server.flush();
                        }
                    } catch (IOException e) {
                    }
                    // server-to-client loop in the main thread exit.
                    try {
                        to_server.close();
                    } catch (IOException e) {
                    }
                }
            };
            // Start the client-to-server request thread running
            t.start();
            // Meanwhile, in the main thread, read the server's responses
            // and pass them back to the client.  This will be done in
            // parallel with the client-to-server request thread above.
            int bytes_read;
            try {
                while ((bytes_read = from_server.read(reply)) != -1) {
                    to_client.write(reply, 0, bytes_read);
                    to_client.flush();
                }
            } catch (IOException e) {
            }
            // The server closed its connection to us, so we close our 
            // connection to our client.
            // This will make the other thread exit.
            to_client.close();
        } catch (IOException e) {
            System.err.println(e);
        } finally {
            // Close the sockets no matter what happens.
            try {
                if (server != null)
                    server.close();
                if (client != null)
                    client.close();
            } catch (IOException e) {
            }
        }
    }
}

{'send', 'serversocket', 'error', 'also', 'cause', 'real'}
/** Use the URLConnection class to get info about the URL */
public static void printinfo(URL url) throws IOException {
    // Get URLConnection from URL
    URLConnection c = url.openConnection();
    // Open a connection to URL
    c.connect();
    // Display some information about the URL contents
    System.out.println("  Content Type: " + c.getContentType());
    System.out.println("  Content Encoding: " + c.getContentEncoding());
    System.out.println("  Content Length: " + c.getContentLength());
    System.out.println("  Date: " + new Date(c.getDate()));
    System.out.println("  Last Modified: " + new Date(c.getLastModified()));
    System.out.println("  Expiration: " + new Date(c.getExpiration()));
    // If it is an HTTP connection, display some additional information.
    if (c instanceof HttpURLConnection) {
        HttpURLConnection h = (HttpURLConnection) c;
        System.out.println("  Request Method: " + h.getRequestMethod());
        System.out.println("  Response Message: " + h.getResponseMessage());
        System.out.println("  Response Code: " + h.getResponseCode());
    }
}

{'urlconnection'}
/**
     * This is the method that does the networking and displays the results.
     * It is implemented as the body of a separate thread because it might
     * take some time to complete, and applet methods need to return promptly.
     **/
public void run() {
    // Disable the button so we don't get multiple queries at once...
    who.setEnabled(false);
    // Create a window to display the output in
    Frame f = new Frame("Who's Logged On: Connecting...");
    f.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            ((Frame) e.getSource()).dispose();
        }
    });
    TextArea t = new TextArea(10, 80);
    t.setFont(new Font("MonoSpaced", Font.PLAIN, 10));
    f.add(t, "Center");
    f.pack();
    f.show();
    // Find out  who's logged on
    Socket s = null;
    PrintWriter out = null;
    BufferedReader in = null;
    try {
        // Connect to port 79 (the standard finger port) on the host
        // that the applet was loaded from.
        String hostname = this.getCodeBase().getHost();
        s = new Socket(hostname, 79);
        // Set up the streams
        out = new PrintWriter(new OutputStreamWriter(s.getOutputStream()));
        in = new BufferedReader(new InputStreamReader(s.getInputStream()));
        // Send a blank line to the finger server, telling it that we want
        // a listing of everyone logged on instead of information about an
        // individual user.
        out.print("\n");
        // Send it now!
        out.flush();
        // Now read the server's response and display it in the textarea
        // The server should send lines terminated with \n.  The 
        // readLine() method will detect these lines, even when running
        // on a Mac that terminates lines with \r
        String line;
        while ((line = in.readLine()) != null) {
            t.append(line);
            t.append("\n");
        }
        // Update the window title to indicate we're finished
        f.setTitle("Who's Logged On: " + hostname);
    }// If something goes wrong, we'll just display the exception message
     catch (IOException e) {
        t.append(e.toString());
        f.setTitle("Who's Logged On: Error");
    } finally // And finally, don't forget to close the streams!
    {
        try {
            in.close();
            out.close();
            s.close();
        } catch (Exception e) {
        }
    }
    // And enable the button again
    who.setEnabled(true);
}

{'readline'}
/**
	 * The Listener constructor creates a thread for itself in the
	 * threadgroup.  It creates a ServerSocket to listen for connections
	 * on the specified port.  It arranges for the ServerSocket to be
	 * interruptible, so that services can be removed from the server.
	 **/
public Listener(ThreadGroup group, int port, Service service) throws IOException {
    super(group, "Listener:" + port);
    listen_socket = new ServerSocket(port);
    // give it a non-zero timeout so accept() can be interrupted
    listen_socket.setSoTimeout(600000);
    this.port = port;
    this.service = service;
}

{'serversocket'}
/**
	 * A Listener is a Thread, and this is its body.
	 * Wait for connection requests, accept them, and pass the socket on
	 * to the addConnection method of the server.
	 **/
public void run() {
    while (!stop) {
        // loop until we're asked to stop.
        try {
            Socket client = listen_socket.accept();
            addConnection(client, service);
        } catch (InterruptedIOException e) {
        } catch (IOException e) {
            log(e);
        }
    }
}

{'addconnection'}
/**
	 * This constructor just saves some state and calls the superclass
	 * constructor to create a thread to handle the connection.  Connection
	 * objects are created by Listener threads.  These threads are part of
	 * the server's ThreadGroup, so all Connection threads are part of that
	 * group, too.
	 **/
public Connection(Socket client, Service service) {
    super("Server.Connection:" + client.getInetAddress().getHostAddress() + ":" + client.getPort());
    this.client = client;
    this.service = service;
}

{'threadgroup'}
/**
	 * This is the body of each and every Connection thread.
	 * All it does is pass the client input and output streams to the
	 * serve() method of the specified Service object.  That method is
	 * responsible for reading from and writing to those streams to
	 * provide the actual service.  Recall that the Service object has
	 * been passed from the Server.addService() method to a Listener
	 * object to the addConnection() method to this Connection object, and
	 * is now finally being used to provide the service.  Note that just
	 * before this thread exits it always calls the endConnection() method
	 * to remove itself from the set of connections
	 **/
public void run() {
    try {
        InputStream in = client.getInputStream();
        OutputStream out = client.getOutputStream();
        service.serve(in, out);
    } catch (IOException e) {
        log(e);
    } finally {
        endConnection(this);
    }
}

{'endconnection', 'addservice', 'addconnection'}
/**
	 * This is the serve method that provides the service.  It reads a
	 * line the client, and uses java.util.StringTokenizer to parse it
	 * into commands and arguments.  It does various things depending on
	 * the command.
	 **/
public void serve(InputStream i, OutputStream o) throws IOException {
    // Setup the streams
    BufferedReader in = new BufferedReader(new InputStreamReader(i));
    PrintWriter out = new PrintWriter(o);
    // For reading client input lines
    String line;
    // Has the user has given the password yet?
    boolean authorized = false;
    // synchronized block to prevent a race condition.
    synchronized (this) {
        if (connected) {
            out.print("ONLY ONE CONTROL CONNECTION ALLOWED.\n");
            out.close();
            return;
        } else
            connected = true;
    }
    // This is the main loop: read a command, parse it, and handle it
    for (; ; ) {
        // infinite loop
        // Display a prompt
        out.print("> ");
        // Make it appear right away
        out.flush();
        // Get the user's input
        line = in.readLine();
        // Quit if we get EOF.
        if (line == null)
            break;
        try {
            // Use a StringTokenizer to parse the user's command
            StringTokenizer t = new StringTokenizer(line);
            // if input was empty
            if (!t.hasMoreTokens())
                continue;
            // Get first word of the input and convert to lower case
            String command = t.nextToken().toLowerCase();
            // appropriate thing for each command
            if (command.equals("password")) {
                // Password command
                // Get the next word
                String p = t.nextToken();
                if (p.equals(this.password)) {
                    // Is it the password?
                    // Say so
                    out.print("OK\n");
                    // Grant authorization
                    authorized = true;
                } else
                    // Otherwise fail
                    out.print("INVALID PASSWORD\n");
            } else if (command.equals("add")) {
                // Check whether password has been given
                if (!authorized)
                    out.print("PASSWORD REQUIRED\n");
                else {
                    // Get the name of the service and try to
                    // dynamically load and instantiate it.
                    // Exceptions will be handled below
                    String serviceName = t.nextToken();
                    Class serviceClass = Class.forName(serviceName);
                    Service service;
                    try {
                        service = (Service) serviceClass.newInstance();
                    } catch (NoSuchMethodError e) {
                        throw new IllegalArgumentException("Service must have a " + "no-argument constructor");
                    }
                    int port = Integer.parseInt(t.nextToken());
                    // If no exceptions occurred, add the service
                    server.addService(service, port);
                    // acknowledge
                    out.print("SERVICE ADDED\n");
                }
            } else if (command.equals("remove")) {
                // Remove service
                if (!authorized)
                    out.print("PASSWORD REQUIRED\n");
                else {
                    int port = Integer.parseInt(t.nextToken());
                    // remove the service
                    server.removeService(port);
                    // acknowledge
                    out.print("SERVICE REMOVED\n");
                }
            } else if (command.equals("max")) {
                // Set connection limit
                if (!authorized)
                    out.print("PASSWORD REQUIRED\n");
                else {
                    int max = Integer.parseInt(t.nextToken());
                    server.setMaxConnections(max);
                    out.print("MAX CONNECTIONS CHANGED\n");
                }
            } else if (command.equals("status")) {
                // Status Display
                if (!authorized)
                    out.print("PASSWORD REQUIRED\n");
                else
                    server.displayStatus(out);
            } else if (command.equals("help")) {
                // Help command
                // Display command syntax.  Password not required
                out.print("COMMANDS:\n" + "\tpassword <password>\n" + "\tadd <service> <port>\n" + "\tremove <port>\n" + "\tmax <max-connections>\n" + "\tstatus\n" + "\thelp\n" + "\tquit\n");
            } else if (// Quit command.
            command.equals("quit"))
                // Quit command.
                break;
            else
                // Error
                out.print("UNRECOGNIZED COMMAND\n");
        } catch (Exception e) {
            out.print("ERROR WHILE PARSING OR EXECUTING COMMAND:\n" + e + "\n");
        }
    }
    // Finally, when the loop command loop ends, close the streams
    // and set our connected flag to false so that other clients can
    // now connect.
    connected = false;
    out.close();
    in.close();
}

{'detail', 'stringtokenizer', 'possible', 'already', 'compare', 'message'}
public static void display(Throwable error) {
    ResourceBundle bundle;
    // If none, print the error in a non-localized way.
    try {
        bundle = ResourceBundle.getBundle("Errors");
    } catch (MissingResourceException e) {
        error.printStackTrace(System.err);
        return;
    }
    // Look up a localized message resource in that bundle, using the
    // classname of the error (or its superclasses) as the resource name.
    // If no resource was found, display the error without localization.
    String message = null;
    Class c = error.getClass();
    while ((message == null) && (c != Object.class)) {
        try {
            message = bundle.getString(c.getName());
        } catch (MissingResourceException e) {
            c = c.getSuperclass();
        }
    }
    if (message == null) {
        error.printStackTrace(System.err);
        return;
    }
    // Try to figure out the filename and line number of the
    // exception.  Output the error's stack trace into a string, and
    // use the heuristic that the first line number that appears in
    // the stack trace is after the first or  second colon.  We assume that
    // this stack frame is the first one the programmer has any control
    // over, and so report it as the location of the exception.
    // Note that this is implementation-dependent and not robust...
    String filename = "";
    int linenum = 0;
    try {
        // Output stream to a string.
        StringWriter sw = new StringWriter();
        // PrintWriter wrapper.
        PrintWriter out = new PrintWriter(sw);
        // Print stacktrace.
        error.printStackTrace(out);
        // Get it as a string.
        String trace = sw.toString();
        // Look for first colon.
        int pos = trace.indexOf(':');
        if (// If the error has a message
        error.getMessage() != null)
            // look for second colon.
            pos = trace.indexOf(':', pos + 1);
        // Look for end of line #
        int pos2 = trace.indexOf(')', pos);
        // line #
        linenum = Integer.parseInt(trace.substring(pos + 1, pos2));
        // Back to start of filename.
        pos2 = trace.lastIndexOf('(', pos);
        // Get filename.
        filename = trace.substring(pos2 + 1, pos);
    }// Ignore exceptions.
     catch (Exception e) {
        ;
    }
    // Set up an array of arguments to use with the message
    String errmsg = error.getMessage();
    Object[] args = { ((errmsg != null) ? errmsg : ""), error.getClass().getName(), filename, new Integer(linenum), new Date() };
    // Finally, display the localized error message, using
    // MessageFormat.format() to substitute the arguments into the message.
    System.out.println(MessageFormat.format(message, args));
}

{'messageformat', 'printwriter'}
/** 
     * This is a simple test program that demonstrates the display() method.
     * You can use it to generate and display a FileNotFoundException or an
     * ArrayIndexOutOfBoundsException
     **/
public static void main(String[] args) {
    try {
        FileReader in = new FileReader(args[0]);
    } catch (Exception e) {
        LocalizedError.display(e);
    }
}

{'arrayindexoutofboundsexception', 'filenotfoundexception'}
public void print(PrintWriter out) {
    // Obtain NumberFormat and DateFormat objects to format our data.
    NumberFormat number = NumberFormat.getInstance();
    NumberFormat price = NumberFormat.getCurrencyInstance();
    NumberFormat percent = NumberFormat.getPercentInstance();
    DateFormat shortdate = DateFormat.getDateInstance(DateFormat.MEDIUM);
    DateFormat fulldate = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
    // Print some introductory data.
    out.println("Portfolio value at " + fulldate.format(lastQuoteTime) + ":");
    out.println("Symbol\tShares\tPurchased\tAt\t" + "Quote\tChange");
    // Display the table using the format() methods of the Format objects.
    for (int i = 0; i < positions.length; i++) {
        out.print(positions[i].name + "\t");
        out.print(number.format(positions[i].shares) + "\t");
        out.print(shortdate.format(positions[i].purchased) + "\t");
        out.print(price.format(positions[i].bought) + "\t");
        out.print(price.format(positions[i].current) + "\t");
        double change = (positions[i].current - positions[i].bought) / positions[i].bought;
        out.println(percent.format(change));
        out.flush();
    }
}

{'numberformat', 'dateformat'}
/**
     * This is a test program that demonstrates the class
     **/
public static void main(String[] args) {
    // This is the portfolio to display.  Note we use a deprecated
    // Date() constructor here for convenience. It represents the year
    // offset from 1900, and will cause a warning message when compiling.
    EquityPosition[] positions = new EquityPosition[] { new EquityPosition("XXX", 400, new Date(100, 1, 3), 11.90, 13.00), new EquityPosition("YYY", 1100, new Date(100, 2, 2), 71.09, 27.25), new EquityPosition("ZZZ", 6000, new Date(100, 4, 17), 23.37, 89.12) };
    // Create the portfolio from these positions
    Portfolio portfolio = new Portfolio(positions, new Date());
    // specified on the command line.
    if (args.length == 2)
        Locale.setDefault(new Locale(args[0], args[1]));
    // Now print the portfolio
    portfolio.print(new PrintWriter(System.out));
}

{'using', 'language', 'country', 'code'}
/** A simple test program for the above code */
public static void main(String[] args) {
    // Get the locale: default, or specified on command-line
    Locale locale;
    if (args.length == 2)
        locale = new Locale(args[0], args[1]);
    else
        locale = Locale.getDefault();
    // Get the resource bundle for that Locale.  This will throw an
    // (unchecked) MissingResourceException if no bundle is found.
    ResourceBundle bundle = ResourceBundle.getBundle("com.davidflanagan.examples.i18n.Menus", locale);
    // Create a simple GUI window to display the menu with
    final JFrame f = new JFrame(// Window title
    "SimpleMenu: " + locale.getDisplayName(Locale.getDefault()));
    // Create a menubar.
    JMenuBar menubar = new JMenuBar();
    // Add menubar to window
    f.setJMenuBar(menubar);
    // Define an action listener for that our menu will use.
    ActionListener listener = new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            String s = e.getActionCommand();
            Component c = f.getContentPane();
            if (s.equals("red"))
                c.setBackground(Color.red);
            else if (s.equals("green"))
                c.setBackground(Color.green);
            else if (s.equals("blue"))
                c.setBackground(Color.blue);
        }
    };
    // Now create a menu using our convenience routine with the resource
    // bundle and action listener we've created
    JMenu menu = SimpleMenu.create(bundle, "colors", new String[] { "red", "green", "blue" }, listener);
    // Finally add the menu to the GUI, and pop it up
    // Add the menu to the menubar
    menubar.add(menu);
    // Set the window size.
    f.setSize(300, 150);
    // Pop the window up.
    f.setVisible(true);
}

{'missingresourceexception'}
public static void main(String[] args) {
    String from = null, to = null;
    String infile = null, outfile = null;
    for (int i = 0; i < args.length; i++) {
        // All args require another.
        if (i == args.length - 1)
            usage();
        if (args[i].equals("-from"))
            from = args[++i];
        else if (args[i].equals("-to"))
            to = args[++i];
        else if (args[i].equals("-in"))
            infile = args[++i];
        else if (args[i].equals("-out"))
            outfile = args[++i];
        else
            usage();
    }
    try // Attempt conversion.
    {
        convert(infile, outfile, from, to);
    } catch (// Handle exceptions.
    Exception // Handle exceptions.
    e) {
        LocalizedError.display(e);
        System.exit(1);
    }
}

{'defined', 'argument', 'end', 'command', 'chapter', 'parse', 'line'}
public static void convert(String infile, String outfile, String from, String to) throws IOException, UnsupportedEncodingException {
    // Set up byte streams.
    InputStream in;
    if (infile != null)
        in = new FileInputStream(infile);
    else
        in = System.in;
    OutputStream out;
    if (outfile != null)
        out = new FileOutputStream(outfile);
    else
        out = System.out;
    // Use default encoding if no encoding is specified.
    if (from == null)
        from = System.getProperty("file.encoding");
    if (to == null)
        to = System.getProperty("file.encoding");
    // Set up character streams.
    Reader r = new BufferedReader(new InputStreamReader(in, from));
    Writer w = new BufferedWriter(new OutputStreamWriter(out, to));
    // Copy characters from input to output.  The InputStreamReader
    // converts from the input encoding to Unicode, and the
    // OutputStreamWriter converts from Unicode to the output encoding.
    // Characters that cannot be represented in the output encoding are
    // output as '?'
    char[] buffer = new char[4096];
    int len;
    while (// Read a block of input.
    (len = r.read(buffer)) != -1) // And write it out.
    w.write(buffer, 0, len);
    // Close the input.
    r.close();
    // Flush and close output.
    w.close();
}

{'inputstreamreader', 'outputstreamwriter'}
/** 
     * This constructor creates the frame, menubar, and scrollbar
     * that work along with the UnicodePanel class, defined below
     **/
public UnicodeDisplay(String name) {
    super(name);
    // Create the panel
    p = new UnicodePanel();
    // Initialize it
    p.setBase((char) (page * 0x100));
    // Center it
    getContentPane().add(p, "Center");
    // Create and set up a scrollbar, and put it on the right
    b = new JScrollBar(Scrollbar.VERTICAL, 0, 1, 0, 0xFF);
    b.setUnitIncrement(1);
    b.setBlockIncrement(0x10);
    b.addAdjustmentListener(new AdjustmentListener() {

        public void adjustmentValueChanged(AdjustmentEvent e) {
            page = e.getValue();
            p.setBase((char) (page * 0x100));
        }
    });
    getContentPane().add(b, "East");
    // Set things up so we respond to window close requests
    this.addWindowListener(new WindowAdapter() {

        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
    // Handle Page Up and Page Down and the up and down arrow keys
    this.addKeyListener(new KeyAdapter() {

        public void keyPressed(KeyEvent e) {
            int code = e.getKeyCode();
            int oldpage = page;
            if ((code == KeyEvent.VK_PAGE_UP) || (code == KeyEvent.VK_UP)) {
                if (e.isShiftDown())
                    page -= 0x10;
                else
                    page -= 1;
                if (page < 0)
                    page = 0;
            } else if ((code == KeyEvent.VK_PAGE_DOWN) || (code == KeyEvent.VK_DOWN)) {
                if (e.isShiftDown())
                    page += 0x10;
                else
                    page += 1;
                if (page > 0xff)
                    page = 0xff;
            }
            if (page != oldpage) {
                // if anything has changed...
                // update the display
                p.setBase((char) (page * 0x100));
                // and update scrollbar to match
                b.setValue(page);
            }
        }
    });
    // Set up a menu system to change fonts.  Use a convenience method.
    JMenuBar menubar = new JMenuBar();
    this.setJMenuBar(menubar);
    menubar.add(makemenu("Font Family", new String[] { "Serif", "SansSerif", "Monospaced" }, this));
    menubar.add(makemenu("Font Style", new String[] { "Plain", "Italic", "Bold", "BoldItalic" }, this));
}

{'unicodepanel'}
/**
	 * The paintComponent() method actually draws the page of glyphs 
	 **/
public void paintComponent(Graphics g) {
    // Start on a 16-character boundary
    int start = (int) base & 0xFFF0;
    // Draw the headings in a special font
    g.setFont(headingfont);
    // Draw 0..F on top
    for (int i = 0; i < 16; i++) {
        String s = Integer.toString(i, 16);
        g.drawString(s, x0 + i * charspacing, y0 - 20);
    }
    // Draw column down left.
    for (int i = 0; i < 16; i++) {
        int j = start + i * 16;
        String s = Integer.toString(j, 16);
        g.drawString(s, 10, y0 + i * lineheight);
    }
    // Now draw the characters
    g.setFont(font);
    char[] c = new char[1];
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            c[0] = (char) (start + j * 16 + i);
            g.drawChars(c, 0, 1, x0 + i * charspacing, y0 + j * lineheight);
        }
    }
}

{'paintcomponent'}
/**
     * This constructor allows printing the contents of any JTextComponent
     * using a default PageFormat and a default scale factor.  The default
     * scale factor is .75 because the default fonts are overly large.
     */
public PrintableDocument(JTextComponent textComponent) {
    this(textComponent, new PageFormat(), .75);
}

{'jtextcomponent', 'pageformat'}
/** 
     * This constructor allows the contents of any JTextComponent to be
     * printed, using any specified PageFormat object and any scaling factor.
     **/
public PrintableDocument(JTextComponent textComponent, PageFormat format, double scalefactor) {
    // Remember the page format, and ask it for the printable area
    this.format = format;
    this.scalefactor = scalefactor;
    this.printX = format.getImageableX() / scalefactor;
    this.printY = format.getImageableY() / scalefactor;
    this.printWidth = format.getImageableWidth() / scalefactor;
    this.printHeight = format.getImageableHeight() / scalefactor;
    double paperWidth = format.getWidth() / scalefactor;
    // Get the document and its root Element from the text component
    Document document = textComponent.getDocument();
    Element rootElement = document.getDefaultRootElement();
    // Get the EditorKit and its ViewFactory from the text component
    EditorKit editorKit = textComponent.getUI().getEditorKit(textComponent);
    ViewFactory viewFactory = editorKit.getViewFactory();
    // Use the ViewFactory to create a root View object for the document
    // This is the object we'll print.  
    root = viewFactory.create(rootElement);
    // The Swing text architecture requires us to call setParent() on
    // our root View before we use it for anything.  In order to do this,
    // we need a View object that can serve as the parent.  We use a 
    // custom implementation defined below.
    root.setParent(new ParentView(root, viewFactory, textComponent));
    // Tell the view how wide the page is; it has to format itself
    // to fit within this width.  The height doesn't really matter here
    root.setSize((float) printWidth, (float) printHeight);
    // Now that the view has formatted itself for the specified width,
    // Ask it how tall it is.  
    double documentHeight = root.getPreferredSpan(View.Y_AXIS);
    // Set up the rectangle that tells the view where to draw itself
    // We'll use it in other methods of this class.
    drawRect = new Rectangle(0, 0, (int) printWidth, (int) documentHeight);
    // figure out where the page breaks are.
    if (documentHeight > printHeight)
        paginate(root, drawRect);
    // Once we've broken it into pages, figure out how many pages.
    numPages = pageLengths.size() + 1;
}

{'jtextcomponent', 'setparent', 'editorkit', 'taller', 'viewfactory', 'pageformat'}
/**
     * This method loops through the children of the specified view,
     * recursing as necessary, and inserts pages breaks when needed.
     * It makes a rudimentary attempt to avoid "widows" and "orphans".
     **/
protected void paginate(View v, Rectangle2D allocation) {
    // Figure out how tall this view is, and tell it to allocate
    // that space among its children
    double myheight = v.getPreferredSpan(View.Y_AXIS);
    v.setSize((float) printWidth, (float) myheight);
    // Now loop through each of the children
    int numkids = v.getViewCount();
    for (int i = 0; i < numkids; i++) {
        // this is the child we're working with
        View kid = v.getView(i);
        // Figure out its size and location
        Shape kidshape = v.getChildAllocation(i, allocation);
        if (kidshape == null)
            continue;
        Rectangle2D kidbox = kidshape.getBounds2D();
        // This is the Y coordinate of the bottom of the child
        double kidpos = kidbox.getY() + kidbox.getHeight() - pageStart;
        // I.e. we want to prevent "widows"
        if ((numkids > 1) && (i == 0)) {
            // on to the next child
            if (kidpos < printY + printHeight * MARGIN_ADJUST)
                continue;
            // Otherwise, the child is near the bottom of the page, so
            // break the page before this child and place this child on
            // the new page.
            breakPage(kidbox.getY());
            continue;
        }
        // prevent "orphans"
        if ((numkids > 1) && (i == numkids - 1)) {
            // If it fits normally, just move on to the next one
            if (kidpos < printY + printHeight)
                continue;
            // page at the end of the group
            if (kidpos < printY + printHeight / MARGIN_ADJUST) {
                breakPage(allocation.getY() + allocation.getHeight());
                continue;
            }
        }
        // then move on to the next child.
        if (kidpos < printY + printHeight)
            continue;
        // no children, then break the page before this child and continue.
        if (kid.getViewCount() == 0) {
            breakPage(kidbox.getY());
            continue;
        }
        // If we get here, then the child did not fit on the page, but it
        // has kids of its own, so recurse to see if any of those kids
        // will fit on the page.
        paginate(kid, kidbox);
    }
}

{'strictly', 'left', 'past', 'allow', 'ensure', 'RANK', 'use', 'help', 'squeeze', 'top', 'appear', 'extra', 'last'}
/** 
     * Break a page at the specified Y coordinate.  Store the necessary
     * information into the pageLengths and pageOffsets lists
     **/
void breakPage(double y) {
    double pageLength = y - pageStart - printY;
    pageStart = y - printY;
    pageLengths.add(new Double(pageLength));
    pageOffsets.add(new Double(pageStart));
}

{'pagelengths', 'pageoffsets'}
/** 
     * Return the PageFormat object for the specified page.  This is a
     * Pageable method. This implementation uses the computed length of the
     * page in the returned PageFormat object.  The PrinterJob will use this
     * as a clipping region, which will prevent extraneous parts of the
     * document from being drawn in the top and bottom margins.
     **/
public PageFormat getPageFormat(int pagenum) {
    // On the last page, just return the user-specified page format
    if (pagenum == numPages - 1)
        return format;
    // Otherwise, look up the height of this page and return an
    // appropriate PageFormat.
    double pageLength = ((Double) pageLengths.get(pagenum)).doubleValue();
    PageFormat f = (PageFormat) format.clone();
    Paper p = f.getPaper();
    if (f.getOrientation() == PageFormat.PORTRAIT)
        p.setImageableArea(printX * scalefactor, printY * scalefactor, printWidth * scalefactor, pageLength * scalefactor);
    else
        p.setImageableArea(printY * scalefactor, printX * scalefactor, pageLength * scalefactor, printWidth * scalefactor);
    f.setPaper(p);
    return f;
}

{'printerjob', 'pageformat'}
/**
     * This is the basic Printable method that prints a specified page
     **/
public int print(Graphics g, PageFormat format, int pageIndex) {
    // Return an error code on attempts to print past the end of the doc
    if (pageIndex >= numPages)
        return NO_SUCH_PAGE;
    // Cast the Graphics object so we can use Java2D operations
    Graphics2D g2 = (Graphics2D) g;
    // Translate to accomodate the top and left margins
    g2.translate(format.getImageableX(), format.getImageableY());
    // Scale the page by the specified scaling factor
    g2.scale(scalefactor, scalefactor);
    // But remember the original clipping region so we can restore it
    if (pageIndex > 0) {
        Shape originalClip = g.getClip();
        g.setClip(new Rectangle(0, (int) -printY, (int) printWidth, (int) printY));
        // Compute the header to display, measure it, then display it
        String numString = "- " + (pageIndex + 1) + " -";
        // Get string and font measurements
        FontRenderContext frc = g2.getFontRenderContext();
        Rectangle2D numBounds = headerFont.getStringBounds(numString, frc);
        LineMetrics metrics = headerFont.getLineMetrics(numString, frc);
        // Set the font
        g.setFont(headerFont);
        // Print with black ink
        g.setColor(Color.black);
        // Display the string
        g.drawString(// Display the string
        numString, (int) ((printWidth - numBounds.getWidth()) / 2), (int) (-(printY - numBounds.getHeight()) / 2 + metrics.getAscent()));
        // Restore the clipping region
        g.setClip(originalClip);
    }
    // Get the staring position and length of the page within the document
    double pageStart = 0.0, pageLength = printHeight;
    if (pageIndex > 0)
        pageStart = ((Double) pageOffsets.get(pageIndex - 1)).doubleValue();
    if (pageIndex < numPages - 1)
        pageLength = ((Double) pageLengths.get(pageIndex)).doubleValue();
    // Scroll so that the appropriate part of the document is lined up
    // with the upper-left corner of the page
    g2.translate(0.0, -pageStart);
    // Now paint the entire document.  Because of the clipping region,
    // only the desired portion of the document will actually be drawn on
    // this sheet of paper.
    root.paint(g, drawRect);
    // Finally return a success code
    return PAGE_EXISTS;
}

{'centered', 'number', 'area'}
public ScribblePrinter1(Frame frame) {
    // Remember the frame: we'll need it to create a PrintJob
    this.frame = frame;
    // Register event types we're interested in for scribbling
    enableEvents(AWTEvent.MOUSE_EVENT_MASK | AWTEvent.MOUSE_MOTION_EVENT_MASK);
    // Add a print button to he layout, and respond to it by printing
    Button b = new Button("Print");
    b.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            printScribble();
        }
    });
    this.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));
    this.add(b);
}

{'printjob'}
/** Print out the scribble */
public void printScribble() {
    // Obtain a PrintJob
    Toolkit toolkit = this.getToolkit();
    PrintJob job = toolkit.getPrintJob(frame, "ScribblePrinter1", printprefs);
    // If the user clicked Cancel in the print dialog, don't print
    if (job == null)
        return;
    // Get the Graphics object we use to draw to the printer
    Graphics g = job.getGraphics();
    // Give the output a larger top and left margin.  Otherwise it will
    // be scrunched up in the upper-left corner of the page.
    g.translate(100, 100);
    // Draw a border around the output area.
    Dimension size = this.getSize();
    g.drawRect(-1, -1, size.width + 2, size.height + 2);
    // Set a clipping region so our scribbles don't go outside the border
    // On-screen this happens automatically, but not on paper.
    g.setClip(0, 0, size.width, size.height);
    // Print this component and all components it contains
    // This will invoke the paint() method, and will paint the button too.
    // Use print() instead of printAll() if you don't the button to show.
    this.printAll(g);
    // Finish up.
    // End the current page
    g.dispose();
    // End the print job
    job.end();
}

{'printall', 'printjob'}
/** The main method.  Create a ScribblePrinter1 object and away we go! */
public static void main(String[] args) {
    Frame frame = new Frame("ScribblePrinter1");
    ScribblePrinter1 s = new ScribblePrinter1(frame);
    frame.add(s, BorderLayout.CENTER);
    frame.setSize(400, 400);
    frame.show();
}

{'scribbleprinterD'}
/**
     * The constructor for this class has a bunch of arguments:  
     * The frame argument is required for all printing in Java.
     * The jobname appears left justified at the top of each printed page.
     * The font size is specified in points, as on-screen font sizes are.
     * The margins are specified in inches (or fractions of inches).
     **/
public HardcopyWriter(Frame frame, String jobname, int fontsize, double leftmargin, double rightmargin, double topmargin, double bottommargin) throws HardcopyWriter.PrintCanceledException {
    // Get the PrintJob object with which we'll do all the printing.
    // The call is synchronized on the static printprops object, which 
    // means that only one print dialog can be popped up at a time.
    // If the user clicks Cancel in the print dialog, throw an exception.
    // get Toolkit from Frame
    Toolkit toolkit = frame.getToolkit();
    synchronized (printprops) {
        job = toolkit.getPrintJob(frame, jobname, printprops);
    }
    if (job == null)
        throw new PrintCanceledException("User cancelled print request");
    // query the page size
    pagesize = job.getPageDimension();
    // query the page resolution
    pagedpi = job.getPageResolution();
    // we've got to fake them.
    if (System.getProperty("os.name").regionMatches(true, 0, "windows", 0, 7)) {
        // Use screen dpi, which is what the PrintJob tries to emulate
        pagedpi = toolkit.getScreenResolution();
        // Assume a 8.5" x 11" page size.  A4 paper users must change this.
        pagesize = new Dimension((int) (8.5 * pagedpi), 11 * pagedpi);
        // We also have to adjust the fontsize.  It is specified in points,
        // (1 point = 1/72 of an inch) but Windows measures it in pixels.
        fontsize = fontsize * pagedpi / 72;
    }
    // Compute coordinates of the upper-left corner of the page.
    // I.e. the coordinates of (leftmargin, topmargin).  Also compute
    // the width and height inside of the margins.
    x0 = (int) (leftmargin * pagedpi);
    y0 = (int) (topmargin * pagedpi);
    width = pagesize.width - (int) ((leftmargin + rightmargin) * pagedpi);
    height = pagesize.height - (int) ((topmargin + bottommargin) * pagedpi);
    // Get body font and font size
    font = new Font("Monospaced", Font.PLAIN, fontsize);
    metrics = frame.getFontMetrics(font);
    lineheight = metrics.getHeight();
    lineascent = metrics.getAscent();
    // Assumes a monospaced font!
    charwidth = metrics.charWidth('0');
    // Now compute columns and lines will fit inside the margins
    chars_per_line = width / charwidth;
    lines_per_page = height / lineheight;
    // Get header font information
    // And compute baseline of page header: 1/8" above the top margin
    headerfont = new Font("SansSerif", Font.ITALIC, fontsize);
    headermetrics = frame.getFontMetrics(headerfont);
    headery = y0 - (int) (0.125 * pagedpi) - headermetrics.getHeight() + headermetrics.getAscent();
    // Compute the date/time string to display in the page header
    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT);
    df.setTimeZone(TimeZone.getDefault());
    time = df.format(new Date());
    // save name
    this.jobname = jobname;
    // save font size
    this.fontsize = fontsize;
}

{'bug', 'workaround', 'getpageresolution', 'printjob', 'work', 'getpagedimension'}
/**
     * This is the write() method of the stream.  All Writer subclasses 
     * implement this.  All other versions of write() are variants of this one
     **/
public void write(char[] buffer, int index, int len) {
    synchronized (this.lock) {
        // Loop through all the characters passed to us
        for (int i = index; i < index + len; i++) {
            // If we haven't begun a page (or a new page), do that now.
            if (page == null)
                newpage();
            // unless it is a \n immediately after a \r.
            if (buffer[i] == '\n') {
                if (!last_char_was_return)
                    newline();
                continue;
            }
            if (buffer[i] == '\r') {
                newline();
                last_char_was_return = true;
                continue;
            } else
                last_char_was_return = false;
            // If it some other non-printing character, ignore it.
            if (Character.isWhitespace(buffer[i]) && !Character.isSpaceChar(buffer[i]) && (buffer[i] != '\t'))
                continue;
            // If no more characters will fit on the line, start new line.
            if (charnum >= chars_per_line) {
                newline();
                // Also start a new page, if necessary
                if (page == null)
                    newpage();
            }
            // printer uses we need to position each character individually
            if (Character.isSpaceChar(buffer[i]))
                charnum++;
            else if (buffer[i] == '\t')
                charnum += 8 - (charnum % 8);
            else {
                page.drawChars(buffer, i, 1, x0 + charnum * charwidth, y0 + (linenum * lineheight) + lineascent);
                charnum++;
            }
        }
    }
}

{'inefficient', 'safety', 'number', 'otherwise', 'fontmetrics', 'tab', 'match', 'time', 'without', 'begin', 'skip', 'terminator', 'output', 'print', 'thread', 'exactly'}
/** 
     * This is the flush() method that all Writer subclasses must implement.
     * There is no way to flush a PrintJob without prematurely printing the
     * page, so we don't do anything.
     **/
public void flush() {
/* do nothing */
}

{'printjob'}
/**
     * This is the close() method that all Writer subclasses must implement.
     * Print the pending page (if any) and terminate the PrintJob.
     */
public void close() {
    synchronized (this.lock) {
        // Send page to the printer
        if (page != null)
            page.dispose();
        // Terminate the job
        job.end();
    }
}

{'printjob'}
/** Print the demo page */
public void printDemoPage() {
    // Create a HardcopyWriter, using a 14 point font and 3/4" margins.
    HardcopyWriter hw;
    try {
        hw = new HardcopyWriter(this, "Demo Page", 14, .75, .75, .75, .75);
    } catch (HardcopyWriter.PrintCanceledException e) {
        return;
    }
    // Send output to it through a PrintWriter stream
    PrintWriter out = new PrintWriter(hw);
    // Figure out the size of the page
    int rows = hw.getLinesPerPage(), cols = hw.getCharactersPerLine();
    // Mark upper left and upper-right corners
    // upper-left corner
    out.print("+");
    // space over
    for (int i = 0; i < cols - 2; i++) out.print(" ");
    // upper-right corner
    out.print("+");
    // Display a title
    hw.setFontStyle(Font.BOLD + Font.ITALIC);
    out.println("\n\t\tHardcopy Writer Demo Page\n\n");
    // Demonstrate font styles
    hw.setFontStyle(Font.BOLD);
    out.println("Font Styles:");
    int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC, Font.ITALIC + Font.BOLD };
    for (int i = 0; i < styles.length; i++) {
        hw.setFontStyle(styles[i]);
        out.println("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz");
        out.println("1234567890!@#$%^&*()[]{}<>,.?:;+-=/\\`'\"_~|");
    }
    hw.setFontStyle(Font.PLAIN);
    out.println("\n");
    // Demonstrate tab stops
    hw.setFontStyle(Font.BOLD);
    out.println("Tab Stops:");
    hw.setFontStyle(Font.PLAIN);
    out.println("          1         2         3         4         5");
    out.println("012345678901234567890123456789012345678901234567890");
    out.println("^\t^\t^\t^\t^\t^\t^");
    out.println("\n");
    // Output some information about page dimensions and resolution
    hw.setFontStyle(Font.BOLD);
    out.println("Dimensions:");
    hw.setFontStyle(Font.PLAIN);
    out.println("\tResolution: " + hw.pagedpi + " dots per inch");
    out.println("\tPage width (pixels): " + hw.pagesize.width);
    out.println("\tPage height (pixels): " + hw.pagesize.height);
    out.println("\tWidth inside margins (pixels): " + hw.width);
    out.println("\tHeight inside margins (pixels): " + hw.height);
    out.println("\tCharacters per line: " + cols);
    out.println("\tLines per page: " + rows);
    // Skip down to the bottom of the page
    for (int i = 0; i < rows - 30; i++) out.println();
    // And mark the lower left and lower right
    // lower-left
    out.print("+");
    // space-over
    for (int i = 0; i < cols - 2; i++) out.print(" ");
    // lower-right
    out.print("+");
    // Close the output stream, forcing the page to be printed
    out.close();
}

{'printwriter', 'hardcopywriter'}
/**
     * Print out the scribble.  This is the method invoked by the Print button;
     * it is not part of the Printable interface
     **/
public void printScribble() {
    // Obtain a java.awt.print.PrinterJob  (not java.awt.PrintJob)
    PrinterJob job = PrinterJob.getPrinterJob();
    // Tell the PrinterJob to print us (since we implement Printable)
    // using the default page layout
    job.setPrintable(this, job.defaultPage());
    // The method returns false if the user cancelled the print request
    if (job.printDialog()) {
        // method defined by the Printable interface.
        try {
            job.print();
        } catch (PrinterException e) {
            System.err.println(e);
        }
    }
}

{'option', 'printing', 'printerjob', 'display', 'call', 'allows', 'start', 'printjob'}
/**
     * This is the method defined by the Printable interface.  It prints the
     * scribble to the specified Graphics object, respecting the paper size
     * and margins specified by the PageFormat.  If the specified page number
     * is not page 0, it returns a code saying that printing is complete.  The
     * method must be prepared to be called multiple times per printing request
     **/
public int print(Graphics g, PageFormat format, int pagenum) {
    // We are only one page long; reject any other page numbers
    if (pagenum > 0)
        return Printable.NO_SUCH_PAGE;
    // The Java 1.2 printing API passes us a Graphics object, but we
    // can always cast it to a Graphics2D object
    Graphics2D g2 = (Graphics2D) g;
    // Translate to accomodate the requested top and left margins.
    g2.translate(format.getImageableX(), format.getImageableY());
    // Figure out how big the drawing is, and how big the page 
    // (excluding margins) is
    // Scribble size
    Dimension size = this.getSize();
    // Page width
    double pageWidth = format.getImageableWidth();
    // Page height
    double pageHeight = format.getImageableHeight();
    // If the scribble is too wide or tall for the page, scale it down
    if (size.width > pageWidth) {
        // How much to scale
        double factor = pageWidth / size.width;
        // Adjust coordinate system
        g2.scale(factor, factor);
        // Adjust page size up
        pageWidth /= factor;
        pageHeight /= factor;
    }
    if (size.height > pageHeight) {
        // Do the same thing for height
        double factor = pageHeight / size.height;
        g2.scale(factor, factor);
        pageWidth /= factor;
        pageHeight /= factor;
    }
    // Now we know the scribble will fit on the page.  Center it by
    // translating as necessary.
    g2.translate((pageWidth - size.width) / 2, (pageHeight - size.height) / 2);
    // Draw a line around the outside of the drawing area
    g2.drawRect(-1, -1, size.width + 2, size.height + 2);
    // Set a clipping region so the scribbles don't go out of bounds
    g2.setClip(0, 0, size.width, size.height);
    // Finally, print the component by calling the paintComponent() method.
    // Or, call paint() to paint the component, its background, border, and
    // children, including the Print JButton
    this.paintComponent(g);
    // Tell the PrinterJob that the page number was valid
    return Printable.PAGE_EXISTS;
}

{'jbutton', 'paintcomponent', 'printerjob', 'pageformat'}
/** The main method.  Create a ScribblePrinter2 object and away we go! */
public static void main(String[] args) {
    JFrame frame = new JFrame("ScribblePrinter2");
    ScribblePrinter2 s = new ScribblePrinter2();
    frame.getContentPane().add(s, BorderLayout.CENTER);
    frame.setSize(400, 400);
    frame.setVisible(true);
}

{'scribbleprinterD'}
/** Create a TreeModel for the specified TreeWalker */
public DOMTreeWalkerTreeModel(TreeWalker walker) {
    this.walker = walker;
}

{'treewalker', 'treemodel'}
/** 
     * Create a TreeModel for a TreeWalker that returns all nodes
     * in the specified document
     **/
public DOMTreeWalkerTreeModel(Document document) {
    DocumentTraversal dt = (DocumentTraversal) document;
    walker = dt.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);
}

{'treewalker', 'treemodel'}
/** 
     * Create a TreeModel for a TreeWalker that returns the specified 
     * element and all of its descendant nodes.
     **/
public DOMTreeWalkerTreeModel(Element element) {
    DocumentTraversal dt = (DocumentTraversal) element.getOwnerDocument();
    walker = dt.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false);
}

{'treewalker', 'treemodel'}
// Is this node a leaf? (Leaf nodes are displayed differently by JTree)
public boolean isLeaf(Object node) {
    // Set current node
    walker.setCurrentNode((Node) node);
    // Ask for a child
    Node child = walker.firstChild();
    // Does it have any?
    return (child == null);
}

{'jtree'}
// How many children does this node have?
public int getChildCount(Object node) {
    // Set the current node
    walker.setCurrentNode((Node) node);
    // TreeWalker doesn't count children for us, so we count ourselves
    int numkids = 0;
    // Start with the first child
    Node child = walker.firstChild();
    while (child != null) {
        // Loop 'till there are no more
        // Update the count
        numkids++;
        // Get next child
        child = walker.nextSibling();
    }
    // This is the number of children
    return numkids;
}

{'treewalker'}
// Return the specified child of a parent node.
public Object getChild(Object parent, int index) {
    // Set the current node
    walker.setCurrentNode((Node) parent);
    // TreeWalker provides sequential access to children, not random
    // access, so we've got to loop through the kids one by one
    Node child = walker.firstChild();
    while (index-- > 0) child = walker.nextSibling();
    return child;
}

{'treewalker'}
public short acceptNode(Node n) {
    if (n.getNodeType() == Node.TEXT_NODE) {
        // If nothing is left, then reject the node
        if (((Text) n).getData().trim().length() == 0)
            return NodeFilter.FILTER_REJECT;
    }
    return NodeFilter.FILTER_ACCEPT;
}

{'space', 'strip', 'use', 'trailing', 'leading'}
/**
     * This main() method demonstrates the use of this class, the use of the
     * Xerces DOM parser, and the creation of a DOM Level 2 TreeWalker object.
     **/
public static void main(String[] args) throws IOException, SAXException {
    // Obtain an instance of a Xerces parser to build a DOM tree.
    // Note that we are not using the JAXP API here, so this
    // code uses Apache Xerces APIs that are not standards
    DOMParser parser = new org.apache.xerces.parsers.DOMParser();
    // Get a java.io.Reader for the input XML file and 
    // wrap the input file in a SAX input source
    Reader in = new BufferedReader(new FileReader(args[0]));
    InputSource input = new org.xml.sax.InputSource(in);
    // Tell the Xerces parser to parse the input source
    parser.parse(input);
    // Ask the parser to give us our DOM Document.  Once we've got the DOM
    // tree, we don't have to use the Apache Xerces APIs any more; from
    // here on, we use the standard DOM APIs
    Document document = parser.getDocument();
    // If we're using a DOM Level 2 implementation, then our Document
    // object ought to implement DocumentTraversal 
    DocumentTraversal traversal = (DocumentTraversal) document;
    // For this demonstration, we create a NodeFilter that filters out
    // Text nodes containing only space; these just clutter up the tree
    NodeFilter filter = new NodeFilter() {

        public short acceptNode(Node n) {
            if (n.getNodeType() == Node.TEXT_NODE) {
                // If nothing is left, then reject the node
                if (((Text) n).getData().trim().length() == 0)
                    return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    };
    // This set of flags says to "show" all node types except comments
    int whatToShow = NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_COMMENT;
    // Create a TreeWalker using the filter and the flags
    TreeWalker walker = traversal.createTreeWalker(document, whatToShow, filter, false);
    // Instantiate a TreeModel and a JTree to display it
    JTree tree = new JTree(new DOMTreeWalkerTreeModel(walker));
    // Create a frame and a scrollpane to display the tree, and pop them up
    JFrame frame = new JFrame("DOMTreeWalkerTreeModel Demo");
    frame.getContentPane().add(new JScrollPane(tree));
    frame.setSize(500, 250);
    frame.setVisible(true);
}

{'jtree', 'documenttraversal', 'trailing', 'nodefilter', 'strip', 'treewalker', 'leading', 'treemodel', 'apis'}
/** The main method sets things up for parsing */
public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {
    // Create a JAXP "parser factory" for creating SAX parsers
    javax.xml.parsers.SAXParserFactory spf = SAXParserFactory.newInstance();
    // Configure the parser factory for the type of parsers we require
    // No validation required
    spf.setValidating(false);
    // Now use the parser factory to create a SAXParser object
    // Note that SAXParser is a JAXP class, not a SAX class
    javax.xml.parsers.SAXParser sp = spf.newSAXParser();
    // Create a SAX input source for the file argument
    org.xml.sax.InputSource input = new InputSource(new FileReader(args[0]));
    // Give the InputSource an absolute URL for the file, so that
    // it can resolve relative URLs in a <!DOCTYPE> declaration, e.g.
    input.setSystemId("file://" + new File(args[0]).getAbsolutePath());
    // Create an instance of this class; it defines all the handler methods
    ListServlets1 handler = new ListServlets1();
    // Finally, tell the parser to parse the input and notify the handler
    sp.parse(input, handler);
// Instead of using the SAXParser.parse() method, which is part of the
// JAXP API, we could also use the SAX1 API directly.  Note the
// difference between the JAXP class javax.xml.parsers.SAXParser and
// the SAX1 class org.xml.sax.Parser
//
// org.xml.sax.Parser parser = sp.getParser();  // Get the SAX parser
// parser.setDocumentHandler(handler);          // Set main handler
// parser.setErrorHandler(handler);             // Set error handler
// parser.parse(input);                         // Parse!
}

{'inputsource', 'getparser', 'saxparser', 'setdocumenthandler', 'seterrorhandler'}
/** The main method sets things up for parsing */
public static void main(String[] args) throws IOException, SAXException {
    // Create the parser we'll use.  The parser implementation is a 
    // Xerces class, but we use it only through the SAX XMLReader API
    org.xml.sax.XMLReader parser = new org.apache.xerces.parsers.SAXParser();
    // Specify that we don't want validation.  This is the SAX2
    // API for requesting parser features.  Note the use of a
    // globally unique URL as the feature name.  Non-validation is
    // actually the default, so this line isn't really necessary.
    parser.setFeature("http://xml.org/sax/features/validation", false);
    // Instantiate this class to provide handlers for the parser and 
    // tell the parser about the handlers
    ListServlets2 handler = new ListServlets2();
    parser.setContentHandler(handler);
    parser.setErrorHandler(handler);
    // Create an input source that describes the file to parse.
    // Then tell the parser to parse input from that source
    org.xml.sax.InputSource input = new InputSource(new FileReader(args[0]));
    parser.parse(input);
}

{'xmlreader'}
/** The main method creates and demonstrates a WebAppConfig object */
public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {
    // Create a new WebAppConfig object that represents the web.xml
    // file specified by the first command-line argument
    WebAppConfig config = new WebAppConfig(new File(args[0]));
    // Query the tree for the class name associated with the specified
    // servlet name
    System.out.println("Class for servlet " + args[1] + " is " + config.getServletClass(args[1]));
    // Add a new servlet name-to-class mapping to the DOM tree
    config.addServlet("foo", "bar");
    // And write out an XML version of the DOM tree to standard out
    config.output(new PrintWriter(new OutputStreamWriter(System.out)));
}

{'webappconfig'}
/**
     * Output the DOM tree to the specified stream as an XML document.
     * See the XMLDocumentWriter example for the details.
     **/
public void output(PrintWriter out) {
    XMLDocumentWriter docwriter = new XMLDocumentWriter(out);
    docwriter.write(document);
    docwriter.close();
}

{'xmldocumentwriter'}
/** The main method creates and demonstrates a WebAppConfig2 object */
public static void main(String[] args) throws IOException, JDOMException {
    // Create a new WebAppConfig object that represents the web.xml
    // file specified by the first command-line argument
    WebAppConfig2 config = new WebAppConfig2(new File(args[0]));
    // Query the tree for the class name associated with the servlet
    // name specified as the 2nd command-line argument
    System.out.println("Class for servlet " + args[1] + " is " + config.getServletClass(args[1]));
    // Add a new servlet name-to-class mapping to the DOM tree
    config.addServlet("foo", "bar");
    // And write out an XML version of the DOM tree to standard out
    config.output(System.out);
}

{'webappconfigD', 'webappconfig'}
/**
     * This method looks for specific Element nodes in the JDOM tree in order
     * to figure out the classname associated with the specified servlet name
     **/
public String getServletClass(String servletName) throws JDOMException {
    // Get the root element of the document.
    Element root = document.getRootElement();
    // Find all <servlet> elements in the document, and loop through them
    // to find one with the specified name.  Note the use of java.util.List
    // instead of org.w3c.dom.NodeList.
    List servlets = root.getChildren("servlet");
    for (Iterator i = servlets.iterator(); i.hasNext(); ) {
        Element servlet = (Element) i.next();
        // Get the text of the <servlet-name> tag within the <servlet> tag
        String name = servlet.getChild("servlet-name").getContent();
        if (name.equals(servletName)) {
            // If the names match, return the text of the <servlet-class>
            return servlet.getChild("servlet-class").getContent();
        }
    }
    return null;
}

{'nodelist'}
public static void main(String[] args) throws IOException {
    // Get set up to read lines of text from the user
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    for (; ; ) {
        // Loop forever
        // Print a prompt
        System.out.print("> ");
        // Read a line
        String line = in.readLine();
        if (// If EOF or "quit"...
        (line == null) || line.equals("quit"))
            // ...break out of loop
            break;
        // Use a StringBuffer
        StringBuffer buf = new StringBuffer(line);
        for (// For each character...
        int i = 0; // For each character...
        i < buf.length(); // For each character...
        i++) // ..read, encode, store
        buf.setCharAt(i, rot13(buf.charAt(i)));
        // Print encoded line
        System.out.println(buf);
    }
}

{'stringbuffer'}
/** The factorial() method, using BigIntegers cached in a ArrayList */
public static synchronized BigInteger factorial(int x) {
    if (x < 0)
        throw new IllegalArgumentException("x must be non-negative.");
    for (int size = table.size(); size <= x; size++) {
        BigInteger lastfact = (BigInteger) table.get(size - 1);
        BigInteger nextfact = lastfact.multiply(BigInteger.valueOf(size));
        table.add(nextfact);
    }
    return (BigInteger) table.get(x);
}

{'arraylist', 'bigintegers'}
public static void main(String[] args) {
    // If something goes wrong, handle it in the catch clause below.
    try {
        int x = Integer.parseInt(args[0]);
        System.out.println(x + "! = " + Factorial4.factorial(x));
    }// Thrown if args[0] is undefined.
     catch (ArrayIndexOutOfBoundsException e) {
        System.out.println("You must specify an argument");
        System.out.println("Usage: java FactComputer <number>");
    }// The argument is not a number.  Thrown by Integer.parseInt().
     catch (NumberFormatException e) {
        System.out.println("The argument you specify must be an integer");
    }// The argument is < 0.  Thrown by Factorial4.factorial()
     catch (IllegalArgumentException e) {
        System.out.println("Bad argument: " + e.getMessage());
    }
}

{'sent', 'compute', 'method', 'display', 'user', 'parseint', 'forgot'}
/**
     * This is a very simple sorting algorithm that is not very efficient
     * when sorting large numbers of things
     **/
public static void sort(double[] nums) {
    // to the first unsorted position in the array.
    for (int i = 0; i < nums.length; i++) {
        // holds the index of the smallest element
        int min = i;
        // find the smallest one between i and the end of the array
        for (int j = i; j < nums.length; j++) {
            if (nums[j] < nums[min])
                min = j;
        }
        // Now swap the smallest one with element i.  
        // This leaves all elements between 0 and i sorted.
        double tmp;
        tmp = nums[i];
        nums[i] = nums[min];
        nums[min] = tmp;
    }
}

{'loop', 'time', 'go', 'move', 'remaining'}
public static void main(String[] args) throws IOException {
    // This is how we set things up to read lines of text from the user.
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    // Loop forever
    for (; ; ) {
        // Display a prompt to the user
        System.out.print("FactQuoter> ");
        // Read a line from the user
        String line = in.readLine();
        // or if the user types "quit", then quit
        if ((line == null) || line.equals("quit"))
            break;
        // Try to parse the line, and compute and print the factorial
        try {
            int x = Integer.parseInt(line);
            System.out.println(x + "! = " + Factorial4.factorial(x));
        }// If anything goes wrong, display a generic error message
         catch (Exception e) {
            System.out.println("Invalid Input");
        }
    }
}

{'end', 'file', 'reach'}
public static void main(String[] args) {
    // We will compute all primes less than the value specified on the
    // command line, or, if no argument, all primes less than 100.
    // Assign a default value
    int max = 100;
    try // Parse user-supplied arg
    {
        max = Integer.parseInt(args[0]);
    }// Silently ignore exceptions.
     catch (Exception e) {
    }
    // Create an array that specifies whether each number is prime or not.
    boolean[] isprime = new boolean[max + 1];
    // Assume that all numbers are primes, until proven otherwise.
    for (int i = 0; i <= max; i++) isprime[i] = true;
    // However, we know that 0 and 1 are not primes.  Make a note of it.
    isprime[0] = isprime[1] = false;
    // To compute all primes less than max, we need to rule out
    // multiples of all integers less than the square root of max.
    // See java.lang.Math class
    int n = (int) Math.ceil(Math.sqrt(max));
    //   prime factors of i, so we can skip this case.
    for (int i = 0; i <= n; i++) {
        if (// If i is a prime, 
        isprime[i])
            for (// loop through multiples
            int j = 2 * i; // loop through multiples
            j <= max; // loop through multiples
            j = j + i) // they are not prime.
            isprime[j] = false;
    }
    // Now go look for the largest prime:
    int largest;
    // empty loop body
    for (largest = max; !isprime[largest]; largest--) ;
    // Output the result
    System.out.println("The largest prime less than or equal to " + max + " is " + largest);
}

{'ruled', 'indicate', 'already', 'none'}
public static void main(String[] args) {
    try {
        // Figure out what RemoteBank to connect to by reading a system
        // property (specified on the command line with a -D option to
        // java) or, if it is not defined, use a default URL.  Note
        // that by default this client tries to connect to a server on
        // the local machine
        String url = System.getProperty("bank", "rmi:///FirstRemote");
        // Now look up that RemoteBank server using the Naming object,
        // which contacts the rmiregistry server.  Given the url, this
        // call returns a RemoteBank object whose methods may be
        // invoked remotely
        RemoteBank bank = (RemoteBank) Naming.lookup(url);
        // Convert the user's command to lower case
        String cmd = args[0].toLowerCase();
        // Now, go test the command against a bunch of possible options
        if (cmd.equals("open")) {
            // Open an account
            bank.openAccount(args[1], args[2]);
            System.out.println("Account opened.");
        } else if (cmd.equals("close")) {
            // Close an account
            FunnyMoney money = bank.closeAccount(args[1], args[2]);
            // Note: our currency is denominated in wooden nickels
            System.out.println(money.amount + " wooden nickels returned to you.");
            System.out.println("Thanks for banking with us.");
        } else if (cmd.equals("deposit")) {
            // Deposit money
            FunnyMoney money = new FunnyMoney(Integer.parseInt(args[3]));
            bank.deposit(args[1], args[2], money);
            System.out.println("Deposited " + money.amount + " wooden nickels.");
        } else if (cmd.equals("withdraw")) {
            // Withdraw money
            FunnyMoney money = bank.withdraw(args[1], args[2], Integer.parseInt(args[3]));
            System.out.println("Withdrew " + money.amount + " wooden nickels.");
        } else if (cmd.equals("balance")) {
            // Check account balance
            int amt = bank.getBalance(args[1], args[2]);
            System.out.println("You have " + amt + " wooden nickels in the bank.");
        } else if (cmd.equals("history")) {
            // Get transaction history
            List transactions = bank.getTransactionHistory(args[1], args[2]);
            for (int i = 0; i < transactions.size(); i++) System.out.println(transactions.get(i));
        } else
            System.out.println("Unknown command");
    }// Catch and display RMI exceptions
     catch (RemoteException e) {
        System.err.println(e);
    }// Catch and display Banking related exceptions
     catch (BankingException e) {
        System.err.println(e.getMessage());
    }// Other exceptions are probably user syntax errors, so show usage.
     catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java [-Dbank=<url>] Bank$Client " + "<cmd> <name> <password> [<amount>]");
        System.err.println("where cmd is: open, close, deposit, " + "withdraw, balance, history");
    }
}

{'remotebank'}
/** Get the RemoteMudPerson object for the named person. */
public RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson;

{'remotemudperson'}
/**
     * The main program.  It expects two or three arguments:
     *   0) the name of the host on which the mud server is running
     *   1) the name of the MUD on that host
     *   2) the name of a place within that MUD to start at (optional).
     *
     * It uses the Naming.lookup() method to obtain a RemoteMudServer object
     * for the named MUD on the specified host.  Then it uses the getEntrance()
     * or getNamedPlace() method of RemoteMudServer to obtain the starting
     * RemoteMudPlace object.  It prompts the user for a their name and 
     * description, and creates a MudPerson object.  Finally, it passes
     * the person and the place to runMud() to begin interaction with the MUD.
     **/
public static void main(String[] args) {
    try {
        // Each MUD is uniquely identified by a 
        String hostname = args[0];
        //   host and a MUD name.
        String mudname = args[1];
        // Each place in a MUD has a unique name
        String placename = null;
        if (args.length > 2)
            placename = args[2];
        // Look up the RemoteMudServer object for the named MUD using
        // the default registry on the specified host.  Note the use of
        // the Mud.mudPrefix constant to help prevent naming conflicts
        // in the registry.
        RemoteMudServer server = (RemoteMudServer) Naming.lookup("rmi://" + hostname + "/" + Mud.mudPrefix + mudname);
        // If the user did not specify a place in the mud, use
        // getEntrance() to get the initial place.  Otherwise, call
        // getNamedPlace() to find the initial place.
        RemoteMudPlace location = null;
        if (placename == null)
            location = server.getEntrance();
        else
            location = (RemoteMudPlace) server.getNamedPlace(placename);
        // Greet the user and ask for their name and description.
        // This relies on getLine() and getMultiLine() defined below.
        System.out.println("Welcome to " + mudname);
        String name = getLine("Enter your name: ");
        String description = getMultiLine("Please describe what " + "people see when they look at you:");
        // Define an output stream that the MudPerson object will use to
        // display messages sent to it to the user.  We'll use the console.
        PrintWriter myout = new PrintWriter(System.out);
        // Create a MudPerson object to represent the user in the MUD.
        // Use the specified name and description, and the output stream.
        MudPerson me = new MudPerson(name, description, myout);
        // Lower this thread's priority one notch so that broadcast
        // messages can appear even when we're blocking for I/O.  This is
        // necessary on the Linux platform, but may not be necessary on all
        // platforms.
        int pri = Thread.currentThread().getPriority();
        Thread.currentThread().setPriority(pri - 1);
        // Finally, put the MudPerson into the RemoteMudPlace, and start
        // prompting the user for commands.
        runMud(location, me);
    }// If anything goes wrong, print a message and exit.
     catch (Exception e) {
        System.out.println(e);
        System.out.println("Usage: java MudClient <host> <mud> [<place>]");
        System.exit(1);
    }
}

{'remotemudserver', 'remotemudplace', 'mudprefix', 'mudperson', 'getentrance', 'getmultiline', 'getnamedplace', 'runmud', 'getline'}
/**
     * This method is the main loop of the MudClient.  It places the person
     * into the place (using the enter() method of RemoteMudPlace).  Then it
     * calls the look() method to describe the place to the user, and enters a
     * command loop to prompt the user for a command and process the command
     **/
public static void runMud(RemoteMudPlace entrance, MudPerson me) throws RemoteException {
    // The current place
    RemoteMudPlace location = entrance;
    // The person's name
    String myname = me.getName();
    // The name of the current place
    String placename = null;
    // The name of the mud of that place
    String mudname = null;
    try {
        // Enter the MUD
        location.enter(me, myname, myname + " has entered the MUD.");
        // Figure out where we are (for the prompt)
        mudname = location.getServer().getMudName();
        placename = location.getPlaceName();
        // Describe the place to the user
        look(location);
    } catch (Exception e) {
        System.out.println(e);
        System.exit(1);
    }
    // could go wrong each time through the loop.
    for (; ; ) {
        // Loop until the user types "quit"
        try {
            // generated indirectly by the last command a chance to appear.
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
            }
            // Display a prompt, and get the user's input
            String line = getLine(mudname + '.' + placename + "> ");
            // Break the input into a command and an argument that consists
            // of the rest of the line.  Convert the command to lowercase.
            String cmd, arg;
            int i = line.indexOf(' ');
            if (i == -1) {
                cmd = line;
                arg = null;
            } else {
                cmd = line.substring(0, i).toLowerCase();
                arg = line.substring(i + 1);
            }
            if (arg == null)
                arg = "";
            // LOOK: Describe the place and its things, people, and exits
            if (cmd.equals("look"))
                look(location);
            else // EXAMINE: Describe a named thing
            if (cmd.equals("examine"))
                System.out.println(location.examineThing(arg));
            else // DESCRIBE: Describe a named person
            if (cmd.equals("describe")) {
                try {
                    RemoteMudPerson p = location.getPerson(arg);
                    System.out.println(p.getDescription());
                } catch (RemoteException e) {
                    System.out.println(arg + " is having technical " + "difficulties. No description " + "is available.");
                }
            } else // GO: Go in a named direction
            if (cmd.equals("go")) {
                location = location.go(me, arg);
                mudname = location.getServer().getMudName();
                placename = location.getPlaceName();
                look(location);
            } else // SAY: Say something to everyone 
            if (cmd.equals("say"))
                location.speak(me, arg);
            else // DO: Do something that will be described to everyone
            if (cmd.equals("do"))
                location.act(me, arg);
            else // TALK: Say something to one named person
            if (cmd.equals("talk")) {
                try {
                    RemoteMudPerson p = location.getPerson(arg);
                    String msg = getLine("What do you want to say?: ");
                    p.tell(myname + " says \"" + msg + "\"");
                } catch (RemoteException e) {
                    System.out.println(arg + " is having technical " + "difficulties. Can't talk to them.");
                }
            } else // CHANGE: Change my own description 
            if (cmd.equals("change"))
                me.setDescription(getMultiLine("Describe yourself for others: "));
            else // CREATE: Create a new thing in this place
            if (cmd.equals("create")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("name expected");
                String desc = getMultiLine("Please describe the " + arg + ": ");
                location.createThing(me, arg, desc);
            } else // DESTROY: Destroy a named thing
            if (cmd.equals("destroy"))
                location.destroyThing(me, arg);
            else // through the exit specified in the argument.
            if (cmd.equals("open")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                String name = getLine("What is the name of place there?: ");
                String back = getLine("What is the direction from " + "there back to here?: ");
                String desc = getMultiLine("Please describe " + name + ":");
                location.createPlace(me, arg, back, name, desc);
            } else // uni-directionally, and does not destroy a place.
            if (cmd.equals("close")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                location.close(me, arg);
            } else // that may be in another MUD running on another host
            if (cmd.equals("link")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("direction expected");
                String host = getLine("What host are you linking to?: ");
                String mud = getLine("What is the name of the MUD on that host?: ");
                String place = getLine("What is the place name in that MUD?: ");
                location.linkTo(me, arg, host, mud, place);
                System.out.println("Don't forget to make a link from " + "there back to here!");
            } else // if the password is correct
            if (cmd.equals("dump")) {
                if (arg.length() == 0)
                    throw new IllegalArgumentException("filename expected");
                String password = getLine("Password: ");
                location.getServer().dump(password, arg);
            } else // QUIT: Quit the game
            if (cmd.equals("quit")) {
                try {
                    location.exit(me, myname + " has quit.");
                } catch (Exception e) {
                }
                System.out.println("Bye.");
                System.out.flush();
                System.exit(0);
            } else // HELP: Print out a big help message
            if (cmd.equals("help"))
                System.out.println(help);
            else
                // Otherwise, this is an unrecognized command.
                System.out.println("Unknown command.  Try 'help'.");
        }// Handle the many possible types of MudException
         catch (MudException e) {
            if (e instanceof NoSuchThing)
                System.out.println("There isn't any such thing here.");
            else if (e instanceof NoSuchPerson)
                System.out.println("There isn't anyone by that name here.");
            else if (e instanceof NoSuchExit)
                System.out.println("There isn't an exit in that direction.");
            else if (e instanceof NoSuchPlace)
                System.out.println("There isn't any such place.");
            else if (e instanceof ExitAlreadyExists)
                System.out.println("There is already an exit " + "in that direction.");
            else if (e instanceof PlaceAlreadyExists)
                System.out.println("There is already a place " + "with that name.");
            else if (e instanceof LinkFailed)
                System.out.println("That exit is not functioning.");
            else if (e instanceof BadPassword)
                System.out.println("Invalid password.");
            else if (e instanceof NotThere)
                System.out.println("You can't do that when " + "you're not there.");
            else if (e instanceof AlreadyThere)
                System.out.println("You can't go there; " + "you're already there.");
        }// Handle RMI exceptions
         catch (RemoteException e) {
            System.out.println("The MUD is having technical difficulties.");
            System.out.println("Perhaps the server has crashed:");
            System.out.println(e);
        }// Handle everything else that could go wrong.
         catch (Exception e) {
            System.out.println("Syntax or other error:");
            System.out.println(e);
            System.out.println("Try using the 'help' command.");
        }
    }
}

{'file', 'pause', 'covering', 'save', 'object', 'existing', 'follows', 'huge', 'printing', 'bit', 'mudclient', 'begin', 'output', 'block', 'bottom', 'additional', 'occur', 'repeated', 'processing', 'mudexception', 'statement', 'remotemudplace', 'simply', 'happen', 'give', 'supported', 'connect', 'state', 'connects', 'invoke', 'note'}
/** 
     * This convenience method is used in several places in the
     * runMud() method above.  It displays the name and description of
     * the current place (including the name of the mud the place is in), 
     * and also displays the list of things, people, and exits in
     * the current place.
     **/
public static void look(RemoteMudPlace p) throws RemoteException, MudException {
    // Mud name
    String mudname = p.getServer().getMudName();
    // Place name
    String placename = p.getPlaceName();
    // Place description
    String description = p.getDescription();
    // List of things here
    Vector things = p.getThings();
    // List of people here
    Vector names = p.getNames();
    // List of exits from here
    Vector exits = p.getExits();
    // Print it all out
    System.out.println("You are in: " + placename + " of the Mud: " + mudname);
    System.out.println(description);
    System.out.print("Things here: ");
    for (int i = 0; i < things.size(); i++) {
        // Display list of things
        if (i > 0)
            System.out.print(", ");
        System.out.print(things.elementAt(i));
    }
    System.out.print("\nPeople here: ");
    for (int i = 0; i < names.size(); i++) {
        // Display list of people
        if (i > 0)
            System.out.print(", ");
        System.out.print(names.elementAt(i));
    }
    System.out.print("\nExits are: ");
    for (int i = 0; i < exits.size(); i++) {
        // Display list of exits
        if (i > 0)
            System.out.print(", ");
        System.out.print(exits.elementAt(i));
    }
    // Blank line
    System.out.println();
    // Make it appear now!
    System.out.flush();
}

{'runmud'}
/**
     * A convenience method for getting multi-line input from the user.
     * It prompts for the input, displays instructions, and guarantees that
     * the input is not empty.  It also allows the user to enter the name of
     * a file from which text will be read.
     **/
public static String getMultiLine(String prompt) {
    String text = "";
    for (; ; ) {
        // We'll break out of this loop when we get non-empty input
        try {
            // The stream to read from 
            BufferedReader br = in;
            // Display the prompt
            System.out.println(prompt);
            // Display some instructions
            System.out.println("You can enter multiple lines.  " + "End with a '.' on a line by itself.\n" + "Or enter a '<<' followed by a filename");
            // Make the prompt and instructions appear now.
            System.out.flush();
            // Read lines
            String line;
            while ((line = br.readLine()) != null) {
                // Or until a dot by itself
                if (line.equals("."))
                    break;
                // instead of from the console.
                if (line.trim().startsWith("<<")) {
                    String filename = line.trim().substring(2).trim();
                    br = new BufferedReader(new FileReader(filename));
                    // Don't count the << as part of the input
                    continue;
                } else
                    // Add the line to the collected input
                    text += line + "\n";
            }
            // the user and go back to the prompt and the instructions.
            if (text.length() > 0)
                return text;
            else
                System.out.println("Please enter at least one line.");
        }// instructions
         catch (Exception e) {
            System.out.println(e);
        }
    }
}

{'otherwise', 'eof', 'error', 'reading', 'io', 'specified', 'got', 'example', 'displaying', 'chastise'}
/**
     * Start a MUD from scratch, with the given name and password.  Create
     * an initial MudPlace object as the entrance, giving it the specified
     * name and description.
     **/
public MudServer(String mudname, String password, String placename, String description) throws RemoteException {
    this.mudname = mudname;
    this.password = password;
    this.places = new Hashtable();
    // Create the entrance place
    try {
        this.entrance = new MudPlace(this, placename, description);
    }// Should never happen
     catch (PlaceAlreadyExists e) {
    }
}

{'mudplace'}
/**
     * This remote method returns a RemoteMudPlace object for the named place.
     * In this sense, a MudServer acts as like an RMI Registry object,
     * returning remote objects looked up by name.  It is simpler to do it this
     * way than to use an actual Registry object.  If the named place does not
     * exist, it throws a NoSuchPlace exception
     **/
public RemoteMudPlace getNamedPlace(String name) throws RemoteException, NoSuchPlace {
    RemoteMudPlace p = (RemoteMudPlace) places.get(name);
    if (p == null)
        throw new NoSuchPlace();
    return p;
}

{'remotemudplace', 'mudserver', 'nosuchplace'}
/**
     * Define a new placename to place mapping in our hashtable.  
     * This is not a remote method.  The MudPlace() constructor calls it
     * to register the new place it is creating.
     **/
public void setPlaceName(RemoteMudPlace place, String name) throws PlaceAlreadyExists {
    if (places.containsKey(name))
        throw new PlaceAlreadyExists();
    places.put(name, place);
}

{'mudplace'}
/**
     * This main() method defines the standalone program that starts up a MUD
     * server.  If invoked with a single argument, it treats that argument as
     * the name of a file containing the serialized and compressed state of an
     * existing MUD, and recreates it.  Otherwise, it expects four command-line
     * arguments: the name of the MUD, the password, the name of the entrance
     * place for the MUD, and a description of that entrance place.
     * Besides creating the MudServer object, this program sets an appropriate
     * security manager, and uses the default rmiregistry to register the
     * the MudServer under its given name.
     **/
public static void main(String[] args) {
    try {
        MudServer server;
        if (args.length == 1) {
            // Read the MUD state in from a file
            FileInputStream f = new FileInputStream(args[0]);
            ObjectInputStream in = new ObjectInputStream(new GZIPInputStream(f));
            server = (MudServer) in.readObject();
        } else
            // Otherwise, create an initial MUD from scratch
            server = new MudServer(args[0], args[1], args[2], args[3]);
        Naming.rebind(Mud.mudPrefix + server.mudname, server);
    }// Display an error message if anything goes wrong.
     catch (Exception e) {
        System.out.println(e);
        System.out.println("Usage: java MudServer <savefile>\n" + "   or: java MudServer <mudname> <password> " + "<placename> <description>");
        System.exit(1);
    }
}

{'mudserver'}
/** 
     * This remote method returns a RemoteMudPerson object corresponding to
     * the specified name, or throws an exception if no such person is here 
     **/
public RemoteMudPerson getPerson(String name) throws RemoteException, NoSuchPerson {
    synchronized (names) {
        // What about when there are 2 of the same name?
        int i = names.indexOf(name);
        if (i == -1)
            throw new NoSuchPerson();
        return (RemoteMudPerson) people.elementAt(i);
    }
}

{'remotemudperson'}
/** 
     * This remote method moves the specified RemoteMudPerson from this place
     * in the named direction (i.e. through the named exit) to whatever place
     * is there.  It throws exceptions if the specified person isn't in this
     * place to begin with, or if they are already in the place through the 
     * exit or if the exit doesn't exist, or if the exit links to another MUD 
     * server and the server is not functioning.
     **/
public RemoteMudPlace go(RemoteMudPerson who, String direction) throws RemoteException, NotThere, AlreadyThere, NoSuchExit, LinkFailed {
    // Make sure the direction is valid, and get destination if it is
    Object destination;
    synchronized (exits) {
        int i = exits.indexOf(direction);
        if (i == -1)
            throw new NoSuchExit();
        destination = destinations.elementAt(i);
    }
    // If destination is a string, it is a place on another server, so
    // connect to that server.  Otherwise, it is a place already on this
    // server.  Throw an exception if we can't connect to the server.
    RemoteMudPlace newplace;
    if (destination instanceof String) {
        try {
            String t = (String) destination;
            int pos = t.indexOf('@');
            String url = t.substring(0, pos);
            String placename = t.substring(pos + 1);
            RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);
            newplace = s.getNamedPlace(placename);
        } catch (Exception e) {
            throw new LinkFailed();
        }
    } else
        // If the destination is not a string, then it is a Place
        newplace = (RemoteMudPlace) destination;
    // Make sure the person is here and get their name.  
    // Throw an exception if they are not here
    String name = verifyPresence(who);
    // Move the person out of here, and tell everyone who remains about it.
    this.exit(who, name + " has gone " + direction);
    // Put the person into the new place.  
    // Send a message to everyone already in that new place
    String fromwhere;
    if (// going to a local place
    newplace instanceof MudPlace)
        fromwhere = placename;
    else
        fromwhere = server.getMudName() + "." + placename;
    newplace.enter(who, name, name + " has arrived from: " + fromwhere);
    // know where they are now at.
    return newplace;
}

{'remotemudplace', 'remotemudperson', 'client'}
/**
     * Create a new place in this MUD, with the specified name an description. 
     * The new place is accessible from this place through
     * the specified exit, and this place is accessible from the new place 
     * through the specified entrance.  The creator must be in this place
     * in order to create a exit from this place.
     **/
public void createPlace(RemoteMudPerson creator, String exit, String entrance, String name, String description) throws RemoteException, NotThere, ExitAlreadyExists, PlaceAlreadyExists {
    // Verify that the creator is actually here in this place
    String creatorname = verifyPresence(creator);
    synchronized (exits) {
        // Check that the exit doesn't already exist.
        if (exits.indexOf(exit) != -1)
            throw new ExitAlreadyExists();
        // Create the new place, registering its name with the server
        MudPlace destination = new MudPlace(server, name, description);
        // Link from there back to here
        destination.exits.addElement(entrance);
        destination.destinations.addElement(this);
        // And link from here to there
        exits.addElement(exit);
        destinations.addElement(destination);
    }
    // Let everyone know about the new exit, and the new place beyond
    tellEveryone(creatorname + " has created a new place: " + exit);
}

{'time', 'TIME', 'client', 'change'}
/**
     * Create a new exit from this mud, linked to a named place in a named
     * MUD on a named host (this can also be used to link to a named place in 
     * the current MUD, of course).  Because of the possibilities of deadlock,
     * this method only links from here to there; it does not create a return
     * exit from there to here.  That must be done with a separate call.
     **/
public void linkTo(RemoteMudPerson linker, String exit, String hostname, String mudname, String placename) throws RemoteException, NotThere, ExitAlreadyExists, NoSuchPlace {
    // Verify that the linker is actually here 
    String name = verifyPresence(linker);
    // Check that the link target actually exists.  Throw NoSuchPlace if
    // not.  Note that NoSuchPlace may also mean "NoSuchMud" or
    // "MudNotResponding".
    String url = "rmi://" + hostname + '/' + Mud.mudPrefix + mudname;
    try {
        RemoteMudServer s = (RemoteMudServer) Naming.lookup(url);
        RemoteMudPlace destination = s.getNamedPlace(placename);
    } catch (Exception e) {
        throw new NoSuchPlace();
    }
    synchronized (exits) {
        // Check that the exit doesn't already exist.
        if (exits.indexOf(exit) != -1)
            throw new ExitAlreadyExists();
        // Add the exit, to the list of exit names
        exits.addElement(exit);
        // And add the destination to the list of destinations.  Note that
        // the destination is stored as a string rather than as a
        // RemoteMudPlace.  This is because if the remote server goes down
        // then comes back up again, a RemoteMudPlace is not valid, but the
        // string still is.
        destinations.addElement(url + '@' + placename);
    }
    // Let everyone know about the new exit and where it leads
    tellEveryone(name + " has linked " + exit + " to " + "'" + placename + "' in MUD '" + mudname + "' on host " + hostname);
}

{'remotemudplace', 'nosuchmud', 'nosuchplace', 'mudnotresponding'}
/** 
     * This method puts a person into this place, assigning them the
     * specified name, and displaying a message to anyone else who is in
     * that place.  This method is called by go(), and the client should
     * call it to initially place a person into the MUD.  Once the person
     * is in the MUD, however, the client should restrict them to using go()
     * and should not allow them to call this method directly.
     * If there have been networking problems, a client might call this method
     * to restore a person to this place, in case they've been bumped out.
     * (A person will be bumped out of a place if the server tries to send
     * a message to them and gets a RemoteException.)
     **/
public void enter(RemoteMudPerson who, String name, String message) throws RemoteException, AlreadyThere {
    // Send the message to everyone who is already here.
    if (message != null)
        tellEveryone(message);
    // Add the person to this place.
    synchronized (names) {
        if (people.indexOf(who) != -1)
            throw new AlreadyThere();
        names.addElement(name);
        people.addElement(who);
    }
}

{'remoteexception'}
public void run() {
    // Loop through the recipients
    for (int i = 0; i < recipients.size(); i++) {
        RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);
        // Try to send the message to each one.
        try {
            person.tell(message);
        }// this place.
         catch (RemoteException e) {
            try {
                MudPlace.this.exit(person, null);
            } catch (Exception ex) {
            }
        }
    }
}

{'fails', 'client', 'failed', 'remove', 'silently', 'assume', 'network'}
/** 
     * Create and start a thread that sends out a message everyone in this
     * place.  If it gets a RemoteException talking to a person, it silently
     * removes that person from this place.  This is not a remote method, but
     * is used internally by a number of remote methods.
     **/
protected void tellEveryone(final String message) {
    // If there is no-one here, don't bother sending the message!
    if (people.size() == 0)
        return;
    // Make a copy of the people here now.  The message is sent
    // asynchronously and the list of people in the room may change before
    // the message is sent to everyone.
    final Vector recipients = (Vector) people.clone();
    // Create and start a thread to send the message, using an anonymous
    // class.  We do this because sending the message to everyone in this
    // place might take some time, (particularly on a slow or flaky
    // network) and we don't want to wait.
    new Thread() {

        public void run() {
            // Loop through the recipients
            for (int i = 0; i < recipients.size(); i++) {
                RemoteMudPerson person = (RemoteMudPerson) recipients.elementAt(i);
                // Try to send the message to each one.
                try {
                    person.tell(message);
                }// this place.
                 catch (RemoteException e) {
                    try {
                        MudPlace.this.exit(person, null);
                    } catch (Exception ex) {
                    }
                }
            }
        }
    }.start();
}

{'remoteexception', 'assume', 'fails', 'client', 'failed'}
/**
     * This convenience method checks whether the specified person is here.
     * If so, it returns their name.  If not it throws a NotThere exception
     **/
protected String verifyPresence(RemoteMudPerson who) throws NotThere {
    int i = people.indexOf(who);
    if (i == -1)
        throw new NotThere();
    else
        return (String) names.elementAt(i);
}

{'notthere'}
/** 
     * Close the named account.  This method is synchronized to make it 
     * thread safe, since it manipulates the accounts hashtable.
     **/
public synchronized FunnyMoney closeAccount(String name, String password) throws RemoteException, BankingException {
    Account acct;
    acct = verify(name, password);
    accounts.remove(name);
    // have to obtain a lock on that account to be thread safe.
    synchronized (acct) {
        int balance = acct.balance;
        acct.balance = 0;
        return new FunnyMoney(balance);
    }
}

{'RANK', 'transaction', 'changing'}
/** Deposit the specified FunnyMoney to the named account */
public void deposit(String name, String password, FunnyMoney money) throws RemoteException, BankingException {
    Account acct = verify(name, password);
    synchronized (acct) {
        acct.balance += money.amount;
        acct.transactions.add("Deposited " + money.amount + " on " + new Date());
    }
}

{'funnymoney'}
/**
     * The main program that runs this RemoteBankServer.
     * Create a RemoteBankServer object and give it a name in the registry.
     * Read a system property to determine the name, but use "FirstRemote"
     * as the default name.  This is all that is necessary to set up the
     * service.  RMI takes care of the rest.
     **/
public static void main(String[] args) {
    try {
        // Create a bank server object
        RemoteBankServer bank = new RemoteBankServer();
        // Figure out what to name it
        String name = System.getProperty("bankname", "FirstRemote");
        // Name it that
        Naming.rebind(name, bank);
        // Tell the world we're up and running
        System.out.println(name + " is open and ready for customers.");
    } catch (Exception e) {
        System.err.println(e);
        System.err.println("Usage: java [-Dbankname=<name>] " + "com.davidflanagan.examples.rmi.RemoteBankServer");
        System.exit(1);
    }
}

{'thread', 'remotebankserver', 'force', 'TIME', 'firstremote'}
// The bean box calls this method to tell us what object to customize.
// This method will always be called before the customizer is displayed,
// so it is safe to create the customizer GUI here.
public void setObject(Object o) {
    // save the object we're customizing
    bean = (YesNoPanel) o;
    // Put a label at the top of the panel.
    this.setLayout(new BorderLayout());
    this.add(new Label("Enter the message to appear in the panel:"), "North");
    // And a big text area below it for entering the message.
    message = new TextArea(bean.getMessageText());
    message.addTextListener(this);
    // TextAreas don't know how big they want to be.  You must tell them.
    message.setSize(400, 200);
    this.add(message, "Center");
    // Then add a row of textfields for entering the button labels.
    // The row container
    Panel buttonbox = new Panel();
    // Equally spaced
    buttonbox.setLayout(new GridLayout(1, 0, 25, 10));
    // Put row on bottom
    this.add(buttonbox, "South");
    // Now go create three TextFields to put in this row.  But actually
    // position a Label above each, so create an container for each
    // TextField+Label combination.
    // Array of TextFields.
    fields = new TextField[3];
    String[] labels = new String[] { // Labels for each.
    "Yes Button Label", "No Button Label", "Cancel Button Label" };
    String[] values = new String[] { // Initial values of each.
    bean.getYesLabel(), bean.getNoLabel(), bean.getCancelLabel() };
    for (int i = 0; i < 3; i++) {
        // Create a container.
        Panel p = new Panel();
        // Give it a BorderLayout.
        p.setLayout(new BorderLayout());
        // Put a label on the top.
        p.add(new Label(labels[i]), "North");
        // Create the text field.
        fields[i] = new TextField(values[i]);
        // Put it below the label.
        p.add(fields[i], "Center");
        // Set the event listener.
        fields[i].addTextListener(this);
        // Add container to row.
        buttonbox.add(p);
    }
}

{'textfield', 'borderlayout', 'textareas'}
/** This is a convenience method for creating PropertyDescriptor objects */
static PropertyDescriptor prop(String name, String description) {
    try {
        PropertyDescriptor p = new PropertyDescriptor(name, YesNoPanel.class);
        p.setShortDescription(description);
        return p;
    } catch (IntrospectionException e) {
        return null;
    }
}

{'propertydescriptor'}
// Return the custom editor.  This just creates and returns a TextArea
// to edit the multi-line text.  But it also registers a listener on the
// text area to update the value as the user types and to fire the
// property change events that property editors are required to fire.
public Component getCustomEditor() {
    final TextArea t = new TextArea(value);
    // TextArea has no preferred size, so set one
    t.setSize(300, 150);
    t.addTextListener(new TextListener() {

        public void textValueChanged(TextEvent e) {
            value = t.getText();
            listeners.firePropertyChange(null, null, null);
        }
    });
    return t;
}

{'textarea'}
/** A constructor for programmers using this class "by hand" */
public YesNoPanel(String messageText, Alignment alignment, String yesLabel, String noLabel, String cancelLabel) {
    // Create the components for this panel
    setLayout(new BorderLayout(15, 15));
    // Put the message label in the middle of the window.
    message = new MultiLineLabel(messageText, 20, 20, alignment);
    add(message, BorderLayout.CENTER);
    // Create a panel for the Panel buttons and put it at the bottom
    // of the Panel.  Specify a FlowLayout layout manager for it.
    Panel buttonbox = new Panel();
    buttonbox.setLayout(new FlowLayout(FlowLayout.CENTER, 25, 15));
    add(buttonbox, BorderLayout.SOUTH);
    // Create each specified button, specifying the action listener
    // and action command for each, and adding them to the buttonbox
    // Create buttons
    yes = new Button();
    no = new Button();
    cancel = new Button();
    // Add the buttons to the button box
    buttonbox.add(yes);
    buttonbox.add(no);
    buttonbox.add(cancel);
    // Register listeners for each button
    yes.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.YES));
        }
    });
    no.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.NO));
        }
    });
    cancel.addActionListener(new ActionListener() {

        public void actionPerformed(ActionEvent e) {
            fireEvent(new AnswerEvent(YesNoPanel.this, AnswerEvent.CANCEL));
        }
    });
    // Now call property setter methods to set the message and button
    // components to contain the right text
    setMessageText(messageText);
    setAlignment(alignment);
    setYesLabel(yesLabel);
    setNoLabel(noLabel);
    setCancelLabel(cancelLabel);
}

{'flowlayout'}
/** A main method that demonstrates the class */
public static void main(String[] args) {
    // Create an instance of InfoPanel, with title and message specified:
    YesNoPanel p = new YesNoPanel("Do you really want to quit?");
    // Register an action listener for the Panel.  This one just prints
    // the results out to the console.
    p.addAnswerListener(new AnswerListener() {

        public void yes(AnswerEvent e) {
            System.exit(0);
        }

        public void no(AnswerEvent e) {
            System.out.println("No");
        }

        public void cancel(AnswerEvent e) {
            System.out.println("Cancel");
        }
    });
    Frame f = new Frame();
    f.add(p);
    f.pack();
    f.setVisible(true);
}

{'infopanel'}
/**
     * This method is called by a layout manager when it wants to
     * know how big we'd like to be.  In Java 1.1, getPreferredSize() is
     * the preferred version of this method.  We use this deprecated version
     * so that this component can interoperate with 1.0 components.
     */
public Dimension preferredSize() {
    if (!measured)
        measure();
    return new Dimension(max_width + 2 * margin_width, num_lines * line_height + 2 * margin_height);
}

{'getpreferredsize'}
/**
     * This method is called when the layout manager wants to know
     * the bare minimum amount of space we need to get by.
     * For Java 1.1, we'd use getMinimumSize().
     */
public Dimension minimumSize() {
    return preferredSize();
}

{'getminimumsize'}
/**
     * This method draws the component.
     * Note that it handles the margins and the alignment, but that
     * it doesn't have to worry about the color or font--the superclass
     * takes care of setting those in the Graphics object we're passed.
     **/
public void paint(Graphics g) {
    int x, y;
    // use getSize() in Java 1.1
    Dimension size = this.size();
    if (!measured)
        measure();
    y = line_ascent + (size.height - num_lines * line_height) / 2;
    for (int i = 0; i < num_lines; i++, y += line_height) {
        if (alignment == Alignment.LEFT)
            x = margin_width;
        else if (alignment == Alignment.CENTER)
            x = (size.width - line_widths[i]) / 2;
        else
            x = size.width - margin_width - line_widths[i];
        g.drawString(lines[i], x, y);
    }
}

{'getsize'}
/**
     * This internal method breaks a specified label up into an array of lines.
     * It uses the StringTokenizer utility class.
     **/
protected synchronized void newLabel() {
    StringTokenizer t = new StringTokenizer(label, "\n");
    num_lines = t.countTokens();
    lines = new String[num_lines];
    line_widths = new int[num_lines];
    for (int i = 0; i < num_lines; i++) lines[i] = t.nextToken();
}

{'stringtokenizer'}
/**
     * This method from the Externalizable interface is responsible for saving
     * the complete state of the object to the specified stream.  It can write
     * anything it wants as long as readExternal() can read it.
     **/
public void writeExternal(ObjectOutput out) throws IOException {
    // Compact the array.
    if (data.length > size)
        resize(size);
    // Start with our version number.
    out.writeByte(version);
    // Output the number of array elements
    out.writeInt(size);
    for (int i = 0; i < size; i++) {
        // Now loop through the array
        // The array element to write
        int n = data[i];
        if ((n < Short.MAX_VALUE) && (n > Short.MIN_VALUE + 1)) {
            // If n fits in a short and is not Short.MIN_VALUE, then write
            // it out as a short, saving ourselves two bytes
            out.writeShort(n);
        } else {
            // Otherwise write out the special value Short.MIN_VALUE to
            // signal that the number does not fit in a short, and then
            // output the number using a full 4 bytes, for 6 bytes total
            out.writeShort(Short.MIN_VALUE);
            out.writeInt(n);
        }
    }
}

{'readexternal'}
/**
     * This Externalizable method is responsible for completely restoring the
     * state of the object.  A no-arg constructor will be called to re-create
     * the object, and this method must read the state written by 
     * writeExternal() to restore the object's state.
     **/
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    // Start by reading and verifying the version number.
    byte v = in.readByte();
    if (v != version)
        throw new IOException("CompactIntList: unknown version number");
    // Read the number of array elements, and make array that big
    int newsize = in.readInt();
    resize(newsize);
    this.size = newsize;
    // Now read that many values from the stream
    for (int i = 0; i < newsize; i++) {
        short n = in.readShort();
        if (n != Short.MIN_VALUE)
            data[i] = n;
        else
            data[i] = in.readInt();
    }
}

{'writeexternal'}
/**
     * Use object serialization to make a "deep clone" of the object o.
     * This method serializes o and all objects it refers to, and then
     * deserializes that graph of objects, which means that everything is
     * copied.  This differs from the clone() method of an object which is
     * usually implemented to produce a "shallow" clone that copies references
     * to other objects, instead of copying all referenced objects.
     **/
static Object deepclone(final Serializable o) throws IOException, ClassNotFoundException {
    // Create a connected pair of "piped" streams.  
    // We'll write bytes to one, and them from the other one.
    final PipedOutputStream pipeout = new PipedOutputStream();
    PipedInputStream pipein = new PipedInputStream(pipeout);
    // Now define an independent thread to serialize the object and write
    // its bytes to the PipedOutputStream
    Thread writer = new Thread() {

        public void run() {
            ObjectOutputStream out = null;
            try {
                out = new ObjectOutputStream(pipeout);
                out.writeObject(o);
            } catch (IOException e) {
            } finally {
                try {
                    out.close();
                } catch (Exception e) {
                }
            }
        }
    };
    // Make the thread start serializing and writing
    writer.start();
    // Meanwhile, in this thread, read and deserialize from the piped
    // input stream.  The resulting object is a deep clone of the original.
    ObjectInputStream in = new ObjectInputStream(pipein);
    return in.readObject();
}

{'pipedoutputstream'}
