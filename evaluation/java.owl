<?xml version="1.0"?>


<!DOCTYPE Ontology [
    <!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" >
    <!ENTITY xml "http://www.w3.org/XML/1998/namespace" >
    <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" >
    <!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
]>


<Ontology xmlns="http://www.w3.org/2002/07/owl#"
     xml:base="http://www.sis.pitt.edu/~paws/ont/java.owl"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     ontologyIRI="http://www.sis.pitt.edu/~paws/ont/java.owl">
    <Prefix name="" IRI="http://www.sis.pitt.edu/~paws/ont/java.owl#"/>
    <Prefix name="p1" IRI="http://www.owl-ontologies.com/assert.owl#"/>
    <Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/>
    <Prefix name="rdf" IRI="http://www.w3.org/1999/02/22-rdf-syntax-ns#"/>
    <Prefix name="xsd" IRI="http://www.w3.org/2001/XMLSchema#"/>
    <Prefix name="rdfs" IRI="http://www.w3.org/2000/01/rdf-schema#"/>
    <!--<Annotation>
        <AnnotationProperty abbreviatedIRI="rdfs:label"/>
        <Literal datatypeIRI="&xsd;string">java_ontology</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="owl:versionInfo"/>
        <Literal datatypeIRI="&xsd;string">java_ontology by paws.sis.pitt.edu v. 0.8.1 2009-03-25</Literal>
    </Annotation>
    <Annotation>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <Literal datatypeIRI="&xsd;string">This is a second version of Java ontology created by the PAWS group for indexing adaptive java content
The main purpose of this ontology is to represent the domian of Java and provide the basis for modelling of student knowledge of java concepts and content-based adaptation of Java-related learning activities
This version is an RDFS ontology. It spesifieds the basic vocabulary of the domain. It has three relations: subClassOf, partOf-hasPart  and relatedTo</Literal>
    </Annotation>-->
    <Declaration>
        <Class IRI="#AbstractClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractClassDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractMethodDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AbstractModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Abstraction"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AccessSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ActualMethodParameter"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AddAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AddExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AdditiveExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AndExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArithmeticExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayCreationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayElement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayElementType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayInitializer"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayLength"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ArrayVariable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#AutoBoxing"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitShiftAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitShiftExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseAndAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseAndExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseOrAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseOrExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseXorAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BitwiseXorExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BooleanDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BooleanExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BooleanValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#BreakStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ByteDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ByteValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#CallBack"/>
    </Declaration>
    <Declaration>
        <Class IRI="#CaseClause"/>
    </Declaration>
    <Declaration>
        <Class IRI="#CharDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#CharValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Class"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassBody"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassConstantInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassField"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassFieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassMemberDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassMemberInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ClassSingnature"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConditionalExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Constant"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstantInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstantInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Constructor"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstructorCall"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstructorDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstructorName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ConstructorSignature"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ContinueStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DOM"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Data"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DefaultAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DefaultClause"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DefinitionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DivideAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DivideExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DoStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DoubleDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#DoubleValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Encapsulation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#EqualExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ExceptionClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ExceptionHandlingStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ExplicitTypeCasting"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Expression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ExpressionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ExtendsSpecification"/>
    </Declaration>
    <Declaration>
        <Class IRI="#False"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Field"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FieldDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FieldInheritance"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalClassDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalInstanceFieldInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalMethodDefintion"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FinalModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FloatDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FloatValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ForEachStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ForStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#FormalMethodParameter"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GenericClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GenericClassDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GenericObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GotoStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GreaterEqualExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#GreaterExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Identifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IfElseIfStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IfElseStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IfStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ImplementsSpecification"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ImplicitTypeCasting"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ImportStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IncrementDecrementExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Inheritance"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InheritanceBasedPolymorphism"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InnerClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InnerClassDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InstanceField"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InstanceFieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InstanceFieldInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InstanceFieldInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InstanceOfExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IntDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IntValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Interface"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceBasedPolymorphism"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceBody"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceClassConversion"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceImplementation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#InterfaceSignature"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Interfacing"/>
    </Declaration>
    <Declaration>
        <Class IRI="#IterationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Java"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaDatabaseAccess"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaLanguage"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaNetworking"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaOOP"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaPortability"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaSequirity"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibrary"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibraryClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibraryInterface"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibraryObject"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaStandardLibraryPackage"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaTechnology"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JavaXMLProcessing"/>
    </Declaration>
    <Declaration>
        <Class IRI="#JumpStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#LessEqualExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#LessExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#LogicalExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#LongDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#LongValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MainMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MainMethodDefintion"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Method"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodBody"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodImplementation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodInheritance"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodInvocationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodOverloading"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodOverriding"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MethodSignature"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Modifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ModulusAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ModulusExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiDimensionalArrayCreationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiDimensionalArrayDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiDimensionalArrayInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiDimensionalArrayInitializer"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiDimensionalArrayVariable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiplicativeExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiplyAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#MultiplyExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#NativeMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#NestedStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#NotEqualExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#NotExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OOPPrinciple"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Object"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ObjectEquality"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ObjectMethodInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ObjectReference"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ObjectVariable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OnDemandImport"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Operator"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OperatorAssociativity"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OperatorPrecedence"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OrExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OverridingClone"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OverridingEquals"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OverridingHashCode"/>
    </Declaration>
    <Declaration>
        <Class IRI="#OverridingToString"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Package"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PackageSpecificationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Parenthesis"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PolymorphicObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Polymorphism"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PostDecrementExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PostIncrementExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PreDecrementExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PreIncrementExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateConstructorSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PrivateModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProgramElementBody"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProgramElementDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProgramElementSignature"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProgramStructure"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedConstructorSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ProtectedModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicConstructorSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#PublicModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#RelationalExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ReturnStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ReturnedType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ReturnedValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SAX"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SelectionStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ShortDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ShortValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SignedLeftShiftAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SignedLeftShiftExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SignedRightShiftAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SignedRightShiftExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SimpleAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SimpleDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SimpleDataTypeValue"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SimpleVariable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Specification"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StandardIdentifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Statement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StatementBlock"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticImport"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticMethodDefinition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticMethodInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StaticModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StrictfpClassSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StrictfpInterfaceSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StrictfpMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StrictfpModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringAddition"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringLiteral"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringLiteralMethodInvocation"/>
    </Declaration>
    <Declaration>
        <Class IRI="#StringVariable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Subclass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SubtractAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SubtractExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperReference"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Superclass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperclassConstructor"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperclassConstructorCall"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperclassMethod"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperclassMethodCall"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SuperclassSubclassConversion"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SwitchStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SynchronizedMethodSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#SynchronizedModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ThisReference"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ThrowStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#ThrowsSpecification"/>
    </Declaration>
    <Declaration>
        <Class IRI="#TransientFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#TransientModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#True"/>
    </Declaration>
    <Declaration>
        <Class IRI="#TryCatchFinallyStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#TryCatchStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#TypeCasting"/>
    </Declaration>
    <Declaration>
        <Class IRI="#UnaryMinusOperator"/>
    </Declaration>
    <Declaration>
        <Class IRI="#UnsignedRightShiftAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#UnsignedRightShiftExpression"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Value"/>
    </Declaration>
    <Declaration>
        <Class IRI="#Variable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VariableDeclarationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VariableInitializationStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VariableName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VoidDataType"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VolatileFieldSpecifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#VolatileModifier"/>
    </Declaration>
    <Declaration>
        <Class IRI="#WhileStatement"/>
    </Declaration>
    <Declaration>
        <Class IRI="#WrapperClass"/>
    </Declaration>
    <Declaration>
        <Class IRI="#XPath"/>
    </Declaration>
    <Declaration>
        <Class IRI="#XSLT"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Boolean"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Byte"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Character"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Class"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Class.forName"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Double"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Double.parseDouble"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Exception"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Float"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Integer"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Integer.parseInt"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Long"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.abs"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.ceil"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.cos"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.exp"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.floor"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.log"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.max"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.min"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.pow"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.round"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.sin"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.sqrt"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Math.tan"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Object"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Object.clone"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Object.equals"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Object.hashCode"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Object.toString"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Short"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.charAt"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.compareTo"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.compareToIgnoreCase"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.concat"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.equals"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.equalsIgnoreCase"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.indexOf"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.length"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.replace"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.substring"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.toLowerCase"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.String.toUpperCase"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System.err"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System.in"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System.out"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System.out.print"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.System.out.println"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Thread"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Throwable"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.lang.Void"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.add"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.get"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.indexOf"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.remove"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.set"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.ArrayList.size"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.List"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Random"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Random.nextDouble"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Random.nextInt"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Scanner"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Scanner.next"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Scanner.nextDouble"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Scanner.nextInt"/>
    </Declaration>
    <Declaration>
        <Class IRI="#java.util.Scanner.nextLine"/>
    </Declaration>
    <Declaration>
        <Class IRI="#null"/>
    </Declaration>
    <Declaration>
        <Class IRI="#nullInitialization"/>
    </Declaration>
    <Declaration>
        <Class IRI="#nullReturn"/>
    </Declaration>
    <Declaration>
        <ObjectProperty IRI="#hasPart"/>
    </Declaration>
    <Declaration>
        <ObjectProperty IRI="#partOf"/>
    </Declaration>
    <Declaration>
        <ObjectProperty IRI="#relatedTo"/>
    </Declaration>
    <Declaration>
        <DataProperty IRI="#indexing"/>
    </Declaration>
    <Declaration>
        <DataProperty IRI="#parsable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AbstractClass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AbstractMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AbstractModifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArithmeticAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArithmeticExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayElement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayElementType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayInitializer"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayLength"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ArrayVariable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AssignmentExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#AutoBoxing"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#BooleanDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#BooleanValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#BreakStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ByteDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ByteValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#CharDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#CharValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Class"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassBody"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassField"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ClassSingnature"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConditionalExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Constant"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConstantInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConstantInvocation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Constructor"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConstructorDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConstructorName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ConstructorSignature"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#DataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#DoubleDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#DoubleValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Encapsulation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Expression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ExpressionStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ExtendsSpecification"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Field"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FieldDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FieldInheritance"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalClass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalClassDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalInstanceFieldInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FinalModifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FloatDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FloatValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#FormalMethodParameter"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#GenericClass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#GenericClassDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#GenericObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ImplementsSpecification"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ImportStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#IncrementDecrementExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Inheritance"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InheritanceBasedPolymorphism"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InstanceField"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InstanceFieldInvocation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InstanceOfExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#IntDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#IntValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Interface"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceBasedPolymorphism"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceBody"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceClassConversion"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceImplementation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#InterfaceSignature"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Interfacing"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#JavaStandardLibraryMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#JavaStandardLibraryObject"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#JavaStandardLibraryPackage"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#LongDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#LongValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MainMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MainMethodDefintion"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Method"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodBody"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodImplementation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodInheritance"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodInvocation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodInvocationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodOverloading"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodOverriding"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#MethodSignature"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Object"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ObjectEquality"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ObjectReference"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ObjectVariable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Operator"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OperatorAssociativity"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OperatorPrecedence"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OverridingClone"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OverridingEquals"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OverridingHashCode"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#OverridingToString"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Package"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#PolymorphicObjectCreationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Polymorphism"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#PrivateAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#PublicAccessSpecifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ReturnStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ReturnedType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ReturnedValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ShortDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ShortValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SimpleDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SimpleVariable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Statement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StatementBlock"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StaticMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StaticModifier"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringAddition"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringLiteral"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringLiteralMethodInvocation"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#StringVariable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Subclass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperReference"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Superclass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperclassConstructor"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperclassConstructorCall"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperclassMethod"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperclassMethodCall"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SuperclassSubclassConversion"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#SwitchStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ThrowStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#ThrowsSpecification"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#TryCatchFinallyStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#TryCatchStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#TypeCasting"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Value"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#Variable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#VariableDeclarationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#VariableName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#VoidDataType"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#WrapperClass"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Boolean"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Byte"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Character"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Class"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Class.forName"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Double"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Double.parseDouble"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Exception"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Float"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Integer"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Integer.parseInt"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Long"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.abs"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.ceil"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.cos"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.exp"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.floor"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.log"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.max"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.min"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.pow"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.round"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.sin"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.sqrt"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Math.tan"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Object"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Object.clone"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Object.hashCode"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Object.toString"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Short"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.charAt"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.compareTo"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.compareToIgnoreCase"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.concat"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.equals"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.equalsIgnoreCase"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.indexOf"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.length"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.replace"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.substring"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.toLowerCase"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.String.toUpperCase"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System.err"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System.in"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System.out"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System.out.print"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.System.out.println"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Thread"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Throwable"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.lang.Void"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.add"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.get"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.indexOf"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.remove"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.set"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.ArrayList.size"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.List"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Random"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Random.nextDouble"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Random.nextInt"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Scanner.next"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Scanner.nextDouble"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Scanner.nextInt"/>
    </Declaration>
    <Declaration>
        <NamedIndividual IRI="#java.util.Scanner.nextLine"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="#indexing"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty IRI="#parsable"/>
    </Declaration>
    <Declaration>
        <AnnotationProperty abbreviatedIRI="owl:disjointWith"/>
    </Declaration>
    <SubClassOf>
        <Class IRI="#AbstractClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractClassDefinition"/>
        <Class IRI="#ClassDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractClassSpecifier"/>
        <Class IRI="#AbstractModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractInterfaceSpecifier"/>
        <Class IRI="#AbstractModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractMethod"/>
        <Class IRI="#Method"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractMethodDefinition"/>
        <Class IRI="#MethodDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractMethodSpecifier"/>
        <Class IRI="#AbstractModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AbstractModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Abstraction"/>
        <Class IRI="#OOPPrinciple"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AccessSpecifier"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ActualMethodParameter"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AddAssignmentExpression"/>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AddExpression"/>
        <Class IRI="#AdditiveExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AdditiveExpression"/>
        <Class IRI="#ArithmeticExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AndExpression"/>
        <Class IRI="#BooleanExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArithmeticAssignmentExpression"/>
        <Class IRI="#AssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArithmeticExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayCreationStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayDataType"/>
        <Class IRI="#ClassDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayElement"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayElementType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayInitializationStatement"/>
        <Class IRI="#VariableInitializationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayInitializer"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayLength"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ArrayVariable"/>
        <Class IRI="#ObjectVariable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AssignmentExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#AutoBoxing"/>
        <Class IRI="#TypeCasting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitShiftAssignmentExpression"/>
        <Class IRI="#AssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitShiftExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseAndAssignmentExpression"/>
        <Class IRI="#BitwiseAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseAndExpression"/>
        <Class IRI="#BitwiseExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseAssignmentExpression"/>
        <Class IRI="#AssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseOrAssignmentExpression"/>
        <Class IRI="#BitwiseAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseOrExpression"/>
        <Class IRI="#BitwiseExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseXorAssignmentExpression"/>
        <Class IRI="#BitwiseAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BitwiseXorExpression"/>
        <Class IRI="#BitwiseExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BooleanDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BooleanExpression"/>
        <Class IRI="#LogicalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BooleanValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#BreakStatement"/>
        <Class IRI="#JumpStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ByteDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ByteValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#CallBack"/>
        <Class IRI="#Interfacing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#CaseClause"/>
        <Class IRI="#SwitchStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#CharDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#CharValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Class"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassBody"/>
        <Class IRI="#ProgramElementBody"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassConstantInitializationStatement"/>
        <Class IRI="#ClassFieldDefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassDataType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassDefinition"/>
        <Class IRI="#ProgramElementDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassField"/>
        <Class IRI="#Field"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassFieldDefinitionStatement"/>
        <Class IRI="#FieldDefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassMemberDefinition"/>
        <Class IRI="#ProgramElementDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassMemberInvocation"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassName"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ClassSingnature"/>
        <Class IRI="#ProgramElementSignature"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConditionalExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Constant"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstantInitializationStatement"/>
        <Class IRI="#VariableInitializationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstantInvocation"/>
        <Class IRI="#ClassMemberInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Constructor"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstructorCall"/>
        <Class IRI="#ClassMemberInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstructorDefinition"/>
        <Class IRI="#ClassMemberDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstructorName"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ConstructorSignature"/>
        <Class IRI="#ProgramElementSignature"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ContinueStatement"/>
        <Class IRI="#JumpStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DOM"/>
        <Class IRI="#JavaXMLProcessing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Data"/>
        <Class IRI="#JavaLanguage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DataType"/>
        <Class IRI="#Data"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DefaultAccessSpecifier"/>
        <Class IRI="#AccessSpecifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DefaultClause"/>
        <Class IRI="#SwitchStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DefinitionStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DivideAssignmentExpression"/>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DivideExpression"/>
        <Class IRI="#MultiplicativeExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DoStatement"/>
        <Class IRI="#IterationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DoubleDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#DoubleValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Encapsulation"/>
        <Class IRI="#OOPPrinciple"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#EqualExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ExceptionClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ExceptionHandlingStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ExplicitTypeCasting"/>
        <Class IRI="#TypeCasting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Expression"/>
        <Class IRI="#JavaLanguage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ExpressionStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ExtendsSpecification"/>
        <Class IRI="#Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#False"/>
        <Class IRI="#BooleanValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Field"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FieldDefinition"/>
        <Class IRI="#ClassMemberDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FieldDefinitionStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FieldInheritance"/>
        <Class IRI="#Inheritance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalClassDefinition"/>
        <Class IRI="#ClassDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalClassSpecifier"/>
        <Class IRI="#FinalModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalFieldSpecifier"/>
        <Class IRI="#FinalModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalInstanceFieldInitializationStatement"/>
        <Class IRI="#InstanceFieldDefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalMethod"/>
        <Class IRI="#Method"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalMethodDefintion"/>
        <Class IRI="#MethodDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalMethodSpecifier"/>
        <Class IRI="#FinalModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FinalModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FloatDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FloatValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ForEachStatement"/>
        <Class IRI="#IterationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ForStatement"/>
        <Class IRI="#IterationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#FormalMethodParameter"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GenericClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GenericClassDefinition"/>
        <Class IRI="#ClassDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GenericObjectCreationStatement"/>
        <Class IRI="#ObjectCreationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GotoStatement"/>
        <Class IRI="#JumpStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GreaterEqualExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#GreaterExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Identifier"/>
        <Class IRI="#JavaLanguage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IfElseIfStatement"/>
        <Class IRI="#SelectionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IfElseStatement"/>
        <Class IRI="#SelectionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IfStatement"/>
        <Class IRI="#SelectionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ImplementsSpecification"/>
        <Class IRI="#Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ImplicitTypeCasting"/>
        <Class IRI="#TypeCasting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ImportStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IncrementDecrementExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Inheritance"/>
        <Class IRI="#OOPPrinciple"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InheritanceBasedPolymorphism"/>
        <Class IRI="#Polymorphism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InnerClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InnerClassDefinition"/>
        <Class IRI="#ClassDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InstanceField"/>
        <Class IRI="#Field"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InstanceFieldDefinitionStatement"/>
        <Class IRI="#FieldDefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InstanceFieldInitializationStatement"/>
        <Class IRI="#InstanceFieldDefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InstanceFieldInvocation"/>
        <Class IRI="#ClassMemberInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InstanceOfExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IntDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IntValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Interface"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceBasedPolymorphism"/>
        <Class IRI="#Polymorphism"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceBody"/>
        <Class IRI="#ProgramElementBody"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceClassConversion"/>
        <Class IRI="#TypeCasting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceDataType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceDefinition"/>
        <Class IRI="#ProgramElementDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceImplementation"/>
        <Class IRI="#Interfacing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceName"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#InterfaceSignature"/>
        <Class IRI="#ProgramElementSignature"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Interfacing"/>
        <Class IRI="#OOPPrinciple"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#IterationStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaDatabaseAccess"/>
        <Class IRI="#JavaTechnology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaLanguage"/>
        <Class IRI="#Java"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaNetworking"/>
        <Class IRI="#JavaTechnology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaOOP"/>
        <Class IRI="#Java"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaPortability"/>
        <Class IRI="#JavaTechnology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaSequirity"/>
        <Class IRI="#JavaTechnology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibrary"/>
        <Class IRI="#Java"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibraryClass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibraryInterface"/>
        <Class IRI="#Interface"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibraryMethod"/>
        <Class IRI="#Method"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibraryObject"/>
        <Class IRI="#Object"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaStandardLibraryPackage"/>
        <Class IRI="#Package"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaTechnology"/>
        <Class IRI="#Java"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JavaXMLProcessing"/>
        <Class IRI="#JavaTechnology"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#JumpStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#LessEqualExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#LessExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#LogicalExpression"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#LongDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#LongValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MainMethod"/>
        <Class IRI="#StaticMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MainMethodDefintion"/>
        <Class IRI="#StaticMethodDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Method"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodBody"/>
        <Class IRI="#ProgramElementBody"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodDefinition"/>
        <Class IRI="#ClassMemberDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodImplementation"/>
        <Class IRI="#Interfacing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodInheritance"/>
        <Class IRI="#Inheritance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodInvocation"/>
        <Class IRI="#ClassMemberInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodInvocationStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodName"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodOverloading"/>
        <Class IRI="#MethodDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodOverriding"/>
        <Class IRI="#Inheritance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MethodSignature"/>
        <Class IRI="#ProgramElementSignature"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Modifier"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ModulusAssignmentExpression"/>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ModulusExpression"/>
        <Class IRI="#MultiplicativeExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiDimensionalArrayCreationStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiDimensionalArrayDataType"/>
        <Class IRI="#ClassDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiDimensionalArrayInitializationStatement"/>
        <Class IRI="#VariableInitializationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiDimensionalArrayInitializer"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiDimensionalArrayVariable"/>
        <Class IRI="#ObjectVariable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiplicativeExpression"/>
        <Class IRI="#ArithmeticExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiplyAssignmentExpression"/>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#MultiplyExpression"/>
        <Class IRI="#MultiplicativeExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#NativeMethodSpecifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#NestedStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#NotEqualExpression"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#NotExpression"/>
        <Class IRI="#BooleanExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OOPPrinciple"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Object"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ObjectCreationStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ObjectEquality"/>
        <Class IRI="#RelationalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ObjectMethodInvocation"/>
        <Class IRI="#MethodInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ObjectReference"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ObjectVariable"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OnDemandImport"/>
        <Class IRI="#ImportStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Operator"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OperatorAssociativity"/>
        <Class IRI="#Operator"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OperatorPrecedence"/>
        <Class IRI="#Operator"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OrExpression"/>
        <Class IRI="#BooleanExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OverridingClone"/>
        <Class IRI="#MethodOverriding"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OverridingEquals"/>
        <Class IRI="#MethodOverriding"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OverridingHashCode"/>
        <Class IRI="#MethodOverriding"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#OverridingToString"/>
        <Class IRI="#MethodOverriding"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Package"/>
        <Class IRI="#JavaOOP"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PackageSpecificationStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Parenthesis"/>
        <Class IRI="#ArithmeticExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PolymorphicObjectCreationStatement"/>
        <Class IRI="#ObjectCreationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Polymorphism"/>
        <Class IRI="#OOPPrinciple"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PostDecrementExpression"/>
        <Class IRI="#IncrementDecrementExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PostIncrementExpression"/>
        <Class IRI="#IncrementDecrementExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PreDecrementExpression"/>
        <Class IRI="#IncrementDecrementExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PreIncrementExpression"/>
        <Class IRI="#IncrementDecrementExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateAccessSpecifier"/>
        <Class IRI="#AccessSpecifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateClassSpecifier"/>
        <Class IRI="#PrivateModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateConstructorSpecifier"/>
        <Class IRI="#PrivateModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateFieldSpecifier"/>
        <Class IRI="#PrivateModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateInterfaceSpecifier"/>
        <Class IRI="#PrivateModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateMethodSpecifier"/>
        <Class IRI="#PrivateModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PrivateModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProgramElementBody"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProgramElementDefinition"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProgramElementSignature"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProgramStructure"/>
        <Class IRI="#JavaLanguage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedAccessSpecifier"/>
        <Class IRI="#AccessSpecifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedClassSpecifier"/>
        <Class IRI="#ProtectedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedConstructorSpecifier"/>
        <Class IRI="#ProtectedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedFieldSpecifier"/>
        <Class IRI="#ProtectedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedInterfaceSpecifier"/>
        <Class IRI="#ProtectedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedMethodSpecifier"/>
        <Class IRI="#ProtectedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ProtectedModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicAccessSpecifier"/>
        <Class IRI="#AccessSpecifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicClassSpecifier"/>
        <Class IRI="#PublicModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicConstructorSpecifier"/>
        <Class IRI="#PublicModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicFieldSpecifier"/>
        <Class IRI="#PublicModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicInterfaceSpecifier"/>
        <Class IRI="#PublicModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicMethodSpecifier"/>
        <Class IRI="#PublicModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#PublicModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#RelationalExpression"/>
        <Class IRI="#LogicalExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ReturnStatement"/>
        <Class IRI="#JumpStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ReturnedType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ReturnedValue"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SAX"/>
        <Class IRI="#JavaXMLProcessing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SelectionStatement"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ShortDataType"/>
        <Class IRI="#SimpleDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ShortValue"/>
        <Class IRI="#SimpleDataTypeValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SignedLeftShiftAssignmentExpression"/>
        <Class IRI="#BitShiftAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SignedLeftShiftExpression"/>
        <Class IRI="#BitShiftExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SignedRightShiftAssignmentExpression"/>
        <Class IRI="#BitShiftAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SignedRightShiftExpression"/>
        <Class IRI="#BitShiftExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SimpleAssignmentExpression"/>
        <Class IRI="#AssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SimpleDataType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SimpleDataTypeValue"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SimpleVariable"/>
        <Class IRI="#Variable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Specification"/>
        <Class IRI="#ProgramStructure"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StandardIdentifier"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Statement"/>
        <Class IRI="#JavaLanguage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StatementBlock"/>
        <Class IRI="#Statement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticClassSpecifier"/>
        <Class IRI="#StaticModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticFieldSpecifier"/>
        <Class IRI="#StaticModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticImport"/>
        <Class IRI="#StaticModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticInterfaceSpecifier"/>
        <Class IRI="#StaticModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticMethod"/>
        <Class IRI="#Method"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticMethodDefinition"/>
        <Class IRI="#MethodDefinition"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticMethodInvocation"/>
        <Class IRI="#MethodInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticMethodSpecifier"/>
        <Class IRI="#StaticModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StaticModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StrictfpClassSpecifier"/>
        <Class IRI="#StrictfpModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StrictfpInterfaceSpecifier"/>
        <Class IRI="#StrictfpModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StrictfpMethodSpecifier"/>
        <Class IRI="#StrictfpModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StrictfpModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringAddition"/>
        <Class IRI="#AddExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringDataType"/>
        <Class IRI="#ClassDataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringInitializationStatement"/>
        <Class IRI="#VariableInitializationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringLiteral"/>
        <Class IRI="#Value"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringLiteralMethodInvocation"/>
        <Class IRI="#MethodInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#StringVariable"/>
        <Class IRI="#ObjectVariable"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Subclass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SubtractAssignmentExpression"/>
        <Class IRI="#ArithmeticAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SubtractExpression"/>
        <Class IRI="#AdditiveExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperReference"/>
        <Class IRI="#ObjectReference"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Superclass"/>
        <Class IRI="#Class"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperclassConstructor"/>
        <Class IRI="#Inheritance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperclassConstructorCall"/>
        <Class IRI="#ConstructorCall"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperclassMethod"/>
        <Class IRI="#Inheritance"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperclassMethodCall"/>
        <Class IRI="#MethodInvocation"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SuperclassSubclassConversion"/>
        <Class IRI="#TypeCasting"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SwitchStatement"/>
        <Class IRI="#SelectionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SynchronizedMethodSpecifier"/>
        <Class IRI="#SynchronizedModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#SynchronizedModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ThisReference"/>
        <Class IRI="#ObjectReference"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ThrowStatement"/>
        <Class IRI="#ExceptionHandlingStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#ThrowsSpecification"/>
        <Class IRI="#Specification"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#TransientFieldSpecifier"/>
        <Class IRI="#TransientModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#TransientModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#True"/>
        <Class IRI="#BooleanValue"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#TryCatchFinallyStatement"/>
        <Class IRI="#ExceptionHandlingStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#TryCatchStatement"/>
        <Class IRI="#ExceptionHandlingStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#TypeCasting"/>
        <Class IRI="#Expression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#UnaryMinusOperator"/>
        <Class IRI="#ArithmeticExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#UnsignedRightShiftAssignmentExpression"/>
        <Class IRI="#BitShiftAssignmentExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#UnsignedRightShiftExpression"/>
        <Class IRI="#BitShiftExpression"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Value"/>
        <Class IRI="#Data"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#Variable"/>
        <Class IRI="#Data"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VariableDeclarationStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VariableInitializationStatement"/>
        <Class IRI="#DefinitionStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VariableName"/>
        <Class IRI="#Identifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VoidDataType"/>
        <Class IRI="#DataType"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VolatileFieldSpecifier"/>
        <Class IRI="#VolatileModifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#VolatileModifier"/>
        <Class IRI="#Modifier"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#WhileStatement"/>
        <Class IRI="#IterationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#WrapperClass"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#XPath"/>
        <Class IRI="#JavaXMLProcessing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#XSLT"/>
        <Class IRI="#JavaXMLProcessing"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang"/>
        <Class IRI="#JavaStandardLibraryPackage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Boolean"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Byte"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Character"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Class"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Class.forName"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Double"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Double.parseDouble"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Exception"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Float"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Integer"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Integer.parseInt"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Long"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.abs"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.ceil"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.cos"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.exp"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.floor"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.log"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.max"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.min"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.pow"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.round"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.sin"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.sqrt"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Math.tan"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Object"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Object.clone"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Object.equals"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Object.hashCode"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Object.toString"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Short"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.charAt"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.compareTo"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.compareToIgnoreCase"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.concat"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.equals"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.equalsIgnoreCase"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.indexOf"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.length"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.replace"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.substring"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.toLowerCase"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.String.toUpperCase"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System.err"/>
        <Class IRI="#JavaStandardLibraryObject"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System.in"/>
        <Class IRI="#JavaStandardLibraryObject"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System.out"/>
        <Class IRI="#JavaStandardLibraryObject"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System.out.print"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.System.out.println"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Thread"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Throwable"/>
        <Class IRI="#JavaStandardLibraryInterface"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.lang.Void"/>
        <Class IRI="#WrapperClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util"/>
        <Class IRI="#JavaStandardLibraryPackage"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.add"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.get"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.indexOf"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.remove"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.set"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.ArrayList.size"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.List"/>
        <Class IRI="#JavaStandardLibraryInterface"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Random"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Random.nextDouble"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Random.nextInt"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Scanner"/>
        <Class IRI="#JavaStandardLibraryClass"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Scanner.next"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Scanner.nextDouble"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Scanner.nextInt"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#java.util.Scanner.nextLine"/>
        <Class IRI="#JavaStandardLibraryMethod"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#null"/>
        <Class IRI="#ObjectReference"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#nullInitialization"/>
        <Class IRI="#VariableInitializationStatement"/>
    </SubClassOf>
    <SubClassOf>
        <Class IRI="#nullReturn"/>
        <Class IRI="#ReturnedValue"/>
    </SubClassOf>
    <SameIndividual>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#ClassDataType"/>
    </SameIndividual>
    <SameIndividual>
        <NamedIndividual IRI="#ClassName"/>
        <NamedIndividual IRI="#ConstructorName"/>
    </SameIndividual>
    <SameIndividual>
        <NamedIndividual IRI="#FieldDefinition"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </SameIndividual>
    <SameIndividual>
        <NamedIndividual IRI="#Interface"/>
        <NamedIndividual IRI="#InterfaceDataType"/>
    </SameIndividual>
    <SameIndividual>
        <NamedIndividual IRI="#StringDataType"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </SameIndividual>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#AbstractClass"/>
        <NamedIndividual IRI="#AbstractMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractClass"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractClass"/>
        <NamedIndividual IRI="#AbstractModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
        <NamedIndividual IRI="#AbstractModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractMethod"/>
        <NamedIndividual IRI="#Interface"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractMethod"/>
        <NamedIndividual IRI="#AbstractClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractMethod"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractMethod"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractMethod"/>
        <NamedIndividual IRI="#MethodImplementation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
        <NamedIndividual IRI="#AbstractModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
        <NamedIndividual IRI="#InterfaceBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
        <NamedIndividual IRI="#AbstractMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractModifier"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AbstractModifier"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AbstractModifier"/>
        <NamedIndividual IRI="#AbstractClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
        <NamedIndividual IRI="#Encapsulation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArithmeticAssignmentExpression"/>
        <NamedIndividual IRI="#SimpleVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArithmeticAssignmentExpression"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArithmeticExpression"/>
        <NamedIndividual IRI="#Expression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArithmeticExpression"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
        <NamedIndividual IRI="#ArrayElementType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
        <NamedIndividual IRI="#ArrayLength"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayDataType"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayDataType"/>
        <NamedIndividual IRI="#ArrayElementType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayDataType"/>
        <NamedIndividual IRI="#ArrayElement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayDataType"/>
        <NamedIndividual IRI="#ArrayLength"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayDataType"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayElement"/>
        <NamedIndividual IRI="#ArrayElementType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayElement"/>
        <NamedIndividual IRI="#ArrayDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayElement"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayElementType"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayElementType"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayElementType"/>
        <NamedIndividual IRI="#ArrayElement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayElementType"/>
        <NamedIndividual IRI="#ArrayDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
        <NamedIndividual IRI="#ArrayElementType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
        <NamedIndividual IRI="#ArrayDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayLength"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayLength"/>
        <NamedIndividual IRI="#ArrayDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayLength"/>
        <NamedIndividual IRI="#ArrayVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayLength"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayInitializer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayElement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ArrayVariable"/>
        <NamedIndividual IRI="#ArrayDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#AutoBoxing"/>
        <NamedIndividual IRI="#WrapperClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#AutoBoxing"/>
        <NamedIndividual IRI="#SimpleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#BooleanDataType"/>
        <NamedIndividual IRI="#BooleanValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#BooleanDataType"/>
        <NamedIndividual IRI="#java.lang.Boolean"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#BooleanValue"/>
        <NamedIndividual IRI="#BooleanDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#BreakStatement"/>
        <NamedIndividual IRI="#SwitchStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ByteDataType"/>
        <NamedIndividual IRI="#ByteValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ByteDataType"/>
        <NamedIndividual IRI="#java.lang.Byte"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ByteValue"/>
        <NamedIndividual IRI="#ByteDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#CharDataType"/>
        <NamedIndividual IRI="#java.lang.Character"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#CharDataType"/>
        <NamedIndividual IRI="#CharValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#CharValue"/>
        <NamedIndividual IRI="#CharDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#Constructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#Package"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#StaticMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#InstanceOfExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Class"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassBody"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassBody"/>
        <NamedIndividual IRI="#MethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassBody"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassBody"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassDataType"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ClassDataType"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ClassDataType"/>
        <NamedIndividual IRI="#ObjectReference"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#ClassBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#ImportStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#AbstractClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#Package"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ClassDefinition"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassField"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassField"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ClassField"/>
        <NamedIndividual IRI="#ConstantInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
        <NamedIndividual IRI="#ClassField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
        <NamedIndividual IRI="#StaticModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassName"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassName"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassName"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#ImplementsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#ClassName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ClassSingnature"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConditionalExpression"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Constant"/>
        <NamedIndividual IRI="#ConstantInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Constant"/>
        <NamedIndividual IRI="#ConstantInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Constant"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ConstantInitializationStatement"/>
        <NamedIndividual IRI="#Constant"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ConstantInvocation"/>
        <NamedIndividual IRI="#ClassField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ConstantInvocation"/>
        <NamedIndividual IRI="#Constant"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Constructor"/>
        <NamedIndividual IRI="#ConstructorName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Constructor"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Constructor"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Constructor"/>
        <NamedIndividual IRI="#ConstructorName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Constructor"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
        <NamedIndividual IRI="#MethodBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
        <NamedIndividual IRI="#Constructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
        <NamedIndividual IRI="#ClassBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorName"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorName"/>
        <NamedIndividual IRI="#Constructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorName"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ConstructorName"/>
        <NamedIndividual IRI="#Constructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
        <NamedIndividual IRI="#FormalMethodParameter"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
        <NamedIndividual IRI="#ConstructorName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#VariableDeclarationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#TypeCasting"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DataType"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DoubleDataType"/>
        <NamedIndividual IRI="#DoubleValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DoubleDataType"/>
        <NamedIndividual IRI="#java.lang.Double"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#DoubleValue"/>
        <NamedIndividual IRI="#DoubleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Encapsulation"/>
        <NamedIndividual IRI="#PrivateAccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Encapsulation"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Expression"/>
        <NamedIndividual IRI="#Operator"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Expression"/>
        <NamedIndividual IRI="#ArithmeticExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Expression"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
        <NamedIndividual IRI="#IncrementDecrementExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
        <NamedIndividual IRI="#ConditionalExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
        <NamedIndividual IRI="#Expression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
        <NamedIndividual IRI="#ClassName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Field"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
        <NamedIndividual IRI="#ClassBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FieldInheritance"/>
        <NamedIndividual IRI="#Subclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FieldInheritance"/>
        <NamedIndividual IRI="#Superclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FieldInheritance"/>
        <NamedIndividual IRI="#InstanceField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalClass"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalClass"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalClass"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
        <NamedIndividual IRI="#FinalClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalInstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalInstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalMethod"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalMethod"/>
        <NamedIndividual IRI="#MethodOverriding"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
        <NamedIndividual IRI="#FinalModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
        <NamedIndividual IRI="#MethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
        <NamedIndividual IRI="#FinalMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#FinalClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#FinalInstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#FinalClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FinalModifier"/>
        <NamedIndividual IRI="#Constant"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FloatDataType"/>
        <NamedIndividual IRI="#FloatValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FloatDataType"/>
        <NamedIndividual IRI="#java.lang.Float"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#FloatValue"/>
        <NamedIndividual IRI="#FloatDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FormalMethodParameter"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#FormalMethodParameter"/>
        <NamedIndividual IRI="#ConstructorSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#GenericClass"/>
        <NamedIndividual IRI="#GenericObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#GenericClass"/>
        <NamedIndividual IRI="#GenericClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#GenericClassDefinition"/>
        <NamedIndividual IRI="#GenericClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#GenericObjectCreationStatement"/>
        <NamedIndividual IRI="#GenericClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ImplementsSpecification"/>
        <NamedIndividual IRI="#InterfaceName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ImplementsSpecification"/>
        <NamedIndividual IRI="#ClassSingnature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ImportStatement"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ImportStatement"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ImportStatement"/>
        <NamedIndividual IRI="#Package"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#IncrementDecrementExpression"/>
        <NamedIndividual IRI="#ExpressionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#SuperclassSubclassConversion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#Subclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#Superclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#Interfacing"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#AbstractClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Inheritance"/>
        <NamedIndividual IRI="#FinalClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InheritanceBasedPolymorphism"/>
        <NamedIndividual IRI="#MethodOverriding"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InheritanceBasedPolymorphism"/>
        <NamedIndividual IRI="#SuperclassSubclassConversion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InstanceField"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InstanceField"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InstanceField"/>
        <NamedIndividual IRI="#FieldInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InstanceField"/>
        <NamedIndividual IRI="#InstanceFieldInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
        <NamedIndividual IRI="#FieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
        <NamedIndividual IRI="#InstanceField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#InstanceFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
        <NamedIndividual IRI="#FinalInstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InstanceFieldInvocation"/>
        <NamedIndividual IRI="#InstanceField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InstanceOfExpression"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#IntDataType"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#IntDataType"/>
        <NamedIndividual IRI="#IntValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#IntValue"/>
        <NamedIndividual IRI="#IntDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Interface"/>
        <NamedIndividual IRI="#AbstractMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Interface"/>
        <NamedIndividual IRI="#InterfaceClassConversion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Interface"/>
        <NamedIndividual IRI="#InterfaceDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InterfaceBasedPolymorphism"/>
        <NamedIndividual IRI="#InterfaceClassConversion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceBody"/>
        <NamedIndividual IRI="#AbstractMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceBody"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceClassConversion"/>
        <NamedIndividual IRI="#Interface"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InterfaceClassConversion"/>
        <NamedIndividual IRI="#InterfaceBasedPolymorphism"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InterfaceDataType"/>
        <NamedIndividual IRI="#Interface"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InterfaceDataType"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
        <NamedIndividual IRI="#ImportStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
        <NamedIndividual IRI="#InterfaceBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
        <NamedIndividual IRI="#Package"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#InterfaceImplementation"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceName"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceName"/>
        <NamedIndividual IRI="#ImplementsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
        <NamedIndividual IRI="#InterfaceName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
        <NamedIndividual IRI="#ExtendsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
        <NamedIndividual IRI="#PublicAccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Interfacing"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
        <NamedIndividual IRI="#JavaStandardLibraryMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
        <NamedIndividual IRI="#JavaStandardLibraryObject"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
        <NamedIndividual IRI="#JavaStandardLibraryPackage"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
        <NamedIndividual IRI="#TryCatchStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
        <NamedIndividual IRI="#ThrowStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
        <NamedIndividual IRI="#ThrowsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
        <NamedIndividual IRI="#TryCatchFinallyStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryMethod"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryObject"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#JavaStandardLibraryPackage"/>
        <NamedIndividual IRI="#JavaStandardLibrary"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#LongDataType"/>
        <NamedIndividual IRI="#LongValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#LongDataType"/>
        <NamedIndividual IRI="#java.lang.Long"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#LongValue"/>
        <NamedIndividual IRI="#LongDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MainMethod"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
        <NamedIndividual IRI="#MethodBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
        <NamedIndividual IRI="#StaticModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
        <NamedIndividual IRI="#PublicAccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
        <NamedIndividual IRI="#MainMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#MethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#ReturnedValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Method"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodBody"/>
        <NamedIndividual IRI="#StatementBlock"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodBody"/>
        <NamedIndividual IRI="#ReturnStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodBody"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodBody"/>
        <NamedIndividual IRI="#MethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodBody"/>
        <NamedIndividual IRI="#ConstructorDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodDefinition"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodDefinition"/>
        <NamedIndividual IRI="#MethodBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodDefinition"/>
        <NamedIndividual IRI="#ClassBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodDefinition"/>
        <NamedIndividual IRI="#FinalMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodDefinition"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodImplementation"/>
        <NamedIndividual IRI="#AbstractMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#Superclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#Subclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#AbstractMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#MethodOverriding"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInheritance"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodInvocation"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodInvocation"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodInvocation"/>
        <NamedIndividual IRI="#MethodInvocationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInvocation"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodInvocation"/>
        <NamedIndividual IRI="#ReturnedValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodInvocationStatement"/>
        <NamedIndividual IRI="#MethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#MethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#MethodOverloading"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#InterfaceImplementation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#MethodOverriding"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodName"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodOverloading"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodOverriding"/>
        <NamedIndividual IRI="#InheritanceBasedPolymorphism"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodOverriding"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodOverriding"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#MethodOverriding"/>
        <NamedIndividual IRI="#FinalMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#ThrowsSpecification"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#FormalMethodParameter"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#AccessSpecifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#ReturnedType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#MethodSignature"/>
        <NamedIndividual IRI="#MethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#InstanceField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#ClassField"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#Field"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#Constructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Object"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
        <NamedIndividual IRI="#ConstructorName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
        <NamedIndividual IRI="#ClassDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectEquality"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectReference"/>
        <NamedIndividual IRI="#ClassDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectReference"/>
        <NamedIndividual IRI="#ObjectVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#MethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#InterfaceDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#ClassDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ObjectVariable"/>
        <NamedIndividual IRI="#ObjectReference"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Operator"/>
        <NamedIndividual IRI="#Expression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Operator"/>
        <NamedIndividual IRI="#OperatorPrecedence"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Operator"/>
        <NamedIndividual IRI="#OperatorAssociativity"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OperatorAssociativity"/>
        <NamedIndividual IRI="#Operator"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OperatorPrecedence"/>
        <NamedIndividual IRI="#Operator"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OverridingClone"/>
        <NamedIndividual IRI="#java.lang.Object.clone"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OverridingEquals"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OverridingHashCode"/>
        <NamedIndividual IRI="#java.lang.Object.hashCode"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#OverridingToString"/>
        <NamedIndividual IRI="#java.lang.Object.toString"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Package"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Package"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Package"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Package"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Package"/>
        <NamedIndividual IRI="#ImportStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
        <NamedIndividual IRI="#InterfaceDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
        <NamedIndividual IRI="#ClassDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#PackageSpecificationStatement"/>
        <NamedIndividual IRI="#Package"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#PolymorphicObjectCreationStatement"/>
        <NamedIndividual IRI="#Polymorphism"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Polymorphism"/>
        <NamedIndividual IRI="#PolymorphicObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#PrivateAccessSpecifier"/>
        <NamedIndividual IRI="#Encapsulation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#PublicAccessSpecifier"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#PublicAccessSpecifier"/>
        <NamedIndividual IRI="#InterfaceSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ReturnStatement"/>
        <NamedIndividual IRI="#MethodBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnStatement"/>
        <NamedIndividual IRI="#ReturnedValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ReturnedType"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedType"/>
        <NamedIndividual IRI="#VoidDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedType"/>
        <NamedIndividual IRI="#ReturnedValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedValue"/>
        <NamedIndividual IRI="#MethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedValue"/>
        <NamedIndividual IRI="#Method"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedValue"/>
        <NamedIndividual IRI="#ReturnStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ReturnedValue"/>
        <NamedIndividual IRI="#ReturnedType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ShortDataType"/>
        <NamedIndividual IRI="#ShortValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ShortDataType"/>
        <NamedIndividual IRI="#java.lang.Short"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#ShortValue"/>
        <NamedIndividual IRI="#ShortDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#ArrayCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#ArrayInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataType"/>
        <NamedIndividual IRI="#WrapperClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataType"/>
        <NamedIndividual IRI="#AutoBoxing"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataType"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataType"/>
        <NamedIndividual IRI="#SimpleVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
        <NamedIndividual IRI="#ArithmeticAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
        <NamedIndividual IRI="#SimpleVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
        <NamedIndividual IRI="#SimpleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
        <NamedIndividual IRI="#ArithmeticExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleVariable"/>
        <NamedIndividual IRI="#SimpleDataTypeValue"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleVariable"/>
        <NamedIndividual IRI="#ArithmeticAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SimpleVariable"/>
        <NamedIndividual IRI="#SimpleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Statement"/>
        <NamedIndividual IRI="#StatementBlock"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StatementBlock"/>
        <NamedIndividual IRI="#Statement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StatementBlock"/>
        <NamedIndividual IRI="#MethodBody"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StaticMethod"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StaticMethod"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StaticMethod"/>
        <NamedIndividual IRI="#Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
        <NamedIndividual IRI="#StaticModifier"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
        <NamedIndividual IRI="#MethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
        <NamedIndividual IRI="#StaticMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
        <NamedIndividual IRI="#MethodName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
        <NamedIndividual IRI="#ClassName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StaticMethodInvocation"/>
        <NamedIndividual IRI="#StaticMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StaticModifier"/>
        <NamedIndividual IRI="#StaticMethodDefinition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StaticModifier"/>
        <NamedIndividual IRI="#ClassFieldDefinitionStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StaticModifier"/>
        <NamedIndividual IRI="#MainMethodDefintion"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringAddition"/>
        <NamedIndividual IRI="#StringDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringDataType"/>
        <NamedIndividual IRI="#StringLiteralMethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringDataType"/>
        <NamedIndividual IRI="#StringVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringDataType"/>
        <NamedIndividual IRI="#StringLiteral"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringDataType"/>
        <NamedIndividual IRI="#StringAddition"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
        <NamedIndividual IRI="#StringLiteral"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
        <NamedIndividual IRI="#StringVariable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StringLiteral"/>
        <NamedIndividual IRI="#StringLiteralMethodInvocation"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StringLiteral"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringLiteral"/>
        <NamedIndividual IRI="#StringDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#StringLiteralMethodInvocation"/>
        <NamedIndividual IRI="#StringLiteral"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringLiteralMethodInvocation"/>
        <NamedIndividual IRI="#StringDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#StringVariable"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#StringVariable"/>
        <NamedIndividual IRI="#StringDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Subclass"/>
        <NamedIndividual IRI="#FieldInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Subclass"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Subclass"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Subclass"/>
        <NamedIndividual IRI="#Superclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperReference"/>
        <NamedIndividual IRI="#SuperclassConstructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperReference"/>
        <NamedIndividual IRI="#Superclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperReference"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Superclass"/>
        <NamedIndividual IRI="#FieldInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#Superclass"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Superclass"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Superclass"/>
        <NamedIndividual IRI="#Subclass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Superclass"/>
        <NamedIndividual IRI="#SuperReference"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassConstructor"/>
        <NamedIndividual IRI="#SuperReference"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassConstructor"/>
        <NamedIndividual IRI="#SuperclassConstructorCall"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassConstructorCall"/>
        <NamedIndividual IRI="#SuperclassConstructor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
        <NamedIndividual IRI="#SuperclassMethodCall"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
        <NamedIndividual IRI="#SuperReference"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
        <NamedIndividual IRI="#MethodInheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassMethodCall"/>
        <NamedIndividual IRI="#SuperclassMethod"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#SuperclassSubclassConversion"/>
        <NamedIndividual IRI="#Inheritance"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#SuperclassSubclassConversion"/>
        <NamedIndividual IRI="#InheritanceBasedPolymorphism"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#SwitchStatement"/>
        <NamedIndividual IRI="#BreakStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ThrowStatement"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#ThrowsSpecification"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#ThrowsSpecification"/>
        <NamedIndividual IRI="#MethodSignature"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#TryCatchFinallyStatement"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#TryCatchStatement"/>
        <NamedIndividual IRI="#JavaStandardLibraryClass"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#TypeCasting"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#InstanceFieldInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#ClassConstantInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Value"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#VariableDeclarationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#VariableName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#AssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#Variable"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableDeclarationStatement"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableDeclarationStatement"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
        <NamedIndividual IRI="#DataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
        <NamedIndividual IRI="#Value"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
        <NamedIndividual IRI="#SimpleAssignmentExpression"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#VariableInitializationStatement"/>
        <NamedIndividual IRI="#ObjectCreationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#VariableName"/>
        <NamedIndividual IRI="#Variable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#VoidDataType"/>
        <NamedIndividual IRI="#java.lang.Void"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#VoidDataType"/>
        <NamedIndividual IRI="#ReturnedType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#WrapperClass"/>
        <NamedIndividual IRI="#AutoBoxing"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#WrapperClass"/>
        <NamedIndividual IRI="#SimpleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Character"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Float"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Short"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Thread"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Void"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Exception"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.System"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Boolean"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Byte"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Double"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Long"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang"/>
        <NamedIndividual IRI="#java.lang.Throwable"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Boolean"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Boolean"/>
        <NamedIndividual IRI="#BooleanDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Byte"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Byte"/>
        <NamedIndividual IRI="#ByteDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Character"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Character"/>
        <NamedIndividual IRI="#CharDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Class"/>
        <NamedIndividual IRI="#java.lang.Class.forName"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Class"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Class.forName"/>
        <NamedIndividual IRI="#java.lang.Class"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Double"/>
        <NamedIndividual IRI="#java.lang.Double.parseDouble"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Double"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Double"/>
        <NamedIndividual IRI="#DoubleDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Double.parseDouble"/>
        <NamedIndividual IRI="#java.lang.Double"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Exception"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Float"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Float"/>
        <NamedIndividual IRI="#FloatDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
        <NamedIndividual IRI="#java.lang.Integer.parseInt"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
        <NamedIndividual IRI="#IntDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Integer.parseInt"/>
        <NamedIndividual IRI="#java.lang.Integer"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Long"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Long"/>
        <NamedIndividual IRI="#LongDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.round"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.floor"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.max"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.abs"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.min"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.pow"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.ceil"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.sqrt"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.cos"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.tan"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.exp"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.log"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang.Math.sin"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.abs"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.ceil"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.cos"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.exp"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.floor"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.log"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.max"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.min"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.pow"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.round"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.sin"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.sqrt"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Math.tan"/>
        <NamedIndividual IRI="#java.lang.Math"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Object"/>
        <NamedIndividual IRI="#java.lang.Object.clone"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Object"/>
        <NamedIndividual IRI="#java.lang.Object.toString"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Object"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.Object"/>
        <NamedIndividual IRI="#java.lang.Object.hashCode"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Object"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Object.clone"/>
        <NamedIndividual IRI="#java.lang.Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Object.clone"/>
        <NamedIndividual IRI="#OverridingClone"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
        <NamedIndividual IRI="#java.lang.Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
        <NamedIndividual IRI="#ObjectEquality"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Object.equals"/>
        <NamedIndividual IRI="#OverridingEquals"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Object.hashCode"/>
        <NamedIndividual IRI="#java.lang.Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Object.hashCode"/>
        <NamedIndividual IRI="#OverridingHashCode"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Object.toString"/>
        <NamedIndividual IRI="#java.lang.Object"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Object.toString"/>
        <NamedIndividual IRI="#OverridingToString"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Short"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Short"/>
        <NamedIndividual IRI="#ShortDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.replace"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.charAt"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.equals"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.concat"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.substring"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.length"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.indexOf"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.compareToIgnoreCase"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.equalsIgnoreCase"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.compareTo"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.toLowerCase"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang.String.toUpperCase"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String"/>
        <NamedIndividual IRI="#StringInitializationStatement"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.charAt"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.compareTo"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.compareToIgnoreCase"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.concat"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.equals"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.equalsIgnoreCase"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.indexOf"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.length"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.replace"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.substring"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.toLowerCase"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.String.toUpperCase"/>
        <NamedIndividual IRI="#java.lang.String"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.System"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.System"/>
        <NamedIndividual IRI="#java.lang.System.err"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.System"/>
        <NamedIndividual IRI="#java.lang.System.in"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System.err"/>
        <NamedIndividual IRI="#java.lang.System"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System.in"/>
        <NamedIndividual IRI="#java.lang.System"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
        <NamedIndividual IRI="#java.lang.System.out.println"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
        <NamedIndividual IRI="#java.lang.System.out.print"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
        <NamedIndividual IRI="#java.lang.System"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System.out.print"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.System.out.println"/>
        <NamedIndividual IRI="#java.lang.System.out"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Thread"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Throwable"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.lang.Void"/>
        <NamedIndividual IRI="#java.lang"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#relatedTo"/>
        <NamedIndividual IRI="#java.lang.Void"/>
        <NamedIndividual IRI="#VoidDataType"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util"/>
        <NamedIndividual IRI="#java.util.Random"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util"/>
        <NamedIndividual IRI="#java.util.List"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.indexOf"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.size"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.get"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.remove"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.set"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util.ArrayList.add"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
        <NamedIndividual IRI="#java.util"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.add"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.get"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.indexOf"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.remove"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.set"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.ArrayList.size"/>
        <NamedIndividual IRI="#java.util.ArrayList"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.List"/>
        <NamedIndividual IRI="#java.util"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Random"/>
        <NamedIndividual IRI="#java.util.Random.nextInt"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Random"/>
        <NamedIndividual IRI="#java.util.Random.nextDouble"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Random"/>
        <NamedIndividual IRI="#java.util"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Random.nextDouble"/>
        <NamedIndividual IRI="#java.util.Random"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Random.nextInt"/>
        <NamedIndividual IRI="#java.util.Random"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
        <NamedIndividual IRI="#java.util.Scanner.next"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
        <NamedIndividual IRI="#java.util.Scanner.nextInt"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
        <NamedIndividual IRI="#java.util.Scanner.nextLine"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#hasPart"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
        <NamedIndividual IRI="#java.util.Scanner.nextDouble"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
        <NamedIndividual IRI="#java.util"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Scanner.next"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Scanner.nextDouble"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Scanner.nextInt"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </ObjectPropertyAssertion>
    <ObjectPropertyAssertion>
        <ObjectProperty IRI="#partOf"/>
        <NamedIndividual IRI="#java.util.Scanner.nextLine"/>
        <NamedIndividual IRI="#java.util.Scanner"/>
    </ObjectPropertyAssertion>
    <InverseObjectProperties>
        <ObjectProperty IRI="#partOf"/>
        <ObjectProperty IRI="#hasPart"/>
    </InverseObjectProperties>
    <InverseObjectProperties>
        <ObjectProperty IRI="#relatedTo"/>
        <ObjectProperty IRI="#relatedTo"/>
    </InverseObjectProperties>
    <SymmetricObjectProperty>
        <ObjectProperty IRI="#relatedTo"/>
    </SymmetricObjectProperty>
    <TransitiveObjectProperty>
        <ObjectProperty IRI="#hasPart"/>
    </TransitiveObjectProperty>
    <TransitiveObjectProperty>
        <ObjectProperty IRI="#partOf"/>
    </TransitiveObjectProperty>
    <TransitiveObjectProperty>
        <ObjectProperty IRI="#relatedTo"/>
    </TransitiveObjectProperty>
    <DataPropertyRange>
        <DataProperty IRI="#indexing"/>
        <Datatype abbreviatedIRI="xsd:boolean"/>
    </DataPropertyRange>
    <DataPropertyRange>
        <DataProperty IRI="#parsable"/>
        <Datatype abbreviatedIRI="xsd:boolean"/>
    </DataPropertyRange>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AbstractClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AbstractClass</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Provide a contract between a service provider and its clients.   2. An abstract class can provide implementation.   3. To make an abstract method, use the abstract modifier in front of the method declaration.      # An abstract class is a class that cannot be instantiated# An abstract class must be implemented by a subclass.An abstract class is a class that is declared abstractit may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.If a class includes abstract methods, the class itself must be declared abstract, as in:When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, the subclass must also be declared abstract.Unlike interfaces, abstract classes can contain fields that are not static and final, and they can contain implemented methods. Such abstract classes are similar to interfaces, except that they provide a partial implementation, leaving it to subclasses to complete the implementation. If an abstract class contains only abstract method declarations, it should be declared as an interface instead.Multiple interfaces can be implemented by classes anywhere in the class hierarchy, whether or not they are related to one another in any way. Think of Comparable or Cloneable, for example.By comparison, abstract classes are most commonly subclassed to share pieces of implementation. A single abstract class is subclassed by similar classes that have a lot in common (the implemented parts of the abstract class), but also have some differences (the abstract methods).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AbstractClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AbstractClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Provide a contract between a service provider and its clients.   2. An abstract class can provide implementation.   3. To make an abstract method, use the abstract modifier in front of the method declaration.      # An abstract class is a class that cannot be instantiated# An abstract class must be implemented by a subclass.An abstract class is a class that is declared abstractit may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.If a class includes abstract methods, the class itself must be declared abstract, as in:When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, the subclass must also be declared abstract.Unlike interfaces, abstract classes can contain fields that are not static and final, and they can contain implemented methods. Such abstract classes are similar to interfaces, except that they provide a partial implementation, leaving it to subclasses to complete the implementation. If an abstract class contains only abstract method declarations, it should be declared as an interface instead.Multiple interfaces can be implemented by classes anywhere in the class hierarchy, whether or not they are related to one another in any way. Think of Comparable or Cloneable, for example.By comparison, abstract classes are most commonly subclassed to share pieces of implementation. A single abstract class is subclassed by similar classes that have a lot in common (the implemented parts of the abstract class), but also have some differences (the abstract methods).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AbstractMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AbstractMethod</IRI>
        <Literal datatypeIRI="&xsd;string">An abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:If a class includes abstract methods, the class itself must be declared abstract, as in:All of the methods in an interface (see the Interfaces section) are implicitly abstract, so the abstract modifier is not used with interface methods (it could beit&apos;s just not necessary).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AbstractMethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AbstractMethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">An abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:If a class includes abstract methods, the class itself must be declared abstract, as in:All of the methods in an interface (see the Interfaces section) are implicitly abstract, so the abstract modifier is not used with interface methods (it could beit&apos;s just not necessary).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AbstractModifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AbstractModifier</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Provide a contract between a service provider and its clients.   2. An abstract class can provide implementation.   3. To make an abstract method, use the abstract modifier in front of the method declaration.      # An abstract class is a class that cannot be instantiated# An abstract class must be implemented by a subclass.An abstract class is a class that is declared abstractit may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.If a class includes abstract methods, the class itself must be declared abstract, as in:When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, if it does not, the subclass must also be declared abstract.Unlike interfaces, abstract classes can contain fields that are not static and final, and they can contain implemented methods. Such abstract classes are similar to interfaces, except that they provide a partial implementation, leaving it to subclasses to complete the implementation. If an abstract class contains only abstract method declarations, it should be declared as an interface instead.Multiple interfaces can be implemented by classes anywhere in the class hierarchy, whether or not they are related to one another in any way. Think of Comparable or Cloneable, for example.By comparison, abstract classes are most commonly subclassed to share pieces of implementation. A single abstract class is subclassed by similar classes that have a lot in common (the implemented parts of the abstract class), but also have some differences (the abstract methods).An abstract method is a method that is declared without an implementation (without braces, and followed by a semicolon), like this:If a class includes abstract methods, the class itself must be declared abstract, as in:All of the methods in an interface (see the Interfaces section) are implicitly abstract, so the abstract modifier is not used with interface methods (it could beit&apos;s just not necessary).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Abstraction</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Abstraction</IRI>
        <Literal datatypeIRI="&xsd;string">An abstraction denotes the essential characteristics of an object that distinguish it from all other kinds of object and thus provide crisply defined conceptual boundaries, relative to the perspective of the viewer.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ActualMethodParameter</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ActualMethodParameter</IRI>
        <Literal datatypeIRI="&xsd;string">The declaration for a method or a constructor declares the number and the type of the arguments for that method or constructor. For example, the following is a method that computes the monthly payments for a home loan, based on the amount of the loan, the interest rate, the length of the loan (the number of periods), and the future value of the loan:This method has four parameters: the loan amount, the interest rate, the future value and the number of periods. The first three are double-precision floating point numbers, and the fourth is an integer. The parameters are used in the method body and at runtime will take on the values of the arguments that are passed in.Note:Parameters refers to the list of variables in a method declaration. Arguments are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration&apos;s parameters in type and order.You can use any data type for a parameter of a method or a constructor. This includes primitive data types, such as doubles, floats, and integers, as you saw in the computePayment method, and reference data types, such as objects and arrays.Here&apos;s an example of a method that accepts an array as an argument. In this example, the method creates a new Polygon object and initializes it from an array of Point objects (assume that Point is a class that represents an x, y coordinate):</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AddAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AddAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">You can also combine the arithmetic operators with the simple assignment operator to create compound assignments. For example, x+=1; and x=x+1; both increment the value of x by 1. All compound assignment operators require both operands to be of primitive type, except for +=, which allows the right-hand operand to be of any type if the left-hand operand is of type String.At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:		First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.		Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see 15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion (5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.Adds value of the varibale to the left with the value of the expression to the right and assigns the result to the variable to the left &apos;=+&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AddExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AddExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There&apos;s a good chance you&apos;ll recognize them by their counterparts in basic mathematics.     + 	additive operatorAddition Operator &apos;+&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AdditiveExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AdditiveExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Additive operators &apos;+&apos; &apos;-&apos;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AndExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AndExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The &amp;&amp; (logical AND) operator indicates whether both operands are true. If both operands have nonzero values, the result has the value 1. Otherwise, the result has the value 0. The type of the result is int. Both operands must have a arithmetic or pointer type. The usual arithmetic conversions on each operand are performed. If both operands have values of true, the result has the value true. Otherwise, the result has the value false. Both operands and the result have type boolean. Unlike the &amp; (bitwise AND) operator, the &amp;&amp; operator guarantees left-to-right evaluation of the operands. If the left operand evaluates to  false, the right operand is not evaluated. The &amp;&amp; operator is like &amp; (15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is true. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions a, b, and c, evaluation of the expression ((a)&amp;&amp;(b))&amp;&amp;(c) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression (a)&amp;&amp;((b)&amp;&amp;(c)).Each operand of &amp;&amp; must be of type boolean, or a compile-time error occurs. The type of a conditional-and expression is always boolean.At run time, the left-hand operand expression is evaluated first; if its value is false, the value of the conditional-and expression is false and the right-hand operand expression is not evaluated. If the value of the left-hand operand is true, then the right-hand expression is evaluated and its value becomes the value of the conditional-and expression. Thus, &amp;&amp; computes the same result as &amp; on boolean operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.Boolean (Logical) AND &apos;&amp;&amp;&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArithmeticAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArithmeticAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Following C and C++ syntax Java allows to combine arithmetical operators and simple assignement into complex assignements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArithmeticExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArithmeticExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Arithmetic operators &apos;+&apos; &apos;-&apos; &apos;*&apos; &apos;/&apos; &apos;%&apos; &apos;(&apos; &apos;)&apos;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The above program declares anArray with the following line of code:    int[] anArray;          // declares an array of integersLike declarations for variables of other types, an array declaration has two components: the array&apos;s type and the array&apos;s name. An array&apos;s type is written as type[], where type is the data type of the contained elements; the square brackets are special symbols indicating that this variable holds an array. The size of the array is not part of its type (which is why the brackets are empty). An array&apos;s name can be anything you want, provided that it follows the rules and conventions as previously discussed in the naming section. As with variables of other types, the declaration does not actually create an array  it simply tells the compiler that this variable will hold an array of the specified type.Similarly, you can declare arrays of other types:    byte[] anArrayOfBytes;    short[] anArrayOfShorts;    long[] anArrayOfLongs;    float[] anArrayOfFloats;    double[] anArrayOfDoubles;    boolean[] anArrayOfBooleans;    char[] anArrayOfChars;    String[] anArrayOfStrings;You can also place the square brackets after the array&apos;s name:    float anArrayOfFloats[]; // this form is discouragedHowever, convention discourages this form; the brackets identify the array type and should appear with the type designation. One way to create an array is with the new operator. The next statement in the ArrayDemo program allocates an array with enough memory for ten integer elements and assigns the array to the anArray variable.    anArray = new int[10];  // create an array of integersIf this statement were missing, the compiler would print an error like the following, and compilation would fail:    ArrayDemo.java:4: Variable anArray may not have been initialized.Array Creation statement consist of array declaration, new oprator type of array elements and &apos;[]&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayDataType</IRI>
        <Literal datatypeIRI="&xsd;string">An array is a container object that holds a fixed number of values of a single type. The length of an array is established when the array is created. After creation, its length is fixed. You&apos;ve seen an example of arrays already, in the main method of the &quot;Hello World!&quot; application. This section discusses arrays in greater detail.Illustration of an array as 10 boxes numbered 0 through 9; an index of 0 indicates the first element in the arrayAn array of ten elementsEach item in an array is called an element, and each element is accessed by its numerical index. As shown in the above illustration, numbering begins with 0. The 9th element, for example, would therefore be accessed at index 8. 	1.	An array is a named set of same-type variables.	2.	Each variable in the array is called an array element.	3.	The first element will have an index of 0.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayElement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayElement</IRI>
        <Literal datatypeIRI="&xsd;string">Each item in an array is called an element, and each element is accessed by its numerical index. As shown in the above illustration, numbering begins with 0. The 9th element, for example, would therefore be accessed at index 8.The following program, ArrayDemo, creates an array of integers, puts some values in it, and prints each value to standard output. The next few lines assign values to each element of the array:    anArray[0] = 100; // initialize first element    anArray[1] = 200; // initialize second element    anArray[2] = 300; // etc.Each array element is accessed by its numerical index:    System.out.println(&quot;Element 1 at index 0: &quot; + anArray[0]);    System.out.println(&quot;Element 2 at index 1: &quot; + anArray[1]);    System.out.println(&quot;Element 3 at index 2: &quot; + anArray[2]);Array element stores a single value. The array consists of array elements. All array elements have the same data type^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayElementType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayElementType</IRI>
        <Literal datatypeIRI="&xsd;string">An array is a container object that holds a fixed number of values of a single type.Each item in an array is called an element, and each element is accessed by its numerical index. As shown in the above illustration, numbering begins with 0. The 9th element, for example, would therefore be accessed at index 8.The following program, ArrayDemo, creates an array of integers, puts some values in it, and prints each value to standard output.An array type is written as the name of an element type followed by some number of empty pairs of square brackets []. The number of bracket pairs indicates the depth of array nesting. An array&apos;s length is not part of its type.The element type of an array may be any type, whether primitive or reference. In particular:		Arrays with an interface type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any type that implements the interface.		Arrays with an abstract class type as the component type are allowed. The elements of such an array may have as their value a null reference or instances of any subclass of the abstract class that is not itself abstract.Array types are used in declarations and in cast expressionsArray element type specifies the type of array elements - the type of values that can be stored in the array^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Alternatively, you can use the shortcut syntax to create and initialize an array:    int[] anArray = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};Here the length of the array is determined by the number of values provided between { and }. array variable intialization (including  type of array elements, [], and array variable name)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayInitializer</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayInitializer</IRI>
        <Literal datatypeIRI="&xsd;string">Alternatively, you can use the shortcut syntax to create and initialize an array:Here the length of the array is determined by the number of values provided between { and }.An array initializer may be specified in a declaration, or as part of an array creation expression (15.10), creating an array and providing some initial values:An array initializer is written as a comma-separated list of expressions, enclosed by braces &quot;{&quot; and &quot;}&quot;.The length of the constructed array will equal the number of expressions.The expressions in an array initializer are executed from left to right in the textual order they occur in the source code. The nth variable initializer specifies the value of the n-1st array component. Each expression must be assignment-compatible (5.2) with the array&apos;s component type, or a compile-time error results.If the component type is itself an array type, then the expression specifying a component may itself be an array initializer; that is, array initializers may be nested.A trailing comma may appear after the last expression in an array initializer and is ignored.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayLength</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayLength</IRI>
        <Literal datatypeIRI="&xsd;string">One way to create an array is with the new operator. The next statement in the ArrayDemo program allocates an array with enough memory for ten integer elements and assigns the array to the anArray variable.    anArray = new int[10];  // create an array of integersHere the length of the array is determined by the number of values provided between { and }. Finally, you can use the built-in length property to determine the size of any array. The code     System.out.println(anArray.length);will print the array&apos;s size to standard output.Array Lenght spesifies how many elements the array can store^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ArrayVariable</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ArrayVariable</IRI>
        <Literal datatypeIRI="&xsd;string">A variable of array type holds a reference to an object. Declaring a variable of array type does not create an array object or allocate any space for array components. It creates only the variable itself, which can contain a reference to an array. However, the initializer part of a declarator (8.3) may create an array, a reference to which then becomes the initial value of the variable.Because an array&apos;s length is not part of its type, a single variable of array type may contain references to arrays of different lengths.Here are examples of declarations of array variables that do not create arrays:Here are some examples of declarations of array variables that create array objects:The [] may appear as part of the type at the beginning of the declaration, or as part of the declarator for a particular variable, or both, as in this example:Once an array object is created, its length never changes. To make an array variable refer to an array of different length, a reference to a different array must be assigned to the variable.If an array variable v has type A[], where A is a reference type, then v can hold a reference to an instance of any array type B[], provided B can be assigned to A. This may result in a run-time exception on a later assignment; see 10.10 for a discussion.a variable of array data type storing a reference to array representation in memory^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Assignement operators change the value of the variable to the left with the vlaue of the expression to the right</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#AutoBoxing</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#AutoBoxing</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Boxing refers to the conversion of a primitive to a corresponding wrapper instance, such as from an int to a java.lang.Integer.   2. Unboxing is the conversion of a wrapper instance to a primitive type, such as from Byte to byte.         1. Related to Java&apos;s type wrappers.   2. How values are moved into and out of a wrapper instance   3. Java primitive type wrappers: Boolean, Byte, Character, Double, Float, Long, Integer, Short.      2. 17. 1. 	Type conversion (JDK1.5 Autoboxing/Unboxing)			2. 17. 2. 	Boxing and Unboxing			2. 17. 3. 	Autoboxing and Auto-Unboxing							2. 17. 6. 	To unbox an object			2. 17. 7. 	Autoboxing/unboxing: an argument passed to a method or returned from a method			2. 17. 8. 	Autoboxing/unboxing occurs inside expressions			2. 17. 9. 	Auto-unboxing: mix different types of numeric objects in an expression. 				2. 17. 11. 	Autoboxing/Unboxing Boolean and Character Values			2. 17. 12. 	Autoboxing/unboxing takes place with method parameters and return values.			2. 17. 13. 	Auto-unboxing allows you to mix different types of numeric objects in an expression.When working with numbers, most of the time you use the primitive types in your code. For example:There are, however, reasons to use objects in place of primitives, and the Java platform provides wrapper classes for each of the primitive data types. These classes &quot;wrap&quot; the primitive in an object. Often, the wrapping is done by the compilerif you use a primitive where an object is expected, the compiler boxes the primitive in its wrapper class for you. Similarly, if you use a number object when a primitive is expected, the compiler unboxes the object for you.Here is an example of boxing and unboxing:When x and y are assigned integer values, the compiler boxes the integers because x and y are integer objects. In the println() statement, x and y are unboxed so that they can be added as integers.All of the numeric wrapper classes are subclasses of the abstract class Number:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitShiftAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#BitShiftAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Compines simple assignment and bit shift operators</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitShiftExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseAndAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseAndExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#BitwiseAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Compines simple assignment and bitwise operators</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseOrAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseOrExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseXorAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BitwiseXorExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BooleanDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#BooleanDataType</IRI>
        <Literal datatypeIRI="&xsd;string">boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&apos;t something that&apos;s precisely defined. # Variables of type boolean can have only one of two values, true or false.# The values &apos;true&apos; and &apos;false&apos; are boolean literals.boolean data type (reserved word &quot;boolean&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BooleanExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#BooleanExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Three major operators of Boolena Algebra (and, or, not)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BooleanValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#BreakStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#BreakStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. The break statement is used to break from an enclosing do, while, for, or switch statement.   2. It is a compile error to use break anywhere else.   3. &apos;break&apos; breaks the loop without executing the rest of the statements in the block.   The break statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the switch statement. You can also use an unlabeled break to terminate a for, while, or do-while loop, as shown in the following BreakDemo program:break statement (breaks loop execution)
most often break statment is used as a part of switch statement^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ByteDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ByteDataType</IRI>
        <Literal datatypeIRI="&xsd;string">byte: The byte data type is an 8-bit signed two&apos;s complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive). The byte data type can be useful for saving memory in large arrays, where the memory savings actually matters. They can also be used in place of int where their limits help to clarify your code; the fact that a variable&apos;s range is limited can serve as a form of documentation. integer data type for numbers between -128 and 127 (reserved word &quot;byte&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ByteValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#CallBack</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#CaseClause</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#CaseClause</IRI>
        <Literal datatypeIRI="&xsd;string">Another point of interest is the break statement after each case. Each break statement terminates the enclosing switch statement. Control flow continues with the first statement following the switch block. The break statements are necessary because without them, case statements fall through; that is, without an explicit break, control will flow sequentially through subsequent case statements. The following program, SwitchDemo2, illustrates why it might be useful to have case statements fall through:case clause - single option of a switch statement^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#CharDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#CharDataType</IRI>
        <Literal datatypeIRI="&xsd;string">char: The char data type is a single 16-bit Unicode character. It has a minimum value of &apos;\u0000&apos; (or 0) and a maximum value of &apos;\uffff&apos; (or 65,535 inclusive). </Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#CharValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#CharValue</IRI>
        <Literal datatypeIRI="&xsd;string">A character literal is expressed as a character or an escape sequence, enclosed in ASCII single quotes. (The single-quote, or apostrophe, character is \u0027.)A character literal is always of type char.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Class</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Class</IRI>
        <Literal datatypeIRI="&xsd;string">In the real world, you&apos;ll often find many individual objects all of the same kind. There may be thousands of other bicycles in existence, all of the same make and model. Each bicycle was built from the same set of blueprints and therefore contains the same components. In object-oriented terms, we say that your bicycle is an instance of the class of objects known as bicycles. A class is the blueprint from which individual objects are created.The following Bicycle class is one possible implementation of a bicycle:The syntax of the Java programming language will look new to you, but the design of this class is based on the previous discussion of bicycle objects. The fields cadence, speed, and gear represent the object&apos;s state, and the methods (changeCadence, changeGear, speedUp etc.) define its interaction with the outside world.You may have noticed that the Bicycle class does not contain a main method. That&apos;s because it&apos;s not a complete application; it&apos;s just the blueprint for bicycles that might be used in an application. The responsibility of creating and using new Bicycle objects belongs to some other class in your application. Classes are the fundamental building blocks of a Java program. You can define an Employee class as follows:   1. By convention, class names capitalize the initial of each word.   2. For example: Employee, Boss, DateUtility, PostOffice, RegularRateCalculator.   3. This type of naming convention is known as Pascal naming convention.   4. The other convention, the camel naming convention, capitalize the initial of each word, except the first word.   5. Method and field names use the camel naming convention.A class is a blueprint or prototype from which objects are created.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassBody</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassConstantInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ClassConstantInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   &apos;public static final&apos; variables are constant.The naming convention for static final variables is to have them in upper case and separate two words with an underscore. For example:static final static final If you want to make a static final variable accessible from outside the class, you can make it public too:The static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.For example, the following variable declaration defines a constant named PI, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):static final double PI = 3.141592653589793;Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).Note:If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ClassDataType</IRI>
        <Literal datatypeIRI="&xsd;string">class as a data type</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">In the real world, you&apos;ll often find many individual objects all of the same kind. There may be thousands of other bicycles in existence, all of the same make and model. Each bicycle was built from the same set of blueprints and therefore contains the same components. In object-oriented terms, we say that your bicycle is an instance of the class of objects known as bicycles. A class is the blueprint from which individual objects are created.The following Bicycle class is one possible implementation of a bicycle:The syntax of the Java programming language will look new to you, but the design of this class is based on the previous discussion of bicycle objects. The fields cadence, speed, and gear represent the object&apos;s state, and the methods (changeCadence, changeGear, speedUp etc.) define its interaction with the outside world.You may have noticed that the Bicycle class does not contain a main method. That&apos;s because it&apos;s not a complete application; it&apos;s just the blueprint for bicycles that might be used in an application. The responsibility of creating and using new Bicycle objects belongs to some other class in your application. Classes are the fundamental building blocks of a Java program. You can define an Employee class as follows:   1. By convention, class names capitalize the initial of each word.   2. For example: Employee, Boss, DateUtility, PostOffice, RegularRateCalculator.   3. This type of naming convention is known as Pascal naming convention.   4. The other convention, the camel naming convention, capitalize the initial of each word, except the first word.   5. Method and field names use the camel naming convention.You&apos;ve seen classes defined in the following way:class MyClass {    //field, constructor, and method declarations}This is a class declaration. The class body (the area between the braces) contains all the code that provides for the life cycle of the objects created from the class: constructors for initializing new objects, declarations for the fields that provide the state of the class and its objects, and methods to implement the behavior of the class and its objects.The preceding class declaration is a minimal oneit contains only those components of a class declaration that are required. You can provide more information about the class, such as the name of its superclass, whether it implements any interfaces, and so on, at the start of the class declaration.You can also add modifiers like public or private at the very beginningso you can see that the opening line of a class declaration can become quite complicated. The modifiers public and private, which determine what other classes can access MyClass, are discussed later in this lesson. The lesson on interfaces and inheritance will explain how and why you would use the extends and implements keywords in a class declaration. For the moment you do not need to worry about these extra complications.In general, class declarations can include these components, in order:	1.	Modifiers such as public, private, and a number of others that you will encounter later.	2.	The class name, with the initial letter capitalized by convention.	3.	The name of the class&apos;s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.	4.	A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.	5.	The class body, surrounded by braces, {}.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassField</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ClassField</IRI>
        <Literal datatypeIRI="&xsd;string">Class Variables (Static Fields) A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as static since conceptually the same number of gears will apply to all instances. The code static int numGears = 6; would create such a static field. Additionally, the keyword final could be added to indicate that the number of gears will never change.    1. Static members are not tied to class instances.   2. Static members can be called without having an instance.In this section, we discuss the use of the static keyword to create fields and methods that belong to the class, rather than to an instance of the class.Sometimes, you want to have variables that are common to all objects. This is accomplished with the static modifier. Fields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.For example, suppose you want to create a number of Bicycle objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many Bicycle objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, numberOfBicycles, as follows:Class variables are referenced by the class name itself, as inThis makes it clear that they are class variables.A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassFieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ClassFieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. You can use the keyword static in front of a field  declaration.   2. The static keyword may come before or after the access modifier.   You can only declare a static variable in a class level.In this section, we discuss the use of the static keyword to create fields and methods that belong to the class, rather than to an instance of the class.Sometimes, you want to have variables that are common to all objects. This is accomplished with the static modifier. Fields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.For example, suppose you want to create a number of Bicycle objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many Bicycle objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, numberOfBicycles, as follows:Class variables are referenced by the class name itself, as inThis makes it clear that they are class variables.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassMemberDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassMemberInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ClassSingnature</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConditionalExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ConditionalExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The conditional operator ? : uses the boolean value of one expression to decide which of two other expressions should be evaluated.The conditional operator is syntactically right-associative (it groups right-to-left), so that a?b:c?d:e?f:g means the same as a?b:(c?d:(e?f:g)).		ConditionalExpression:			ConditionalOrExpression			ConditionalOrExpression ? Expression : ConditionalExpression		The conditional operator has three operand expressions; ? appears between the first and second expressions, and : appears between the second and third expressions.The first expression must be of type boolean, or a compile-time error occurs.The conditional operator may be used to choose between second and third operands of numeric type, or second and third operands of type boolean, or second and third operands that are each of either reference type or the null type. All other cases result in a compile-time error.Note that it is not permitted for either the second or the third operand expression to be an invocation of a void method. In fact, it is not permitted for a conditional expression to appear in any context where an invocation of a void method could appear (14.8).At run time, the first operand expression of the conditional expression is evaluated first; its boolean value is then used to choose either the second or the third operand expression:		If the value of the first operand is true, then the second operand expression is chosen.		If the value of the first operand is false, then the third operand expression is chosen.The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated above. The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.Ternary operator &apos;? :&apos; a shortcut for trivial if-else based calculations^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Constant</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Constant</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Using the final keyword to declare a variable.   2. The final keyword specifies that the value of a variable is final and cannot be changed.   3. It is a convention in Java to write constants in uppercase letters.   You can prefix a variable declaration with the keyword final to make its value unchangeable. You can make both local variables and class fields final.   1. Once assigned a value, the final value cannot change.   2. Attempting to change it will result in a compile error.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstantInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ConstantInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Using the final keyword to declare a variable.   2. The final keyword specifies that the value of a variable is final and cannot be changed.   3. It is a convention in Java to write constants in uppercase letters.   You can prefix a variable declaration with the keyword final to make its value unchangeable. You can make both local variables and class fields final.   1. Once assigned a value, the final value cannot change.   2. Attempting to change it will result in a compile error.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstantInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ConstantInvocation</IRI>
        <Literal datatypeIRI="&xsd;string">class constants (final fields) are usually defined as public static final. One can invoke them the same way methods are invoked, Since theay are usually defined as static, no object needs ot be created to call them, class name is used instead.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Constructor</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Constructor</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Every class must have at least one constructor.   2. If there is no constructors for your class, the compiler will supply a default constructor(no-arg constructor).   3. A constructor is used to construct an object.   4. A constructor looks like a method and is sometimes called a constructor method.   5. A constructor never returns a value   6. A constructor always has the same name as the class.   7. A constructor may have zero argument, in which case it is called a no-argument (or no-arg, for short) constructor.   8. Constructor arguments can be used to initialize the fields in the object.The syntax for a constructor is as follows.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstructorCall</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ConstructorCall</IRI>
        <Literal datatypeIRI="&xsd;string">A class instance creation expression is used to create new objects that are instances of classes.Class instance creation expressions have two forms:Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an anonymous class (15.9.5) and creates an instance of it.We say that a class is instantiated when an instance of the class is created by a class instance creation expression. Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created instance are, what constructor should be invoked to create the new instance and what arguments should be passed to that constructor.If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class.The type of the class instance creation expression is the class type being instantiated.At run time, evaluation of a class instance creation expression is as follows.First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to null, a NullPointerException is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an OutOfMemoryError (15.9.6).The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its default value (4.5.5).Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements (8.8) and is described in detail in 12.5.The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.Call of the constructor creates an new object and returns a refernece to to it^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstructorDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ConstructorDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Every class must have at least one constructor.   2. If there is no constructors for your class, the compiler will supply a default constructor(no-arg constructor).   3. A constructor is used to construct an object.   4. A constructor looks like a method and is sometimes called a constructor method.   5. A constructor never returns a value   6. A constructor always has the same name as the class.   7. A constructor may have zero argument, in which case it is called a no-argument (or no-arg, for short) constructor.   8. Constructor arguments can be used to initialize the fields in the object.The syntax for a constructor is as follows.A class contains constructors that are invoked to create objects from the class blueprint. Constructor declarations look like method declarationsexcept that they use the name of the class and have no return type. For example, Bicycle has one constructor:To create a new Bicycle object called myBike, a constructor is called by the new operator:Bicycle myBike = new Bicycle(30, 0, 8);new Bicycle(30, 0, 8) creates space in memory for the object and initializes its fields.Although Bicycle only has one constructor, it could have others, including a no-argument constructor:Bicycle yourBike = new Bicycle(); invokes the no-argument constructor to create a new Bicycle object called yourBike.Both constructors could have been declared in Bicycle because they have different argument lists. As with methods, the Java platform differentiates constructors on the basis of the number of arguments in the list and their types. You cannot write two constructors that have the same number and type of arguments for the same class, because the platform would not be able to tell them apart. Doing so causes a compile-time error.You don&apos;t have to provide any constructors for your class, but you must be careful when doing this. The compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation, the compiler will complain if the superclass doesn&apos;t have a no-argument constructor so you must verify that it does. If your class has no explicit superclass, then it has an implicit superclass of Object, which does have a no-argument constructor.You can use a superclass constructor yourself. The MountainBike class at the beginning of this lesson did just that. This will be discussed later, in the lesson on interfaces and inheritance.You can use access modifiers in a constructor&apos;s declaration to control which other classes can call the constructor.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstructorName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ConstructorSignature</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ContinueStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ContinueStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The continue statement stops the execution of the current iteration and causes control to begin with the next iteration.The continue statement: skips all or part of a loop iterationThe continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop&apos;s body and evaluates the boolean expression that controls the loop. The following program, ContinueDemo , steps through a String, counting the occurences of the letter &quot;p&quot;. If the current character is not a p, the continue statement skips the rest of the loop and proceeds to the next character. If it is a &quot;p&quot;, the program increments the letter count.continue statement (interrupts current loop iteration)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DOM</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Data</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Data</IRI>
        <Literal datatypeIRI="&xsd;string">Superconcept of everytrhing related to Data types, different kinds of variables, their values and operations with viriables</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DataType</IRI>
        <Literal datatypeIRI="&xsd;string">Data type</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DefaultAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DefaultAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;string">The default access is that a member can be accessed anywhere within the package that contains its declaration; other possibilities are public, protected, and private.if none of the access modifiers public, protected, or private are specified, a class member or constructor is accessible throughout the package that contains the declaration of the class in which the class member is declared, but the class member or constructor is not accessible in any other package.If a public class has a method or constructor with default access, then this method or constructor is not accessible to or inherited by a subclass declared outside this package.For example, if we have:then a subclass in another package may declare an unrelated move method, with the same signature (8.3.2) and return type. Because the original move method is not accessible from package morepoints, super may not be used:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DefaultClause</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DefaultClause</IRI>
        <Literal datatypeIRI="&xsd;string">The default section handles all values that aren&apos;t explicitly handled by one of the case sections.default clause - final option of the switch statement^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DivideAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DivideAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">All compound assignment operators require both operands to be of primitive type, except for +=, which allows the right-hand operand to be of any type if the left-hand operand is of type String.At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:		First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.		Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see 15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion (5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.Divide the value of the varibale to the left by the value of the expression to the right and assigns the result to the variable to the left &apos;=/&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DivideExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DivideExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There&apos;s a good chance you&apos;ll recognize them by their counterparts in basic mathematics. / 	division operatorThe binary / operator performs division, producing the quotient of its operands. The left-hand operand is the dividend and the right-hand operand is the divisor.Integer division rounds toward 0. That is, the quotient produced for operands n and d that are integers after binary numeric promotion (5.6.2) is an integer value q whose magnitude is as large as possible while satisfying ; moreover, q is positive when  and n and d have the same sign, but q is negative when  and n and d have opposite signs. There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for its type, and the divisor is -1, then integer overflow occurs and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case. On the other hand, if the value of the divisor in an integer division is 0, then an ArithmeticException is thrown.Division operator &apos;/&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DoStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DoStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The do-while statement is like the while statement, except that the associated block always gets executed at least once.Its syntax is as follows:Just like the while statement, you can omit the braces if there is only one statement within them. However, always use braces for the sake of clarity.The following do-while demonstrates that at least the code in the do block will be executed once even though the initial value of j used to test the expression j &lt; 3 evaluates to false.he Java programming language also provides a do-while statement, which can be expressed as follows:do {     statement(s)} while (expression);The difference between do-while and while is that do-while evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the do block are always executed at least once, as shown in the following DoWhileDemo program:The do statement executes a Statement and an Expression repeatedly until the value of the Expression is false.		DoStatement:			do Statement while ( Expression ) ;		The Expression must have type boolean, or a compile-time error occurs.A do statement is executed by first executing the Statement. Then there is a choice:		If execution of the Statement completes normally, then the Expression is evaluated. If evaluation of the Expression completes abruptly for some reason, the do statement completes abruptly for the same reason. Otherwise, there is a choice based on the resulting value:		If the value is true, then the entire do statement is executed again.		If the value is false, no further action is taken and the do statement completes normally.		If execution of the Statement completes abruptly, see 14.12.1 below.Executing a do statement always executes the contained Statement at least once.do-while loop (postcondition)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DoubleDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DoubleDataType</IRI>
        <Literal datatypeIRI="&xsd;string">double: The double data type is a double-precision 64-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in section 4.2.3 of the Java Language Specification. For decimal values, this data type is generally the default choice. As mentioned above, this data type should never be used for precise values, such as currency. double-precision folating-point type in Java for numbers from -10^308 to10^308 and up 15 significant deciamal digits (reserved word double)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#DoubleValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#DoubleValue</IRI>
        <Literal datatypeIRI="&xsd;string">A floating-point literal has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an exponent, and a type suffix. The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer.At least one digit, in either the whole number or the fraction part, and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional.A floating-point literal is of type double and it can optionally be suffixed with an ASCII letter D or d.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Encapsulation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Encapsulation</IRI>
        <Literal datatypeIRI="&xsd;string">The first (left-most) modifier used lets you control what other classes have access to a member field. For the moment, consider only public and private. Other access modifiers will be discussed later.		private modifierthe field is accessible only within its own class.In the spirit of encapsulation, it is common to make fields private. This means that they can only be directly accessed from the Bicycle class. We still need access to these values, however. This can be done indirectly by adding public methods that obtain the field values for us:Encapsulation is the hiding of the internal mechanisms and data structures of a class behind its public interface, in such a way that users of the component (other pieces of software) only need to know what the class does not and cannot make themselves dependent on the details of class implementation.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#EqualExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#EqualExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The equality operators are syntactically left-associative (they group left-to-right), but this fact is essentially never useful; for example, a==b==c parses as (a==b)==c. The result type of a==b is always boolean, and c must therefore be of type boolean or a compile-time error occurs. Thus, a==b==c does not test to see whether a, b, and c are all equal.The == (equal to) and the != (not equal to) operators are analogous to the relational operators except for their lower precedence. Thus, a&lt;b==c&lt;d is true whenever a&lt;b and c&lt;d have the same truth value.The equality operators may be used to compare two operands of numeric type, or two operands of type boolean, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always boolean.In all cases, a!=b produces the same result as !(a==b). The equality operators are commutative if the operand expressions have no side effects.Logical equality (equal-to operator) &apos;==&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ExceptionClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ExceptionClass</IRI>
        <Literal datatypeIRI="&xsd;string">Every exception is represented by an instance of the class Throwable or one of its subclasses; such an object can be used to carry information from the point at which an exception occurs to the handler that catches it. The possible exceptions in a program are organized in a hierarchy of classes, rooted at class Throwable (11.5), a direct subclass of Object. The classes Exception and Error are direct subclasses of Throwable. The class RuntimeException is a direct subclass of Exception.Programs can use the pre-existing exception classes in throw statements, or define additional exception classes, as subclasses of Throwable or of any of its subclasses, as appropriate. To take advantage of the Java platform&apos;s compile-time checking for exception handlers, it is typical to define most new exception classes as checked exception classes, specifically as subclasses of Exception that are not subclasses of RuntimeException.The class Exception is the superclass of all the exceptions that ordinary programs may wish to recover from. The class RuntimeException is a subclass of class Exception. The subclasses of RuntimeException are unchecked exception classes. The subclasses of Exception other than RuntimeException are all checked exception classes.The class Error and its subclasses are exceptions from which ordinary programs are not ordinarily expected to recover. See the Java API specification for a detailed description of the exception hierarchy.The class Error is a separate subclass of Throwable, distinct from Exception in the class hierarchy, to allow programs to use the idiom.to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ExceptionHandlingStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ExplicitTypeCasting</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ExplicitTypeCasting</IRI>
        <Literal datatypeIRI="&xsd;string">Casting conversion is applied to the operand of a cast operator (15.16): the type of the operand expression must be converted to the type explicitly named by the cast operator. Casting contexts allow the use of an identity conversion (5.1.1), a widening primitive conversion (5.1.2), a narrowing primitive conversion (5.1.3), a widening reference conversion (5.1.4), or a narrowing reference conversion (5.1.5). Thus casting conversions are more inclusive than assignment or method invocation conversions: a cast can do any permitted conversion other than a string conversion.Some casts can be proven incorrect at compile time; such casts result in a compile-time error.A value of a primitive type can be cast to another primitive type by identity conversion, if the types are the same, or by a widening primitive conversion or a narrowing primitive conversion.A value of a primitive type cannot be cast to a reference type by casting conversion, nor can a value of a reference type be cast to a primitive type.A cast expression converts, at run time, a value of one numeric type to a similar value of another numeric type; or confirms, at compile time, that the type of an expression is boolean; or checks, at run time, that a reference value refers to an object whose class is compatible with a specified reference type.		CastExpression:			( PrimitiveType Dimsopt ) UnaryExpression			( ReferenceType ) UnaryExpressionNotPlusMinus		See 15.15 for a discussion of the distinction between UnaryExpression and UnaryExpressionNotPlusMinus.The type of a cast expression is the type whose name appears within the parentheses. (The parentheses and the type they contain are sometimes called the cast operator.) The result of a cast expression is not a variable, but a value, even if the result of the operand expression is a variable.A cast operator has no effect on the choice of value set (4.2.3) for a value of type float or type double. Consequently, a cast to type float within an expression that is not FP-strict (15.4) does not necessarily cause its value to be converted to an element of the float value set, and a cast to type double within an expression that is not FP-strict does not necessarily cause its value to be converted to an element of the double value set.At run time, the operand value is converted by casting conversion (5.5) to the type specified by the cast operator.Not all casts are permitted by the language. Some casts result in an error at compile time. For example, a primitive value may not be cast to a reference type. Some casts can be proven, at compile time, always to be correct at run time. For example, it is always correct to convert a value of a class type to the type of its superclass; such a cast should require no special action at run time. Finally, some casts cannot be proven to be either always correct or always incorrect at compile time. Such casts require a test at run time.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Expression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Expression</IRI>
        <Literal datatypeIRI="&xsd;string">An expression is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ExpressionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ExpressionStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Statements are roughly equivalent to sentences in natural languages. A statement forms a complete unit of execution. The following types of expressions can be made into a statement by terminating the expression with a semicolon (;).Such statements are called expression statements. Here are some examples of expression statements.In addition to expression statements, there are two other kinds of statements:Some expressions can be made statements by terminating them with a semicolon. For example, x++ is an expression. However, this is a statement:x++;Certain kinds of expressions may be used as statements by following them with semicolons:An expression statement is executed by evaluating the expression; if the expression has a value, the value is discarded. Execution of the expression statement completes normally if and only if evaluation of the expression completes normally.Expression statement consits of an assignement expression or relational operator expression or incremenet/decremenet expassion and a semicolon^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ExtendsSpecification</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ExtendsSpecification</IRI>
        <Literal datatypeIRI="&xsd;string">Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. In this example, Bicycle now becomes the superclass of MountainBike, RoadBike, and TandemBike. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of subclasses:A diagram of classes in a hierarchy.A hierarchy of bicycle classes.The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:class MountainBike extends Bicycle {     // new fields and methods defining a mountain bike would go here}This gives MountainBike all the same fields and methods as Bicycle, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.You extend a class by using the extends keyword in a class declaration,The Parent classThe Child class</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#False</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#False</IRI>
        <Literal datatypeIRI="&xsd;string">The boolean type has two values, represented by literals &apos;false&apos; and ...The following code declares a boolean variable includeSign and assigns it the value of false.The boolean type has two values, represented by the literals true and false, formed from ASCII letters.A boolean literal is always of type boolean.Logical false value (reserved word &quot;false&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Field</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FieldDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FieldDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">The variables of a class type are introduced by field declarations:The FieldModifiers are described in 8.3.1. The Identifier in a FieldDeclarator may be used in a name to refer to the field. Fields are members; the scope (6.3) of a field declaration is specified in 8.1.5. More than one field may be declared in a single field declaration by using more than one declarator; the FieldModifiers and Type apply to all the declarators in the declaration. Variable declarations involving array types are discussed in 10.2.The access modifiers public, protected, and private are discussed in 6.6. A compile-time error occurs if the same modifier appears more than once in a field declaration, or if a field declaration has more than one of the access modifiers public, protected, and private.If two or more (distinct) field modifiers appear in a field declaration, it is customary, though not required, that they appear in the order consistent with that shown above in the production for FieldModifier.Initialization expressions for instance variables may use the simple name of any static variable declared in or inherited by the class, even one whose declaration occurs textually later.Thus the example:compiles without error; it initializes j to 1 when class Test is initialized, and initializes f to the current value of j every time an instance of class Test is created.Initialization expressions for instance variables are permitted to refer to the current object this (15.8.3) and to use the keyword super (15.11.2, 15.12).Use of instance variables whose declarations appear textually after the use is sometimes restricted, even though these instance variables are in scope. See 8.3.2.3 for the precise rules governing forward reference to instance variables.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;string">variable declaration (including variable type and variable name)
it is a part of the declaration statement</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FieldInheritance</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FieldInheritance</IRI>
        <Literal datatypeIRI="&xsd;string">If the class declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superclasses, and superinterfaces of the class. The field declaration also shadows (6.3.1) declarations of any accessible fields in enclosing classes or interfaces, and any local variables, formal method parameters, and exception handler parameters with the same name in any enclosing blocks.If a field declaration hides the declaration of another field, the two fields need not have the same type.A class inherits from its direct superclass and direct superinterfaces all the non-private fields of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.Note that a private field of a superclass might be accessible to a subclass (for example, if both classes are members of the same class). Nevertheless, a private field is never inherited by a subclass.It is possible for a class to inherit more than one field with the same name (8.3.3.3). Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such field by its simple name will result in a compile-time error, because such a reference is ambiguous.There might be several paths by which the same field declaration might be inherited from an interface. In such a situation, the field is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.A class may inherit two or more fields with the same name, either from two interfaces or from its superclass and an interface. A compile-time error occurs on any attempt to refer to any ambiguously inherited field by its simple name. A qualified name or a field access expression that contains the keyword super (15.11.2) may be used to access such fields unambiguously. In the example:Subclass inherits all instance fields and class fields of the superclass. ^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalClass</IRI>
        <Literal datatypeIRI="&xsd;string">You can prevent others from extending your class by making it final using the keyword final in the class declaration.Note that you can also declare an entire class final  this prevents the class from being subclassed. This is particularly useful, for example, when creating an immutable class like the String class.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="owl:disjointWith"/>
        <IRI>#FinalClass</IRI>
        <Literal datatypeIRI="&xsd;string"></Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">You can prevent others from extending your class by making it final using the keyword final in the class declaration.Note that you can also declare an entire class final  this prevents the class from being subclassed. This is particularly useful, for example, when creating an immutable class like the String class.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalInstanceFieldInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalInstanceFieldInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">If a field declarator contains a variable initializer, then it has the semantics of an assignment (15.26) to the declared variable, and:		If the declarator is for a class variable (that is, a static field), then the variable initializer is evaluated and the assignment performed exactly once, when the class is initialized	One subtlety here is that, at run time, static variables that are final and that are initialized with compile-time constant values are initialized first. This also applies to such fields in interfaces (9.3.1). These variables are &quot;constants&quot; that will never be observed to have their default initial values (4.5.5), even by devious programs. See 12.4.2 and 13.4.8 for more discussion. Use of class variables whose declarations appear textually after the use is sometimes restricted, even though these class variables are in scope. See 8.3.2.3 for the precise rules governing forward reference to class variables.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalMethod</IRI>
        <Literal datatypeIRI="&xsd;string">You can declare some or all of a class&apos;s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does thisa number of its methods are final.You might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalMethodDefintion</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalMethodDefintion</IRI>
        <Literal datatypeIRI="&xsd;string">You can declare some or all of a class&apos;s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does thisa number of its methods are final.You might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FinalModifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FinalModifier</IRI>
        <Literal datatypeIRI="&xsd;string">You can prevent others from extending your class by making it final using the keyword final in the class declaration.Note that you can also declare an entire class final  this prevents the class from being subclassed. This is particularly useful, for example, when creating an immutable class like the String class.You can prefix a variable declaration with the keyword final to make its value unchangeable. You can make both local variables and class fields final.   1. Once assigned a value, the final value cannot change.   2. Attempting to change it will result in a compile error.The static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.For example, the following variable declaration defines a constant named PI, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):static final double PI = 3.141592653589793;Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).Note:If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.You can declare some or all of a class&apos;s methods final. You use the final keyword in a method declaration to indicate that the method cannot be overridden by subclasses. The Object class does thisa number of its methods are final.You might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object. For example, you might want to make the getFirstPlayer method in this ChessAlgorithm class final:Methods called from constructors should generally be declared final. If a constructor calls a non-final method, a subclass may redefine that method with surprising or undesirable results.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FloatDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FloatDataType</IRI>
        <Literal datatypeIRI="&xsd;string">float: The float data type is a single-precision 32-bit IEEE 754 floating point. Its range of values is beyond the scope of this discussion, but is specified in section 4.2.3  of the Java Language Specification. As with the recommendations for byte and short, use a float (instead of double) if you need to save memory in large arrays of floating point numbers. This data type should never be used for precise values, such as currency. For that, you will need to use the java.math.BigDecimal class instead. Numbers and Strings covers BigDecimal and other useful classes provided by the Java platform. single-precision floating-point type in Java for number form -10^38 to 10^38 and up to 7 significant deciam digits (reserved word &quot;float&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FloatValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FloatValue</IRI>
        <Literal datatypeIRI="&xsd;string">A floating-point literal has the following parts: a whole-number part, a decimal point (represented by an ASCII period character), a fractional part, an exponent, and a type suffix. The exponent, if present, is indicated by the ASCII letter e or E followed by an optionally signed integer.At least one digit, in either the whole number or the fraction part, and either a decimal point, an exponent, or a float type suffix are required. All other parts are optional.A floating-point literal is of type float if it is suffixed with an ASCII letter F or f;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ForEachStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ForEachStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The general form of the for-each version of the for is shown here:for(type itr-var : iterableObj) statement-blockThe object referred to by iterableObj must be an array or an object that implements the new Iterable interface.The for-each loop is essentially read-onlyUsing the For-Each Loop with CollectionsUsing &apos;for each&apos; to loop through arrayThe for statement also has another form designed for iteration through Collections and arrays This form is sometimes referred to as the enhanced for statement, and can be used to make your loops more compact and easy to read. To demonstrate, consider the following array, which holds the numbers 1 through 10:int[] numbers = {1,2,3,4,5,6,7,8,9,10};The following program, EnhancedForDemo, uses the enhanced for to loop through the array:for-each loop (enhanced for loop) available starting from Java 5.0^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ForStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ForStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The for statement is like the while statement, i.e. you use it to create loop. The for statement has following syntax:   1. init is an initialization that will be performed before the first iteration.   2. booleanExpression is a boolean expression which will cause the execution of statement(s) if it evaluates to true.   3. update is a statement that will be executed after the execution of the statement block.   4. init, expression, and update are optional.The for statement will stop only if one of the following conditions is met:   1. booleanExpression evaluates to false   2. A break or continue statement is executed   3. A runtime error occurs.   It is common to declare a variable and assign a value to it in the initialization part. The variable declared will be visible to the expression and update parts as well as to the statement block.For example, the following for statement loops five times and each time prints the value of i. Note that the variable i is not visible anywhere else since it is declared within the for loop.The initialization part of the for statement is optional.The update statement is optional.You can even omit the booleanExpression part.If you compare for and while, you&apos;ll see that you can always replace the while statement with for. This is to say thatThe for statement provides a compact way to iterate over a range of values. Programmers often refer to it as the &quot;for loop&quot; because of the way in which it repeatedly loops until a particular condition is satisfied. The general form of the for statement can be expressed as follows:for (initialization; termination; increment) {    statement(s)}When using this version of the for statement, keep in mind that:		The initialization expression initializes the loop; it&apos;s executed once, as the loop begins.		When the termination expression evaluates to false, the loop terminates.		The increment expression is invoked after each iteration through the loop; it is perfectly acceptable for this expression to increment or decrement a value.The following program, ForDemo, uses the general form of the for statement to print the numbers 1 through 10 to standard output:Notice how the code declares a variable within the initialization expression. The scope of this variable extends from its declaration to the end of the block governed by the for statement, so it can be used in the termination and increment expressions as well. If the variable that controls a for statement is not needed outside of the loop, it&apos;s best to declare the variable in the initialization expression. The names i, j, and k are often used to control for loops; declaring them within the initialization expression limits their life span and reduces errors.The three expressions of the for loop are optional; an infinite loop can be created as follows:for ( ; ; ) {    // infinite loop         // your code goes here}The for statement executes some initialization code, then executes an Expression, a Statement, and some update code repeatedly until the value of the Expression is false.A for statement is executed by first executing the ForInit code:		If the ForInit code is a list of statement expressions (14.8), the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForInit statement expressions to the right of the one that completed abruptly are not evaluated.If the ForInit code is a local variable declaration, it is executed as if it were a local variable declaration statement (14.4) appearing in a block. The scope of a local variable declared in the ForInit part of a for statement (14.13) includes all of the following:		Its own initializer		Any further declarators to the right in the ForInit part of the for statement		The Expression and ForUpdate parts of the for statement		The contained StatementIf execution of the local variable declaration completes abruptly for any reason, the for statement completes abruptly for the same reason.		If the ForInit part is not present, no action is taken.	Next, a for iteration step is performed, as follows:		If the Expression is present, it is evaluated, and if evaluation of the Expression completes abruptly, the for statement completes abruptly for the same reason. Otherwise, there is then a choice based on the presence or absence of the Expression and the resulting value if the Expression is present:		If the Expression is not present, or it is present and the value resulting from its evaluation is true, then the contained Statement is executed. Then there is a choice:		If execution of the Statement completes normally, then the following two steps are performed in sequence:		First, if the ForUpdate part is present, the expressions are evaluated in sequence from left to right; their values, if any, are discarded. If evaluation of any expression completes abruptly for some reason, the for statement completes abruptly for the same reason; any ForUpdate statement expressions to the right of the one that completed abruptly are not evaluated. If the ForUpdate part is not present, no action is taken.		Second, another for iteration step is performed.		If execution of the Statement completes abruptly, see 14.13.3 below.		If the Expression is present and the value resulting from its evaluation is false, no further action is taken and the for statement completes normally.If the value of the Expression is false the first time it is evaluated, then the Statement is not executed.If the Expression is not present, then the only way a for statement can complete normally is by use of a break statement.for loop (counter)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#FormalMethodParameter</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#FormalMethodParameter</IRI>
        <Literal datatypeIRI="&xsd;string">Parameters You&apos;ve already seen examples of parameters, both in the Bicycle class and in the main method of the &quot;Hello World!&quot; application. Recall that the signature for the main method is public static void main(String[] args). Here, the args variable is the parameter to this method. The important thing to remember is that parameters are always classified as &quot;variables&quot; not &quot;fields&quot;. This applies to other parameter-accepting constructs as well (such as constructors and exception handlers) that you&apos;ll learn about later in the tutorial. Primitive variables are passed by value.# When you pass a primitive variable, the JVM will copy the value of the passed-in variable to a new local variable.# If you change the value of the local variable, the change will not affect the passed in primitive variable.reference variables are passed by reference.# If you pass a reference variable, the local variable will refer to the same object as the passed in reference variable.# If you change the object referenced within your method, the change will also be reflected in the calling code.The declaration for a method or a constructor declares the number and the type of the arguments for that method or constructor. For example, the following is a method that computes the monthly payments for a home loan, based on the amount of the loan, the interest rate, the length of the loan (the number of periods), and the future value of the loan:This method has four parameters: the loan amount, the interest rate, the future value and the number of periods. The first three are double-precision floating point numbers, and the fourth is an integer. The parameters are used in the method body and at runtime will take on the values of the arguments that are passed in.Note:Parameters refers to the list of variables in a method declaration. Arguments are the actual values that are passed in when the method is invoked. When you invoke a method, the arguments used must match the declaration&apos;s parameters in type and order.You can use any data type for a parameter of a method or a constructor. This includes primitive data types, such as doubles, floats, and integers, as you saw in the computePayment method, and reference data types, such as objects and arrays.Here&apos;s an example of a method that accepts an array as an argument. In this example, the method creates a new Polygon object and initializes it from an array of Point objects (assume that Point is a class that represents an x, y coordinate):When you declare a parameter to a method or a constructor, you provide a name for that parameter. This name is used within the method body to refer to the passed-in argument.The name of a parameter must be unique in its scope. It cannot be the same as the name of another parameter for the same method or constructor, and it cannot be the name of a local variable within the method or constructor.A parameter can have the same name as one of the class&apos;s fields. If this is the case, the parameter is said to shadow the field. Shadowing fields can make your code difficult to read and is conventionally used only within constructors and methods that set a particular field. For example, consider the following Circle class and its setOrigin method:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GenericClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GenericClass</IRI>
        <Literal datatypeIRI="&xsd;string">Let&apos;s update our Box class to use generics. We&apos;ll first create a generic type declaration by changing the code &quot;public class Box&quot; to &quot;public class Box&lt;T&gt;&quot;; this introduces one type variable, named T, that can be used anywhere inside the class. This same technique can be applied to interfaces as well. There&apos;s nothing particularly complex about this concept. In fact, it&apos;s quite similar to what you already know about variables in general. Just think of T as a special kind of variable, whose &quot;value&quot; will be whatever type you pass in; this can be any class type, any interface type, or even another type variable. It just can&apos;t be any of the primitive data types. In this context, we also say that T is a formal type parameter of the Box class.As you can see, we&apos;ve replaced all occurrences of Object with T. To reference this generic class from within your own code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:It&apos;s important to understand that type variables are not actually types themselves. In the above examples, you won&apos;t find T.java or T.class anywhere on the filesystem. Furthermore, T is not a part of the Box class name. In fact during compilation, all generic information will be removed entirely, leaving only Box.class on the filesystem. We&apos;ll discuss this later in the section on Type ErasureAlso note that a generic type may have multiple type parameters, but each parameter must be unique within its declaring class or interface. A declaration of Box&lt;T,T&gt;, for example, would generate an error on the second occurrence of T, but Box&lt;T,U&gt;, however, would be allowed.Type parameters can also be declared within method and constructor signatures to create generic methods and generic constructors. This is similar to declaring a generic type, but the type parameter&apos;s scope is limited to the method or constructor in which it&apos;s declared.Here we&apos;ve added one generic method, named inspect, that defines one type parameter, named U. This method accepts an object and prints its type to standard output. For comparison, it also prints out the type of T. For convenience, this class now also has a main method so that it can be run as an application.A more realistic use of generic methods might be something like the following, which defines a static method that stuffs references to a single item into multiple boxes:To use this method, your code would look something like the following:The complete syntax for invoking this method is:Here we&apos;ve explicitly provided the type to be used as U, but more often than not, this can be left out and the compiler will infer the type that&apos;s needed:This feature, known as type inference, allows you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GenericClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GenericClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">Let&apos;s update our Box class to use generics. We&apos;ll first create a generic type declaration by changing the code &quot;public class Box&quot; to &quot;public class Box&lt;T&gt;&quot;; this introduces one type variable, named T, that can be used anywhere inside the class. This same technique can be applied to interfaces as well. There&apos;s nothing particularly complex about this concept. In fact, it&apos;s quite similar to what you already know about variables in general. Just think of T as a special kind of variable, whose &quot;value&quot; will be whatever type you pass in; this can be any class type, any interface type, or even another type variable. It just can&apos;t be any of the primitive data types. In this context, we also say that T is a formal type parameter of the Box class.As you can see, we&apos;ve replaced all occurrences of Object with T. To reference this generic class from within your own code, you must perform a generic type invocation, which replaces T with some concrete value, such as Integer:It&apos;s important to understand that type variables are not actually types themselves. In the above examples, you won&apos;t find T.java or T.class anywhere on the filesystem. Furthermore, T is not a part of the Box class name. In fact during compilation, all generic information will be removed entirely, leaving only Box.class on the filesystem. We&apos;ll discuss this later in the section on Type ErasureAlso note that a generic type may have multiple type parameters, but each parameter must be unique within its declaring class or interface. A declaration of Box&lt;T,T&gt;, for example, would generate an error on the second occurrence of T, but Box&lt;T,U&gt;, however, would be allowed.Type parameters can also be declared within method and constructor signatures to create generic methods and generic constructors. This is similar to declaring a generic type, but the type parameter&apos;s scope is limited to the method or constructor in which it&apos;s declared.Here we&apos;ve added one generic method, named inspect, that defines one type parameter, named U. This method accepts an object and prints its type to standard output. For comparison, it also prints out the type of T. For convenience, this class now also has a main method so that it can be run as an application.A more realistic use of generic methods might be something like the following, which defines a static method that stuffs references to a single item into multiple boxes:To use this method, your code would look something like the following:The complete syntax for invoking this method is:Here we&apos;ve explicitly provided the type to be used as U, but more often than not, this can be left out and the compiler will infer the type that&apos;s needed:This feature, known as type inference, allows you to invoke a generic method as you would an ordinary method, without specifying a type between angle brackets.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GenericObjectCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GenericObjectCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">You can think of a generic type invocation as being similar to an ordinary method invocation, but instead of passing an argument to a method, you&apos;re passing a type argument  Integer in this case  to the Box class itself. Like any other variable declaration, this code does not actually create a new Box object. It simply declares that integerBox will hold a reference to a &quot;Box of Integer&quot;, which is how Box&lt;Integer&gt; is read.An invocation of a generic type is generally known as a parameterized type.To instantiate this class, use the new keyword, as usual, but place &lt;Integer&gt; between the class name and the parenthesis:Or, you can put the entire statement on one line, such as:Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();Once integerBox is initialized, you&apos;re free to invoke its get method without providing a cast, as in BoxDemo3:Furthermore, if you try adding an incompatible type to the box, such as String, compilation will fail, alerting you to what previously would have been a runtime bug:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GotoStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GotoStatement</IRI>
        <Literal datatypeIRI="&xsd;string">go-to statement (the most hated programming statement)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GreaterEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GreaterEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The relational operators are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, a&lt;b&lt;c parses as (a&lt;b)&lt;c, which is always a compile-time error, because the type of a&lt;b is always boolean and &lt; is not an operator on boolean values.The type of a relational expression is always boolean.Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=		The value produced by the &lt; operator is true if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is false.		The value produced by the &lt;= operator is true if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is false.		The value produced by the &gt; operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.		The value produced by the &gt;= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.Greater  than or equal to &apos;&gt;=&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#GreaterExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#GreaterExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The relational operators are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, a&lt;b&lt;c parses as (a&lt;b)&lt;c, which is always a compile-time error, because the type of a&lt;b is always boolean and &lt; is not an operator on boolean values.The type of a relational expression is always boolean.Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=		The value produced by the &lt; operator is true if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is false.		The value produced by the &lt;= operator is true if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is false.		The value produced by the &gt; operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.		The value produced by the &gt;= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.Greater than &apos;&gt;&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Identifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IfElseIfStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IfElseIfStatement</IRI>
        <Literal datatypeIRI="&xsd;string">if-else-if  statement (conditional statement with many options - switch substitute)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IfElseStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IfElseStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The if statement is a conditional branch statement. The syntax of the if statement is either one of these twoIn the following example, the if block will be executed if a is greater than 3. Otherwise, the else block will be executed.The if-then-else statement provides a secondary path of execution when an &quot;if&quot; clause evaluates to false. You could use an if-then-else statement in the applyBrakes method to take some action if the brakes are applied when the bicycle is not in motion. In this case, the action is to simply print an error message stating that the bicycle has already stopped.You may have noticed that the value of testscore can satisfy more than one expression in the compound statement: 76 &gt;= 70 and 76 &gt;= 60. However, once a condition is satisfied, the appropriate statements are executed (grade = &apos;C&apos;;) and the remaining conditions are not evaluated.An if-then-else statement is executed by first evaluating the Expression. If evaluation of the Expression completes abruptly for some reason, then the if-then-else statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:		If the value is true, then the first contained Statement (the one before the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally.		If the value is false, then the second contained Statement (the one after the else keyword) is executed; the if-then-else statement completes normally if and only if execution of that statement completes normally.if-else  statement (conditional statement with two options)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IfStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IfStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The if statement is a conditional branch statement. The syntax of the if statement is either one of these twoFor example, in the following if statement, the if block will be executed if x is greater than 4.The if-then statement is the most basic of all the control flow statements. It tells your program to execute a certain section of code only if a particular test evaluates to true. For example, the Bicycle class could allow the brakes to decrease the bicycle&apos;s speed only if the bicycle is already in motion.f this test evaluates to false (meaning that the bicycle is not in motion), control jumps to the end of the if-then statement.In addition, the opening and closing braces are optional, provided that the &quot;then&quot; clause contains only one statement:Deciding when to omit the braces is a matter of personal taste. Omitting them can make the code more brittle. If a second statement is later added to the &quot;then&quot; clause, a common mistake would be forgetting to add the newly required braces. The compiler cannot catch this sort of error; you&apos;ll just get the wrong results.An if-then statement is executed by first evaluating the Expression. If evaluation of the Expression completes abruptly for some reason, the if-then statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:		If the value is true, then the contained Statement is executed; the if-then statement completes normally if and only if execution of the Statement completes normally.		If the value is false, no further action is taken and the if-then statement completes normally.simple if statement (conditional statement with one option)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ImplementsSpecification</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ImplementsSpecification</IRI>
        <Literal datatypeIRI="&xsd;string">As you&apos;ve already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object&apos;s interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the &quot;power&quot; button to turn the television on and off.In its most common form, an interface is a group of related methods with empty bodies. A bicycle&apos;s behavior, if specified as an interface, might appear as follows:To implement this interface, the name of your class would change (to ACMEBicycle, for example), and you&apos;d use the implements keyword in the class declaration:    class ACMEBicycle implements Bicycle {       // remainder of this class implemented as before    }Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.   1. An implementation class has to override all methods in the interface.   2. A class can implement multiple interfaces.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ImplicitTypeCasting</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ImplicitTypeCasting</IRI>
        <Literal datatypeIRI="&xsd;string">Every expression written in the Java programming language has a type that can be deduced from the structure of the expression and the types of the literals, variables, and methods mentioned in the expression. It is possible, however, to write an expression in a context where the type of the expression is not appropriate. In some cases, this leads to an error at compile time; for example, if the expression in an if statement (14.9) has any type other than boolean, a compile-time error occurs. In other cases, the context may be able to accept a type that is related to the type of the expression; as a convenience, rather than requiring the programmer to indicate a type conversion explicitly, the language performs an implicit conversion from the type of the expression to a type acceptable for its surrounding context.Numeric promotion is applied to the operands of an arithmetic operator. Numeric promotion contexts allow the use of an identity conversion (5.1.1) or a widening primitive conversion (5.1.2).Numeric promotions are used to convert the operands of a numeric operator to a common type so that an operation can be performed. The two kinds of numeric promotion are unary numeric promotion (5.6.1) and binary numeric promotion (5.6.2). The analogous conversions in C are called &quot;the usual unary conversions&quot; and &quot;the usual binary conversions.&quot;Numeric promotion is not a general feature of the Java programming language, but rather a property of the specific definitions of the built-in operations.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ImportStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ImportStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Java provides the keyword import to indicate that you want to use a package or a class from a package. For example, to use the java.io.File class, you must have the following import statement:   1. &apos;import&apos; statements must come after the package statement but before the class declaration.   2. The import keyword can appear multiple times in a class.   You can import all classes in the same package by using the wild character *. For example, the following code imports all members of the java.io package.   However, to make your code more readable, it is recommended that you import a package member one at a time.   Members of the java.lang package are imported automatically. Thus, to use the java.lang.String, for example, you do not need to explicitly import the class.The only way to use classes that belong to other packages without importing them is to use the fully qualified names of the classes in your code. For example, the following code declares the java.io.File class using its fully qualified name.If you class import identically-named classes from different packages, you must use the fully qualified names when declaring the classes. For example, the Java core libraries contain the classes java.sql.Date and java.util.Date. In this case, you must write the fully qualified names of java.sql.Date and java.util.Date to use them.The types that comprise a package are known as the package members.To use a public package member from outside its package, you must do one of the following:		Refer to the member by its fully qualified name		Import the package member		Import the member&apos;s entire packageEach is appropriate for different situations, as explained in the sections that follow.So far, most of the examples in this tutorial have referred to types by their simple names, such as Rectangle and StackOfInts. You can use a package member&apos;s simple name if the code you are writing is in the same package as that member or if that member has been imported.However, if you are trying to use a member from a different package and that package has not been imported, you must use the member&apos;s fully qualified name, which includes the package name. Here is the fully qualified name for the Rectangle class declared in the graphics package in the previous example.You could use this qualified name to create an instance of graphics.Rectangle:Qualified names are all right for infrequent use. When a name is used repetitively, however, typing the name repeatedly becomes tedious and the code becomes difficult to read. As an alternative, you can import the member or its package and then use its simple name.To import a specific member into the current file, put an import statement at the beginning of the file before any type definitions but after the package statement, if there is one. Here&apos;s how you would import the Rectangle class from the graphics package created in the previous section.import graphics.Rectangle;Now you can refer to the Rectangle class by its simple name.Rectangle myRectangle = new Rectangle();This approach works well if you use just a few members from the graphics package. But if you use many types from a package, you should import the entire package.To import all the types contained in a particular package, use the import statement with the asterisk (*) wildcard character.import graphics.*;Now you can refer to any class or interface in the graphics package by its simple name.The asterisk in the import statement can be used only to specify all the classes within a package, as shown here. It cannot be used to match a subset of the classes in a package. For example, the following does not match all the classes in the graphics package that begin with A.Instead, it generates a compiler error. With the import statement, you generally import only a single package member or an entire package.Another, less common form of import allows you to import the public nested classes of an enclosing class. For example, if the graphics.Rectangle class contained useful nested classes, such as Rectangle.DoubleWide and Rectangle.Square, you could import Rectangle and its nested classes by using the following two statements.For convenience, the Java compiler automatically imports three entire packages for each source file: (1) the package with no name, (2) the java.lang package, and (3) the current package (the package for the current file).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IncrementDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IncrementDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Incremenet and decrement operators</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Inheritance</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Inheritance</IRI>
        <Literal datatypeIRI="&xsd;string">Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. In this example, Bicycle now becomes the superclass of MountainBike, RoadBike, and TandemBike. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of subclasses:A diagram of classes in a hierarchy.A hierarchy of bicycle classes.The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:class MountainBike extends Bicycle {     // new fields and methods defining a mountain bike would go here}This gives MountainBike all the same fields and methods as Bicycle, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.   1. You extend a class by creating a new class.   2. The former and the latter will then have a parent-child relationship.   3. The original class is the parent class or the base class or the superclass.   4. The new class is called a child class or a subclass or a derived class of the parent.   5. The process of extending a class in object-oriented programming is called inheritance.   6. In a subclass you can add new methods and new fields as well as override existing methods in the parent class to change their behaviors.   7. Inheritance gives you the opportunity to add some functionality that does not exist in the original class.   8. Inheritance can also change the behaviors of the existing class to better suit your needs.   9. The subclass and the superclass has an &quot;is-a&quot; relationship.   Within a subclass you can access its superclass&apos;s public and protected methods and fields , but not the superclass&apos;s private methods. If the subclass and the superclass are in the same package, you can also access the superclass&apos;s default methods and fields.In the preceding lessons, you have seen inheritance mentioned several times. In the Java language, classes can be derived from other classes, thereby inheriting fields and methods from those classes.A class that is derived from another class is called a subclass (also a derived class, extended class, or child class). The class from which the subclass is derived is called a superclass (also a base class or a parent class).Excepting Object, which has no superclass, every class has one and only one direct superclass (single inheritance). In the absence of any other explicit superclass, every class is implicitly a subclass of Object.Classes can be derived from classes that are derived from classes that are derived from classes, and so on, and ultimately derived from the topmost class, Object. Such a class is said to be descended from all the classes in the inheritance chain stretching back to Object.The idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that includes some of the code that you want, you can derive your new class from the existing class. In doing this, you can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.Inheritance is a way to form new classes using classes that have already been defined.
It provides a mechanism for organizing and structuring classes into hierarchies.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InheritanceBasedPolymorphism</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InheritanceBasedPolymorphism</IRI>
        <Literal datatypeIRI="&xsd;string">It means the ability of a single variable of a given type to be used to reference objects of different types and to automatically call the method that is specific to the type of object the variable references.polymorphism works with derived class objects.When a subclasses overrride methods of a superclass, a variable declared as asuperclass will invoke differnt methods depending on the actual sublcass type of the obejct referred by the variable^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InnerClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InnerClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InnerClassDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers (8.7) or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields (15.28).To illustrate these rules, consider the example below:Inner classes may inherit static members that are not compile-time constants even though they may not declare them. Nested classes that are not inner classes may declare static members freely, in accordance with the usual rules of the Java programming language. Member interfaces (8.5) are always implicitly static so they are never considered to be inner classes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InstanceField</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InstanceField</IRI>
        <Literal datatypeIRI="&xsd;string">Instance Variables (Non-Static Fields) Technically speaking, objects store their individual states in &quot;non-static fields&quot;, that is, fields declared without the static keyword. Non-static fields are also known as instance variables because their values are unique to each instance of a class (to each object, in other words); the currentSpeed of one bicycle is independent from the currentSpeed of another.    1. Fields are variables.   2. They can be primitives or references to objects.For example, the Employee class has two fields, age and salary.   1. Field names should follow the camel naming convention.   2. The initial of each word in the field, except for the first word, is written with a capital letter.   3. For example: age, maxAge, address, validAddress, numberOfRows.      Member variables in a classthese are called fields.   The Bicycle class uses the following lines of code to define its fields:public int cadence;public int gear;public int speed;Field declarations are composed of three components, in order:	1.	Zero or more modifiers, such as public or private.	2.	The field&apos;s type.	3.	The field&apos;s name.The fields of Bicycle are named cadence, gear, and speed and are all of data type integer (int). The public keyword identifies these fields as public members, accessible by any object that can access the class.Objects store their individual states in the fields declared without the static keyword. Instance fields are also known as instance variables because their values are unique to each instance of a class (to each object).^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InstanceFieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InstanceFieldDefinitionStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Fields are variables.   2. They can be primitives or references to objects.For example, the Employee class has two fields, age and salary.   1. Field names should follow the camel naming convention.   2. The initial of each word in the field, except for the first word, is written with a capital letter.   3. For example: age, maxAge, address, validAddress, numberOfRows.      Member variables in a classthese are called fields.   The Bicycle class uses the following lines of code to define its fields:public int cadence;public int gear;public int speed;Field declarations are composed of three components, in order:	1.	Zero or more modifiers, such as public or private.	2.	The field&apos;s type.	3.	The field&apos;s name.The fields of Bicycle are named cadence, gear, and speed and are all of data type integer (int). The public keyword identifies these fields as public members, accessible by any object that can access the class.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InstanceFieldInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InstanceFieldInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InstanceOfExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InstanceOfExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Type Comparison Operator instanceofThe instanceof operator compares an object to a specified type. You can use it to test if an object is an instance of a class, an instance of a subclass, or an instance of a class that implements a particular interface.The following program, InstanceofDemo, defines a parent class (named Parent), a simple interface (named MyInterface), and a child class (named Child) that inherits from the parent and implements the interface. The type of a RelationalExpression operand of the instanceof operator must be a reference type or the null type; otherwise, a compile-time error occurs. The ReferenceType mentioned after the instanceof operator must denote a reference type; otherwise, a compile-time error occurs.At run time, the result of the instanceof operator is true if the value of the RelationalExpression is not null and the reference could be cast (15.16) to the ReferenceType without raising a ClassCastException. Otherwise the result is false.If a cast of the RelationalExpression to the ReferenceType would be rejected as a compile-time error, then the instanceof relational expression likewise produces a compile-time error. In such a situation, the result of the instanceof expression could never be true.Checks whether the object is an instance of a class
(More spesifically, whether the object/interface variable stores a reference to the object of this particular class or one one of its subclasses)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IntDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IntDataType</IRI>
        <Literal datatypeIRI="&xsd;string">int: The int data type is a 32-bit signed two&apos;s complement integer. It has a minimum value of -2,147,483,648 and a maximum value of 2,147,483,647 (inclusive). For integral values, this data type is generally the default choice unless there is a reason (like the above) to choose something else. This data type will most likely be large enough for the numbers your program will use, but if you need a wider range of values, use long instead. integer data type for numbers between -2,147,483,648 and 2,147,483,647 (reserved word &quot;int&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IntValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IntValue</IRI>
        <Literal datatypeIRI="&xsd;string">The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two&apos;s-complement integers, respectively, and char, whose values are 16-bit unsigned integers representing Unicode characters.The values of the integral types are integers in the following ranges:		For byte, from -128 to 127, inclusive		For short, from -32768 to 32767, inclusive		For int, from -2147483648 to 2147483647, inclusive		For long, from -9223372036854775808 to 9223372036854775807, inclusive		For char, from &apos;\u0000&apos; to &apos;\uffff&apos; inclusive, that is, from 0 to 65535</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Interface</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceBasedPolymorphism</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InterfaceBasedPolymorphism</IRI>
        <Literal datatypeIRI="&xsd;string">The compile time type of a variable is always declared, and the compile time type of an expression can be deduced at compile time. The compile time type limits the possible values that the variable can hold or the expression can produce at run time. If a run-time value is a reference that is not null, it refers to an object or array that has a class, and that class will necessarily be compatible with the compile-time type.Even though a variable or expression may have a compile-time type that is an interface type, there are no instances of interfaces. A variable or expression whose type is an interface type can reference any object whose class implements (8.1.4) that interface.An object varibale declared using an interface type will invoke differnt methods depending on the actual class of the object reffered by the variable ^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceBody</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceClassConversion</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InterfaceDataType</IRI>
        <Literal datatypeIRI="&xsd;string">Interface as a data type</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InterfaceDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">As you&apos;ve already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object&apos;s interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the &quot;power&quot; button to turn the television on and off.In its most common form, an interface is a group of related methods with empty bodies. A bicycle&apos;s behavior, if specified as an interface, might appear as follows:To implement this interface, the name of your class would change (to ACMEBicycle, for example), and you&apos;d use the implements keyword in the class declaration:    class ACMEBicycle implements Bicycle {       // remainder of this class implemented as before    }Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.   1. The interface should be regarded as a contract between a service provider and its clients.   4. In Java, the interface is a type.Follow this format to write an interface:1. Fields in an interface must be initialized and are implicitly public, static, and final.   2. You declare methods in an interface just as you would in a class.   3. Methods in an interface do not have a body.   4. All methods are implicitly public and abstractThere are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a &quot;contract&quot; that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group&apos;s code is written. Generally speaking, interfaces are such contracts.For example, imagine a futuristic society where computer-controlled robotic cars transport passengers through city streets without a human operator. Automobile manufacturers write software (Java, of course) that operates the automobilestop, start, accelerate, turn left, and so forth. Another industrial group, electronic guidance instrument manufacturers, make computer systems that receive GPS (Global Positioning System) position data and wireless transmission of traffic conditions and use that information to drive the car.The auto manufacturers must publish an industry-standard interface that spells out in detail what methods can be invoked to make the car move (any car, from any manufacturer). The guidance manufacturers can then write software that invokes the methods described in the interface to command the car. Neither industrial group needs to know how the other group&apos;s software is implemented. In fact, each group considers its software highly proprietary and reserves the right to modify it at any time, as long as it continues to adhere to the published interface.In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, and nested types. There are no method bodies. Interfaces cannot be instantiatedthey can only be implemented by classes or extended by other interfaces. Extension is discussed later in this lesson.Defining an interface is similar to creating a new class:Note that the method signatures have no braces and are terminated with a semicolon.An interface declaration consists of modifiers, the keyword interface, the interface name, a comma-separated list of parent interfaces (if any), and the interface body. For example:The public access specifier indicates that the interface can be used by any class in any package. If you do not specify that the interface is public, your interface will be accessible only to classes defined in the same package as the interface.An interface can extend other interfaces, just as a class can extend or subclass another class. However, whereas a class can extend only one other class, an interface can extend any number of interfaces. The interface declaration includes a comma-separated list of all the interfaces that it extends.The interface body contains method declarations for all the methods included in the interface. A method declaration within an interface is followed by a semicolon, but no braces, because an interface does not provide implementations for the methods declared within it. All methods declared in an interface are implicitly public, so the public modifier can be omitted.An interface can contain constant declarations in addition to method declarations. All constant values defined in an interface are implicitly public, static, and final. Once again, these modifiers can be omitted.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceImplementation</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#InterfaceImplementation</IRI>
        <Literal datatypeIRI="&xsd;string">As you&apos;ve already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object&apos;s interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the &quot;power&quot; button to turn the television on and off.In its most common form, an interface is a group of related methods with empty bodies. A bicycle&apos;s behavior, if specified as an interface, might appear as follows:To implement this interface, the name of your class would change (to ACMEBicycle, for example), and you&apos;d use the implements keyword in the class declaration:    class ACMEBicycle implements Bicycle {       // remainder of this class implemented as before    }Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.   1. An implementation class has to override all methods in the interface.   2. A class can implement multiple interfaces.To use an interface, you write a class that implements the interface. When an instantiable class implements an interface, it provides a method body for each of the methods declared in the interface. For example,To declare a class that implements an interface, you include an implements clause in the class declaration. Your class can implement more than one interface, so the implements keyword is followed by a comma-separated list of the interfaces implemented by the class.By convention, the implements clause follows the extends clause, if there is one.If you want to be able to compare the size of similar objects, no matter what they are, the class that instantiates them should implement Relatable.Any class can implement Relatable if there is some way to compare the relative &quot;size&quot; of objects instantiated from the class. For strings, it could be number of characters; for books, it could be number of pages; for students, it could be weight; and so forth. For planar geometric objects, area would be a good choice (see the RectanglePlus class that follows), while volume would work for three-dimensional geometric objects. All such classes can implement the isLargerThan() method.If you know that a class implements Relatable, then you know that you can compare the size of the objects instantiated from that class.Here is the Rectangle class that was presented in the Creating Objects section, rewritten to implement Relatable.Because RectanglePlus implements Relatable, the size of any two RectanglePlus objects can be compared</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#InterfaceSignature</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Interfacing</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Interfacing</IRI>
        <Literal datatypeIRI="&xsd;string">As you&apos;ve already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object&apos;s interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the &quot;power&quot; button to turn the television on and off.In its most common form, an interface is a group of related methods with empty bodies. A bicycle&apos;s behavior, if specified as an interface, might appear as follows:To implement this interface, the name of your class would change (to ACMEBicycle, for example), and you&apos;d use the implements keyword in the class declaration:    class ACMEBicycle implements Bicycle {       // remainder of this class implemented as before    }Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.   1. The interface should be regarded as a contract between a service provider and its clients.   4. In Java, the interface is a type.Follow this format to write an interface:1. Fields in an interface must be initialized and are implicitly public, static, and final.   2. You declare methods in an interface just as you would in a class.   3. Methods in an interface do not have a body.   4. All methods are implicitly public and abstractThere are a number of situations in software engineering when it is important for disparate groups of programmers to agree to a &quot;contract&quot; that spells out how their software interacts. Each group should be able to write their code without any knowledge of how the other group&apos;s code is written. Generally speaking, interfaces are such contracts.For example, imagine a futuristic society where computer-controlled robotic cars transport passengers through city streets without a human operator. Automobile manufacturers write software (Java, of course) that operates the automobilestop, start, accelerate, turn left, and so forth. Another industrial group, electronic guidance instrument manufacturers, make computer systems that receive GPS (Global Positioning System) position data and wireless transmission of traffic conditions and use that information to drive the car.The auto manufacturers must publish an industry-standard interface that spells out in detail what methods can be invoked to make the car move (any car, from any manufacturer). The guidance manufacturers can then write software that invokes the methods described in the interface to command the car. Neither industrial group needs to know how the other group&apos;s software is implemented. In fact, each group considers its software highly proprietary and reserves the right to modify it at any time, as long as it continues to adhere to the published interface.In the Java programming language, an interface is a reference type, similar to a class, that can contain only constants, method signatures, and nested types. There are no method bodies. Interfaces cannot be instantiatedthey can only be implemented by classes or extended by other interfaces. Extension is discussed later in this lesson.Defining an interface is similar to creating a new class:Note that the method signatures have no braces and are terminated with a semicolon.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#IterationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#IterationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Java itereation (loop) statements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Java</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Java</IRI>
        <Literal datatypeIRI="&xsd;string">Abstract superconcept of Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaDatabaseAccess</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaDatabaseAccess</IRI>
        <Literal datatypeIRI="&xsd;string">Java and Relational Databases</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaLanguage</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#parsable"/>
        <IRI>#JavaLanguage</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaLanguage</IRI>
        <Literal datatypeIRI="&xsd;string">Superconcept of Java Programming Language. It combines Java syntax, data processing, structure of java programs, etc</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaNetworking</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaNetworking</IRI>
        <Literal datatypeIRI="&xsd;string">Programming networking applications iin Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaOOP</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaOOP</IRI>
        <Literal datatypeIRI="&xsd;string">Object-oriented programming iin Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaPortability</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaPortability</IRI>
        <Literal datatypeIRI="&xsd;string">Portability issues of Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaSequirity</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaSequirity</IRI>
        <Literal datatypeIRI="&xsd;string">Sequirity issues in Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibrary</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaStandardLibrary</IRI>
        <Literal datatypeIRI="&xsd;string">Java Standard Edition API Specification, Java SDK</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibraryClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibraryInterface</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibraryMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibraryObject</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaStandardLibraryPackage</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaStandardLibraryPackage</IRI>
        <Literal datatypeIRI="&xsd;string">A package is a namespace that organizes a set of related classes and interfaces. Conceptually you can think of packages as being similar to different folders on your computer. You might keep HTML pages in one folder, images in another, and scripts or applications in yet another. Because software written in the Java programming language can be composed of hundreds or thousands of individual classes, it makes sense to keep things organized by placing related classes and interfaces into packages.The Java platform provides an enormous class library (a set of packages) suitable for use in your own applications. This library is known as the &quot;Application Programming Interface&quot;, or &quot;API&quot; for short. Its packages represent the tasks most commonly associated with general-purpose programming. For example, a String object contains state and behavior for character strings; a File object allows a programmer to easily create, delete, inspect, compare, or modify a file on the filesystem; a Socket object allows for the creation and use of network sockets; various GUI objects control buttons and checkboxes and anything else related to graphical user interfaces. There are literally thousands of classes to choose from. This allows you, the programmer, to focus on the design of your particular application, rather than the infrastructure required to make it work. </Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaTechnology</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaTechnology</IRI>
        <Literal datatypeIRI="&xsd;string">Spesific aspects of Java tehcnology</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JavaXMLProcessing</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JavaXMLProcessing</IRI>
        <Literal datatypeIRI="&xsd;string">XML parsing, genenration and processing in Java</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#JumpStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#JumpStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Java jump statements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#LessEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#LessEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The relational operators are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, a&lt;b&lt;c parses as (a&lt;b)&lt;c, which is always a compile-time error, because the type of a&lt;b is always boolean and &lt; is not an operator on boolean values.The type of a relational expression is always boolean.Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=		The value produced by the &lt; operator is true if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is false.		The value produced by the &lt;= operator is true if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is false.		The value produced by the &gt; operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.		The value produced by the &gt;= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.Less than or equal to &apos;&lt;=&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#LessExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#LessExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The relational operators are syntactically left-associative (they group left-to-right), but this fact is not useful; for example, a&lt;b&lt;c parses as (a&lt;b)&lt;c, which is always a compile-time error, because the type of a&lt;b is always boolean and &lt; is not an operator on boolean values.The type of a relational expression is always boolean.Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=		The value produced by the &lt; operator is true if the value of the left-hand operand is less than the value of the right-hand operand, and otherwise is false.		The value produced by the &lt;= operator is true if the value of the left-hand operand is less than or equal to the value of the right-hand operand, and otherwise is false.		The value produced by the &gt; operator is true if the value of the left-hand operand is greater than the value of the right-hand operand, and otherwise is false.		The value produced by the &gt;= operator is true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand, and otherwise is false.Less than &apos;&lt;&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#LogicalExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#LogicalExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Logical operators. The result of logical expressions have type boolean</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#LongDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#LongDataType</IRI>
        <Literal datatypeIRI="&xsd;string">long: The long data type is a 64-bit signed two&apos;s complement integer. It has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807 (inclusive). Use this data type when you need a range of values wider than those provided by int. integer data type for numbers between -9,223.372,036,854,808 and 9,223.372,036,854,807 (reserved word &quot;long&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#LongValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#LongValue</IRI>
        <Literal datatypeIRI="&xsd;string">The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit and 64-bit signed two&apos;s-complement integers, respectively, and char, whose values are 16-bit unsigned integers representing Unicode characters.The values of the integral types are integers in the following ranges:		For byte, from -128 to 127, inclusive		For short, from -32768 to 32767, inclusive		For int, from -2147483648 to 2147483647, inclusive		For long, from -9223372036854775808 to 9223372036854775807, inclusive		For char, from &apos;\u0000&apos; to &apos;\uffff&apos; inclusive, that is, from 0 to 65535</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MainMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MainMethodDefintion</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MainMethodDefintion</IRI>
        <Literal datatypeIRI="&xsd;string">   1. A special method called main provides the entry point to an application.   2. An application can have many classes and only one of the classes needs to have the method main.   3. This method allows the class containing it to be invoked.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Method</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodBody</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">   1. ethods define actions that a class&apos;s objects (or instances) can do.   2. A method has a declaration part and a body.   3. The declaration part consists of a return value, the method name, and a list of arguments.   4. The body contains code that perform the action.   5. The return type of a method can be a primitive, an object, or void.   6. The return type void means that the method returns nothing.   7. The declaration part of a method is also called the signature of the method.For example, here is the getSalary method that returns a double.Here is an example of a typical method declaration:public double calculateAnswer(double wingSpan, int numberOfEngines, double length, double grossTons) {	//do the calculation here}The only required elements of a method declaration are the method&apos;s return type, name, a pair of parentheses, (), and a body between braces, {}.More generally, method declarations have six components, in order:	1.	Modifierssuch as public, private, and others you will learn about later.	2.	The return typethe data type of the value returned by the method, or void if the method does not return a value.	3.	The method namethe rules for field names apply to method names as well, but the convention is a little different.	4.	The parameter list in parenthesisa comma-delimited list of input parameters, preceded by their data types, enclosed by parentheses, (). If there are no parameters, you must use empty parentheses.	5.	An exception listto be discussed later.	6.	The method body, enclosed between bracesthe method&apos;s code, including the declaration of local variables, goes here.Modifiers, return types, and parameters will be discussed later in this lesson. Exceptions are discussed in a later lesson.Definition:Two of the components of a method declaration comprise the method signaturethe method&apos;s name and the parameter types.The signature of the method declared above is:calculateAnswer(double, int, double, double)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodImplementation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodInheritance</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodInheritance</IRI>
        <Literal datatypeIRI="&xsd;string">In the Java language, classes can be derived from other classes, thereby inheriting fields and methods from those classes.A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.MountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for the constructor, it is as if you had written a new MountainBike class entirely from scratch, with four fields and five methods. However, you didn&apos;t have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex and had taken substantial time to debug.A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:The inherited fields can be used directly, just like any other fields.The inherited methods can be used directly as they are.Subclass inherits all methods of the superclass. ^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodInvocationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodInvocationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">You also use an object reference to invoke an object&apos;s method. You append the method&apos;s simple name to the object reference, with an intervening dot operator (.). Also, you provide, within enclosing parentheses, any arguments to the method. If the method does not require any arguments, use empty parentheses.The Rectangle class has two methods: getArea() to compute the rectangle&apos;s area and move() to change the rectangle&apos;s origin. Here&apos;s the CreateObjectDemo code that invokes these two methods:The first statement invokes rectOne&apos;s getArea() method and displays the results. The second line moves rectTwo because the move() method assigns new values to the object&apos;s origin.x and origin.y.As with instance fields, objectReference must be a reference to an object. You can use a variable name, but you also can use any expression that returns an object reference. The new operator returns an object reference, so you can use the value returned from new to invoke a new object&apos;s methods:The expression new Rectangle(100, 50) returns an object reference that refers to a Rectangle object. As shown, you can use the dot notation to invoke the new Rectangle&apos;s getArea() method to compute the area of the new rectangle.Some methods, such as getArea(), return a value. For methods that return a value, you can use the method invocation in expressions. You can assign the return value to a variable, use it to make decisions, or control a loop. This code assigns the value returned by getArea() to the variable areaOfRectangle:Remember, invoking a method on a particular object is the same as sending a message to that object. In this case, the object that getArea() is invoked on is the rectangle returned by the constructor.You also use an object reference to invoke an object&apos;s method. You append the method&apos;s simple name to the object reference, with an intervening dot operator (.). Also, you provide, within enclosing parentheses, any arguments to the method. If the method does not require any arguments, use empty parentheses.The Rectangle class has two methods: getArea() to compute the rectangle&apos;s area and move() to change the rectangle&apos;s origin. Here&apos;s the CreateObjectDemo code that invokes these two methods:The first statement invokes rectOne&apos;s getArea() method and displays the results. The second line moves rectTwo because the move() method assigns new values to the object&apos;s origin.x and origin.y.As with instance fields, objectReference must be a reference to an object. You can use a variable name, but you also can use any expression that returns an object reference. The new operator returns an object reference, so you can use the value returned from new to invoke a new object&apos;s methods:The expression new Rectangle(100, 50) returns an object reference that refers to a Rectangle object. As shown, you can use the dot notation to invoke the new Rectangle&apos;s getArea() method to compute the area of the new rectangle.Some methods, such as getArea(), return a value. For methods that return a value, you can use the method invocation in expressions. You can assign the return value to a variable, use it to make decisions, or control a loop. This code assigns the value returned by getArea() to the variable areaOfRectangle:Remember, invoking a method on a particular object is the same as sending a message to that object. In this case, the object that getArea() is invoked on is the rectangle returned by the constructor.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodName</IRI>
        <Literal datatypeIRI="&xsd;string">Although a method name can be any legal identifier, code conventions restrict method names. By convention, method names should be a verb in lowercase or a multi-word name that begins with a verb in lowercase, followed by adjectives, nouns, etc. In multi-word names, the first letter of each of the second and following words should be capitalized. Here are some examples:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodOverloading</IRI>
        <Literal datatypeIRI="&xsd;string">Java allows you to have multiple methods having the same name, as long as each method accept different sets of argument types. In other words, in our example, it is legal to have these two methods in the same class.This technique is called method overloading. The return value of the method is not taken into consideration. As such, these two methods must not exist in the same class:A method&apos;s name with the types and sequence of the parameters form the method&apos;s signatureTypically, a method has a unique name within its class. However, a method might have the same name as other methods due to method overloading.The Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in the lesson titled &quot;Interfaces and Inheritance&quot;).Suppose that you have a class that can use calligraphy to draw various types of data (strings, integers, and so on) and that contains a method for drawing each data type. It is cumbersome to use a new name for each methodfor example, drawString, drawInteger, drawFloat, and so on. In the Java programming language, you can use the same name for all the drawing methods but pass a different argument list to each method. Thus, the data drawing class might declare four methods named draw, each of which has a different parameter list.Overloaded methods are differentiated by the number and the type of the arguments passed into the method. In the code sample, draw(String s) and draw(int i) are distinct and unique methods because they require different argument types.You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.The compiler does not consider return type when differentiating methods, so you cannot declare two methods with the same signature even if they have a different return type.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodOverriding</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MethodOverriding</IRI>
        <Literal datatypeIRI="&xsd;string">   1. When you extends a class, you can change the behavior of a method in the parent class.   2. This is called method overriding.   3. This happens when you write in a subclass a method that has the same signature as a method in the parent class.   4. If only the name is the same but the list of arguments is not, then it is method overloading.An instance method in a subclass with the same signature (name, plus the number and the type of its parameters) and return type as an instance method in the superclass overrides the superclass&apos;s method.The ability of a subclass to override a method allows a class to inherit from a superclass whose behavior is &quot;close enough&quot; and then to modify behavior as needed. The overriding method has the same name, number and type of parameters, and return type as the method it overrides. An overriding method can also return a subtype of the type returned by the overridden method. This is called a covariant return type.When overriding a method, you might want to use the @Override annotation that instructs the compiler that you intend to override a method in the superclass. If, for some reason, the compiler detects that the method does not exist in one of the superclasses, it will generate an error.Subclass can override methods of the superclass if these methods should behave differently for the objects fot eh subclass.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MethodSignature</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Modifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ModulusAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ModulusAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">All compound assignment operators require both operands to be of primitive type, except for +=, which allows the right-hand operand to be of any type if the left-hand operand is of type String.At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:		First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.		Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see 15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion (5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.Find the reminder of the division of the value of the varibale to the left by the value of the expression to the right and assigns the result to the variable to the left &apos;=%&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ModulusExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ModulusExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There&apos;s a good chance you&apos;ll recognize them by their counterparts in basic mathematics. The only symbol that might look new to you is &quot;%&quot;, which divides one operand by another and returns the remainder as its result.    %	remainder operatorThe binary % operator is said to yield the remainder of its operands from an implied division; the left-hand operand is the dividend and the right-hand operand is the divisor.In Java programming language, it also accepts floating-point operands.The remainder operation for operands that are integers after binary numeric promotion (5.6.2) produces a result value such that (a/b)*b+(a%b) is equal to a. This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor. If the value of the divisor for an integer remainder operator is 0, then an ArithmeticException is thrown.The result of a floating-point remainder operation as computed by the % operator is not the same as that produced by the remainder operation defined by IEEE 754. The IEEE 754 remainder operation computes the remainder from a rounding division, not a truncating division, and so its behavior is not analogous to that of the usual integer remainder operator. Instead, the Java programming language defines % on floating-point operations to behave in a manner analogous to that of the integer remainder operator; this may be compared with the C library function fmod.Division reminder operator &apos;%&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MultiplicativeExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MultiplicativeExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Multiplicative operators &apos;*&apos; &apos;/&apos; &apos;%&apos;</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MultiplyAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MultiplyAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">All compound assignment operators require both operands to be of primitive type, except for +=, which allows the right-hand operand to be of any type if the left-hand operand is of type String.At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:		First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.		Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see 15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion (5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.Multiply the value of the varibale to the left by the value of the expression to the right and assigns the result to the variable to the left &apos;=*&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#MultiplyExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#MultiplyExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There&apos;s a good chance you&apos;ll recognize them by their counterparts in basic mathematics.   *	multiplication operatorThe binary * operator performs multiplication, producing the product of its operands. Multiplication is a commutative operation if the operand expressions have no side effects. While integer multiplication is associative when the operands are all of the same type, floating-point multiplication is not associative.If an integer multiplication overflows, then the result is the low-order bits of the mathematical product as represented in some sufficiently large two&apos;s-complement format. As a result, if overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two operand values.Multiplication Operator &apos;-&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#NestedStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#NestedStatement</IRI>
        <Literal datatypeIRI="&xsd;string">nested statement (statement inside another statement)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#NotEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#NotEqualExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The equality operators are syntactically left-associative (they group left-to-right), but this fact is essentially never useful; for example, a==b==c parses as (a==b)==c. The result type of a==b is always boolean, and c must therefore be of type boolean or a compile-time error occurs. Thus, a==b==c does not test to see whether a, b, and c are all equal.The == (equal to) and the != (not equal to) operators are analogous to the relational operators except for their lower precedence. Thus, a&lt;b==c&lt;d is true whenever a&lt;b and c&lt;d have the same truth value.The equality operators may be used to compare two operands of numeric type, or two operands of type boolean, or two operands that are each of either reference type or the null type. All other cases result in a compile-time error. The type of an equality expression is always boolean.In all cases, a!=b produces the same result as !(a==b). The equality operators are commutative if the operand expressions have no side effects.Logical inequality (not-equal-to operator) &apos;!=&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#NotExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#NotExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The type of the operand expression of the unary ! operator must be boolean, or a compile-time error occurs. The type of the unary logical complement expression is boolean.At run time, the value of the unary logical complement expression is true if the operand value is false and false if the operand value is true.Boolean (Logical) NOT &apos;!&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OOPPrinciple</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Object</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Object</IRI>
        <Literal datatypeIRI="&xsd;string">Objects are key to understanding object-oriented technology. Look around right now and you&apos;ll find many examples of real-world objects: your dog, your desk, your television set, your bicycle.Real-world objects share two characteristics: They all have state and behavior. Dogs have state (name, color, breed, hungry) and behavior (barking, fetching, wagging tail). Bicycles also have state (current gear, current pedal cadence, current speed) and behavior (changing gear, changing pedal cadence, applying brakes). Identifying the state and behavior for real-world objects is a great way to begin thinking in terms of object-oriented programming.Take a minute right now to observe the real-world objects that are in your immediate area. For each object that you see, ask yourself two questions: &quot;What possible states can this object be in?&quot; and &quot;What possible behavior can this object perform?&quot;. Make sure to write down your observations. As you do, you&apos;ll notice that real-world objects vary in complexity; your desktop lamp may have only two possible states (on and off) and two possible behaviors (turn on, turn off), but your desktop radio might have additional states (on, off, current volume, current station) and behavior (turn on, turn off, increase volume, decrease volume, seek, scan, and tune). You may also notice that some objects, in turn, will also contain other objects. These real-world observations all translate into the world of object-oriented programming.A circle with an inner circle filled with items, surrounded by gray wedges representing methods that allow access to the inner circle.A software object.Software objects are conceptually similar to real-world objects: they too consist of state and related behavior. An object stores its state in fields (variables in some programming languages) and exposes its behavior through methods (functions in some programming languages). Methods operate on an object&apos;s internal state and serve as the primary mechanism for object-to-object communication. Hiding internal state and requiring all interaction to be performed through an object&apos;s methods is known as data encapsulation  a fundamental principle of object-oriented programming.Consider a bicycle, for example:A picture of an object, with bibycle methods and instance variables.A bicycle modeled as a software object.By attributing state (current speed, current pedal cadence, and current gear) and providing methods for changing that state, the object remains in control of how the outside world is allowed to use it. For example, if the bicycle only has 6 gears, a method to change gears could reject any value that is less than 1 or greater than 6.Bundling code into individual software objects provides a number of benefits, including:   1. Modularity: The source code for an object can be written and maintained independently of the source code for other objects. Once created, an object can be easily passed around inside the system.   2. Information-hiding: By interacting only with an object&apos;s methods, the details of its internal implementation remain hidden from the outside world.   3. Code re-use: If an object already exists (perhaps written by another software developer), you can use that object in your program. This allows specialists to implement/test/debug complex, task-specific objects, which you can then trust to run in your own code.   4. Pluggability and debugging ease: If a particular object turns out to be problematic, you can simply remove it from your application and plug in a different object as its replacement. This is analogous to fixing mechanical problems in the real world. If a bolt breaks, you replace it, not the entire machine. As you know, a class provides the blueprint for objects; you create an object from a class. Each of the following statements taken from the CreateObjectDemo program creates an object and assigns it to a variable:The first line creates an object of the Point class, and the second and third lines each create an object of the Rectangle class.Each of these statements has three parts (discussed in detail below):	1.	Declaration: The code set in bold are all variable declarations that associate a variable name with an object type.	2.	Instantiation: The new keyword is a Java operator that creates the object.	3.	Initialization: The new operator is followed by a call to a constructor, which initializes the new object.An object is a software bundle of related state and behavior. Software objects are often used to model the real-world objects that you find in everyday life.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ObjectCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ObjectCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Using the new keyword.   2. new is always followed by the constructor of the class.For example, to create an Employee object, you write:Here, &apos;employee&apos; is an object reference of type Employee.   1. Once you have an object, you can call its methods and access its fields, by using the object reference.   2. You use a period (.) to call a method or a field.The following code, for instance, creates an Employee object and assigns values to its age and salary fields:When an object is created, the JVM also performs initialization that assign default values to fields.As you know, a class provides the blueprint for objects; you create an object from a class. Each of the following statements taken from the CreateObjectDemo program creates an object and assigns it to a variable:The first line creates an object of the Point class, and the second and third lines each create an object of the Rectangle class.Each of these statements has three parts (discussed in detail below):	1.	Declaration: The code set in bold are all variable declarations that associate a variable name with an object type.	2.	Instantiation: The new keyword is a Java operator that creates the object.	3.	Initialization: The new operator is followed by a call to a constructor, which initializes the new object.		The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the object constructor.Note:The phrase &quot;instantiating a class&quot; means the same thing as &quot;creating an object.&quot; When you create an object, you are creating an &quot;instance&quot; of a class, therefore &quot;instantiating&quot; a class.The new operator requires a single, postfix argument: a call to a constructor. The name of the constructor provides the name of the class to instantiate.The new operator returns a reference to the object it created. This reference is usually assigned to a variable of the appropriate type, like:The reference returned by the new operator does not have to be assigned to a variable. It can also be used directly in an expression. For example:This statement will be discussed in the next section.This class contains a single constructor. You can recognize a constructor because its declaration uses the same name as the class and it has no return type. The constructor in the Point class takes two integer arguments, as declared by the code (int a, int b). The following statement provides 23 and 94 as values for those arguments:A class instance creation expression is used to create new objects that are instances of classes.Class instance creation expressions have two forms:Both unqualified and qualified class instance creation expressions may optionally end with a class body. Such a class instance creation expression declares an anonymous class (15.9.5) and creates an instance of it.We say that a class is instantiated when an instance of the class is created by a class instance creation expression. Class instantiation involves determining what class is to be instantiated, what the enclosing instances (if any) of the newly created instance are, what constructor should be invoked to create the new instance and what arguments should be passed to that constructor.If the class instance creation expression ends in a class body, then the class being instantiated is an anonymous class.The type of the class instance creation expression is the class type being instantiated.At run time, evaluation of a class instance creation expression is as follows.First, if the class instance creation expression is a qualified class instance creation expression, the qualifying primary expression is evaluated. If the qualifying expression evaluates to null, a NullPointerException is raised, and the class instance creation expression completes abruptly. If the qualifying expression completes abruptly, the class instance creation expression completes abruptly for the same reason.Next, space is allocated for the new class instance. If there is insufficient space to allocate the object, evaluation of the class instance creation expression completes abruptly by throwing an OutOfMemoryError (15.9.6).The new object contains new instances of all the fields declared in the specified class type and all its superclasses. As each new field instance is created, it is initialized to its default value (4.5.5).Next, the actual arguments to the constructor are evaluated, left-to-right. If any of the argument evaluations completes abruptly, any argument expressions to its right are not evaluated, and the class instance creation expression completes abruptly for the same reason.Next, the selected constructor of the specified class type is invoked. This results in invoking at least one constructor for each superclass of the class type. This process can be directed by explicit constructor invocation statements (8.8) and is described in detail in 12.5.The value of a class instance creation expression is a reference to the newly created object of the specified class. Every time the expression is evaluated, a fresh object is created.Object creation consists of object creation and a semicolon^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ObjectEquality</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ObjectEquality</IRI>
        <Literal datatypeIRI="&xsd;string">If the operands of an equality operator are both of either reference type or the null type, then the operation is object equality.A compile-time error occurs if it is impossible to convert the type of either operand to the type of the other by a casting conversion (5.5). The run-time values of the two operands would necessarily be unequal.At run time, the result of == is true if the operand values are both null or both refer to the same object or array; otherwise, the result is false.The result of != is false if the operand values are both null or both refer to the same object or array; otherwise, the result is true.While == may be used to compare references of type String, such an equality test determines whether or not the two operands refer to the same String object. The result is false if the operands are distinct String objects, even if they contain the same sequence of characters. The contents of two strings s and t can be tested for equality by the method invocation s.equals(t)The equals() method compares two objects for equality and returns true if they are equal. The equals() method provided in the Object class uses the identity operator (==) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The equals() method provided by Object tests whether the object references are equalthat is, if the objects compared are the exact same object.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ObjectMethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ObjectMethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;string">To call a method for a certain object you need to spesify the object and a the method separated by &quot;.&quot; This operation calls to invoke a method. The method will operate on the data stored in object&apos;s fields and the parameters passed to the method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ObjectReference</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ObjectReference</IRI>
        <Literal datatypeIRI="&xsd;string">An object is a class instance or an array.The reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.A new class instance is implicitly created when the string concatenation operator + (15.18.1) is used in an expression, resulting in a new object of type String (4.3.3). A new array object is implicitly created when an array initializer expression (10.6) is evaluated; this can occur when a class or interface is initialized (12.4), when a new instance of a class is created (15.9), or when a local variable declaration statement is executed (14.4).There may be many references to the same object. Most objects have state, stored in the fields of objects that are instances of classes or in the variables that are the components of an array object. If two variables contain references to the same object, the state of the object can be modified using one variable&apos;s reference to the object, and then the altered state can be observed through the reference in the other variable.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ObjectVariable</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ObjectVariable</IRI>
        <Literal datatypeIRI="&xsd;string">Variables are data placeholders. There are two data types in Java:   1. Reference types provides a reference to an object.Object varaibale storing a reference to the object representation in memory^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Operator</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Operator</IRI>
        <Literal datatypeIRI="&xsd;string">Every expression in Java must have at least one operator</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OperatorAssociativity</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OperatorAssociativity</IRI>
        <Literal datatypeIRI="&xsd;string">Associativity of operators (left to right or right to left)</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OperatorPrecedence</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OperatorPrecedence</IRI>
        <Literal datatypeIRI="&xsd;string">As we explore the operators of the Java programming language, it may be helpful for you to know ahead of time which operators have the highest precedence. The operators in the following table are listed according to precedence order. The closer to the top of the table an operator appears, the higher its precedence. Operators with higher precedence are evaluated before operators with relatively lower precedence. Operators on the same line have equal precedence. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first. All binary operators except for the assignment operators are evaluated from left to right; assignment operators are evaluated right to left. If you don&apos;t explicitly indicate the order for the operations to be performed, the order is determined by the precedence assigned to the operators in use within the expression. Operators that have a higher precedence get evaluated firstPrecedence of operators^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OrExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OrExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The || operator is like | (15.22.2), but evaluates its right-hand operand only if the value of its left-hand operand is false. It is syntactically left-associative (it groups left-to-right). It is fully associative with respect to both side effects and result value; that is, for any expressions a, b, and c, evaluation of the expression ((a)||(b))||(c) produces the same result, with the same side effects occurring in the same order, as evaluation of the expression (a)||((b)||(c)).Each operand of || must be of type boolean, or a compile-time error occurs. The type of a conditional-or expression is always boolean.At run time, the left-hand operand expression is evaluated first; if its value is true, the value of the conditional-or expression is true and the right-hand operand expression is not evaluated. If the value of the left-hand operand is false, then the right-hand expression is evaluated and its value becomes the value of the conditional-or expression.Thus, || computes the same result as | on boolean operands. It differs only in that the right-hand operand expression is evaluated conditionally rather than always.Boolean (Logical) OR &apos;||&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OverridingClone</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OverridingClone</IRI>
        <Literal datatypeIRI="&xsd;string">If a class, or one of its superclasses, implements the Cloneable interface, you can use the clone() method to create a copy from an existing object. To create a clone, you write:aCloneableObject.clone();Object&apos;s implementation of this method checks to see whether the object on which clone() was invoked implements the Cloneable interface. If the object does not, the method throws a CloneNotSupportedException exception. Exception handling will be covered in a later lesson. For the moment, you need to know that clone() must be declared asprotected Object clone() throws CloneNotSupportedException    -- or --public Object clone() throws CloneNotSupportedExceptionif you are going to write a clone() method to override the one in Object.If the object on which clone() was invoked does implement the Cloneable interface, Object&apos;s implementation of the clone() method creates an object of the same class as the original object and initializes the new object&apos;s member variables to have the same values as the original object&apos;s corresponding member variables.The simplest way to make your class cloneable is to add implements Cloneable to your class&apos;s declaration. then your objects can invoke the clone() method.For some classes, the default behavior of Object&apos;s clone() method works just fine. If, however, an object contains a reference to an external object, say ObjExternal, you may need to override clone() to get correct behavior. Otherwise, a change in ObjExternal made by one object will be visible in its clone also. This means that the original object and its clone are not independentto decouple them, you must override clone() so that it clones the object and ObjExternal. Then the original object references ObjExternal and the clone references a clone of ObjExternal, so that the object and its clone are truly independent.clone() is one of the four basic methods of the Object class that should be overriden by any good-style class to avoid incorect clonning by inherited Object.clone()^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OverridingEquals</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OverridingEquals</IRI>
        <Literal datatypeIRI="&xsd;string">The equals() method compares two objects for equality and returns true if they are equal. The equals() method provided in the Object class uses the identity operator (==) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The equals() method provided by Object tests whether the object references are equalthat is, if the objects compared are the exact same object.To test whether two objects are equal in the sense of equivalency (containing the same information), you must override the equals() method. Here is an example of a Book class that overrides equals():Consider this code that tests two instances of the Book class for equality:This program displays objects are equal even though firstBook and secondBook reference two distinct objects. They are considered equal because the objects compared contain the same ISBN number.You should always override the equals() method if the identity operator is not appropriate for your class.Note:If you override equals(), you must override hashCode() as well.equals() is one of the four basic methods of the Object class that should be overriden by any good-style class to avoid incorect objecte comparison by inherited Object.equals()^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OverridingHashCode</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OverridingHashCode</IRI>
        <Literal datatypeIRI="&xsd;string">The value returned by hashCode() is the object&apos;s hash code, which is the object&apos;s memory address in hexadecimal.By definition, if two objects are equal, their hash code must also be equal. If you override the equals() method, you change the way two objects are equated and Object&apos;s implementation of hashCode() is no longer valid. Therefore, if you override the equals() method, you must also override the hashCode() method as well.hashCode() is one of the four basic methods of the Object class that should be overriden by any good-style class to avoid incorect hash code computation by inherited Object.hashCode()^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#OverridingToString</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#OverridingToString</IRI>
        <Literal datatypeIRI="&xsd;string">You should always consider overriding the toString() method in your classes.The Object&apos;s toString() method returns a String representation of the object, which is very useful for debugging. The String representation for an object depends entirely on the object, which is why you need to override toString() in your classes.You can use toString() along with System.out.println() to display a text representation of an object, such as an instance of Book:System.out.println(firstBook.toString());which would, for a properly overridden toString() method, print something useful, like this:toString() is one of the four basic methods of the Object class that should be overriden by any good-style class to avoid incorect printing of objects by inherited Object.toString()^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Package</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Package</IRI>
        <Literal datatypeIRI="&xsd;string">A package is a namespace that organizes a set of related classes and interfaces. Conceptually you can think of packages as being similar to different folders on your computer. You might keep HTML pages in one folder, images in another, and scripts or applications in yet another. Because software written in the Java programming language can be composed of hundreds or thousands of individual classes, it makes sense to keep things organized by placing related classes and interfaces into packages.The Java platform provides an enormous class library (a set of packages) suitable for use in your own applications. This library is known as the &quot;Application Programming Interface&quot;, or &quot;API&quot; for short. Its packages represent the tasks most commonly associated with general-purpose programming. For example, a String object contains state and behavior for character strings; a File object allows a programmer to easily create, delete, inspect, compare, or modify a file on the filesystem; a Socket object allows for the creation and use of network sockets; various GUI objects control buttons and checkboxes and anything else related to graphical user interfaces. There are literally thousands of classes to choose from. This allows you, the programmer, to focus on the design of your particular application, rather than the infrastructure required to make it work. Java provides the keyword import to indicate that you want to use a package or a class from a package. For example, to use the java.io.File class, you must have the following import statement:   1. &apos;import&apos; statements must come after the package statement but before the class declaration.   2. The import keyword can appear multiple times in a class.   You can import all classes in the same package by using the wild character *. For example, the following code imports all members of the java.io package.   However, to make your code more readable, it is recommended that you import a package member one at a time.   Members of the java.lang package are imported automatically. Thus, to use the java.lang.String, for example, you do not need to explicitly import the class.The only way to use classes that belong to other packages without importing them is to use the fully qualified names of the classes in your code. For example, the following code declares the java.io.File class using its fully qualified name.If you class import identically-named classes from different packages, you must use the fully qualified names when declaring the classes. For example, the Java core libraries contain the classes java.sql.Date and java.util.Date. In this case, you must write the fully qualified names of java.sql.Date and java.util.Date to use them.To make types easier to find and use, to avoid naming conflicts, and to control access, programmers bundle groups of related types into packages.A package is a grouping of related types providing access protection and name space management. Note that types refers to classes, interfaces, enumerations, and annotation types. Enumerations and annotation types are special kinds of classes and interfaces, respectively, so types are often referred to in this lesson simply as classes and interfaces.The types that are part of the Java platform are members of various packages that bundle classes by function: fundamental classes are in java.lang, classes for reading and writing (input and output) are in java.io, and so on. You can put your types in packages too.You should bundle these classes and the interface in a package for several reasons, including the following:		You and other programmers can easily determine that these types are related.		You and other programmers know where to find types that can provide graphics-related functions.		The names of your types won&apos;t conflict with the type names in other packages because the package creates a new namespace.		You can allow types within the package to have unrestricted access to one another yet still restrict access for types outside the package.	To create a package, you choose a name for the package (naming conventions are discussed in the next section) and put a package statement with that name at the top of every source file that contains the types (classes, interfaces, enumerations, and annotation types) that you want to include in the package.	If you do not use a package statement, your type ends up in an unnamed package. Generally speaking, an unnamed package is only for small or temporary applications or when you are just beginning the development process. Otherwise, classes and interfaces belong in named packages.	Package names are written in all lowercase to avoid conflict with the names of classes or interfaces.Companies use their reversed Internet domain name to begin their package namesfor example, com.example.orion for a package named orion created by a programmer at example.com.Name collisions that occur within a single company need to be handled by convention within that company, perhaps by including the region or the project name after the company name (for example, com.company.region.package).Packages in the Java language itself begin with java. or javax.In some cases, the internet domain name may not be a valid package name. This can occur if the domain name contains a hyphen or other special character, if the package name begins with a digit or other character that is illegal to use as the beginning of a Java name, or if the package name contains a reserved Java keyword, such as &quot;int&quot;. In this event, the suggested convention is to add an underscore. For example:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PackageSpecificationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PackageSpecificationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">A package declaration appears within a compilation unit to indicate the package to which the compilation unit belongs.A package declaration in a compilation unit specifies the name (6.2) of the package to which the compilation unit belongs.		PackageDeclaration:			package PackageName ;		The package name mentioned in a package declaration must be the fully qualified name (6.7) of the package.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Parenthesis</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Parenthesis</IRI>
        <Literal datatypeIRI="&xsd;string">Java programming language implementations must respect the order of evaluation as indicated explicitly by parentheses and implicitly by operator precedence. An implementation may not take advantage of algebraic identities such as the associative law to rewrite expressions into a more convenient computational order unless it can be proven that the replacement expression is equivalent in value and in its observable side effects, even in the presence of multiple threads of execution (using the thread execution model in 17), for all possible computational values that might be involved.Parenthesis &apos;(&apos;  &apos;)&apos; to change the default presedence of operators^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PolymorphicObjectCreationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Polymorphism</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Polymorphism</IRI>
        <Literal datatypeIRI="&xsd;string">Polymorphism assumes different behavior of an invoked method depending on the actual type of an object, which is determined at a run time </Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PostDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PostDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;string">A postfix expression followed by a -- operator is a postfix decrement expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix decrement expression is the type of the variable. The result of the postfix decrement expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then the postfix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion (5.6.2) is performed on the value 1 and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion (5.1.3) to the type of the variable before it is stored. The value of the postfix decrement expression is the value of the variable before the new value is stored.Post-decrement &apos;--&apos; decreases the value of the operand by one after the entire expression has been evaluated^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PostIncrementExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PostIncrementExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The unary operators require only one operand; they perform various operations such as incrementing    ++  	Increment operator; increments a value by 1The increment/decrement operators can be applied before (prefix) or after (postfix) the operand. The code result++; and ++result; will both end in result being incremented by one. The only difference is that the prefix version (++result) evaluates to the incremented value, whereas the postfix version (result++) evaluates to the original value. If you are just performing a simple increment/decrement, it doesn&apos;t really matter which version you choose. But if you use this operator in part of a larger expression, the one that you choose may make a significant difference. A postfix expression followed by a ++ operator is a postfix increment expression. The result of the postfix expression must be a variable of a numeric type, or a compile-time error occurs. The type of the postfix increment expression is the type of the variable. The result of the postfix increment expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then the postfix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion (5.6.2) is performed on the value 1 and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion (5.1.3) to the type of the variable before it is stored. The value of the postfix increment expression is the value of the variable before the new value is stored.Post-increment &apos;++&apos; increases the value of the operand by one after the entire expression has been evaluated^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PreDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PreDecrementExpression</IRI>
        <Literal datatypeIRI="&xsd;string">A unary expression preceded by a -- operator is a prefix decrement expression. The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix decrement expression is the type of the variable. The result of the prefix decrement expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then the prefix decrement expression completes abruptly for the same reason and no decrementation occurs. Otherwise, the value 1 is subtracted from the value of the variable and the difference is stored back into the variable. Before the subtraction, binary numeric promotion (5.6.2) is performed on the value 1 and the value of the variable. If necessary, the difference is narrowed by a narrowing primitive conversion (5.1.3) to the type of the variable before it is stored. The value of the prefix decrement expression is the value of the variable after the new value is stored.Pre-decrement &apos;--&apos; decreases the value of the operand by one before the rest of the expression has been evaluated^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PreIncrementExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PreIncrementExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The unary operators require only one operand; they perform various operations such as incrementing    ++  	Increment operator; increments a value by 1The increment/decrement operators can be applied before (prefix) or after (postfix) the operand. The code result++; and ++result; will both end in result being incremented by one. The only difference is that the prefix version (++result) evaluates to the incremented value, whereas the postfix version (result++) evaluates to the original value. If you are just performing a simple increment/decrement, it doesn&apos;t really matter which version you choose. But if you use this operator in part of a larger expression, the one that you choose may make a significant difference. A unary expression preceded by a ++ operator is a prefix increment expression. The result of the unary expression must be a variable of a numeric type, or a compile-time error occurs. The type of the prefix increment expression is the type of the variable. The result of the prefix increment expression is not a variable, but a value.At run time, if evaluation of the operand expression completes abruptly, then the prefix increment expression completes abruptly for the same reason and no incrementation occurs. Otherwise, the value 1 is added to the value of the variable and the sum is stored back into the variable. Before the addition, binary numeric promotion (5.6.2) is performed on the value 1 and the value of the variable. If necessary, the sum is narrowed by a narrowing primitive conversion (5.1.3) to the type of the variable before it is stored. The value of the prefix increment expression is the value of the variable after the new value is stored.Pre-increment &apos;++&apos; increases the value of the operand by one before the rest of the expression has been evaluated^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PrivateAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PrivateAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;string">The first (left-most) modifier used lets you control what other classes have access to a member field. For the moment, consider only public and private. Other access modifiers will be discussed later.		private modifierthe field is accessible only within its own class.In the spirit of encapsulation, it is common to make fields private. This means that they can only be directly accessed from the Bicycle class. We still need access to these values, however. This can be done indirectly by adding public methods that obtain the field values for us:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ProgramElementBody</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ProgramElementDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ProgramElementSignature</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ProgramStructure</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ProtectedAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ProtectedAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;string">A protected member or constructor of an object may be accessed from outside the package in which it is declared only by code that is responsible for the implementation of that object.Let C be the class in which a protected member m is declared. Access is permitted only within the body of a subclass S of CLet C be the class in which a protected constructor is declared and let S be the innermost class in whose declaration the use of the protected constructor occurs.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#PublicAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#PublicAccessSpecifier</IRI>
        <Literal datatypeIRI="&xsd;string">The first (left-most) modifier used lets you control what other classes have access to a member field.public modifierthe field is accessible from all classes.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#RelationalExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#RelationalExpression</IRI>
        <Literal datatypeIRI="&xsd;string">Relational operators compare the values of their operands</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ReturnStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ReturnStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The last of the branching statements is the return statement. The return statement exits from the current method, and control flow returns to where the method was invoked. The return statement has two forms: one that returns a value, and one that doesn&apos;t. To return a value, simply put the value (or an expression that calculates the value) after the return keyword.     return ++count;The data type of the returned value must match the type of the method&apos;s declared return value. When a method is declared void, use the form of return that doesn&apos;t return a value.A method returns to the code that invoked it when it		completes all the statements in the method,		reaches a return statement, or		throws an exception (covered later),whichever occurs first.You declare a method&apos;s return type in its method declaration. Within the body of the method, you use the return statement to return the value.Any method declared void doesn&apos;t return a value. It does not need to contain a return statement, but it may do so. In such a case, a return statement can be used to branch out of a control flow block and exit the method and is simply used like this: return; If you try to return a value from a method that is declared void, you will get a compiler error.Any method that is not declared void must contain a return statement with a corresponding return value, like this: return returnValue; The data type of the return value must match the method&apos;s declared return type; you can&apos;t return an integer value from a method declared to return a boolean.This method returns the integer that the expression width*height evaluates to.The area method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate Bicycle objects, we might have a method like this:A return statement returns control to the invoker of a method (8.4, 15.12) or constructor (8.8, 15.9).		ReturnStatement:			return Expressionopt ;		A return statement with no Expression must be contained in the body of a method that is declared, using the keyword void, not to return any value (8.4), or in the body of a constructor (8.8). A compile-time error occurs if a return statement appears within an instance initializer or a static initializer (8.7). A return statement with no Expression attempts to transfer control to the invoker of the method or constructor that contains it.To be precise, a return statement with no Expression always completes abruptly, the reason being a return with no value.A return statement with an Expression must be contained in a method declaration that is declared to return a value (8.4) or a compile-time error occurs. The Expression must denote a variable or value of some type T, or a compile-time error occurs. The type T must be assignable (5.2) to the declared result type of the method, or a compile-time error occurs.A return statement with an Expression attempts to transfer control to the invoker of the method that contains it; the value of the Expression becomes the value of the method invocation. More precisely, execution of such a return statement first evaluates the Expression. If the evaluation of the Expression completes abruptly for some reason, then the return statement completes abruptly for that reason. If evaluation of the Expression completes normally, producing a value V, then the return statement completes abruptly, the reason being a return with value V. If the expression is of type float and is not FP-strict (15.4), then the value may be an element of either the float value set or the float-extended-exponent value set (4.2.3). If the expression is of type double and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.It can be seen, then, that a return statement always completes abruptly.The preceding descriptions say &quot;attempts to transfer control&quot; rather than just &quot;transfers control&quot; because if there are any try statements (14.19) within the method or constructor whose try blocks contain the return statement, then any finally clauses of those try statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a finally clause can disrupt the transfer of control initiated by a return statement.return statement (ends the method execution and returns (optionally) the result of the method)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ReturnedType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ReturnedType</IRI>
        <Literal datatypeIRI="&xsd;string">A method returns to the code that invoked it when it		completes all the statements in the method,		reaches a return statement, or		throws an exception (covered later),whichever occurs first.You declare a method&apos;s return type in its method declaration. Within the body of the method, you use the return statement to return the value.Any method declared void doesn&apos;t return a value. It does not need to contain a return statement, but it may do so. In such a case, a return statement can be used to branch out of a control flow block and exit the method and is simply used like this: return; If you try to return a value from a method that is declared void, you will get a compiler error.Any method that is not declared void must contain a return statement with a corresponding return value, like this: return returnValue; The data type of the return value must match the method&apos;s declared return type; you can&apos;t return an integer value from a method declared to return a boolean.This method returns the integer that the expression width*height evaluates to.The area method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate Bicycle objects, we might have a method like this:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ReturnedValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ReturnedValue</IRI>
        <Literal datatypeIRI="&xsd;string">A method returns to the code that invoked it when it		completes all the statements in the method,		reaches a return statement, or		throws an exception (covered later),whichever occurs first.You declare a method&apos;s return type in its method declaration. Within the body of the method, you use the return statement to return the value.Any method declared void doesn&apos;t return a value. It does not need to contain a return statement, but it may do so. In such a case, a return statement can be used to branch out of a control flow block and exit the method and is simply used like this: return; If you try to return a value from a method that is declared void, you will get a compiler error.Any method that is not declared void must contain a return statement with a corresponding return value, like this: return returnValue; The data type of the return value must match the method&apos;s declared return type; you can&apos;t return an integer value from a method declared to return a boolean.This method returns the integer that the expression width*height evaluates to.The area method returns a primitive type. A method can also return a reference type. For example, in a program to manipulate Bicycle objects, we might have a method like this:the method returned value (the result of the method)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SAX</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SelectionStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SelectionStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Java selection (decision, conditional) statements</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ShortDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ShortDataType</IRI>
        <Literal datatypeIRI="&xsd;string">short: The short data type is a 16-bit signed two&apos;s complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive). As with byte, the same guidelines apply: you can use a short to save memory in large arrays, in situations where the memory savings actually matters. integer data type for numbers between -32,768 and 32,767 (reserved word &quot;short&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ShortValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SignedLeftShiftAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SignedLeftShiftExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SignedRightShiftAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SignedRightShiftExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SimpleAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SimpleAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">One of the most common operators that you&apos;ll encounter is the simple assignment operator &quot;=&quot;. You saw this operator in the Bicycle class; it assigns the value on its right to the operand on its left:This operator can also be used on objects to assign object references, as discussed in Creating Objects. Simple (default, traditional) assignment &apos;=&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SimpleDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SimpleDataType</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language is staticaly-typed, which means that all variables must first be declared before they can be used. This involves stating the variable&apos;s type and name, as you&apos;ve already seen:    int gear = 1;Doing so tells your program that a field named &quot;gear&quot; exists, holds numerical data, and has an initial value of &quot;1&quot;. A variable&apos;s data type determines the values it may contain, plus the operations that may be performed on it. In addition to int, the Java programming language supports seven other primitive data types. A primitive type is predefined by the language and is named by a reserved keyword. Primitive values do not share state with other primitive values. The eight primitive data types supported by the Java programming language are: Java has eight primitive types of data: byte, short, int, long, char, float, double, and boolean.These can be put in four groups:   1. Integers includes byte, short, int, and long   2. Floating-point numbers includes float and double   3. Characters includes char, like letters and numbers.   4. Boolean includes boolean representing true/false values.Simple (fundamental, basic) data types^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SimpleDataTypeValue</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SimpleVariable</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SimpleVariable</IRI>
        <Literal datatypeIRI="&xsd;string">Local Variables Similar to how an object stores its state in fields, a method will often store its temporary state in local variables. The syntax for declaring a local variable is similar to declaring a field (for example, int count = 0;). There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared  which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class. Variables are data placeholders. There are two data types in Java:  Primitive types hold a primitive.A local variable storing a value of a simple data type. Local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Specification</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StandardIdentifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Statement</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Statement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. In programming, a statement is an instruction to do something.   2. It controls the sequence of execution of a program.   3. In Java, a statement is terminated with a semicolon and multiple statements can be written on a single line.   Statements are roughly equivalent to sentences in natural languages. A statement forms a complete unit of execution.Java programming statements (or instructions)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StatementBlock</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StatementBlock</IRI>
        <Literal datatypeIRI="&xsd;string">   1. You can have a block of statements enclosed between braces.   2. If the value of expression is true, all the statements enclosed in the block will be executed.   3. Without the braces, the code no longer has a statement block.      A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.A block is a sequence of statements, local class declarations and local variable declaration statements within braces.A block is executed by executing each of the local variable declaration statements and other statements in order from first to last (left to right). If all of these block statements complete normally, then the block completes normally. If any of these block statements complete abruptly for any reason, then the block completes abruptly for the same reason.The scope of a local variable declaration in a block (14.2) is the rest of the block in which the declaration appears, starting with its own initializer (14.4) and including any further declarators to the right in the local variable declaration statement.The name of a local variable v may not be redeclared as a local variable of the directly enclosing method, constructor or initializer block within the scope of v, or a compile-time error occurs. The name of a local variable v may not be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method, constructor or initializer block within the scope of v, or a compile-time error occurs. However, a local variable of a method or initializer block may be shadowed (6.3.1) anywhere inside a class declaration nested within the scope of the local variable.A local variable cannot be referred to using a qualified name (6.6), only a simple name.A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StaticMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StaticMethod</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Static members are not tied to class instances.   2. Static members can be called without having an instance.The Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as inA common use for static methods is to access static fields. For example, we could add a static method to the Bicycle class to access the numberOfBicycles static field:Not all combinations of instance and class variables and methods are allowed:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StaticMethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StaticMethodDefinition</IRI>
        <Literal datatypeIRI="&xsd;string">   1. You can use the keyword static in front of a  method declaration.   2. The static keyword may come before or after the access modifier.   # From inside a static method, you cannot call instance methods or instance fields because they only exist after you create an object.# You can access other static methods or fields from a static method.The Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as inA common use for static methods is to access static fields. For example, we could add a static method to the Bicycle class to access the numberOfBicycles static field:Not all combinations of instance and class variables and methods are allowed:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StaticMethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StaticMethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;string">If a method (static or instance) is called from another class, something must be given before the method name to specify the class where the method is defined. For instance methods, this is the object that the method will access. For static methods, the class name should be specified.The Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StaticModifier</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StaticModifier</IRI>
        <Literal datatypeIRI="&xsd;string">   1. Static members are not tied to class instances.   2. Static members can be called without having an instance.   1. You can use the keyword static in front of a  method declaration.   2. The static keyword may come before or after the access modifier.   # From inside a static method, you cannot call instance methods or instance fields because they only exist after you create an object.# You can access other static methods or fields from a static method.In this section, we discuss the use of the static keyword to create fields and methods that belong to the class, rather than to an instance of the class.Sometimes, you want to have variables that are common to all objects. This is accomplished with the static modifier. Fields that have the static modifier in their declaration are called static fields or class variables. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.For example, suppose you want to create a number of Bicycle objects and assign each a serial number, beginning with 1 for the first object. This ID number is unique to each object and is therefore an instance variable. At the same time, you need a field to keep track of how many Bicycle objects have been created so that you know what ID to assign to the next one. Such a field is not related to any individual object, but to the class as a whole. For this you need a class variable, numberOfBicycles, as follows:Class variables are referenced by the class name itself, as inThis makes it clear that they are class variables.The Java programming language supports static methods as well as static variables. Static methods, which have the static modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as inA common use for static methods is to access static fields. For example, we could add a static method to the Bicycle class to access the numberOfBicycles static field:Not all combinations of instance and class variables and methods are allowed:The static modifier, in combination with the final modifier, is also used to define constants. The final modifier indicates that the value of this field cannot change.For example, the following variable declaration defines a constant named PI, whose value is an approximation of pi (the ratio of the circumference of a circle to its diameter):static final double PI = 3.141592653589793;Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).Note:If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringAddition</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StringAddition</IRI>
        <Literal datatypeIRI="&xsd;string">The + operator can also be used for concatenating (joining) two strings together, as shown in the following ConcatDemo program:    class ConcatDemo {         public static void main(String[] args){              String firstString = &quot;This is&quot;;              String secondString = &quot; a concatenated string.&quot;;              String thirdString = firstString+secondString;              System.out.println(thirdString);         }    }By the end of this program, the variable thirdString contains &quot;This is a concatenated string.&quot;, which gets printed to standard output. The String class includes a method for concatenating two strings:string1.concat(string2); This returns a new string that is string1 with string2 added to it at the end.Strings are more commonly concatenated with the +(addition) operator, as in&quot;Hello,&quot; + &quot; world&quot; + &quot;!&quot;which results in&quot;Hello, world!&quot;The + operator is widely used in print statements. For example:Such a concatenation can be a mixture of any objects. For each object that is not a String, its toString() method is called to convert it to a String.The Java programming language does not permit literal strings to span lines in source files, so you must use the + concatenation operator at the end of each line in a multi-line string. For example,Breaking strings between lines using the + concatenation operator is, once again, very common in print statements.If only one operand expression is of type String, then string conversion is performed on the other operand to produce a string at run time. The result is a reference to a newly created String object that is the concatenation of the two operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in the newly created string.Any type may be converted to type String by string conversion.A value x of primitive type T is first converted to a reference value as if by giving it as an argument to an appropriate class instance creation expression:An implementation may choose to perform conversion and concatenation in one step to avoid creating and then discarding an intermediate String object. To increase the performance of repeated string concatenation, a Java compiler may use the StringBuffer class or a similar technique to reduce the number of intermediate String objects that are created by evaluation of an expression.For primitive types, an implementation may also optimize away the creation of a wrapper object by converting directly from a primitive type to a string.Arithmetic addition of strings results in string concatenation. If only one of the arguments is string, it will be concatenated with the string representation of the second argument^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StringDataType</IRI>
        <Literal datatypeIRI="&xsd;string">In addition to the eight primitive data types listed above, the Java programming language also provides special support for character strings via the java.lang.String class. Enclosing your character string within double quotes will automatically create a new String object; for example, String s = &quot;this is a string&quot;;. String objects are immutable, which means that once created, their values cannot be changed. The String class is not technically a primitive data type, but considering the special support given to it by the language, you&apos;ll probably tend to think of it as such. You&apos;ll learn more about the String class in Simple Data ObjectsStrings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.The Java platform provides the String class to create and manipulate strings.The String class is immutable, so that once it is created a String object cannot be changed. The String class has a number of methods, some of which will be discussed below, that appear to modify strings. Since strings are immutable, what these methods really do is create and return a new string that contains the result of the operation.The most direct way to create a string is to write:String greeting = &quot;Hello world!&quot;;In this case, &quot;Hello world!&quot; is a string literala series of characters in your code that is enclosed in double quotes. Whenever it encounters a string literal in your code, the compiler creates a String object with its valuein this case, Hello world!.As with any other object, you can create String objects by using the new keyword and a constructor. The String class has thirteen constructors that allow you to provide the initial value of the string using different sources, such as an array of characters:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StringInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">The most direct way to create a string is to write:String greeting = &quot;Hello world!&quot;;In this case, &quot;Hello world!&quot; is a string literala series of characters in your code that is enclosed in double quotes. Whenever it encounters a string literal in your code, the compiler creates a String object with its valuein this case, Hello world!Initialization of a String object by a string literal
String Initialization is a kind of variable initialialization^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringLiteral</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StringLiteral</IRI>
        <Literal datatypeIRI="&xsd;string">A string literal consists of zero or more characters enclosed in double quotes. Each character may be represented by an escape sequence.A string literal is always of type String (4.3.3. A string literal always refers to the same instance (4.3.1) of class String.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringLiteralMethodInvocation</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#StringVariable</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#StringVariable</IRI>
        <Literal datatypeIRI="&xsd;string">a variable of class String, storing a reference to the String representation in memory</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Subclass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Subclass</IRI>
        <Literal datatypeIRI="&xsd;string">Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. In this example, Bicycle now becomes the superclass of MountainBike, RoadBike, and TandemBike. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of subclasses:A diagram of classes in a hierarchy.A hierarchy of bicycle classes.The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:class MountainBike extends Bicycle {     // new fields and methods defining a mountain bike would go here}This gives MountainBike all the same fields and methods as Bicycle, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.A class declaration for a MountainBike class that is a subclass of Bicycle might look like this:MountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for the constructor, it is as if you had written a new MountainBike class entirely from scratch, with four fields and five methods. However, you didn&apos;t have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex and had taken substantial time to debug.A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:		The inherited fields can be used directly, just like any other fields.		You can declare a field in the subclass with the same name as the one in the superclass, thus hiding it (not recommended).		You can declare new fields in the subclass that are not in the superclass.		The inherited methods can be used directly as they are.		You can write a new instance method in the subclass that has the same signature as the one in the superclass, thus overriding it.		You can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.		You can declare new methods in the subclass that are not in the superclass.		You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.The following sections in this lesson will expand on these topics.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SubtractAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SubtractAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;string">All compound assignment operators require both operands to be of primitive type, except for +=, which allows the right-hand operand to be of any type if the left-hand operand is of type String.At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression, then four steps are required:		First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.		Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly (the only possibility is an integer division by zero-see 15.17.2), then the assignment expression completes abruptly for the same reason and no assignment occurs.		Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion (5.1.8) to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.Subtract the value of the expression to the right  from the value of the varibale to the left and assigns the result to the variable to the left &apos;=-&quot;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SubtractExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SubtractExpression</IRI>
        <Literal datatypeIRI="&xsd;string">The Java programming language provides operators that perform addition, subtraction, multiplication, and division. There&apos;s a good chance you&apos;ll recognize them by their counterparts in basic mathematics.     - 	subtraction operatorSubtraction Operator &apos;-&apos;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperReference</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperReference</IRI>
        <Literal datatypeIRI="&xsd;string">If your method overrides one of its superclass&apos;s methods, you can invoke the overridden method through the use of the keyword super. You can also use super to refer to a hidden field (although hiding fields is discouraged). Consider this class, Superclass:Here is a subclass, called Subclass, that overrides printMethod():Within Subclass, the simple name printMethod() refers to the one declared in Subclass, which overrides the one in Superclass. So, to refer to printMethod() inherited from Superclass, Subclass must use a qualified name, using super as shown. Compiling and executing Subclass prints the following:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Superclass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Superclass</IRI>
        <Literal datatypeIRI="&xsd;string">Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. In this example, Bicycle now becomes the superclass of MountainBike, RoadBike, and TandemBike. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of subclasses:A diagram of classes in a hierarchy.A hierarchy of bicycle classes.The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:class MountainBike extends Bicycle {     // new fields and methods defining a mountain bike would go here}This gives MountainBike all the same fields and methods as Bicycle, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperclassConstructor</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperclassConstructor</IRI>
        <Literal datatypeIRI="&xsd;string">   1. You can explicitly call the parent&apos;s constructor from a subclass&apos;s constructor by using the super keyword.   2. &apos;super&apos; must be the first statement in the constructor.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperclassConstructorCall</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperclassConstructorCall</IRI>
        <Literal datatypeIRI="&xsd;string">   1. You can explicitly call the parent&apos;s constructor from a subclass&apos;s constructor by using the super keyword.   2. &apos;super&apos; must be the first statement in the constructor.The following example illustrates how to use the super keyword to invoke a superclass&apos;s constructor. Recall from the Bicycle example that MountainBike is a subclass of Bicycle. Here is the MountainBike (subclass) constructor that calls the superclass constructor and then adds initialization code of its own:nvocation of a superclass constructor must be the first line in the subclass constructor.The syntax for calling a superclass constructor issuper();  --or--super(parameter list);With super(), the superclass no-argument constructor is called. With super(parameter list), the superclass constructor with a matching parameter list is called.Note:If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error. Object does have such a constructor, so if Object is the only superclass, there is no problem.If a subclass constructor invokes a constructor of its superclass, either explicitly or implicitly, you might think that there will be a whole chain of constructors called, all the way back to the constructor of Object. In fact, this is the case. It is called constructor chaining, and you need to be aware of it when there is a long line of class descent.Constructors of the subclasses must call the super constructor first to initialize inherited fields and then initialize new added fields of the subclass. To call the super constructor one shoudl use &quot;super()&quot;^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperclassMethod</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperclassMethod</IRI>
        <Literal datatypeIRI="&xsd;string">to call methods of the superclass, if they are not overriden, one call them the way, the are implemented in the subclass, If a method has been overriden, then inside the sublcass one should use super refference. </Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperclassMethodCall</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperclassMethodCall</IRI>
        <Literal datatypeIRI="&xsd;string">The special forms using the keyword super are valid only in an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class; these are exactly the same situations in which the keyword this may be used (15.8.3). The forms involving super may not be used anywhere in the class Object, since Object has no superclass; if super appears in class Object, then a compile-time error results.Suppose that a field access expression super.name appears within class C, and the immediate superclass of C is class S. Then super.name is treated exactly as if it had been the expression ((S)this).name; thus, it refers to the field named name of the current object, but with the current object viewed as an instance of the superclass. Thus it can access the field named name that is visible in class S, even if that field is hidden by a declaration of a field named name in class C.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SuperclassSubclassConversion</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SuperclassSubclassConversion</IRI>
        <Literal datatypeIRI="&xsd;string">   1. With objects, you can cast an instance of a subclass to its parent class.   2. Casting an object to a parent class is called upcasting.   To upcast a Child object, all you need to do is assign the object to a reference variable of type Parent. The parent reference variable cannot access the members that are only available in Child.Because parent references an object of type Child, you can cast it back to Child. It is called downcasting because you are casting an object to a class down the inheritance hierarchy. Downcasting requires that you write the child type in brackets. For example:We have seen that an object is of the data type of the class from which it was instantiated. For example, if we writepublic MountainBike myBike = new MountainBike();then myBike is of type MountainBike.MountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.The reverse is not necessarily true: a Bicycle may be a MountainBike, but it isn&apos;t necessarily. Similarly, an Object may be a Bicycle or a MountainBike, but it isn&apos;t necessarily.Casting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we writeObject obj = new MountainBike();then obj is both an Object and a Mountainbike (until such time as obj is assigned another object that is not a Mountainbike). This is called implicit casting.If, on the other hand, we writeMountainBike myBike = obj;we would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can tell the compiler that we promise to assign a MountainBike to obj by explicit casting:MountainBike myBike = (MountainBike)obj;This cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a Mountainbike at runtime, an exception will be thrown.Note:You can make a logical test as to the type of a particular object using the instanceof operator. This can save you from a runtime error owing to an improper cast. For example:if (obj instanceof MountainBike) {   MountainBike myBike = (MountainBike)obj;}Here the instanceof operator verifies that obj refers to a MountainBike so that we can make the cast with knowledge that there will be no runtime exception thrown.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#SwitchStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#SwitchStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. An alternative to a series of else if is the switch statement.   2. The switch statement allows you to choose a block of statements to run from a selection of code, based on the return value of an expression.   3. The expression used in the switch statement must return an int or an enumerated value.The syntax of the switch statement is as follows.Failure to add a break statement after a case will not generate a compile error but may have more serious consequences because the statements on the next case will be executed.Here is an example of the switch statement:Unlike if-then and if-then-else, the switch statement allows for any number of possible execution paths. A switch works with the byte, short, char, and int primitive data types. It also works with enumerated types (discussed in Classes and Inheritance) and a few special classes that &quot;wrap&quot; certain primitive types: Character, Byte, Short, and Integer (discussed in Simple Data Objects ).The following program, SwitchDemo, declares an int named month whose value represents a month out of the year. The program displays the name of the month, based on the value of month, using the switch statement.The body of a switch statement is known as a switch block. Any statement immediately contained by the switch block may be labeled with one or more case or default labels. The switch statement evaluates its expression and executes the appropriate case.The switch statement transfers control to one of several statements depending on the value of an expression.The type of the Expression must be char, byte, short, or int, or a compile-time error occurs.The body of a switch statement is known as a switch block. Any statement immediately contained by the switch block may be labeled with one or more case or default labels. These labels are said to be associated with the switch statement, as are the values of the constant expressions (15.28) in the case labels.All of the following must be true, or a compile-time error will result:		Every case constant expression associated with a switch statement must be assignable (5.2) to the type of the switch Expression.		No two of the case constant expressions associated with a switch statement may have the same value.		At most one default label may be associated with the same switch statement.switch statement (selector, multiple selection statement)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ThisReference</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ThisReference</IRI>
        <Literal datatypeIRI="&xsd;string">You use the this keyword from any method or constructor to refer to the current object.Within an instance method or a constructor, this is a reference to the current object  the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using this.The most common reason for using the this keyword is because a field is shadowed by a method or constructor parameter.Each argument to the constructor shadows one of the object&apos;s fields  inside the constructor x is a local copy of the constructor&apos;s first argument. To refer to the Point field x, the constructor must use this.x.From within a constructor, you can also use the this keyword to call another constructor in the same class. Doing so is called an explicit constructor invocation. Here&apos;s another Rectangle class, with a different implementation from the one in the Objects section.This class contains a set of constructors. Each constructor initializes some or all of the rectangle&apos;s member variables. The constructors provide a default value for any member variable whose initial value is not provided by an argument. For example, the no-argument constructor calls the four-argument constructor with four 0 values and the two-argument constructor calls the four-argument constructor with two 0 values. As before, the compiler determines which constructor to call, based on the number and the type of arguments.If present, the invocation of another constructor must be the first line in the constructor.The keyword this may be used only in the body of an instance method, instance initializer or constructor, or in the initializer of an instance variable of a class. If it appears anywhere else, a compile-time error occurs.When used as a primary expression, the keyword this denotes a value, that is a reference to the object for which the instance method was invoked (15.12), or to the object being constructed.The keyword this is also used in a special explicit constructor invocation statement, which can appear at the beginning of a constructor body</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ThrowStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ThrowStatement</IRI>
        <Literal datatypeIRI="&xsd;string">A throw statement causes an exception (11) to be thrown. The result is an immediate transfer of control (11.3) that may exit multiple statements and multiple constructor, instance initializer, static initializer and field initializer evaluations, and method invocations until a try statement (14.19) is found that catches the thrown value. If no such try statement is found, then execution of the thread (17) that executed the throw is terminated (11.3) after invocation of the uncaughtException method for the thread group to which the thread belongs.		ThrowStatement:			throw Expression ;		The Expression in a throw statement must denote a variable or value of a reference type which is assignable (5.2) to the type Throwable, or a compile-time error occurs. Moreover, at least one of the following three conditions must be true, or a compile-time error occurs:		The exception is not a checked exception (11.2)-specifically, one of the following situations is true:		The type of the Expression is the class RuntimeException or a subclass of RuntimeException.		The type of the Expression is the class Error or a subclass of Error.		The throw statement is contained in the try block of a try statement (14.19) and the type of the Expression is assignable (5.2) to the type of the parameter of at least one catch clause of the try statement. (In this case we say the thrown value is caught by the try statement.)		The throw statement is contained in a method or constructor declaration and the type of the Expression is assignable (5.2) to at least one type listed in the throws clause (8.4.4, 8.8.4) of the declaration.A throw statement first evaluates the Expression. If the evaluation of the Expression completes abruptly for some reason, then the throw completes abruptly for that reason. If evaluation of the Expression completes normally, producing a non-null value V, then the throw statement completes abruptly, the reason being a throw with value V. If evaluation of the Expression completes normally, producing a null value, then an instance V&apos; of class NullPointerException is created and thrown instead of null. The throw statement then completes abruptly, the reason being a throw with value V&apos;.It can be seen, then, that a throw statement always completes abruptly.If there are any enclosing try statements (14.19) whose try blocks contain the throw statement, then any finally clauses of those try statements are executed as control is transferred outward, until the thrown value is caught. Note that abrupt completion of a finally clause can disrupt the transfer of control initiated by a throw statement.If a throw statement is contained in a method declaration, but its value is not caught by some try statement that contains it, then the invocation of the method completes abruptly because of the throw.If a throw statement is contained in a constructor declaration, but its value is not caught by some try statement that contains it, then the class instance creation expression that invoked the constructor will complete abruptly because of the throw.If a throw statement is contained in a static initializer (8.7), then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it. If at run-time, despite this check, the value is not caught by some try statement that contains the throw statement, then the value is rethrown if it is an instance of class Error or one of its subclasses; otherwise, it is wrapped in an ExceptionInInitializerError object, which is then thrown (12.4.2).If a throw statement is contained in an instance initializer (8.6), then a compile-time check ensures that either its value is always an unchecked exception or its value is always caught by some try statement that contains it, or the type of the thrown exception (or one of its superclasses) occurs in the throws clause of every constructor of the class.By convention, user-declared throwable types should usually be declared to be subclasses of class Exception, which is a subclass of class Throwable (11.5).All methods use the throw statement to throw an exception. The throw statement requires a single argument: a throwable object. Throwable objects are instances of any subclass of the Throwable class. Here&apos;s an example of a throw statement.throw someThrowableObject;Let&apos;s look at the throw statement in context. The following pop method is taken from a class that implements a common stack object. The method removes the top element from the stack and returns the object.The pop method checks to see whether any elements are on the stack. If the stack is empty (its size is equal to 0), pop instantiates a new EmptyStackException object (a member of java.util) and throws it. The Creating Exception Classes section in this chapter explains how to create your own exception classes. For now, all you need to remember is that you can throw only objects that inherit from the java.lang.Throwable class.Note that the declaration of the pop method does not contain a throws clause. EmptyStackException is not a checked exception, so pop is not required to state that it might occur.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#ThrowsSpecification</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#ThrowsSpecification</IRI>
        <Literal datatypeIRI="&xsd;string">A throws clause is used to declare any checked exceptions (11.2) that can result from the execution of a method or constructor:A compile-time error occurs if any ClassType mentioned in a throws clause is not the class Throwable or a subclass of Throwable. It is permitted but not required to mention other (unchecked) exceptions in a throws clause.For each checked exception that can result from execution of the body of a method or constructor, a compile-time error occurs unless that exception type or a superclass of that exception type is mentioned in a throws clause in the declaration of the method or constructor.The requirement to declare checked exceptions allows the compiler to ensure that code for handling such error conditions has been included. Methods or constructors that fail to handle exceptional conditions thrown as checked exceptions will normally result in a compile-time error because of the lack of a proper exception type in a throws clause. The Java programming language thus encourages a programming style where rare and otherwise truly exceptional conditions are documented in this way.The previous section showed how to write an exception handler for the writeList method in the ListOfNumbers class. Sometimes, it&apos;s appropriate for code to catch exceptions that can occur within it. In other cases, however, it&apos;s better to let a method further up the call stack handle the exception. For example, if you were providing the ListOfNumbers class as part of a package of classes, you probably couldn&apos;t anticipate the needs of all the users of your package. In this case, it&apos;s better to not catch the exception and to allow a method further up the call stack to handle it.If the writeList method doesn&apos;t catch the checked exceptions that can occur within it, the writeList method must specify that it can throw these exceptions. Let&apos;s modify the original writeList method to specify the exceptions it can throw instead of catching them. To remind you, here&apos;s the original version of the writeList method that won&apos;t compile.To specify that writeList can throw two exceptions, add a throws clause to the method declaration for the writeList method. The throws clause comprises the throws keyword followed by a comma-separated list of all the exceptions thrown by that method. The clause goes after the method name and argument list and before the brace that defines the scope of the method; here&apos;s an example.Remember that ArrayIndexOutOfBoundsException is an unchecked exception; including it in the throws clause is not mandatory. You could just write the following.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#True</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#True</IRI>
        <Literal datatypeIRI="&xsd;string">The boolean type has two values, represented by literals &apos;true&apos; and ...The following code declares a boolean variable includeSign and assigns it the value of true.The boolean type has two values, represented by the literals true and false, formed from ASCII letters.A boolean literal is always of type boolean.logical true values (reserved word &quot;true&quot;)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#TryCatchFinallyStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#TryCatchFinallyStatement</IRI>
        <Literal datatypeIRI="&xsd;string">If the try statement has a finally clause, then another block of code is executed, no matter whether the try block completes normally or abruptly, and no matter whether a catch clause is first given control.TryStatement:	try Block Catches	try Block Catchesopt FinallyCatches:	CatchClause	Catches CatchClauseCatchClause:	catch ( FormalParameter ) BlockFinally:	finally Block		A finally clause ensures that the finally block is executed after the try block and any catch block that might be executed, no matter how control leaves the try block or catch block.Handling of the finally block is rather complex, so the two cases of a try statement with and without a finally block are described separately.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#TryCatchStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#TryCatchStatement</IRI>
        <Literal datatypeIRI="&xsd;string">A try statement executes a block. If a value is thrown and the try statement has one or more catch clauses that can catch it, then control will be transferred to the first such catch clause.TryStatement:	try Block Catches	try Block Catchesopt FinallyCatches:	CatchClause	Catches CatchClauseCatchClause:	catch ( FormalParameter ) Block	The Block immediately after the keyword try is called the try block of the try statement. The Block immediately after the keyword finally is called the finally block of the try statement.A try statement may have catch clauses (also called exception handlers). A catch clause must have exactly one parameter (which is called an exception parameter); the declared type of the exception parameter must be the class Throwable or a subclass of Throwable, or a compile-time error occurs. The scope of the parameter variable is the Block of the catch clause.An exception parameter of a catch clause must not have the same name as a local variable or parameter of the method or initializer block immediately enclosing the catch clause, or a compile-time error occurs.The scope of a parameter of an exception handler that is declared in a catch clause of a try statement (14.19) is the entire block associated with the catch.Within the Block of the catch clause, the name of the parameter may not be redeclared as a local variable of the directly enclosing method or initializer block, nor may it be redeclared as an exception parameter of a catch clause in a try statement of the directly enclosing method or initializer block, or a compile-time error occurs. However, an exception parameter may be shadowed (6.3.1) anywhere inside a class declaration nested within the Block of the catch clause.It is a compile-time error if an exception parameter that is declared final is assigned to within the body of the catch clause.Exception parameters cannot be referred to using qualified names (6.6), only by simple names.Exception handlers are considered in left-to-right order: the earliest possible catch clause accepts the exception, receiving as its actual argument the thrown exception object.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#TypeCasting</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#TypeCasting</IRI>
        <Literal datatypeIRI="&xsd;string">Typecasting, datatype withing brackets &apos;(datatype)&apos;
Necessary for casting with potential information loss (e.g. double to int or long to int or double to float), for casting from the interface  to the class implementing it, and for casting from the superclass to the subclass</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#UnaryMinusOperator</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#UnaryMinusOperator</IRI>
        <Literal datatypeIRI="&xsd;string">The type of the operand expression of the unary - operator must be a primitive numeric type, or a compile-time error occurs. Unary numeric promotion (5.6.1) is performed on the operand. The type of the unary minus expression is the promoted type of the operand.At run time, the value of the unary minus expression is the arithmetic negation of the promoted value of the operand.For integer values, negation is the same as subtraction from zero. The Java programming language uses two&apos;s-complement representation for integers, and the range of two&apos;s-complement values is not symmetric, so negation of the maximum negative int or long results in that same maximum negative number. Overflow occurs in this case, but no exception is thrown. For all integer values x, -x equals (~x)+1.For floating-point values, negation is not the same as subtraction from zero, because if x is +0.0, then 0.0-x is +0.0, but -x is -0.0. Unary minus merely inverts the sign of a floating-point number.Unary minus,&apos;-&apos;  to change the sign of the expression result^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#UnsignedRightShiftAssignmentExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#UnsignedRightShiftExpression</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Value</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#Variable</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#Variable</IRI>
        <Literal datatypeIRI="&xsd;string">General concept of a variable in Java
Variables have DataTypes
Variable serve as operands in Expressions</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#VariableDeclarationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#VariableDeclarationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">A local variable declaration statement declares one or more local variable names.A local variable declaration statement is an executable statement. Every time it is executed, the declarators are processed in order from left to right. If a declarator has an initialization expression, the expression is evaluated and its value is assigned to the variable. If a declarator does not have an initialization expression, then a Java compiler must prove, using exactly the algorithm given in 16, that every reference to the variable is necessarily preceded by execution of an assignment to the variable. If this is not the case, then a compile-time error occurs.Every local variable declaration statement is immediately contained by a block. Local variable declaration statements may be intermixed freely with other kinds of statements in the block.A local variable declaration can also appear in the header of a for statement (14.13). In this case it is executed in the same manner as if it were part of a local variable declaration statement.Each declarator in a local variable declaration declares one local variable, whose name is the Identifier that appears in the declarator.If the optional keyword final appears at the start of the declarator, the variable being declared is a final variable(4.5.4).The type of the variable is denoted by the Type that appears in the local variable declaration, followed by any bracket pairs that follow the Identifier in the declarator.Thus, the local variable declaration: is equivalent to the series of declarations:A local variable of type float always contains a value that is an element of the float value set (4.2.3); similarly, a local variable of type double always contains a value that is an element of the double value set. It is not permitted for a local variable of type float to contain an element of the float-extended-exponent value set that is not also an element of the float value set, nor for a local variable of type double to contain an element of the double-extended-exponent value set that is not also an element of the double value set.Declaration statement consists of the variable declaration and a semicolon^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#VariableInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#VariableInitializationStatement</IRI>
        <Literal datatypeIRI="&xsd;string">Initialization statement consists of the variable initialization and a semicolon.Both simple variables and object variables.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#VariableName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#VariableName</IRI>
        <Literal datatypeIRI="&xsd;string">Variable names are case-sensitive. A variable&apos;s name can be any legal identifier  an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign &quot;$&quot;, or the underscore character &quot;_&quot;. The convention, however, is to always begin your variable names with a letter, not &quot;$&quot; or &quot;_&quot;. Additionally, the dollar sign character, by convention, is never used at all. You may find some situations where auto-generated names will contain the dollar sign, but your variable names should always avoid using it. A similar convention exists for the underscore character; while it&apos;s technically legal to begin your variable&apos;s name with &quot;_&quot;, this practice is discouraged. White space is not permitted. Subsequent characters may be letters, digits, dollar signs, or underscore characters. Conventions (and common sense) apply to this rule as well. When choosing a name for your variables, use full words instead of cryptic abbreviations. Doing so will make your code easier to read and understand. In many cases it will also make your code self-documenting; fields named cadence, speed, and gear, for example, are much more intuitive than abbreviated versions, such as s, c, and g. Also keep in mind that the name you choose must not be a keyword or reserved word. All variables, whether they are fields, local variables, or parameters, follow the same naming rules and conventions that were covered in the Language Basics lesson, VariablesNaming .In this lesson, be aware that the same naming rules and conventions are used for method and class names, except that		the first letter of a class name should be capitalized, and		the first (or only) word in a method name should be a verb.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#VoidDataType</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#WhileStatement</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#WhileStatement</IRI>
        <Literal datatypeIRI="&xsd;string">   1. One way to create a loop is by using the while statement.   2. Another way is to use the for statementThe while statement has the following syntax.   1. statement(s) will be executed as long as booleanExpression evaluates to true.   2. If there is only a single statement inside the braces, you may omit the braces.   3. For clarity, you should always use braces even when there is only one statement.As an example of the while statement, the following code prints integer numbers that are less than three.The while statement continually executes a block of statements while a particular condition is true. Its syntax can be expressed as:while (expression) {     statement(s)}The while statement evaluates expression, which must return a boolean value. If the expression evaluates to true, the while statement executes the statement(s) in the while block. The while statement continues testing the expression and executing its block until the expression evaluates to false. Using the while statement to print the values from 1 through 10 can be accomplished as in the following WhileDemo program:The while statement executes an Expression and a Statement repeatedly until the value of the Expression is false.		WhileStatement:			while ( Expression ) Statement				WhileStatementNoShortIf:			while ( Expression ) StatementNoShortIf		The Expression must have type boolean, or a compile-time error occurs.A while statement is executed by first evaluating the Expression. If evaluation of the Expression completes abruptly for some reason, the while statement completes abruptly for the same reason. Otherwise, execution continues by making a choice based on the resulting value:		If the value is true, then the contained Statement is executed. Then there is a choice:		If execution of the Statement completes normally, then the entire while statement is executed again, beginning by re-evaluating the Expression.		If execution of the Statement completes abruptly, see 14.11.1 below.		If the value of the Expression is false, no further action is taken and the while statement completes normally.If the value of the Expression is false the first time it is evaluated, then the Statement is not executed.while loop (precondition)^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#WrapperClass</IRI>
        <Literal datatypeIRI="&xsd;boolean">false</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#XPath</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#XSLT</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#indexing</IRI>
        <Literal datatypeIRI="&xsd;string">This property specifies whether the class can be used for content indexing</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang</IRI>
        <Literal datatypeIRI="&xsd;string">Provides classes that are fundamental to the design of the Java programming language. The most important classes are Object, which is the root of the class hierarchy, and Class, instances of which represent classes at run time.Frequently it is necessary to represent a value of primitive type as if it were an object. The wrapper classes Boolean, Character, Integer, Long, Float, and Double serve this purpose. An object of type Double, for example, contains a field whose type is double, representing that value in such a way that a reference to it can be stored in a variable of reference type. These classes also provide a number of methods for converting among primitive values, as well as supporting such standard methods as equals and hashCode. The Void class is a non-instantiable class that holds a reference to a Class object represening the primitive type void.The class Math provides commonly used mathematical functions such as sine, cosine, and square root. The classes String and StringBuffer similarly provide commonly used operations on character strings.Classes ClassLoader, Process, Runtime, SecurityManager, and System provide &quot;system operations&quot; that manage the dynamic loading of classes, creation of external processes, host environment inquiries such as the time of day, and enforcement of security policies.Class Throwable encompasses objects that may be thrown by the throw statement (14.16). Subclasses of Throwable represent errors and exceptions.java.lang package^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Boolean</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Boolean</IRI>
        <Literal datatypeIRI="&xsd;string">The java.lang.Boolean class wraps a boolean. You can construct a Boolean object from a boolean or a String, using one of these constructors.public Boolean (boolean value)     public Boolean (String value)For example:Boolean b1 = new Boolean (false);     Boolean b2 = new Boolean (&quot;true&quot;);To convert a Boolean to a boolean, use its booleanValue method: public boolean booleanValue()</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Byte</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Byte</IRI>
        <Literal datatypeIRI="&xsd;string">The Byte class wraps a value of primitive type byte in an object. An object of type Byte contains a single field whose type is byte.In addition, this class provides several methods for converting a byte to a String and a String to a byte, as well as other constants and methods useful when dealing with a byte.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Character</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Character</IRI>
        <Literal datatypeIRI="&xsd;string">The Character class wraps a value of the primitive type char in an object. An object of type Character contains a single field whose type is char.In addition, this class provides several methods for determining a character&apos;s category (lowercase letter, digit, etc.) and for converting characters from uppercase to lowercase and vice versa.Character information is based on the Unicode Standard, version 4.0.The methods and data of class Character are defined by the information in the UnicodeData file that is part of the Unicode Character Database maintained by the Unicode Consortium. This file specifies various properties including name and general category for every defined Unicode code point or character range.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Class</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Class</IRI>
        <Literal datatypeIRI="&xsd;string">nstances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Class.forName</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Class.forName</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the Class object associated with the class or interface with the given string name. Invoking this method is equivalent to:  Class.forName(className, true, currentLoader) where currentLoader denotes the defining class loader of the current class.For example, the following code fragment returns the runtime Class descriptor for the class named java.lang.Thread:   Classt= Class.forName(&quot;java.lang.Thread&quot;) A call to forName(&quot;X&quot;) causes the class named X to be initialized.Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.If name denotes an array class, the component type of the array class is loaded but not initialized.For example, in an instance method the expression:  Class.forName(&quot;Foo&quot;) is equivalent to:  Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader()) Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.If the loader is null, and a security manager is present, and the caller&apos;s class loader is not null, then this method calls the security manager&apos;s checkPermission method with a RuntimePermission(&quot;getClassLoader&quot;) permission to ensure it&apos;s ok to access the bootstrap class loader.^^http://www.w3.org/2001/XMLSchema#string</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Double</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Double</IRI>
        <Literal datatypeIRI="&xsd;string">The Double class wraps a value of the primitive type double in an object. An object of type Double contains a single field whose type is double.In addition, this class provides several methods for converting a double to a String and a String to a double, as well as other constants and methods useful when dealing with a double.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Double.parseDouble</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Double.parseDouble</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a new double initialized to the value represented by the specified String, as performed by the valueOf method of class Double.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Exception</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Exception</IRI>
        <Literal datatypeIRI="&xsd;string">The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.When a program violates the semantic constraints of the Java programming language, the Java virtual machine signals this error to the program as an exception. An example of such a violation is an attempt to index outside the bounds of an array. Some programming languages and their implementations react to such errors by peremptorily terminating the program; other programming languages allow an implementation to react in an arbitrary or unpredictable way. Neither of these approaches is compatible with the design goals of the Java platform: to provide portability and robustness. Instead, the Java programming language specifies that an exception will be thrown when semantic constraints are violated and will cause a non-local transfer of control from the point where the exception occurred to a point that can be specified by the programmer. An exception is said to be thrown from the point where it occurred and is said to be caught at the point to which control is transferred.The Java programming language uses exceptions to handle errors and other exceptional events. This lesson describes when and how to use exceptions.When an error occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an exception object, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called throwing an exception.After a method throws an exception, the runtime system attempts to find something to handle it. The set of possible &quot;somethings&quot; to handle the exception is the ordered list of methods that had been called to get to the method where the error occurred. The list of methods is known as the call stack (see the next figure).The runtime system searches the call stack for a method that contains a block of code that can handle the exception. This block of code is called an exception handler. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler. An exception handler is considered appropriate if the type of the exception object thrown matches the type that can be handled by the handler.The exception handler chosen is said to catch the exception. If the runtime system exhaustively searches all the methods on the call stack without finding an appropriate exception handler, as shown in the next figure, the runtime system (and, consequently, the program) terminates.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Float</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Float</IRI>
        <Literal datatypeIRI="&xsd;string">The Float class wraps a value of primitive type float in an object. An object of type Float contains a single field whose type is float.In addition, this class provides several methods for converting a float to a String and a String to a float, as well as other constants and methods useful when dealing with a float.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Integer</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Integer</IRI>
        <Literal datatypeIRI="&xsd;string">The Integer class wraps a value of the primitive type int in an object. An object of type Integer contains a single field whose type is int.In addition, this class provides several methods for converting an int to a String and a String to an int, as well as other constants and methods useful when dealing with an int.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Integer.parseInt</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Integer.parseInt</IRI>
        <Literal datatypeIRI="&xsd;string">Parses the string argument as a signed decimal integer. The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign &apos;-&apos; (&apos;\u002D&apos;) to indicate a negative value. The resulting integer value is returned, exactly as if the argument and the radix 10 were given as arguments to the parseInt(java.lang.String, int) method.Parses the string argument as a signed integer in the radix specified by the second argument. The characters in the string must all be digits of the specified radix (as determined by whether Character.digit(char, int) returns a nonnegative value), except that the first character may be an ASCII minus sign &apos;-&apos; (&apos;\u002D&apos;) to indicate a negative value. The resulting integer value is returned.An exception of type NumberFormatException is thrown if any of the following situations occurs:		The first argument is null or is a string of length zero.		The radix is either smaller than Character.MIN_RADIX or larger than Character.MAX_RADIX.		Any character of the string is not a digit of the specified radix, except that the first character may be a minus sign &apos;-&apos; (&apos;\u002D&apos;) provided that the string is longer than length 1.		The value represented by the string is not a value of type int.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Long</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Long</IRI>
        <Literal datatypeIRI="&xsd;string">The Long class wraps a value of the primitive type long in an object. An object of type Long contains a single field whose type is long.In addition, this class provides several methods for converting a long to a String and a String to a long, as well as other constants and methods useful when dealing with a long.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math</IRI>
        <Literal datatypeIRI="&xsd;string">The class Math contains methods for performing basic numeric operations such as the elementary exponential, logarithm, square root, and trigonometric functions.Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required.By default many of the Math methods simply call the equivalent method in StrictMath for their implementation. Code generators are encouraged to use platform-specific native libraries or microprocessor instructions, where available, to provide higher-performance implementations of Math methods. Such higher-performance implementations still must conform to the specification for Math.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.abs</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.ceil</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.ceil</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the smallest (closest to negative infinity) double value that is greater than or equal to the argument and is equal to a mathematical integer. Special cases:		If the argument value is already equal to a mathematical integer, then the result is the same as the argument.		If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.		If the argument value is less than zero but greater than -1.0, then the result is negative zero.Note that the value of Math.ceil(x) is exactly the value of -Math.floor(-x).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.cos</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.cos</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the trigonometric cosine of an angle. Special cases:		If the argument is NaN or an infinity, then the result is NaN.The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.exp</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.exp</IRI>
        <Literal datatypeIRI="&xsd;string">Returns Euler&apos;s number e raised to the power of a double value. Special cases:		If the argument is NaN, the result is NaN.		If the argument is positive infinity, then the result is positive infinity.		If the argument is negative infinity, then the result is positive zero.The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.floor</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.floor</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the largest (closest to positive infinity) double value that is less than or equal to the argument and is equal to a mathematical integer. Special cases:		If the argument value is already equal to a mathematical integer, then the result is the same as the argument.		If the argument is NaN or an infinity or positive zero or negative zero, then the result is the same as the argument.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.log</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.max</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.min</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.min</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the smaller of two double values. That is, the result is the value closer to negative infinity. If the arguments have the same value, the result is that same value. If either value is NaN, then the result is NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. If one argument is positive zero and the other is negative zero, the result is negative zero.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.pow</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.pow</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the value of the first argument raised to the power of the second argument. </Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.round</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Math.round</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the closest int to the argument. The result is rounded to an integer by adding 1/2, taking the floor of the result, and casting the result to type int. In other words, the result is equal to the value of the expression:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.sin</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.sqrt</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Math.tan</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Object</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Object</IRI>
        <Literal datatypeIRI="&xsd;string">The Object class, defined in the java.lang package, defines and implements behavior common to all classesincluding the ones that you write. In the Java platform, many classes derive directly from Object, other classes derive from some of those classes, and so on, forming a hierarchy of classes.At the top of the hierarchy, Object is the most general of all classes. Classes near the bottom of the hierarchy provide more specialized behavior.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Object.clone</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Object.clone</IRI>
        <Literal datatypeIRI="&xsd;string">If a class, or one of its superclasses, implements the Cloneable interface, you can use the clone() method to create a copy from an existing object. To create a clone, you write:aCloneableObject.clone();Object&apos;s implementation of this method checks to see whether the object on which clone() was invoked implements the Cloneable interface. If the object does not, the method throws a CloneNotSupportedException exception. Exception handling will be covered in a later lesson. For the moment, you need to know that clone() must be declared asprotected Object clone() throws CloneNotSupportedException    -- or --public Object clone() throws CloneNotSupportedExceptionif you are going to write a clone() method to override the one in Object.If the object on which clone() was invoked does implement the Cloneable interface, Object&apos;s implementation of the clone() method creates an object of the same class as the original object and initializes the new object&apos;s member variables to have the same values as the original object&apos;s corresponding member variables.The simplest way to make your class cloneable is to add implements Cloneable to your class&apos;s declaration. then your objects can invoke the clone() method.For some classes, the default behavior of Object&apos;s clone() method works just fine. If, however, an object contains a reference to an external object, say ObjExternal, you may need to override clone() to get correct behavior. Otherwise, a change in ObjExternal made by one object will be visible in its clone also. This means that the original object and its clone are not independentto decouple them, you must override clone() so that it clones the object and ObjExternal. Then the original object references ObjExternal and the clone references a clone of ObjExternal, so that the object and its clone are truly independent.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Object.equals</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Object.equals</IRI>
        <Literal datatypeIRI="&xsd;string">The equals() method compares two objects for equality and returns true if they are equal. The equals() method provided in the Object class uses the identity operator (==) to determine whether two objects are equal. For primitive data types, this gives the correct result. For objects, however, it does not. The equals() method provided by Object tests whether the object references are equalthat is, if the objects compared are the exact same object.To test whether two objects are equal in the sense of equivalency (containing the same information), you must override the equals() method. Here is an example of a Book class that overrides equals():Consider this code that tests two instances of the Book class for equality:This program displays objects are equal even though firstBook and secondBook reference two distinct objects. They are considered equal because the objects compared contain the same ISBN number.You should always override the equals() method if the identity operator is not appropriate for your class.Note:If you override equals(), you must override hashCode() as well.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Object.hashCode</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Object.hashCode</IRI>
        <Literal datatypeIRI="&xsd;string">The value returned by hashCode() is the object&apos;s hash code, which is the object&apos;s memory address in hexadecimal.By definition, if two objects are equal, their hash code must also be equal. If you override the equals() method, you change the way two objects are equated and Object&apos;s implementation of hashCode() is no longer valid. Therefore, if you override the equals() method, you must also override the hashCode() method as well.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Object.toString</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Object.toString</IRI>
        <Literal datatypeIRI="&xsd;string">You should always consider overriding the toString() method in your classes.The Object&apos;s toString() method returns a String representation of the object, which is very useful for debugging. The String representation for an object depends entirely on the object, which is why you need to override toString() in your classes.You can use toString() along with System.out.println() to display a text representation of an object, such as an instance of Book:System.out.println(firstBook.toString());which would, for a properly overridden toString() method, print something useful, like this:</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Short</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Short</IRI>
        <Literal datatypeIRI="&xsd;string">The Short class wraps a value of primitive type short in an object. An object of type Short contains a single field whose type is short.In addition, this class provides several methods for converting a short to a String and a String to a short, as well as other constants and methods useful when dealing with a short.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String</IRI>
        <Literal datatypeIRI="&xsd;string">The String class represents character strings. All string literals in Java programs, such as &quot;abc&quot;, are implemented as instances of this class.Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.The class String includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the Character class.The Java language provides special support for the string concatenation operator (+), and for conversion of other objects to strings. String concatenation is implemented through the StringBuilder(or StringBuffer) class and its append method. String conversions are implemented through the method toString, defined by Object and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification.Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information). Index values refer to char code units, so a supplementary character uses two positions in a String.The String class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., char values).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.charAt</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.charAt</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the char value at the specified index. An index ranges from 0 to length() - 1. The first char value of the sequence is at index 0, the next at index 1, and so on, as for array indexing.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.compareTo</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.compareTo</IRI>
        <Literal datatypeIRI="&xsd;string">Compares two strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by this String object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.compareToIgnoreCase</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.compareToIgnoreCase</IRI>
        <Literal datatypeIRI="&xsd;string">Compares two strings lexicographically, ignoring case differences. This method returns an integer whose sign is that of calling compareTo with normalized versions of the strings where case differences have been eliminated by calling Character.toLowerCase(Character.toUpperCase(character)) on each character.Note that this method does not take locale into account, and will result in an unsatisfactory ordering for certain locales. The java.text package provides collators to allow locale-sensitive ordering.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.concat</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.concat</IRI>
        <Literal datatypeIRI="&xsd;string">Concatenates the specified string to the end of this string.If the length of the argument string is 0, then this String object is returned. Otherwise, a new String object is created, representing a character sequence that is the concatenation of the character sequence represented by this String object and the character sequence represented by the argument string.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.equals</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.equals</IRI>
        <Literal datatypeIRI="&xsd;string">Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.equalsIgnoreCase</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.equalsIgnoreCase</IRI>
        <Literal datatypeIRI="&xsd;string">Compares this String to another String, ignoring case considerations. Two strings are considered equal ignoring case if they are of the same length and corresponding characters in the two strings are equal ignoring case.Two characters c1 and c2 are considered the same ignoring case if at least one of the following is true:		The two characters are the same (as compared by the == operator)		Applying the method Character.toUpperCase(char) to each character produces the same result		Applying the method Character.toLowerCase(char) to each character produces the same result</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.indexOf</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.indexOf</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the index within this string of the first occurrence of the specified character. If a character with value ch occurs in the character sequence represented by this String object, then the index (in Unicode code units) of the first such occurrence is returned.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.length</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.length</IRI>
        <Literal datatypeIRI="&xsd;string">One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object.public int length()Returns the length of this string. The length is equal to the number of Unicode code units in the string.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.replace</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.replace</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.If the character oldChar does not occur in the character sequence represented by this String object, then a reference to this String object is returned. Otherwise, a new String object is created that represents a character sequence identical to the character sequence represented by this String object, except that every occurrence of oldChar is replaced by an occurrence of newChar.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.substring</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.substring</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a new string that is a substring of this string. The substring begins with the character at the specified index and extends to the end of this string.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.toLowerCase</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.toLowerCase</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a new string that is a substring of this string. The substring begins with the character at the specified index and extends to the end of this string.Returns a new string that is a substring of this string. The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. Thus the length of the substring is endIndex-beginIndex.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.String.toUpperCase</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.String.toUpperCase</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a copy of the string, with leading and trailing whitespace omitted.If this String object represents an empty character sequence, or the first and last characters of character sequence represented by this String object both have codes greater than &apos;\u0020&apos; (the space character), then a reference to this String object is returned.Otherwise, if there is no character with a code greater than &apos;\u0020&apos; in the string, then a new String object representing an empty string is created and returned.Otherwise, let k be the index of the first character in the string whose code is greater than &apos;\u0020&apos;, and let m be the index of the last character in the string whose code is greater than &apos;\u0020&apos;. A new String object is created, representing the substring of this string that begins with the character at index k and ends with the character at index m-that is, the result of this.substring(k,m+1).This method may be used to trim whitespace (as defined above) from the beginning and end of a string.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System</IRI>
        <Literal datatypeIRI="&xsd;string">The System class contains several useful class fields and methods. It cannot be instantiated.Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System.err</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System.err</IRI>
        <Literal datatypeIRI="&xsd;string">The &quot;standard&quot; error output stream. This stream is already open and ready to accept output data.Typically this stream corresponds to display output or another output destination specified by the host environment or user. By convention, this output stream is used to display error messages or other information that should come to the immediate attention of a user even if the principal output stream, the value of the variable out, has been redirected to a file or other destination that is typically not continuously monitored.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System.in</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System.in</IRI>
        <Literal datatypeIRI="&xsd;string">The &quot;standard&quot; input stream. This stream is already open and ready to supply input data. Typically this stream corresponds to keyboard input or another input source specified by the host environment or user.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System.out</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System.out</IRI>
        <Literal datatypeIRI="&xsd;string">The &quot;standard&quot; output stream. This stream is already open and ready to accept output data. Typically this stream corresponds to display output or another output destination specified by the host environment or user.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System.out.print</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System.out.print</IRI>
        <Literal datatypeIRI="&xsd;string">Prints its argument to the standard output stream.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.System.out.println</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.System.out.println</IRI>
        <Literal datatypeIRI="&xsd;string">Prints its argument to the standard output stream and then terminates the line.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Thread</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Thread</IRI>
        <Literal datatypeIRI="&xsd;string">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:		The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.		All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Throwable</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Throwable</IRI>
        <Literal datatypeIRI="&xsd;string">The Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause.Instances of two subclasses, Error and Exception, are conventionally used to indicate that exceptional situations have occurred. Typically, these instances are freshly created in the context of the exceptional situation so as to include relevant information (such as stack trace data).A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility is new in release 1.4. It is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a &quot;chain&quot; of exceptions, each caused by another.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.lang.Void</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.lang.Void</IRI>
        <Literal datatypeIRI="&xsd;string">The Void class is an uninstantiable placeholder class to hold a reference to the Class object representing the Java keyword void.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util</IRI>
        <Literal datatypeIRI="&xsd;string">Contains the collections framework, legacy collection classes, event model, date and time facilities, internationalization, and miscellaneous utility classes (a string tokenizer, a random-number generator, and a bit array).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList</IRI>
        <Literal datatypeIRI="&xsd;string">Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation.Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.add</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.add</IRI>
        <Literal datatypeIRI="&xsd;string">Appends the specified element to the end of this list.Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.get</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.get</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the element at the specified position in this list.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.indexOf</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.indexOf</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.remove</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.remove</IRI>
        <Literal datatypeIRI="&xsd;string">Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null?get(i)==null:o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.set</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.set</IRI>
        <Literal datatypeIRI="&xsd;string">Replaces the element at the specified position in this list with the specified element.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.ArrayList.size</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.ArrayList.size</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the number of elements in this list.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.List</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.List</IRI>
        <Literal datatypeIRI="&xsd;string">An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare.The List interface places additional stipulations, beyond those specified in the Collection interface, on the contracts of the iterator, add, remove, equals, and hashCode methods. Declarations for other inherited methods are also included here for convenience.The List interface provides four methods for positional (indexed) access to list elements. Lists (like Java arrays) are zero based. Note that these operations may execute in time proportional to the index value for some implementations (the LinkedList class, for example). Thus, iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation.The List interface provides a special iterator, called a ListIterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the Iterator interface provides. A method is provided to obtain a list iterator that starts at a specified position in the list.The List interface provides two methods to search for a specified object. From a performance standpoint, these methods should be used with caution. In many implementations they will perform costly linear searches.The List interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list.Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Random</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Random</IRI>
        <Literal datatypeIRI="&xsd;string">An instance of this class is used to generate a stream of pseudorandom numbers. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald Knuth, The Art of Computer Programming, Volume 3, Section 3.2.1.)If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code. However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Random.nextDouble</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Random.nextDouble</IRI>
        <Literal datatypeIRI="&xsd;string">Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator&apos;s sequence.The general contract of nextDouble is that one double value, chosen (approximately) uniformly from the range 0.0d (inclusive) to 1.0d (exclusive), is pseudorandomly generated and returned.The method nextDouble is implemented by class Random as if by:The hedge &quot;approximately&quot; is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose double values from the stated range with perfect uniformity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Random.nextInt</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Random.nextInt</IRI>
        <Literal datatypeIRI="&xsd;string">Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator&apos;s sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All n possible int values are produced with (approximately) equal probability. The method nextInt(int n) is implemented by class Random as if by:The hedge &quot;approximately&quot; is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose int values from the stated range with perfect uniformity.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Scanner</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Scanner</IRI>
        <Literal datatypeIRI="&xsd;string">A simple text scanner which can parse primitive types and strings using regular expressions.A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods.The default whitespace delimiter used by a scanner is as recognized by Character.isWhitespace. The reset() method will reset the value of the scanner&apos;s delimiter to the default whitespace delimiter regardless of whether it was previously changed.A scanning operation may block waiting for input.The next() and hasNext() methods and their primitive-type companion methods (such as nextInt() and hasNextInt()) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both hasNext and next methods may block waiting for further input. Whether a hasNext method blocks has no connection to whether or not its associated next method will block.The findInLine(java.lang.String), findWithinHorizon(java.lang.String, int), and skip(java.util.regex.Pattern) methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input.When a scanner throws an InputMismatchException, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.Depending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern &quot;\\s+&quot; will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern &quot;\\s&quot; could return empty tokens since it only passes one space at a time.A scanner can read text from any object which implements the Readable interface. If an invocation of the underlying readable&apos;s Readable.read(java.nio.CharBuffer) method throws an IOException then the scanner assumes that the end of the input has been reached. The most recent IOException thrown by the underlying readable can be retrieved via the ioException() method.When a Scanner is closed, it will close its input source if the source implements the Closeable interface.A Scanner is not safe for multithreaded use without external synchronization.Unless otherwise mentioned, passing a null parameter into any method of a Scanner will cause a NullPointerException to be thrown.A scanner will default to interpreting numbers as decimal unless a different radix has been set by using the useRadix(int) method. The reset() method will reset the value of the scanner&apos;s radix to 10 regardless of whether it was previously changed.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Scanner.next</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Scanner.next</IRI>
        <Literal datatypeIRI="&xsd;string">Finds and returns the next complete token from this scanner. A complete token is preceded and followed by input that matches the delimiter pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext() returned true.Returns the next token if it matches the specified pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext(Pattern) returned true. If the match is successful, the scanner advances past the input that matched the pattern.Returns the next token if it matches the pattern constructed from the specified string. If the match is successful, the scanner advances past the input that matched the pattern.An invocation of this method of the form next(pattern) behaves in exactly the same way as the invocation next(Pattern.compile(pattern)).</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Scanner.nextDouble</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Scanner.nextInt</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Scanner.nextInt</IRI>
        <Literal datatypeIRI="&xsd;string">Scans the next token of the input as an int.An invocation of this method of the form nextInt() behaves in exactly the same way as the invocation nextInt(radix), where radix is the default radix of this scanner.Scans the next token of the input as an int. This method will throw InputMismatchException if the next token cannot be translated into a valid int value as described below. If the translation is successful, the scanner advances past the input that matched.If the next token matches the Integer regular expression defined above then the token is converted into an int value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to Integer.parseInt with the specified radix.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#java.util.Scanner.nextLine</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#java.util.Scanner.nextLine</IRI>
        <Literal datatypeIRI="&xsd;string">Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line.Since this method continues to search through the input looking for a line separator, it may buffer all of the input searching for the line to skip if no line separators are present.</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty IRI="#indexing"/>
        <IRI>#null</IRI>
        <Literal datatypeIRI="&xsd;boolean">true</Literal>
    </AnnotationAssertion>
    <AnnotationAssertion>
        <AnnotationProperty abbreviatedIRI="rdfs:comment"/>
        <IRI>#null</IRI>
        <Literal datatypeIRI="&xsd;string">You can test if a reference variable is null by using the == operator. For instance.</Literal>
    </AnnotationAssertion>
</Ontology>



<!-- Generated by the OWL API (version 3.4.2) http://owlapi.sourceforge.net -->

